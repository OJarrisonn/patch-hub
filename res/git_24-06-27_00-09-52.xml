<?xml version="1.0" encoding="us-ascii"?>
<feed
xmlns="http://www.w3.org/2005/Atom"
xmlns:thr="http://purl.org/syndication/thread/1.0"><title>((s:patch OR s:rfc) AND NOT s:re:) - search results</title><link
rel="alternate"
type="text/html"
href="http://lore.kernel.org/git/?q=((s:patch+OR+s:rfc)+AND+NOT+s:re:)"/><link
rel="self"
href="http://lore.kernel.org/git/?q=((s:patch+OR+s:rfc)+AND+NOT+s:re:)&amp;x=A"/><id>urn:uuid:bf2c134e-36a8-00bb-7d77-16c3a7814731</id><updated>2024-06-27T00:33:26Z</updated><entry><author><name>Jeff King</name><email>peff@peff.net</email></author><title>[PATCH 3/3] t/lib-bundle-uri: use local fake bundle URLs</title><updated>2024-06-26T20:57:48Z</updated><link
href="http://lore.kernel.org/git/20240626205745.GC1457138@coredump.intra.peff.net/"/><id>urn:uuid:be165301-ca5c-94c2-f82f-116230728e6f</id><thr:in-reply-to
ref="urn:uuid:2a6ed316-89a3-fc94-9e67-a1a8a6718c08"
href="http://lore.kernel.org/git/20240626205355.GA1009060@coredump.intra.peff.net/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">A few of the bundle URI tests point config at a fake bundle; they care
only that the client has been configured with _some_ bundle, but it
doesn&#39;t have to actually contain objects.

For the file:// tests, we use &#34;$BUNDLE_URI_REPO_URI/fake.bdl&#34;, a
non-existent file inside the actual remote repo. But for git:// and
http:// tests, we use &#34;<a
href="https://example.com/fake.bdl">https://example.com/fake.bdl</a>&#34;. This works OK in
practice, but it means we actually make a request to example.com (which
returns a placeholder HTML response). That can be annoying when running
the test suite on a spotty network (it doesn&#39;t produce a wrong result,
since we expect it to fail, but it may introduce delays).

We can reduce our dependency on the outside world by using a local URL.
It would work to just do &#34;file://$PWD/fake.bdl&#34; here, since the bundle
code does not care about the actual location. But in the long run I
suspect we may have more restrictions on which protocols can be passed
around as bundle URIs. So instead, let&#39;s stick with the file:// repo&#39;s
pattern and just point to a bogus name based on the remote repo&#39;s URL.

For http this makes perfect sense; we&#39;ll make a request to the local
http server and find that there&#39;s nothing there. For git:// it&#39;s a
little weird, as you wouldn&#39;t normally access a bundle file over git://
at all. But it&#39;s probably the most reasonable guess we can make for now,
and anybody who tightens protocol selection later will know better
what&#39;s the best path forward.

Signed-off-by: Jeff King &lt;peff@peff.net&gt;
---
 t/lib-bundle-uri-protocol.sh | 4 ++--
 1 file <a href="http://lore.kernel.org/git/20240626205745.GC1457138@coredump.intra.peff.net/#related">changed</a>, 2 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/t/lib-bundle-uri-protocol.sh b/t/lib-bundle-uri-protocol.sh
index a4a1af8d02..de09b6b02e 100644
--- a/t/lib-bundle-uri-protocol.sh
+++ b/t/lib-bundle-uri-protocol.sh
</span><span
class="hunk">@@ -18,15 +18,15 @@ git)
</span> 	start_git_daemon --export-all --enable=receive-pack
 	BUNDLE_URI_PARENT=&#34;$GIT_DAEMON_DOCUMENT_ROOT_PATH/parent&#34;
 	BUNDLE_URI_REPO_URI=&#34;$GIT_DAEMON_URL/parent&#34;
<span
class="del">-	BUNDLE_URI_BUNDLE_URI=&#34;<a
href="https://example.com/fake.bdl">https://example.com/fake.bdl</a>&#34;
</span><span
class="add">+	BUNDLE_URI_BUNDLE_URI=&#34;$BUNDLE_URI_REPO_URI/fake.bdl&#34;
</span> 	test_set_prereq BUNDLE_URI_GIT
 	;;
 http)
 	. &#34;$TEST_DIRECTORY&#34;/lib-httpd.sh
 	start_httpd
 	BUNDLE_URI_PARENT=&#34;$HTTPD_DOCUMENT_ROOT_PATH/http_parent&#34;
 	BUNDLE_URI_REPO_URI=&#34;$HTTPD_URL/smart/http_parent&#34;
<span
class="del">-	BUNDLE_URI_BUNDLE_URI=&#34;<a
href="https://example.com/fake.bdl">https://example.com/fake.bdl</a>&#34;
</span><span
class="add">+	BUNDLE_URI_BUNDLE_URI=&#34;$BUNDLE_URI_REPO_URL/fake.bdl&#34;
</span> 	test_set_prereq BUNDLE_URI_HTTP
 	;;
 *)
-- 
2.45.2.1058.g2ff574fec9
</pre></div></content></entry><entry><author><name>Jeff King</name><email>peff@peff.net</email></author><title>[PATCH 2/3] t5551: do not confirm that bogus url cannot be used</title><updated>2024-06-26T20:55:28Z</updated><link
href="http://lore.kernel.org/git/20240626205525.GB1457138@coredump.intra.peff.net/"/><id>urn:uuid:ecbdad1a-6035-802f-25fe-a7f67a7dc856</id><thr:in-reply-to
ref="urn:uuid:2a6ed316-89a3-fc94-9e67-a1a8a6718c08"
href="http://lore.kernel.org/git/20240626205355.GA1009060@coredump.intra.peff.net/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">t5551 tries to access a URL with a bogus hostname and confirms that
http.curloptResolve lets us use this otherwise unresolvable name.

Before doing so, though, we confirm that trying to access the bogus
hostname without http.curloptResolve fails as expected. This isn&#39;t
testing Git at all, but is confirming the test&#39;s assumptions. That&#39;s
often a good thing to do, but in this case it means that we&#39;ll actually
try to resolve the external name. Even though it&#39;s unlikely that
&#34;gitbogusexamplehost.invalid&#34; would ever resolve, the DNS lookup itself
may take time.

It&#39;s probably reasonable to just assume that this obviously-bogus name
would not actually resolve in practice, which lets us reduce our test
suite&#39;s dependency on the outside world.

Signed-off-by: Jeff King &lt;peff@peff.net&gt;
---
 t/t5551-http-fetch-smart.sh | 1 -
 1 file <a href="http://lore.kernel.org/git/20240626205525.GB1457138@coredump.intra.peff.net/#related">changed</a>, 1 deletion(-)

<span
class="head">diff --git a/t/t5551-http-fetch-smart.sh b/t/t5551-http-fetch-smart.sh
index a623a1058c..7b5ab0eae1 100755
--- a/t/t5551-http-fetch-smart.sh
+++ b/t/t5551-http-fetch-smart.sh
</span><span
class="hunk">@@ -643,7 +643,6 @@ test_expect_success &#39;clone empty SHA-256 repository with protocol v0&#39; &#39;
</span> test_expect_success &#39;passing hostname resolution information works&#39; &#39;
 	BOGUS_HOST=gitbogusexamplehost.invalid &#38;&#38;
 	BOGUS_HTTPD_URL=$HTTPD_PROTO://$BOGUS_HOST:$LIB_HTTPD_PORT &#38;&#38;
<span
class="del">-	test_must_fail git ls-remote &#34;$BOGUS_HTTPD_URL/smart/repo.git&#34; &gt;/dev/null &#38;&#38;
</span> 	git -c &#34;http.curloptResolve=$BOGUS_HOST:$LIB_HTTPD_PORT:127.0.0.1&#34; ls-remote &#34;$BOGUS_HTTPD_URL/smart/repo.git&#34; &gt;/dev/null
 &#39;
 
-- 
2.45.2.1058.g2ff574fec9

</pre></div></content></entry><entry><author><name>Jeff King</name><email>peff@peff.net</email></author><title>[PATCH 1/3] t5553: use local url for invalid fetch</title><updated>2024-06-26T20:54:31Z</updated><link
href="http://lore.kernel.org/git/20240626205428.GA1457138@coredump.intra.peff.net/"/><id>urn:uuid:27425347-15fd-b683-81bc-b2ea0607d2a9</id><thr:in-reply-to
ref="urn:uuid:2a6ed316-89a3-fc94-9e67-a1a8a6718c08"
href="http://lore.kernel.org/git/20240626205355.GA1009060@coredump.intra.peff.net/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">We test how &#34;fetch --set-upstream&#34; behaves when given an invalid URL,
using the bogus URL &#34;<a
href="http://nosuchdomain.example.com">http://nosuchdomain.example.com</a>&#34;. But finding out
that it is invalid requires an actual DNS lookup.

Reduce our dependency on external factors by using an invalid local
filesystem URL, which works just as well for our purposes.

Signed-off-by: Jeff King &lt;peff@peff.net&gt;
---
 t/t5553-set-upstream.sh | 8 ++++----
 1 file <a href="http://lore.kernel.org/git/20240626205428.GA1457138@coredump.intra.peff.net/#related">changed</a>, 4 insertions(+), 4 deletions(-)

<span
class="head">diff --git a/t/t5553-set-upstream.sh b/t/t5553-set-upstream.sh
index 48050162c2..70e3376d31 100755
--- a/t/t5553-set-upstream.sh
+++ b/t/t5553-set-upstream.sh
</span><span
class="hunk">@@ -73,10 +73,10 @@ test_expect_success &#39;fetch --set-upstream main:other does not set the branch oth
</span> 	check_config_missing other2
 &#39;
 
<span
class="del">-test_expect_success &#39;fetch --set-upstream <a
href="http://nosuchdomain.example.com">http://nosuchdomain.example.com</a> fails with invalid url&#39; &#39;
</span><span
class="add">+test_expect_success &#39;fetch --set-upstream ./does-not-exist fails with invalid url&#39; &#39;
</span> 	# main explicitly not cleared, we check that it is not touched from previous value
 	clear_config other other2 &#38;&#38;
<span
class="del">-	test_must_fail git fetch --set-upstream <a
href="http://nosuchdomain.example.com">http://nosuchdomain.example.com</a> &#38;&#38;
</span><span
class="add">+	test_must_fail git fetch --set-upstream ./does-not-exist &#38;&#38;
</span> 	check_config main upstream refs/heads/other &#38;&#38;
 	check_config_missing other &#38;&#38;
 	check_config_missing other2
<span
class="hunk">@@ -143,10 +143,10 @@ test_expect_success &#39;pull --set-upstream upstream tag does not set the tag&#39; &#39;
</span> 	check_config_missing three
 &#39;
 
<span
class="del">-test_expect_success &#39;pull --set-upstream <a
href="http://nosuchdomain.example.com">http://nosuchdomain.example.com</a> fails with invalid url&#39; &#39;
</span><span
class="add">+test_expect_success &#39;pull --set-upstream ./does-not-exist fails with invalid url&#39; &#39;
</span> 	# main explicitly not cleared, we check that it is not touched from previous value
 	clear_config other other2 three &#38;&#38;
<span
class="del">-	test_must_fail git pull --set-upstream <a
href="http://nosuchdomain.example.com">http://nosuchdomain.example.com</a> &#38;&#38;
</span><span
class="add">+	test_must_fail git pull --set-upstream ./does-not-exist &#38;&#38;
</span> 	check_config main upstream refs/heads/other &#38;&#38;
 	check_config_missing other &#38;&#38;
 	check_config_missing other2 &#38;&#38;
-- 
2.45.2.1058.g2ff574fec9

</pre></div></content></entry><entry><author><name>Jeff King</name><email>peff@peff.net</email></author><title>[PATCH 0/3] reduce test suite dependency on network</title><updated>2024-06-26T20:53:58Z</updated><link
href="http://lore.kernel.org/git/20240626205355.GA1009060@coredump.intra.peff.net/"/><id>urn:uuid:2a6ed316-89a3-fc94-9e67-a1a8a6718c08</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">I&#39;m in a remote cabin with spotty internet this week, and I noticed
several delays while running &#34;make test&#34;. The culprit was DNS request
packets being dropped due to a passing rainstorm, but not enough that
the OS decided the network was down (the DNS resolver was on the other
end of a VPN). So I was waiting for DNS timeouts.

This is kind of an exotic situation, but it seems to me that the test
suite should avoid making network requests in general, just for the sake
of reproducibility. And avoiding timeouts is a nice bonus.

So here are a few small fixes, after which running &#34;make test&#34; requires
zero DNS lookups (and presumably zero external network at all, though of
course we hit localhost/127.0.0.1 for various http, etc, tests).

  [1/3]: t5553: use local url for invalid fetch
  [2/3]: t5551: do not confirm that bogus url cannot be used
  [3/3]: t/lib-bundle-uri: use local fake bundle URLs

 t/lib-bundle-uri-protocol.sh | 4 ++--
 t/t5551-http-fetch-smart.sh  | 1 -
 t/t5553-set-upstream.sh      | 8 ++++----
 3 files changed, 6 insertions(+), 7 deletions(-)

-Peff
</pre></div></content></entry><entry><author><name>Abhijeet Sonar</name><email>abhijeet.nkt@gmail.com</email></author><title
type="html">[PATCH v7] describe: refresh the index when &#39;broken&#39; flag is used</title><updated>2024-06-26T19:09:46Z</updated><link
href="http://lore.kernel.org/git/20240626190801.68472-1-abhijeet.nkt@gmail.com/"/><id>urn:uuid:e5101458-748c-cf03-d686-4f524bc8afe1</id><thr:in-reply-to
ref="urn:uuid:d0644fb9-76a1-edef-8f7e-23274d7fd938"
href="http://lore.kernel.org/git/xmqqpls3zhc2.fsf@gitster.g/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">When describe is run with &#39;dirty&#39; flag, we refresh the index
to make sure it is in sync with the filesystem before
determining if the working tree is dirty.  However, this is
not done for the codepath where the &#39;broken&#39; flag is used.

This causes `git describe --broken --dirty` to false
positively report the worktree being dirty if a file has
different stat info than what is recorded in the index.
Running `git update-index -q --refresh` to refresh the index
before running diff-index fixes the problem.

Also add tests to deliberately update stat info of a
file before running describe to verify it behaves correctly.

Reported-by: Paul Millar &lt;paul.millar@desy.de&gt;
Suggested-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Helped-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Helped-by: Phillip Wood &lt;phillip.wood123@gmail.com&gt;
Signed-off-by: Abhijeet Sonar &lt;abhijeet.nkt@gmail.com&gt;
---
 builtin/describe.c  | 12 ++++++++++++
 t/t6120-describe.sh | 36 ++++++++++++++++++++++++++++++++++++
 2 files <a href="http://lore.kernel.org/git/20240626190801.68472-1-abhijeet.nkt@gmail.com/#related">changed</a>, 48 insertions(+)

<span
class="head">diff --git a/builtin/describe.c b/builtin/describe.c
index e5287eddf2..cf8edc4222 100644
--- a/builtin/describe.c
+++ b/builtin/describe.c
</span><span
class="hunk">@@ -53,6 +53,10 @@ static const char *diff_index_args[] = {
</span> 	&#34;diff-index&#34;, &#34;--quiet&#34;, &#34;HEAD&#34;, &#34;--&#34;, NULL
 };
 
<span
class="add">+static const char *update_index_args[] = {
+	&#34;update-index&#34;, &#34;--unmerged&#34;, &#34;-q&#34;, &#34;--refresh&#34;, NULL
+};
+
</span> struct commit_name {
 	struct hashmap_entry entry;
 	struct object_id peeled;
<span
class="hunk">@@ -645,6 +649,14 @@ int cmd_describe(int argc, const char **argv, const char *prefix)
</span> 	if (argc == 0) {
 		if (broken) {
 			struct child_process cp = CHILD_PROCESS_INIT;
<span
class="add">+
+			strvec_pushv(&#38;cp.args, update_index_args);
+			cp.git_cmd = 1;
+			cp.no_stdin = 1;
+			cp.no_stdout = 1;
+			run_command(&#38;cp);
+
+			child_process_init(&#38;cp);
</span> 			strvec_pushv(&#38;cp.args, diff_index_args);
 			cp.git_cmd = 1;
 			cp.no_stdin = 1;
<span
class="head">diff --git a/t/t6120-describe.sh b/t/t6120-describe.sh
index e78315d23d..79e0f19deb 100755
--- a/t/t6120-describe.sh
+++ b/t/t6120-describe.sh
</span><span
class="hunk">@@ -671,4 +671,40 @@ test_expect_success &#39;setup misleading taggerdates&#39; &#39;
</span> 
 check_describe newer-tag-older-commit~1 --contains unique-file~2
 
<span
class="add">+test_expect_success &#39;describe --dirty with a file with changed stat&#39; &#39;
+	test_when_finished &#34;rm -fr stat-dirty&#34; &#38;&#38;
+	git init stat-dirty &#38;&#38;
+	(
+		cd stat-dirty &#38;&#38;
+
+		echo A &gt;file &#38;&#38;
+		git add file &#38;&#38;
+		git commit -m A &#38;&#38;
+		git tag A -a -m A &#38;&#38;
+		echo &#34;A&#34; &gt;expect &#38;&#38;
+
+		test-tool chmtime -10 file &#38;&#38;
+		git describe --dirty &gt;actual &#38;&#38;
+		test_cmp expect actual
+	)
+&#39;
+
+test_expect_success &#39;describe --broken --dirty with a file with changed stat&#39; &#39;
+	test_when_finished &#34;rm -fr stat-dirty&#34; &#38;&#38;
+	git init stat-dirty &#38;&#38;
+	(
+		cd stat-dirty &#38;&#38;
+
+		echo A &gt;file &#38;&#38;
+		git add file &#38;&#38;
+		git commit -m A &#38;&#38;
+		git tag A -a -m A &#38;&#38;
+		echo &#34;A&#34; &gt;expect &#38;&#38;
+
+		test-tool chmtime -10 file &#38;&#38;
+		git describe --dirty --broken &gt;actual &#38;&#38;
+		test_cmp expect actual
+	)
+&#39;
+
</span> test_done
-- 
2.45.2.606.g9005149a4a.dirty

</pre></div></content></entry><entry><author><name>Derrick Stolee via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 5/5] sparse-index: improve lstat caching of sparse paths</title><updated>2024-06-26T14:30:00Z</updated><link
href="http://lore.kernel.org/git/0cb344ac14fa942f781221663e2324fd2225fb5f.1719412192.git.gitgitgadget@gmail.com/"/><id>urn:uuid:8578bc86-9d78-1f94-2259-850c00370848</id><thr:in-reply-to
ref="urn:uuid:e1fea83c-e522-ca3f-fb5f-a0f066693ba5"
href="http://lore.kernel.org/git/pull.1754.v2.git.1719412192.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Derrick Stolee &lt;stolee@gmail.com&gt;

The clear_skip_worktree_from_present_files() method was first introduced
in af6a51875a (repo_read_index: clear SKIP_WORKTREE bit from files
present in worktree, 2022-01-14) to allow better interaction with the
working directory in the presence of paths outside of the
sparse-checkout. The initial implementation would lstat() every single
SKIP_WORKTREE path to see if it existed; if it ran across a sparse
directory that existed (when a sparse index was in use), then it would
expand the index and then check every SKIP_WORKTREE path.

Since these lstat() calls were very expensive, this was improved in
d79d299352 (Accelerate clear_skip_worktree_from_present_files() by
caching, 2022-01-14) by caching directories that do not exist so it
could avoid lstat()ing any files under such directories. However, there
are some inefficiencies in that caching mechanism.

The caching mechanism stored only the parent directory as not existing,
even if a higher parent directory also does not exist. This means that
wasted lstat() calls would occur when the paths passed to path_found()
change immediate parent directories but within the same parent directory
that does not exist.

To create an example repository that demonstrates this problem, it helps
to have a directory outside of the sparse-checkout that contains many
deep paths. In particular, the first paths (in lexicographic order)
underneath the sparse directory should have deep directory structures,
maximizing the difference between the old caching algorithm that looks
to a single parent and the new caching algorithm that looks to the
top-most missing directory.

The performance test script p2000-sparse-operations.sh takes the sample
repository and copies its HEAD to several copies nested in directories
of the form f&lt;i&gt;/f&lt;j&gt;/f&lt;k&gt; where i, j, and k are numbers from 1 to 4.
The sparse-checkout cone is then selected as &#34;f2/f4/&#34;. Creating &#34;f1/f1/&#34;
will trigger the behavior and also lead to some interesting cases for
the caching algorithm since &#34;f1/f1/&#34; exists but &#34;f1/f2/&#34; and &#34;f3/&#34; do
not.

This is difficult to notice when running performance tests using the Git
repository (or a blow-up of the Git repository, as in
p2000-sparse-operations.sh) because Git has a very shallow directory
structure.

This change reorganizes the caching algorithm to focus on storing the
highest level leading directory that does not exist; specifically this
means that that directory&#39;s parent _does_ exist. By doing a little extra
work on a path passed to path_found(), we can short-circuit all of the
paths passed to path_found() afterwards that match a prefix with that
non-existing directory. When in a repository where the first sparse file
is likely to have a much deeper path than the first non-existing
directory, this can realize significant gains.

The details of this algorithm require careful attention, so the new
implementation of path_found() has detailed comments, including the use
of a new max_common_dir_prefix() method that may be of independent
interest.

It&#39;s worth noting that this is not universally positive, since we are
doing extra lstat() calls to establish the exact path to cache. In the
blow-up of the Git repository, we can see that the lstat count
_increases_ from 28 to 31. However, these numbers were already
artificially low.

Contributor Elijah Newren created a publicly-available test repository
that demonstrates the difference in these caching algorithms in the most
extreme way. To test, follow these steps:

  git clone --sparse <a
href="https://github.com/newren/gvfs-like-git-bomb">https://github.com/newren/gvfs-like-git-bomb</a>
  cd gvfs-like-git-bomb
  ./runme.sh                   # NOTE: check scripts before running!

At this point, assuming you do not have index.sparse=true set globally,
the index has one million paths with the SKIP_WORKTREE bit and they will
all be sent to path_found() in the sparse loop. You can measure this by
running &#39;git status&#39; with GIT_TRACE2_PERF=1:

    Sparse files in the index: 1,000,000
  sparse_lstat_count (before):   200,000
   sparse_lstat_count (after):         2

And here are the performance numbers:

  Benchmark 1: old
    Time (mean &#177; &#963;):     397.5 ms &#177;   4.1 ms
    Range (min &#8230; max):   391.2 ms &#8230; 404.8 ms    10 runs

  Benchmark 2: new
    Time (mean &#177; &#963;):     252.7 ms &#177;   3.1 ms
    Range (min &#8230; max):   249.4 ms &#8230; 259.5 ms    11 runs

  Summary
    &#39;new&#39; ran
      1.57 &#177; 0.02 times faster than &#39;old&#39;

By modifying this example further, we can demonstrate a more realistic
example and include the sparse index expansion. Continue by creating
this directory, confusing both caching algorithms somewhat:

  mkdir -p bomb/d/e/f/a/a

Then re-run the &#39;git status&#39; tests to see these statistics:

    Sparse files in the index: 1,000,000
  sparse_lstat_count (before):   724,010
   sparse_lstat_count (after):       106

  Benchmark 1: old
    Time (mean &#177; &#963;):     753.0 ms &#177;   3.5 ms
    Range (min &#8230; max):   749.7 ms &#8230; 760.9 ms    10 runs

  Benchmark 2: new
    Time (mean &#177; &#963;):     201.4 ms &#177;   3.2 ms
    Range (min &#8230; max):   196.0 ms &#8230; 207.9 ms    14 runs

  Summary
    &#39;new&#39; ran
      3.74 &#177; 0.06 times faster than &#39;old&#39;

Note that if this repository had a sparse index enabled, the additional
cost of expanding the sparse index affects the total time of these
commands by over four seconds, significantly diminishing the benefit of
the caching algorithm. Having existing paths outside of the
sparse-checkout is a known performance issue for the sparse index and is
a known trade-off for the performance benefits given when no such paths
exist.

Using an internal monorepo with over two million paths at HEAD and a
typical sparse-checkout cone such that the sparse index contains
~190,000 entries (including over two thousand sparse trees), I was able
to measure these lstat counts when one sparse directory actually exists
on disk:

  Sparse files in expanded index: 1,841,997
       full_lstat_count (before): 1,188,161
       full_lstat_count  (after):     4,404

This resulted in this absolute time change, on a warm disk:

      Time in full loop (before): 13.481 s
      Time in full loop  (after):  0.081 s

(These times were calculated on a Windows machine, where lstat() is
slower than a similar Linux machine.)

Helped-by: Elijah Newren &lt;newren@gmail.com&gt;
Signed-off-by: Derrick Stolee &lt;stolee@gmail.com&gt;
---
 sparse-index.c | 114 ++++++++++++++++++++++++++++++++++++++-----------
 1 file <a href="http://lore.kernel.org/git/0cb344ac14fa942f781221663e2324fd2225fb5f.1719412192.git.gitgitgadget@gmail.com/#related">changed</a>, 90 insertions(+), 24 deletions(-)

<span
class="head">diff --git a/sparse-index.c b/sparse-index.c
index 8577fa726b8..7e433250248 100644
--- a/sparse-index.c
+++ b/sparse-index.c
</span><span
class="hunk">@@ -440,14 +440,21 @@ void ensure_correct_sparsity(struct index_state *istate)
</span> }
 
 struct path_found_data {
<span
class="add">+	/**
+	 * The path stored in &#39;dir&#39;, if non-empty, corresponds to the most-
+	 * recent path that we checked where:
+	 *
+	 *   1. The path should be a directory, according to the index.
+	 *   2. The path does not exist.
+	 *   3. The parent path _does_ exist. (This may be the root of the
+	 *      working directory.)
+	 */
</span> 	struct strbuf dir;
<span
class="del">-	int dir_found;
</span> 	size_t lstat_count;
 };
 
 #define PATH_FOUND_DATA_INIT { \
<span
class="del">-	.dir = STRBUF_INIT, \
-	.dir_found = 1 \
</span><span
class="add">+	.dir = STRBUF_INIT \
</span> }
 
 static void clear_path_found_data(struct path_found_data *data)
<span
class="hunk">@@ -455,49 +462,108 @@ static void clear_path_found_data(struct path_found_data *data)
</span> 	strbuf_release(&#38;data-&gt;dir);
 }
 
<span
class="add">+/**
+ * Return the length of the largest common substring that ends in a
+ * slash (&#39;/&#39;) to indicate the largest common parent directory. Returns
+ * zero if no common directory exists.
+ */
+static size_t max_common_dir_prefix(const char *path1, const char *path2)
+{
+	size_t common_prefix = 0;
+	for (size_t i = 0; path1[i] &#38;&#38; path2[i]; i++) {
+		if (path1[i] != path2[i])
+			break;
+
+		/*
+		 * If they agree at a directory separator, then add one
+		 * to make sure it is included in the common prefix string.
+		 */
+		if (path1[i] == &#39;/&#39;)
+			common_prefix = i + 1;
+	}
+
+	return common_prefix;
+}
+
</span> static int path_found(const char *path, struct path_found_data *data)
 {
 	struct stat st;
<span
class="del">-	char *newdir;
</span><span
class="add">+	size_t common_prefix;
</span> 
 	/*
<span
class="del">-	 * If dirname corresponds to a directory that doesn&#39;t exist, and this
-	 * path starts with dirname, then path can&#39;t exist.
</span><span
class="add">+	 * If data-&gt;dir is non-empty, then it contains a path that doesn&#39;t
+	 * exist, including an ending slash (&#39;/&#39;). If it is a prefix of &#39;path&#39;,
+	 * then we can return 0.
</span> 	 */
<span
class="del">-	if (!data-&gt;dir_found &#38;&#38; !memcmp(path, data-&gt;dir.buf, data-&gt;dir.len))
</span><span
class="add">+	if (data-&gt;dir.len &#38;&#38; !memcmp(path, data-&gt;dir.buf, data-&gt;dir.len))
</span> 		return 0;
 
 	/*
<span
class="del">-	 * If path itself exists, return 1.
</span><span
class="add">+	 * Otherwise, we must check if the current path exists. If it does, then
+	 * return 1. The cached directory will be skipped until we come across
+	 * a missing path again.
</span> 	 */
 	data-&gt;lstat_count++;
 	if (!lstat(path, &#38;st))
 		return 1;
 
 	/*
<span
class="del">-	 * Otherwise, path does not exist so we&#39;ll return 0...but we&#39;ll first
-	 * determine some info about its parent directory so we can avoid
-	 * lstat calls for future cache entries.
</span><span
class="add">+	 * At this point, we know that &#39;path&#39; doesn&#39;t exist, and we know that
+	 * the parent directory of &#39;data-&gt;dir&#39; does exist. Let&#39;s set &#39;data-&gt;dir&#39;
+	 * to be the top-most non-existing directory of &#39;path&#39;. If the first
+	 * parent of &#39;path&#39; exists, then we will act as though &#39;path&#39;
+	 * corresponds to a directory (by adding a slash).
</span> 	 */
<span
class="del">-	newdir = strrchr(path, &#39;/&#39;);
-	if (!newdir)
-		return 0; /* Didn&#39;t find a parent dir; just return 0 now. */
</span><span
class="add">+	common_prefix = max_common_dir_prefix(path, data-&gt;dir.buf);
</span> 
 	/*
<span
class="del">-	 * If path starts with directory (which we already lstat&#39;ed and found),
-	 * then no need to lstat parent directory again.
</span><span
class="add">+	 * At this point, &#39;path&#39; and &#39;data-&gt;dir&#39; have a common existing parent
+	 * directory given by path[0..common_prefix] (which could have length 0).
+	 * We &#34;grow&#34; the data-&gt;dir buffer by checking for existing directories
+	 * along &#39;path&#39;.
</span> 	 */
<span
class="del">-	if (data-&gt;dir_found &#38;&#38; data-&gt;dir.buf &#38;&#38;
-	    memcmp(path, data-&gt;dir.buf, data-&gt;dir.len))
-		return 0;
</span> 
<span
class="del">-	/* Free previous dirname, and cache path&#39;s dirname */
-	strbuf_reset(&#38;data-&gt;dir);
-	strbuf_add(&#38;data-&gt;dir, path, newdir - path + 1);
</span><span
class="add">+	strbuf_setlen(&#38;data-&gt;dir, common_prefix);
+	while (1) {
+		/* Find the next directory in &#39;path&#39;. */
+		const char *rest = path + data-&gt;dir.len;
+		const char *next_slash = strchr(rest, &#39;/&#39;);
</span> 
<span
class="del">-	data-&gt;lstat_count++;
-	data-&gt;dir_found = !lstat(data-&gt;dir.buf, &#38;st);
</span><span
class="add">+		/*
+		 * If there are no more slashes, then &#39;path&#39; doesn&#39;t contain a
+		 * non-existent _parent_ directory. Set &#39;data-&gt;dir&#39; to be equal
+		 * to &#39;path&#39; plus an additional slash, so it can be used for
+		 * caching in the future. The filename of &#39;path&#39; is considered
+		 * a non-existent directory.
+		 *
+		 * Note: if &#34;{path}/&#34; exists as a directory, then it will never
+		 * appear as a prefix of other callers to this method, assuming
+		 * the context from the clear_skip_worktree... methods. If this
+		 * method is reused, then this must be reconsidered.
+		 */
+		if (!next_slash) {
+			strbuf_addstr(&#38;data-&gt;dir, rest);
+			strbuf_addch(&#38;data-&gt;dir, &#39;/&#39;);
+			break;
+		}
</span> 
<span
class="add">+		/*
+		 * Now that we have a slash, let&#39;s grow &#39;data-&gt;dir&#39; to include
+		 * this slash, then test if we should stop.
+		 */
+		strbuf_add(&#38;data-&gt;dir, rest, next_slash - rest + 1);
+
+		/* If the parent dir doesn&#39;t exist, then stop here. */
+		data-&gt;lstat_count++;
+		if (lstat(data-&gt;dir.buf, &#38;st))
+			return 0;
+	}
+
+	/*
+	 * At this point, &#39;data-&gt;dir&#39; is equal to &#39;path&#39; plus a slash character,
+	 * and the parent directory of &#39;path&#39; definitely exists. Moreover, we
+	 * know that &#39;path&#39; doesn&#39;t exist, or we would have returned 1 earlier.
+	 */
</span> 	return 0;
 }
 
-- 
gitgitgadget
</pre></div></content></entry><entry><author><name>Derrick Stolee via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 4/5] sparse-index: count lstat() calls</title><updated>2024-06-26T14:29:59Z</updated><link
href="http://lore.kernel.org/git/9549f5b8062909253fef1fc9a62dae9114c43481.1719412192.git.gitgitgadget@gmail.com/"/><id>urn:uuid:e1ea1bb6-15b6-fbe1-bfbf-f3e5a5ebcf1e</id><thr:in-reply-to
ref="urn:uuid:e1fea83c-e522-ca3f-fb5f-a0f066693ba5"
href="http://lore.kernel.org/git/pull.1754.v2.git.1719412192.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Derrick Stolee &lt;stolee@gmail.com&gt;

The clear_skip_worktree.. methods already report some statistics about
how many cache entries are checked against path_found() due to having
the skip-worktree bit set. However, due to path_found() performing some
caching, this isn&#39;t the only information that would be helpful to
report.

Add a new lstat_count member to the path_found_data struct to count the
number of times path_found() calls lstat(). This will be helpful to help
explain performance problems in this method as well as to demonstrate
future changes to the caching algorithm in a more concrete way than
end-to-end timings.

Signed-off-by: Derrick Stolee &lt;stolee@gmail.com&gt;
---
 sparse-index.c | 7 +++++++
 1 file <a href="http://lore.kernel.org/git/9549f5b8062909253fef1fc9a62dae9114c43481.1719412192.git.gitgitgadget@gmail.com/#related">changed</a>, 7 insertions(+)

<span
class="head">diff --git a/sparse-index.c b/sparse-index.c
index fec4f393360..8577fa726b8 100644
--- a/sparse-index.c
+++ b/sparse-index.c
</span><span
class="hunk">@@ -442,6 +442,7 @@ void ensure_correct_sparsity(struct index_state *istate)
</span> struct path_found_data {
 	struct strbuf dir;
 	int dir_found;
<span
class="add">+	size_t lstat_count;
</span> };
 
 #define PATH_FOUND_DATA_INIT { \
<span
class="hunk">@@ -469,6 +470,7 @@ static int path_found(const char *path, struct path_found_data *data)
</span> 	/*
 	 * If path itself exists, return 1.
 	 */
<span
class="add">+	data-&gt;lstat_count++;
</span> 	if (!lstat(path, &#38;st))
 		return 1;
 
<span
class="hunk">@@ -493,6 +495,7 @@ static int path_found(const char *path, struct path_found_data *data)
</span> 	strbuf_reset(&#38;data-&gt;dir);
 	strbuf_add(&#38;data-&gt;dir, path, newdir - path + 1);
 
<span
class="add">+	data-&gt;lstat_count++;
</span> 	data-&gt;dir_found = !lstat(data-&gt;dir.buf, &#38;st);
 
 	return 0;
<span
class="hunk">@@ -524,6 +527,8 @@ static int clear_skip_worktree_from_present_files_sparse(struct index_state *ist
</span> 
 	trace2_data_intmax(&#34;index&#34;, istate-&gt;repo,
 			   &#34;sparse_path_count&#34;, path_count);
<span
class="add">+	trace2_data_intmax(&#34;index&#34;, istate-&gt;repo,
+			   &#34;sparse_lstat_count&#34;, data.lstat_count);
</span> 	trace2_region_leave(&#34;index&#34;, &#34;clear_skip_worktree_from_present_files_sparse&#34;,
 			    istate-&gt;repo);
 	clear_path_found_data(&#38;data);
<span
class="hunk">@@ -553,6 +558,8 @@ static void clear_skip_worktree_from_present_files_full(struct index_state *ista
</span> 
 	trace2_data_intmax(&#34;index&#34;, istate-&gt;repo,
 			   &#34;full_path_count&#34;, path_count);
<span
class="add">+	trace2_data_intmax(&#34;index&#34;, istate-&gt;repo,
+			   &#34;full_lstat_count&#34;, data.lstat_count);
</span> 	trace2_region_leave(&#34;index&#34;, &#34;clear_skip_worktree_from_present_files_full&#34;,
 			    istate-&gt;repo);
 	clear_path_found_data(&#38;data);
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Derrick Stolee via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 3/5] sparse-index: use strbuf in path_found()</title><updated>2024-06-26T14:29:57Z</updated><link
href="http://lore.kernel.org/git/0a82e6b4183e007316a8b027086ad3c960901103.1719412192.git.gitgitgadget@gmail.com/"/><id>urn:uuid:4733f9b4-5fa4-5ccf-758f-dfaf1e2ad4b3</id><thr:in-reply-to
ref="urn:uuid:e1fea83c-e522-ca3f-fb5f-a0f066693ba5"
href="http://lore.kernel.org/git/pull.1754.v2.git.1719412192.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Derrick Stolee &lt;stolee@gmail.com&gt;

The path_found() method previously reused strings from the cache entries
the calling methods were using. This prevents string manipulation in
place and causes some odd reallocation before the final lstat() call in
the method.

Refactor the method to use strbufs and copy the path into the strbuf,
but also only the parent directory and not the whole path. This looks
like extra copying when assigning the path to the strbuf, but we save an
allocation by dropping the &#39;tmp&#39; string, and we are &#34;reusing&#34; the copy
from &#39;tmp&#39; to put the data in the strbuf.

Signed-off-by: Derrick Stolee &lt;stolee@gmail.com&gt;
---
 sparse-index.c | 21 +++++++++------------
 1 file <a href="http://lore.kernel.org/git/0a82e6b4183e007316a8b027086ad3c960901103.1719412192.git.gitgitgadget@gmail.com/#related">changed</a>, 9 insertions(+), 12 deletions(-)

<span
class="head">diff --git a/sparse-index.c b/sparse-index.c
index de6e727f5c1..fec4f393360 100644
--- a/sparse-index.c
+++ b/sparse-index.c
</span><span
class="hunk">@@ -440,31 +440,30 @@ void ensure_correct_sparsity(struct index_state *istate)
</span> }
 
 struct path_found_data {
<span
class="del">-	const char *dirname;
-	size_t dir_len;
</span><span
class="add">+	struct strbuf dir;
</span> 	int dir_found;
 };
 
 #define PATH_FOUND_DATA_INIT { \
<span
class="add">+	.dir = STRBUF_INIT, \
</span> 	.dir_found = 1 \
 }
 
 static void clear_path_found_data(struct path_found_data *data)
 {
<span
class="del">-	return;
</span><span
class="add">+	strbuf_release(&#38;data-&gt;dir);
</span> }
 
 static int path_found(const char *path, struct path_found_data *data)
 {
 	struct stat st;
 	char *newdir;
<span
class="del">-	char *tmp;
</span> 
 	/*
 	 * If dirname corresponds to a directory that doesn&#39;t exist, and this
 	 * path starts with dirname, then path can&#39;t exist.
 	 */
<span
class="del">-	if (!data-&gt;dir_found &#38;&#38; !memcmp(path, data-&gt;dirname, data-&gt;dir_len))
</span><span
class="add">+	if (!data-&gt;dir_found &#38;&#38; !memcmp(path, data-&gt;dir.buf, data-&gt;dir.len))
</span> 		return 0;
 
 	/*
<span
class="hunk">@@ -486,17 +485,15 @@ static int path_found(const char *path, struct path_found_data *data)
</span> 	 * If path starts with directory (which we already lstat&#39;ed and found),
 	 * then no need to lstat parent directory again.
 	 */
<span
class="del">-	if (data-&gt;dir_found &#38;&#38; data-&gt;dirname &#38;&#38;
-	    memcmp(path, data-&gt;dirname, data-&gt;dir_len))
</span><span
class="add">+	if (data-&gt;dir_found &#38;&#38; data-&gt;dir.buf &#38;&#38;
+	    memcmp(path, data-&gt;dir.buf, data-&gt;dir.len))
</span> 		return 0;
 
 	/* Free previous dirname, and cache path&#39;s dirname */
<span
class="del">-	data-&gt;dirname = path;
-	data-&gt;dir_len = newdir - path + 1;
</span><span
class="add">+	strbuf_reset(&#38;data-&gt;dir);
+	strbuf_add(&#38;data-&gt;dir, path, newdir - path + 1);
</span> 
<span
class="del">-	tmp = xstrndup(path, data-&gt;dir_len);
-	data-&gt;dir_found = !lstat(tmp, &#38;st);
-	free(tmp);
</span><span
class="add">+	data-&gt;dir_found = !lstat(data-&gt;dir.buf, &#38;st);
</span> 
 	return 0;
 }
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Derrick Stolee via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 2/5] sparse-index: refactor path_found()</title><updated>2024-06-26T14:29:57Z</updated><link
href="http://lore.kernel.org/git/69c3beaabf7ca8ccf5bbaa248328f77b1be915ba.1719412192.git.gitgitgadget@gmail.com/"/><id>urn:uuid:6d368187-8fa5-c899-b708-ac0f5dd8d39d</id><thr:in-reply-to
ref="urn:uuid:e1fea83c-e522-ca3f-fb5f-a0f066693ba5"
href="http://lore.kernel.org/git/pull.1754.v2.git.1719412192.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Derrick Stolee &lt;stolee@gmail.com&gt;

In advance of changing the behavior of path_found(), take all of the
intermediate data values and group them into a single struct. This
simplifies the method prototype as well as the initialization. Future
changes can be made directly to the struct and method without changing
the callers with this approach.

Note that the clear_path_found_data() method is currently empty, as
there is nothing to free. This method is a placeholder for future
changes that require a non-trivial implementation. Its stub is created
now so consumers could call it now and not change in future changes.

Signed-off-by: Derrick Stolee &lt;stolee@gmail.com&gt;
---
 sparse-index.c | 45 +++++++++++++++++++++++++++++----------------
 1 file <a href="http://lore.kernel.org/git/69c3beaabf7ca8ccf5bbaa248328f77b1be915ba.1719412192.git.gitgitgadget@gmail.com/#related">changed</a>, 29 insertions(+), 16 deletions(-)

<span
class="head">diff --git a/sparse-index.c b/sparse-index.c
index e0457c87fff..de6e727f5c1 100644
--- a/sparse-index.c
+++ b/sparse-index.c
</span><span
class="hunk">@@ -439,8 +439,22 @@ void ensure_correct_sparsity(struct index_state *istate)
</span> 		ensure_full_index(istate);
 }
 
<span
class="del">-static int path_found(const char *path, const char **dirname, size_t *dir_len,
-		      int *dir_found)
</span><span
class="add">+struct path_found_data {
+	const char *dirname;
+	size_t dir_len;
+	int dir_found;
+};
+
+#define PATH_FOUND_DATA_INIT { \
+	.dir_found = 1 \
+}
+
+static void clear_path_found_data(struct path_found_data *data)
+{
+	return;
+}
+
+static int path_found(const char *path, struct path_found_data *data)
</span> {
 	struct stat st;
 	char *newdir;
<span
class="hunk">@@ -450,7 +464,7 @@ static int path_found(const char *path, const char **dirname, size_t *dir_len,
</span> 	 * If dirname corresponds to a directory that doesn&#39;t exist, and this
 	 * path starts with dirname, then path can&#39;t exist.
 	 */
<span
class="del">-	if (!*dir_found &#38;&#38; !memcmp(path, *dirname, *dir_len))
</span><span
class="add">+	if (!data-&gt;dir_found &#38;&#38; !memcmp(path, data-&gt;dirname, data-&gt;dir_len))
</span> 		return 0;
 
 	/*
<span
class="hunk">@@ -472,15 +486,16 @@ static int path_found(const char *path, const char **dirname, size_t *dir_len,
</span> 	 * If path starts with directory (which we already lstat&#39;ed and found),
 	 * then no need to lstat parent directory again.
 	 */
<span
class="del">-	if (*dir_found &#38;&#38; *dirname &#38;&#38; memcmp(path, *dirname, *dir_len))
</span><span
class="add">+	if (data-&gt;dir_found &#38;&#38; data-&gt;dirname &#38;&#38;
+	    memcmp(path, data-&gt;dirname, data-&gt;dir_len))
</span> 		return 0;
 
 	/* Free previous dirname, and cache path&#39;s dirname */
<span
class="del">-	*dirname = path;
-	*dir_len = newdir - path + 1;
</span><span
class="add">+	data-&gt;dirname = path;
+	data-&gt;dir_len = newdir - path + 1;
</span> 
<span
class="del">-	tmp = xstrndup(path, *dir_len);
-	*dir_found = !lstat(tmp, &#38;st);
</span><span
class="add">+	tmp = xstrndup(path, data-&gt;dir_len);
+	data-&gt;dir_found = !lstat(tmp, &#38;st);
</span> 	free(tmp);
 
 	return 0;
<span
class="hunk">@@ -488,9 +503,7 @@ static int path_found(const char *path, const char **dirname, size_t *dir_len,
</span> 
 static int clear_skip_worktree_from_present_files_sparse(struct index_state *istate)
 {
<span
class="del">-	const char *last_dirname = NULL;
-	size_t dir_len = 0;
-	int dir_found = 1;
</span><span
class="add">+	struct path_found_data data = PATH_FOUND_DATA_INIT;
</span> 
 	int path_count = 0;
 	int to_restart = 0;
<span
class="hunk">@@ -502,7 +515,7 @@ static int clear_skip_worktree_from_present_files_sparse(struct index_state *ist
</span> 
 		if (ce_skip_worktree(ce)) {
 			path_count++;
<span
class="del">-			if (path_found(ce-&gt;name, &#38;last_dirname, &#38;dir_len, &#38;dir_found)) {
</span><span
class="add">+			if (path_found(ce-&gt;name, &#38;data)) {
</span> 				if (S_ISSPARSEDIR(ce-&gt;ce_mode)) {
 					to_restart = 1;
 					break;
<span
class="hunk">@@ -516,14 +529,13 @@ static int clear_skip_worktree_from_present_files_sparse(struct index_state *ist
</span> 			   &#34;sparse_path_count&#34;, path_count);
 	trace2_region_leave(&#34;index&#34;, &#34;clear_skip_worktree_from_present_files_sparse&#34;,
 			    istate-&gt;repo);
<span
class="add">+	clear_path_found_data(&#38;data);
</span> 	return to_restart;
 }
 
 static void clear_skip_worktree_from_present_files_full(struct index_state *istate)
 {
<span
class="del">-	const char *last_dirname = NULL;
-	size_t dir_len = 0;
-	int dir_found = 1;
</span><span
class="add">+	struct path_found_data data = PATH_FOUND_DATA_INIT;
</span> 
 	int path_count = 0;
 
<span
class="hunk">@@ -537,7 +549,7 @@ static void clear_skip_worktree_from_present_files_full(struct index_state *ista
</span> 
 		if (ce_skip_worktree(ce)) {
 			path_count++;
<span
class="del">-			if (path_found(ce-&gt;name, &#38;last_dirname, &#38;dir_len, &#38;dir_found))
</span><span
class="add">+			if (path_found(ce-&gt;name, &#38;data))
</span> 				ce-&gt;ce_flags &#38;= ~CE_SKIP_WORKTREE;
 		}
 	}
<span
class="hunk">@@ -546,6 +558,7 @@ static void clear_skip_worktree_from_present_files_full(struct index_state *ista
</span> 			   &#34;full_path_count&#34;, path_count);
 	trace2_region_leave(&#34;index&#34;, &#34;clear_skip_worktree_from_present_files_full&#34;,
 			    istate-&gt;repo);
<span
class="add">+	clear_path_found_data(&#38;data);
</span> }
 
 void clear_skip_worktree_from_present_files(struct index_state *istate)
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Derrick Stolee via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 1/5] sparse-checkout: refactor skip worktree retry logic</title><updated>2024-06-26T14:29:56Z</updated><link
href="http://lore.kernel.org/git/93d0baed0b0f435e5656cef04cf103b5e2e0f41a.1719412192.git.gitgitgadget@gmail.com/"/><id>urn:uuid:a760fb05-f931-8df8-f159-2ce9b2d43e8d</id><thr:in-reply-to
ref="urn:uuid:e1fea83c-e522-ca3f-fb5f-a0f066693ba5"
href="http://lore.kernel.org/git/pull.1754.v2.git.1719412192.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Derrick Stolee &lt;stolee@gmail.com&gt;

The clear_skip_worktree_from_present_files() method was introduced in
af6a51875a (repo_read_index: clear SKIP_WORKTREE bit from files present
in worktree, 2022-01-14) to help cases where sparse-checkout is enabled
but some paths outside of the sparse-checkout also exist on disk.  This
operation can be slow as it needs to check path existence in a way not
stored in the index, so caching was introduced in d79d299352 (Accelerate
clear_skip_worktree_from_present_files() by caching, 2022-01-14).

If users are having trouble with the performance of this operation and
don&#39;t care about paths outside of the sparse-checkout, they can disable
them using the sparse.expectFilesOutsideOfPatterns config option
introduced in ecc7c8841d (repo_read_index: add config to expect files
outside sparse patterns, 2022-02-25).

This check is particularly confusing in the presence of a sparse index,
as a sparse tree entry corresponding to an existing directory must first
be expanded to a full index before examining the paths within. This is
currently implemented using a &#39;goto&#39; and a boolean variable to ensure we
restart only once.

Even with that caching, it was noticed that this could take a long time
to execute. 89aaab11a3 (index: add trace2 region for clear skip
worktree, 2022-11-03) introduced trace2 regions to measure this time.
Further, the way the loop repeats itself was slightly confusing and
prone to breakage, so a BUG() statement was added in 8c7abdc596 (index:
raise a bug if the index is materialised more than once, 2022-11-03) to
be sure that the second run of the loop does not hit any sparse trees.

One thing that can be confusing about the current setup is that the
trace2 regions nest and it is not clear that a second loop is running
after a sparse index is expanded. Here is an example of what the regions
look like in a typical case:

| region_enter | ... | label:clear_skip_worktree_from_present_files
| region_enter | ... | ..label:update
| region_leave | ... | ..label:update
| region_enter | ... | ..label:ensure_full_index
| region_enter | ... | ....label:update
| region_leave | ... | ....label:update
| region_leave | ... | ..label:ensure_full_index
| data         | ... | ..sparse_path_count:1
| data         | ... | ..sparse_path_count_full:269538
| region_leave | ... | label:clear_skip_worktree_from_present_files

One thing that is particularly difficult to understand about these
regions is that most of the time is spent between the close of the
ensure_full_index region and the reporting of the end data. This is
because of the restart of the loop being within the same region as the
first iteration of the loop.

This change refactors the method into two separate methods that are
traced separately. This will be more important later when we change
other features of the methods, but for now the only functional change is
the difference in the structure of the trace regions.

After this change, the same telemetry section is split into three
distinct chunks:

| region_enter | ... | label:clear_skip_worktree_from_present_files_sparse
| data         | ... | ..sparse_path_count:1
| region_leave | ... | label:clear_skip_worktree_from_present_files_sparse
| region_enter | ... | label:update
| region_leave | ... | label:update
| region_enter | ... | label:ensure_full_index
| region_enter | ... | ..label:update
| region_leave | ... | ..label:update
| region_leave | ... | label:ensure_full_index
| region_enter | ... | label:clear_skip_worktree_from_present_files_full
| data         | ... | ..full_path_count:269538
| region_leave | ... | label:clear_skip_worktree_from_present_files_full

Here, we see the sparse loop terminating early with its first sparse
path being a sparse directory containing a file. Then, that loop&#39;s
region terminates before ensure_full_index begins (in this case, the
cache-tree must also be computed). Then, _after_ the index is expanded,
the full loop begins with its own region.

Signed-off-by: Derrick Stolee &lt;stolee@gmail.com&gt;
---
 sparse-index.c | 77 ++++++++++++++++++++++++++++++++++----------------
 1 file <a href="http://lore.kernel.org/git/93d0baed0b0f435e5656cef04cf103b5e2e0f41a.1719412192.git.gitgitgadget@gmail.com/#related">changed</a>, 53 insertions(+), 24 deletions(-)

<span
class="head">diff --git a/sparse-index.c b/sparse-index.c
index e48e40cae71..e0457c87fff 100644
--- a/sparse-index.c
+++ b/sparse-index.c
</span><span
class="hunk">@@ -486,49 +486,78 @@ static int path_found(const char *path, const char **dirname, size_t *dir_len,
</span> 	return 0;
 }
 
<span
class="del">-void clear_skip_worktree_from_present_files(struct index_state *istate)
</span><span
class="add">+static int clear_skip_worktree_from_present_files_sparse(struct index_state *istate)
</span> {
 	const char *last_dirname = NULL;
 	size_t dir_len = 0;
 	int dir_found = 1;
 
<span
class="del">-	int i;
-	int path_count[2] = {0, 0};
-	int restarted = 0;
</span><span
class="add">+	int path_count = 0;
+	int to_restart = 0;
</span> 
<span
class="del">-	if (!core_apply_sparse_checkout ||
-	    sparse_expect_files_outside_of_patterns)
-		return;
-
-	trace2_region_enter(&#34;index&#34;, &#34;clear_skip_worktree_from_present_files&#34;,
</span><span
class="add">+	trace2_region_enter(&#34;index&#34;, &#34;clear_skip_worktree_from_present_files_sparse&#34;,
</span> 			    istate-&gt;repo);
<span
class="del">-restart:
-	for (i = 0; i &lt; istate-&gt;cache_nr; i++) {
</span><span
class="add">+	for (int i = 0; i &lt; istate-&gt;cache_nr; i++) {
</span> 		struct cache_entry *ce = istate-&gt;cache[i];
 
 		if (ce_skip_worktree(ce)) {
<span
class="del">-			path_count[restarted]++;
</span><span
class="add">+			path_count++;
</span> 			if (path_found(ce-&gt;name, &#38;last_dirname, &#38;dir_len, &#38;dir_found)) {
 				if (S_ISSPARSEDIR(ce-&gt;ce_mode)) {
<span
class="del">-					if (restarted)
-						BUG(&#34;ensure-full-index did not fully flatten?&#34;);
-					ensure_full_index(istate);
-					restarted = 1;
-					goto restart;
</span><span
class="add">+					to_restart = 1;
+					break;
</span> 				}
 				ce-&gt;ce_flags &#38;= ~CE_SKIP_WORKTREE;
 			}
 		}
 	}
 
<span
class="del">-	if (path_count[0])
-		trace2_data_intmax(&#34;index&#34;, istate-&gt;repo,
-				   &#34;sparse_path_count&#34;, path_count[0]);
-	if (restarted)
-		trace2_data_intmax(&#34;index&#34;, istate-&gt;repo,
-				   &#34;sparse_path_count_full&#34;, path_count[1]);
-	trace2_region_leave(&#34;index&#34;, &#34;clear_skip_worktree_from_present_files&#34;,
</span><span
class="add">+	trace2_data_intmax(&#34;index&#34;, istate-&gt;repo,
+			   &#34;sparse_path_count&#34;, path_count);
+	trace2_region_leave(&#34;index&#34;, &#34;clear_skip_worktree_from_present_files_sparse&#34;,
+			    istate-&gt;repo);
+	return to_restart;
+}
+
+static void clear_skip_worktree_from_present_files_full(struct index_state *istate)
+{
+	const char *last_dirname = NULL;
+	size_t dir_len = 0;
+	int dir_found = 1;
+
+	int path_count = 0;
+
+	trace2_region_enter(&#34;index&#34;, &#34;clear_skip_worktree_from_present_files_full&#34;,
</span> 			    istate-&gt;repo);
<span
class="add">+	for (int i = 0; i &lt; istate-&gt;cache_nr; i++) {
+		struct cache_entry *ce = istate-&gt;cache[i];
+
+		if (S_ISSPARSEDIR(ce-&gt;ce_mode))
+			BUG(&#34;ensure-full-index did not fully flatten?&#34;);
+
+		if (ce_skip_worktree(ce)) {
+			path_count++;
+			if (path_found(ce-&gt;name, &#38;last_dirname, &#38;dir_len, &#38;dir_found))
+				ce-&gt;ce_flags &#38;= ~CE_SKIP_WORKTREE;
+		}
+	}
+
+	trace2_data_intmax(&#34;index&#34;, istate-&gt;repo,
+			   &#34;full_path_count&#34;, path_count);
+	trace2_region_leave(&#34;index&#34;, &#34;clear_skip_worktree_from_present_files_full&#34;,
+			    istate-&gt;repo);
+}
+
+void clear_skip_worktree_from_present_files(struct index_state *istate)
+{
+	if (!core_apply_sparse_checkout ||
+	    sparse_expect_files_outside_of_patterns)
+		return;
+
+	if (clear_skip_worktree_from_present_files_sparse(istate)) {
+		ensure_full_index(istate);
+		clear_skip_worktree_from_present_files_full(istate);
+	}
</span> }
 
 /*
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Derrick Stolee via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 0/5] sparse-index: improve clear_skip_worktree_from_present_files()</title><updated>2024-06-26T14:29:55Z</updated><link
href="http://lore.kernel.org/git/pull.1754.v2.git.1719412192.gitgitgadget@gmail.com/"/><id>urn:uuid:e1fea83c-e522-ca3f-fb5f-a0f066693ba5</id><thr:in-reply-to
ref="urn:uuid:0a3e9f9b-e887-e20a-cd21-226c7be2a265"
href="http://lore.kernel.org/git/pull.1754.git.1718899877.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">While doing some investigation in a private monorepo with sparse-checkout
and a sparse index, I accidentally left a modified file outside of my
sparse-checkout cone. This caused my Git commands to slow to a crawl, so I
reran with GIT_TRACE2_PERF=1.

While I was able to identify clear_skip_worktree_from_present_files() as the
culprit, it took longer than desired to figure out what was going on. This
series intends to both fix the performance issue (as much as possible) and
do some refactoring to make it easier to understand what is happening.

In the end, I was able to reduce the number of lstat() calls in my case from
over 1.1 million to about 4,400, improving the time from 13.4s to 81ms on a
warm disk cache. (These numbers are from a test after v2, which somehow hit
the old caching algorithm even worse than my test in v1.)


Updates in v2
=============

Thanks to Elijah for a thorough review, leading to valuable improvements.

 * I was mistaken that the sparse index was required for this logic to
   happen. This has changed several descriptions across the commit messages.
 * The final lstat() in path_found() was not needed, so is removed in v2.
   This saves even more time and lstat() calls, updating the stats.
 * Elijah created a particularly nasty example for testing, which I include
   in my final patch. He gets a &#34;Helped-by&#34; credit for this.
 * Several comments, variables, and other improvements based on Elijah&#39;s
   recommendations.

Thanks, Stolee

Derrick Stolee (5):
  sparse-checkout: refactor skip worktree retry logic
  sparse-index: refactor path_found()
  sparse-index: use strbuf in path_found()
  sparse-index: count lstat() calls
  sparse-index: improve lstat caching of sparse paths

 sparse-index.c | 216 +++++++++++++++++++++++++++++++++++++------------
 1 file changed, 164 insertions(+), 52 deletions(-)


base-commit: 66ac6e4bcd111be3fa9c2a6b3fafea718d00678d
Published-As: <a
href="https://github.com/gitgitgadget/git/releases/tag/pr-1754%2Fderrickstolee%2Fclear-skip-speed-v2">https://github.com/gitgitgadget/git/releases/tag/pr-1754%2Fderrickstolee%2Fclear-skip-speed-v2</a>
Fetch-It-Via: git fetch <a
href="https://github.com/gitgitgadget/git">https://github.com/gitgitgadget/git</a> pr-1754/derrickstolee/clear-skip-speed-v2
Pull-Request: <a
href="https://github.com/gitgitgadget/git/pull/1754">https://github.com/gitgitgadget/git/pull/1754</a>

Range-diff vs v1:

 1:  ddd8a9a90ce ! 1:  93d0baed0b0 sparse-index: refactor skip worktree retry logic
     @@ Metadata
      Author: Derrick Stolee &lt;dstolee@microsoft.com&gt;
      
       ## Commit message ##
     -    sparse-index: refactor skip worktree retry logic
     +    sparse-checkout: refactor skip worktree retry logic
      
          The clear_skip_worktree_from_present_files() method was introduced in
          af6a51875a (repo_read_index: clear SKIP_WORKTREE bit from files present
     -    in worktree, 2022-01-14) to help cases where the sparse index is enabled
     -    but some paths outside of the sparse-checkout cone also exist on disk.
     -    This operation can be slow as it needs to check path existence in a way
     -    that is not stored in the collapsed index, so caching was introduced in
     -    d79d299352 (Accelerate clear_skip_worktree_from_present_files() by
     -    caching, 2022-01-14).
     +    in worktree, 2022-01-14) to help cases where sparse-checkout is enabled
     +    but some paths outside of the sparse-checkout also exist on disk.  This
     +    operation can be slow as it needs to check path existence in a way not
     +    stored in the index, so caching was introduced in d79d299352 (Accelerate
     +    clear_skip_worktree_from_present_files() by caching, 2022-01-14).
      
          If users are having trouble with the performance of this operation and
     -    don&#39;t care about paths outside of the sparse-checkout cone, they can
     -    disable them using the sparse.expectFilesOutsideOfPatterns config option
     +    don&#39;t care about paths outside of the sparse-checkout, they can disable
     +    them using the sparse.expectFilesOutsideOfPatterns config option
          introduced in ecc7c8841d (repo_read_index: add config to expect files
          outside sparse patterns, 2022-02-25).
      
     +    This check is particularly confusing in the presence of a sparse index,
     +    as a sparse tree entry corresponding to an existing directory must first
     +    be expanded to a full index before examining the paths within. This is
     +    currently implemented using a &#39;goto&#39; and a boolean variable to ensure we
     +    restart only once.
     +
          Even with that caching, it was noticed that this could take a long time
          to execute. 89aaab11a3 (index: add trace2 region for clear skip
          worktree, 2022-11-03) introduced trace2 regions to measure this time.
     @@ Commit message
      
          One thing that can be confusing about the current setup is that the
          trace2 regions nest and it is not clear that a second loop is running
     -    after the index is expanded. Here is an example of what the regions look
     -    like in a typical case:
     +    after a sparse index is expanded. Here is an example of what the regions
     +    look like in a typical case:
      
          | region_enter | ... | label:clear_skip_worktree_from_present_files
          | region_enter | ... | ..label:update
 2:  7c3b545ee5e ! 2:  69c3beaabf7 sparse-index: refactor path_found()
     @@ Commit message
          the callers with this approach.
      
          Note that the clear_path_found_data() method is currently empty, as
     -    there is nothing to free. However, this will change in the future, so
     -    place the method and its callers for now.
     +    there is nothing to free. This method is a placeholder for future
     +    changes that require a non-trivial implementation. Its stub is created
     +    now so consumers could call it now and not change in future changes.
      
          Signed-off-by: Derrick Stolee &lt;stolee@gmail.com&gt;
      
 3:  217594ffb10 = 3:  0a82e6b4183 sparse-index: use strbuf in path_found()
 4:  88a3145e585 = 4:  9549f5b8062 sparse-index: count lstat() calls
 5:  2654fcb7142 ! 5:  0cb344ac14f sparse-index: improve lstat caching of sparse paths
     @@ Commit message
          in af6a51875a (repo_read_index: clear SKIP_WORKTREE bit from files
          present in worktree, 2022-01-14) to allow better interaction with the
          working directory in the presence of paths outside of the
     -    sparse-checkout cone. The initial implementation would lstat() every
     -    single sparse tree to see if it existed, and if one did, then the sparse
     -    index would expand and every sparse file would be checked.
     +    sparse-checkout. The initial implementation would lstat() every single
     +    SKIP_WORKTREE path to see if it existed; if it ran across a sparse
     +    directory that existed (when a sparse index was in use), then it would
     +    expand the index and then check every SKIP_WORKTREE path.
      
          Since these lstat() calls were very expensive, this was improved in
          d79d299352 (Accelerate clear_skip_worktree_from_present_files() by
     -    caching, 2022-01-14) by caching directories that do not exist. However,
     -    there are some inefficiencies in that caching mechanism.
     +    caching, 2022-01-14) by caching directories that do not exist so it
     +    could avoid lstat()ing any files under such directories. However, there
     +    are some inefficiencies in that caching mechanism.
      
          The caching mechanism stored only the parent directory as not existing,
          even if a higher parent directory also does not exist. This means that
     -    wasted lstat() calls would occur when the sparse files change immediate
     -    parent directories but within the same root directory that does not
     -    exist.
     +    wasted lstat() calls would occur when the paths passed to path_found()
     +    change immediate parent directories but within the same parent directory
     +    that does not exist.
     +
     +    To create an example repository that demonstrates this problem, it helps
     +    to have a directory outside of the sparse-checkout that contains many
     +    deep paths. In particular, the first paths (in lexicographic order)
     +    underneath the sparse directory should have deep directory structures,
     +    maximizing the difference between the old caching algorithm that looks
     +    to a single parent and the new caching algorithm that looks to the
     +    top-most missing directory.
      
     -    To set up a scenario that triggers this code in an interesting way, we
     -    need a sparse-checkout in cone mode and a sparse index. To trigger the
     -    full index expansion and a call to the
     -    clear_skip_worktree_from_present_files_full() method, we need one of the
     -    sparse trees to actually exist on disk. The performance test script
     -    p2000-sparse-operations.sh takes the sample repository and copies its
     -    HEAD to several copies nested in directories of the form f&lt;i&gt;/f&lt;j&gt;/f&lt;k&gt;
     -    where i, j, and k are numbers from 1 to 4. The sparse-checkout cone is
     -    then selected as &#34;f2/f4/&#34;. Creating &#34;f1/f1/&#34; will trigger the behavior
     -    and also lead to some interesting cases for the caching algorithm since
     -    &#34;f1/f1/&#34; exists but &#34;f1/f2/&#34; and &#34;f3/&#34; do not.
     +    The performance test script p2000-sparse-operations.sh takes the sample
     +    repository and copies its HEAD to several copies nested in directories
     +    of the form f&lt;i&gt;/f&lt;j&gt;/f&lt;k&gt; where i, j, and k are numbers from 1 to 4.
     +    The sparse-checkout cone is then selected as &#34;f2/f4/&#34;. Creating &#34;f1/f1/&#34;
     +    will trigger the behavior and also lead to some interesting cases for
     +    the caching algorithm since &#34;f1/f1/&#34; exists but &#34;f1/f2/&#34; and &#34;f3/&#34; do
     +    not.
      
          This is difficult to notice when running performance tests using the Git
          repository (or a blow-up of the Git repository, as in
          p2000-sparse-operations.sh) because Git has a very shallow directory
          structure.
      
     -    This change reorganizes the caching algorithm to focus on storing both
     -    the deepest _existing_ directory and the next-level non-existing
     -    directory. By doing a little extra work on the first sparse file, we can
     -    short-circuit all of the sparse files that exist in that non-existing
     -    directory. When in a repository where the first sparse file is likely to
     -    have a much deeper path than the first non-existing directory, this can
     -    realize significant gains.
     +    This change reorganizes the caching algorithm to focus on storing the
     +    highest level leading directory that does not exist; specifically this
     +    means that that directory&#39;s parent _does_ exist. By doing a little extra
     +    work on a path passed to path_found(), we can short-circuit all of the
     +    paths passed to path_found() afterwards that match a prefix with that
     +    non-existing directory. When in a repository where the first sparse file
     +    is likely to have a much deeper path than the first non-existing
     +    directory, this can realize significant gains.
      
          The details of this algorithm require careful attention, so the new
          implementation of path_found() has detailed comments, including the use
     @@ Commit message
          _increases_ from 28 to 31. However, these numbers were already
          artificially low.
      
     +    Contributor Elijah Newren created a publicly-available test repository
     +    that demonstrates the difference in these caching algorithms in the most
     +    extreme way. To test, follow these steps:
     +
     +      git clone --sparse <a
href="https://github.com/newren/gvfs-like-git-bomb">https://github.com/newren/gvfs-like-git-bomb</a>
     +      cd gvfs-like-git-bomb
     +      ./runme.sh                   # NOTE: check scripts before running!
     +
     +    At this point, assuming you do not have index.sparse=true set globally,
     +    the index has one million paths with the SKIP_WORKTREE bit and they will
     +    all be sent to path_found() in the sparse loop. You can measure this by
     +    running &#39;git status&#39; with GIT_TRACE2_PERF=1:
     +
     +        Sparse files in the index: 1,000,000
     +      sparse_lstat_count (before):   200,000
     +       sparse_lstat_count (after):         2
     +
     +    And here are the performance numbers:
     +
     +      Benchmark 1: old
     +        Time (mean &#177; &#963;):     397.5 ms &#177;   4.1 ms
     +        Range (min &#8230; max):   391.2 ms &#8230; 404.8 ms    10 runs
     +
     +      Benchmark 2: new
     +        Time (mean &#177; &#963;):     252.7 ms &#177;   3.1 ms
     +        Range (min &#8230; max):   249.4 ms &#8230; 259.5 ms    11 runs
     +
     +      Summary
     +        &#39;new&#39; ran
     +          1.57 &#177; 0.02 times faster than &#39;old&#39;
     +
     +    By modifying this example further, we can demonstrate a more realistic
     +    example and include the sparse index expansion. Continue by creating
     +    this directory, confusing both caching algorithms somewhat:
     +
     +      mkdir -p bomb/d/e/f/a/a
     +
     +    Then re-run the &#39;git status&#39; tests to see these statistics:
     +
     +        Sparse files in the index: 1,000,000
     +      sparse_lstat_count (before):   724,010
     +       sparse_lstat_count (after):       106
     +
     +      Benchmark 1: old
     +        Time (mean &#177; &#963;):     753.0 ms &#177;   3.5 ms
     +        Range (min &#8230; max):   749.7 ms &#8230; 760.9 ms    10 runs
     +
     +      Benchmark 2: new
     +        Time (mean &#177; &#963;):     201.4 ms &#177;   3.2 ms
     +        Range (min &#8230; max):   196.0 ms &#8230; 207.9 ms    14 runs
     +
     +      Summary
     +        &#39;new&#39; ran
     +          3.74 &#177; 0.06 times faster than &#39;old&#39;
     +
     +    Note that if this repository had a sparse index enabled, the additional
     +    cost of expanding the sparse index affects the total time of these
     +    commands by over four seconds, significantly diminishing the benefit of
     +    the caching algorithm. Having existing paths outside of the
     +    sparse-checkout is a known performance issue for the sparse index and is
     +    a known trade-off for the performance benefits given when no such paths
     +    exist.
     +
          Using an internal monorepo with over two million paths at HEAD and a
     -    typical sparse-checkout cone such that the index contains ~190,000
     -    entries (including over two thousand sparse trees), I was able to
     -    measure these lstat counts when one sparse directory actually exists on
     -    disk:
     +    typical sparse-checkout cone such that the sparse index contains
     +    ~190,000 entries (including over two thousand sparse trees), I was able
     +    to measure these lstat counts when one sparse directory actually exists
     +    on disk:
      
            Sparse files in expanded index: 1,841,997
     -           full_lstat_count (before):   173,259
     -           full_lstat_count  (after):     6,521
     +           full_lstat_count (before): 1,188,161
     +           full_lstat_count  (after):     4,404
      
          This resulted in this absolute time change, on a warm disk:
      
     -          Time in full loop (before): 2.527 s
     -          Time in full loop  (after): 0.071 s
     +          Time in full loop (before): 13.481 s
     +          Time in full loop  (after):  0.081 s
      
          (These times were calculated on a Windows machine, where lstat() is
          slower than a similar Linux machine.)
      
     +    Helped-by: Elijah Newren &lt;newren@gmail.com&gt;
          Signed-off-by: Derrick Stolee &lt;stolee@gmail.com&gt;
      
       ## sparse-index.c ##
     @@ sparse-index.c: static void clear_path_found_data(struct path_found_data *data)
      +	 * At this point, we know that &#39;path&#39; doesn&#39;t exist, and we know that
      +	 * the parent directory of &#39;data-&gt;dir&#39; does exist. Let&#39;s set &#39;data-&gt;dir&#39;
      +	 * to be the top-most non-existing directory of &#39;path&#39;. If the first
     -+	 * parent of &#39;path&#39; exists, then we will act ast though &#39;path&#39;
     ++	 * parent of &#39;path&#39; exists, then we will act as though &#39;path&#39;
      +	 * corresponds to a directory (by adding a slash).
       	 */
      -	newdir = strrchr(path, &#39;/&#39;);
     @@ sparse-index.c: static void clear_path_found_data(struct path_found_data *data)
      +	strbuf_setlen(&#38;data-&gt;dir, common_prefix);
      +	while (1) {
      +		/* Find the next directory in &#39;path&#39;. */
     -+		const char *next_slash = strchr(path + data-&gt;dir.len, &#39;/&#39;);
     ++		const char *rest = path + data-&gt;dir.len;
     ++		const char *next_slash = strchr(rest, &#39;/&#39;);
       
      -	data-&gt;lstat_count++;
      -	data-&gt;dir_found = !lstat(data-&gt;dir.buf, &#38;st);
     @@ sparse-index.c: static void clear_path_found_data(struct path_found_data *data)
      +		 * method is reused, then this must be reconsidered.
      +		 */
      +		if (!next_slash) {
     -+			strbuf_addstr(&#38;data-&gt;dir, path + data-&gt;dir.len);
     ++			strbuf_addstr(&#38;data-&gt;dir, rest);
      +			strbuf_addch(&#38;data-&gt;dir, &#39;/&#39;);
      +			break;
      +		}
       
     --	return 0;
      +		/*
      +		 * Now that we have a slash, let&#39;s grow &#39;data-&gt;dir&#39; to include
      +		 * this slash, then test if we should stop.
      +		 */
     -+		strbuf_add(&#38;data-&gt;dir, path + data-&gt;dir.len,
     -+			   (next_slash - path) - data-&gt;dir.len + 1);
     ++		strbuf_add(&#38;data-&gt;dir, rest, next_slash - rest + 1);
      +
     -+		/* If the path doesn&#39;t exist, then stop here. */
     ++		/* If the parent dir doesn&#39;t exist, then stop here. */
      +		data-&gt;lstat_count++;
      +		if (lstat(data-&gt;dir.buf, &#38;st))
      +			return 0;
     @@ sparse-index.c: static void clear_path_found_data(struct path_found_data *data)
      +
      +	/*
      +	 * At this point, &#39;data-&gt;dir&#39; is equal to &#39;path&#39; plus a slash character,
     -+	 * and the parent directory of &#39;path&#39; definitely exists. Let&#39;s return
     -+	 * the case of whether &#39;path&#39; exists.
     ++	 * and the parent directory of &#39;path&#39; definitely exists. Moreover, we
     ++	 * know that &#39;path&#39; doesn&#39;t exist, or we would have returned 1 earlier.
      +	 */
     -+
     -+	data-&gt;lstat_count++;
     -+	return !lstat(path, &#38;st);
     + 	return 0;
       }
       
     - static int clear_skip_worktree_from_present_files_sparse(struct index_state *istate)

-- 
gitgitgadget
</pre></div></content></entry><entry><author><name>Cs&#243;k&#225;s, Bence</name><email>csokas.bence@prolan.hu</email></author><title>[PATCH v2] git-send-email: Use sanitized address when reading mbox body</title><updated>2024-06-26T13:25:13Z</updated><link
href="http://lore.kernel.org/git/20240626132440.3762363-2-csokas.bence@prolan.hu/"/><id>urn:uuid:8131157b-28d7-129c-2c6e-e1ecf5b7b85f</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Commas and other punctuation marks in &#39;Cc: &#39;, &#39;Signed-off-by: &#39;
etc. lines mess with git-send-email. In parsing the mbox headers,
this is handled by calling `sanitize_address()`. This function
is called when parsing the message body as well, but was only
used for comparing it to $author. Now we add it to @cc too.

Note that sanitization is only done for the message body, as
`git format-patch` already RFC 2047-encodes mbox headers, so
those are generally trusted to be sane. Also note that
`sanitize_address()` does not process the mailbox addresses,
so it is up to `sendmail` to handle special characters there
(e.g. there are mailboxes in rwgular use with &#39;+&#39;-es in them).

Signed-off-by: Cs&#243;k&#225;s, Bence &lt;csokas.bence@prolan.hu&gt;
---

Notes:
    Changes in v2:
    * added testcase to t9001
    * added rationale behind trusting mbox headers and the address-parts

 git-send-email.perl   |  4 ++--
 t/t9001-send-email.sh | 30 ++++++++++++++++++++++++++++++
 2 files <a href="http://lore.kernel.org/git/20240626132440.3762363-2-csokas.bence@prolan.hu/#related">changed</a>, 32 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/git-send-email.perl b/git-send-email.perl
index f0be4b4560..72044e5ef3 100755
--- a/git-send-email.perl
+++ b/git-send-email.perl
</span><span
class="hunk">@@ -1847,9 +1847,9 @@ sub pre_process_file {
</span> 					$what, $_) unless $quiet;
 				next;
 			}
<span
class="del">-			push @cc, $c;
</span><span
class="add">+			push @cc, $sc;
</span> 			printf(__(&#34;(body) Adding cc: %s from line &#39;%s&#39;\n&#34;),
<span
class="del">-				$c, $_) unless $quiet;
</span><span
class="add">+				$sc, $_) unless $quiet;
</span> 		}
 	}
 	close $fh;
<span
class="head">diff --git a/t/t9001-send-email.sh b/t/t9001-send-email.sh
index 58699f8e4e..7e0b8ae57c 100755
--- a/t/t9001-send-email.sh
+++ b/t/t9001-send-email.sh
</span><span
class="hunk">@@ -1299,6 +1299,36 @@ test_expect_success $PREREQ &#39;utf8 sender is not duplicated&#39; &#39;
</span> 	test_line_count = 1 msgfrom
 &#39;
 
<span
class="add">+test_expect_success $PREREQ &#39;setup expect for cc list&#39; &#34;
+cat &gt;expected-cc &lt;&lt;\EOF
+!recipient@example.com!
+!author@example.com!
+!one@example.com!
+!odd_?=mail@example.com!
+!thor.au@example.com!
+EOF
+&#34;
+
+test_expect_success $PREREQ &#39;cc list is sanitized&#39; &#39;
+	clean_fake_sendmail &#38;&#38;
+	test_commit weird_cc_body &#38;&#38;
+	test_when_finished &#34;git reset --hard HEAD^&#34; &#38;&#38;
+	git commit --amend -F - &lt;&lt;-EOF &#38;&#38;
+	Test Cc: sanitization.
+
+	Cc: Person, One &lt;one@example.com&gt;
+	Reviewed-by: F&#252;&#241;n&#253; N&#226;m&#233; &lt;odd_?=mail@example.com&gt;
+	Signed-off-by: A. U. Thor &lt;thor.au@example.com&gt;
+	EOF
+	git send-email -1 --to=recipient@example.com \
+		--smtp-server=&#34;$(pwd)/fake.sendmail&#34; &gt;actual-show-all-headers &#38;&#38;
+	test_cmp expected-cc commandline1 &#38;&#38;
+	grep &#34;^(body) Adding cc: \&#34;Person, One\&#34; &lt;one@example.com&gt;&#34; actual-show-all-headers &#38;&#38;
+	grep &#34;^(body) Adding cc: =?UTF-8?q?F=C3=BC=C3=B1n=C3=BD=20N=C3=A2m=C3=A9?=&#34;\
+&#34; &lt;odd_?=mail@example.com&gt;&#34; actual-show-all-headers &#38;&#38;
+	grep &#34;^(body) Adding cc: \&#34;A. U. Thor\&#34; &lt;thor.au@example.com&gt;&#34; actual-show-all-headers
+&#39;
+
</span> test_expect_success $PREREQ &#39;sendemail.composeencoding works&#39; &#39;
 	clean_fake_sendmail &#38;&#38;
 	git config sendemail.composeencoding iso-8859-1 &#38;&#38;
-- 
2.34.1


</pre></div></content></entry><entry><author><name>Florian Schmaus</name><email>flo@geekplace.eu</email></author><title>[PATCH 0/1] support GIT_IGNORE_INSECURE_OWNER environment variable</title><updated>2024-06-26T12:41:32Z</updated><link
href="http://lore.kernel.org/git/20240626123330.420227-1-flo@geekplace.eu/"/><id>urn:uuid:e43a56d0-561b-5d89-5a2f-f955743ee8e2</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">I could imagine that the safe-directory check was deliberately not
made controllable via an environment variable. However, git versions
with the safe-directory check gained adoption and we can now see that
there is some fallout caused by the check.

A prominent example is that git-daemon cannot export repos when
running under nobody (see <a
href="https://bugs.gentoo.org/932091">https://bugs.gentoo.org/932091</a>). Since the
&#39;nobody&#39; user typically has no home directory, the suggested fix

        git config --global --add safe.directory xxx.git

does not work. Likewise, adding it to /etc/gitconfig is also not
ideal, as it applies to every user.

In Gentoo, the safe-directory check can be completely disabled via a
USE-flag (i.e., Gentoo&#39;s mechanism for compile-time package
customization). However, I recently suggested to Gentoo&#39;s git-package
maintainers the following patch, introducing the
GIT_IGNORE_INSECURE_OWNER environment variable, as an alternative.

Being able to disable the safe directory check via an environment
variable allows for more flexibility, solves the issue described
above, and does *not* statically and globally disable the
safe-directory check. This was received with a positive response and
the patch will likely be applied by Gentoo.

But downstream patchery is always the second-best option. Therefore,
I hereby propose the patch to upstream.

Florian Schmaus (1):
  setup: support GIT_IGNORE_INSECURE_OWNER environment variable

 setup.c | 8 ++++++++
 1 file changed, 8 insertions(+)

-- 
2.44.2

</pre></div></content></entry><entry><author><name>Abhijeet Sonar</name><email>abhijeet.nkt@gmail.com</email></author><title
type="html">[PATCH v6] describe: refresh the index when &#39;broken&#39; flag is used</title><updated>2024-06-26T12:34:41Z</updated><link
href="http://lore.kernel.org/git/20240626123421.286655-1-abhijeet.nkt@gmail.com/"/><id>urn:uuid:7c4bad8e-f086-6ed2-1c59-d58f74cccc11</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">When describe is run with &#39;dirty&#39; flag, we refresh the index
to make sure it is in sync with the filesystem before
determining if the working tree is dirty.  However, this is
not done for the codepath where the &#39;broken&#39; flag is used.

This causes `git describe --broken --dirty` to false
positively report the worktree being dirty if a file has
different stat info than what is recorded in the index.
Running `git update-index -q --refresh` to refresh the index
before running diff-index fixes the problem.

Also add tests to deliberately update stat info of a
file before running describe to verify it behaves correctly.

Reported-by: Paul Millar &lt;paul.millar@desy.de&gt;
Suggested-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Helped-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Helped-by: Phillip Wood &lt;phillip.wood123@gmail.com&gt;
Helped-by: Karthik Nayak &lt;karthik.188@gmail.com&gt;
Signed-off-by: Abhijeet Sonar &lt;abhijeet.nkt@gmail.com&gt;
---
 builtin/describe.c  | 11 +++++++++++
 t/t6120-describe.sh | 36 ++++++++++++++++++++++++++++++++++++
 2 files <a href="http://lore.kernel.org/git/20240626123421.286655-1-abhijeet.nkt@gmail.com/#related">changed</a>, 47 insertions(+)

<span
class="head">diff --git a/builtin/describe.c b/builtin/describe.c
index e5287eddf2..7cb9d50b36 100644
--- a/builtin/describe.c
+++ b/builtin/describe.c
</span><span
class="hunk">@@ -53,6 +53,10 @@ static const char *diff_index_args[] = {
</span> 	&#34;diff-index&#34;, &#34;--quiet&#34;, &#34;HEAD&#34;, &#34;--&#34;, NULL
 };
 
<span
class="add">+static const char *update_index_args[] = {
+	&#34;update-index&#34;, &#34;--unmerged&#34;, &#34;-q&#34;, &#34;--refresh&#34;, NULL
+};
+
</span> struct commit_name {
 	struct hashmap_entry entry;
 	struct object_id peeled;
<span
class="hunk">@@ -645,6 +649,13 @@ int cmd_describe(int argc, const char **argv, const char *prefix)
</span> 	if (argc == 0) {
 		if (broken) {
 			struct child_process cp = CHILD_PROCESS_INIT;
<span
class="add">+			strvec_pushv(&#38;cp.args, update_index_args);
+			cp.git_cmd = 1;
+			cp.no_stdin = 1;
+			cp.no_stdout = 1;
+			if (run_command(&#38;cp))
+				child_process_clear(&#38;cp);
+
</span> 			strvec_pushv(&#38;cp.args, diff_index_args);
 			cp.git_cmd = 1;
 			cp.no_stdin = 1;
<span
class="head">diff --git a/t/t6120-describe.sh b/t/t6120-describe.sh
index e78315d23d..f8591a5b2a 100755
--- a/t/t6120-describe.sh
+++ b/t/t6120-describe.sh
</span><span
class="hunk">@@ -671,4 +671,40 @@ test_expect_success &#39;setup misleading taggerdates&#39; &#39;
</span> 
 check_describe newer-tag-older-commit~1 --contains unique-file~2
 
<span
class="add">+test_expect_success &#39;describe --dirty with a file with changed stat&#39; &#39;
+	git init stat-dirty &#38;&#38;
+	(
+		cd stat-dirty &#38;&#38;
+
+		echo A &gt;file &#38;&#38;
+		git add file &#38;&#38;
+		git commit -m A &#38;&#38;
+		git tag A -a -m A &#38;&#38;
+
+		cat file &gt;file.new &#38;&#38;
+		mv file.new file &#38;&#38;
+		git describe --dirty &gt;actual &#38;&#38;
+		echo &#34;A&#34; &gt;expected &#38;&#38;
+		test_cmp expected actual
+	)
+&#39;
+
+test_expect_success &#39;describe --dirty --broken with a file with changed stat&#39; &#39;
+	git init stat-dirty-broken &#38;&#38;
+	(
+		cd stat-dirty-broken &#38;&#38;
+
+		echo A &gt;file &#38;&#38;
+		git add file &#38;&#38;
+		git commit -m A &#38;&#38;
+		git tag A -a -m A &#38;&#38;
+
+		cat file &gt;file.new &#38;&#38;
+		mv file.new file &#38;&#38;
+		git describe --dirty --broken &gt;actual &#38;&#38;
+		echo &#34;A&#34; &gt;expected &#38;&#38;
+		test_cmp expected actual
+	)
+&#39;
+
</span> test_done

Range-diff against v5:
1:  52f590b70f ! 1:  c8010b1533 describe: refresh the index when &#39;broken&#39; flag is used
    @@ Commit message
         Suggested-by: Junio C Hamano &lt;gitster@pobox.com&gt;
         Helped-by: Junio C Hamano &lt;gitster@pobox.com&gt;
         Helped-by: Phillip Wood &lt;phillip.wood123@gmail.com&gt;
    +    Helped-by: Karthik Nayak &lt;karthik.188@gmail.com&gt;
         Signed-off-by: Abhijeet Sonar &lt;abhijeet.nkt@gmail.com&gt;
     
      ## builtin/describe.c ##
    @@ t/t6120-describe.sh: test_expect_success &#39;setup misleading taggerdates&#39; &#39;
     +		mv file.new file &#38;&#38;
     +		git describe --dirty &gt;actual &#38;&#38;
     +		echo &#34;A&#34; &gt;expected &#38;&#38;
    -+		test_cmp expected actual &#38;&#38;
    ++		test_cmp expected actual
    ++	)
    ++&#39;
    ++
    ++test_expect_success &#39;describe --dirty --broken with a file with changed stat&#39; &#39;
    ++	git init stat-dirty-broken &#38;&#38;
    ++	(
    ++		cd stat-dirty-broken &#38;&#38;
    ++
    ++		echo A &gt;file &#38;&#38;
    ++		git add file &#38;&#38;
    ++		git commit -m A &#38;&#38;
    ++		git tag A -a -m A &#38;&#38;
     +
     +		cat file &gt;file.new &#38;&#38;
     +		mv file.new file &#38;&#38;
-- 
2.45.2.606.g9005149a4a.dirty

</pre></div></content></entry><entry><author><name>Florian Schmaus</name><email>flo@geekplace.eu</email></author><title>[PATCH] setup: support GIT_IGNORE_INSECURE_OWNER environment variable</title><updated>2024-06-26T12:34:05Z</updated><link
href="http://lore.kernel.org/git/20240626123358.420292-2-flo@geekplace.eu/"/><id>urn:uuid:0dd32a1f-304a-4f07-6e11-34cc8f2b09f9</id><thr:in-reply-to
ref="urn:uuid:bc20fab0-9f4d-c91b-d0c4-6240d24ab967"
href="http://lore.kernel.org/git/20240626123358.420292-1-flo@geekplace.eu/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Sometimes more flexibility to disable/ignore the ownership check, besides
the safe.directory configuration option, is required.

For example, git-daemon running as nobody user, which typically has no
home directory. Therefore, we can not add the path to a user-global
configuration and adding the path to the system-wide configuration could
have negative security implications.

Therefore, make the check configurable via an environment variable.

If the environment variable GIT_IGNORE_INSECURE_OWNER is set to true,
then ignore potentially insecure ownership of git-related path
components.

Signed-off-by: Florian Schmaus &lt;flo@geekplace.eu&gt;
---
 setup.c | 8 ++++++++
 1 file <a href="http://lore.kernel.org/git/20240626123358.420292-2-flo@geekplace.eu/#related">changed</a>, 8 insertions(+)

<span
class="head">diff --git a/setup.c b/setup.c
index 3afa6fb09b28..da3f504fb536 100644
--- a/setup.c
+++ b/setup.c
</span><span
class="hunk">@@ -1278,6 +1278,14 @@ static int ensure_valid_ownership(const char *gitfile,
</span> 	 */
 	git_protected_config(safe_directory_cb, &#38;data);
 
<span
class="add">+	if (data.is_safe)
+		return data.is_safe;
+
+	if (git_env_bool(&#34;GIT_IGNORE_INSECURE_OWNER&#34;, 0)) {
+		warning(&#34;ignoring dubious ownership in repository at &#39;%s&#39; (GIT_IGNORE_INSECURE_OWNER set)&#34;, data.path);
+		return 1;
+	}
+
</span> 	return data.is_safe;
 }
 
-- 
2.44.2

</pre></div></content></entry><entry><author><name>Florian Schmaus</name><email>flo@geekplace.eu</email></author><title>[PATCH 0/1] support GIT_IGNORE_INSECURE_OWNER environment variable</title><updated>2024-06-26T12:34:05Z</updated><link
href="http://lore.kernel.org/git/20240626123358.420292-1-flo@geekplace.eu/"/><id>urn:uuid:bc20fab0-9f4d-c91b-d0c4-6240d24ab967</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">I could imagine that the safe-directory check was deliberately not
made controllable via an environment variable. However, git versions
with the safe-directory check gained adoption and we can now see that
there is some fallout caused by the check.

A prominent example is that git-daemon cannot export repos when
running under nobody (see <a
href="https://bugs.gentoo.org/932091">https://bugs.gentoo.org/932091</a>). Since the
&#39;nobody&#39; user typically has no home directory, the suggested fix

        git config --global --add safe.directory xxx.git

does not work. Likewise, adding it to /etc/gitconfig is also not
ideal, as it applies to every user.

In Gentoo, the safe-directory check can be completely disabled via a
USE-flag (i.e., Gentoo&#39;s mechanism for compile-time package
customization). However, I recently suggested to Gentoo&#39;s git-package
maintainers the following patch, introducing the
GIT_IGNORE_INSECURE_OWNER environment variable, as an alternative.

Being able to disable the safe directory check via an environment
variable allows for more flexibility, solves the issue described
above, and does *not* statically and globally disable the
safe-directory check. This was received with a positive response and
the patch will likely be applied by Gentoo.

But downstream patchery is always the second-best option. Therefore,
I hereby propose the patch to upstream.

Florian Schmaus (1):
  setup: support GIT_IGNORE_INSECURE_OWNER environment variable

 setup.c | 8 ++++++++
 1 file changed, 8 insertions(+)

-- 
2.44.2

</pre></div></content></entry><entry><author><name>Abhijeet Sonar</name><email>abhijeet.nkt@gmail.com</email></author><title
type="html">[PATCH v5] describe: refresh the index when &#39;broken&#39; flag is used</title><updated>2024-06-26T06:53:04Z</updated><link
href="http://lore.kernel.org/git/20240626065223.28154-1-abhijeet.nkt@gmail.com/"/><id>urn:uuid:3590bd00-6cd5-464f-4bb8-331e9a67d927</id><thr:in-reply-to
ref="urn:uuid:8818b079-98bb-b438-6723-997011754d11"
href="http://lore.kernel.org/git/xmqq34p1813n.fsf@gitster.g/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">When describe is run with &#39;dirty&#39; flag, we refresh the index
to make sure it is in sync with the filesystem before
determining if the working tree is dirty.  However, this is
not done for the codepath where the &#39;broken&#39; flag is used.

This causes `git describe --broken --dirty` to false
positively report the worktree being dirty if a file has
different stat info than what is recorded in the index.
Running `git update-index -q --refresh` to refresh the index
before running diff-index fixes the problem.

Also add tests to deliberately update stat info of a
file before running describe to verify it behaves correctly.

Reported-by: Paul Millar &lt;paul.millar@desy.de&gt;
Suggested-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Helped-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Helped-by: Phillip Wood &lt;phillip.wood123@gmail.com&gt;
Signed-off-by: Abhijeet Sonar &lt;abhijeet.nkt@gmail.com&gt;
---
 builtin/describe.c  | 11 +++++++++++
 t/t6120-describe.sh | 24 ++++++++++++++++++++++++
 2 files <a href="http://lore.kernel.org/git/20240626065223.28154-1-abhijeet.nkt@gmail.com/#related">changed</a>, 35 insertions(+)

<span
class="head">diff --git a/builtin/describe.c b/builtin/describe.c
index e5287eddf2..7cb9d50b36 100644
--- a/builtin/describe.c
+++ b/builtin/describe.c
</span><span
class="hunk">@@ -53,6 +53,10 @@ static const char *diff_index_args[] = {
</span> 	&#34;diff-index&#34;, &#34;--quiet&#34;, &#34;HEAD&#34;, &#34;--&#34;, NULL
 };
 
<span
class="add">+static const char *update_index_args[] = {
+	&#34;update-index&#34;, &#34;--unmerged&#34;, &#34;-q&#34;, &#34;--refresh&#34;, NULL
+};
+
</span> struct commit_name {
 	struct hashmap_entry entry;
 	struct object_id peeled;
<span
class="hunk">@@ -645,6 +649,13 @@ int cmd_describe(int argc, const char **argv, const char *prefix)
</span> 	if (argc == 0) {
 		if (broken) {
 			struct child_process cp = CHILD_PROCESS_INIT;
<span
class="add">+			strvec_pushv(&#38;cp.args, update_index_args);
+			cp.git_cmd = 1;
+			cp.no_stdin = 1;
+			cp.no_stdout = 1;
+			if (run_command(&#38;cp))
+				child_process_clear(&#38;cp);
+
</span> 			strvec_pushv(&#38;cp.args, diff_index_args);
 			cp.git_cmd = 1;
 			cp.no_stdin = 1;
<span
class="head">diff --git a/t/t6120-describe.sh b/t/t6120-describe.sh
index e78315d23d..6c396e7abc 100755
--- a/t/t6120-describe.sh
+++ b/t/t6120-describe.sh
</span><span
class="hunk">@@ -671,4 +671,28 @@ test_expect_success &#39;setup misleading taggerdates&#39; &#39;
</span> 
 check_describe newer-tag-older-commit~1 --contains unique-file~2
 
<span
class="add">+test_expect_success &#39;describe --dirty with a file with changed stat&#39; &#39;
+	git init stat-dirty &#38;&#38;
+	(
+		cd stat-dirty &#38;&#38;
+
+		echo A &gt;file &#38;&#38;
+		git add file &#38;&#38;
+		git commit -m A &#38;&#38;
+		git tag A -a -m A &#38;&#38;
+
+		cat file &gt;file.new &#38;&#38;
+		mv file.new file &#38;&#38;
+		git describe --dirty &gt;actual &#38;&#38;
+		echo &#34;A&#34; &gt;expected &#38;&#38;
+		test_cmp expected actual &#38;&#38;
+
+		cat file &gt;file.new &#38;&#38;
+		mv file.new file &#38;&#38;
+		git describe --dirty --broken &gt;actual &#38;&#38;
+		echo &#34;A&#34; &gt;expected &#38;&#38;
+		test_cmp expected actual
+	)
+&#39;
+
</span> test_done

Range-diff against v4:
1:  1da5fa48d9 ! 1:  52f590b70f describe: refresh the index when &#39;broken&#39; flag is used
    @@ builtin/describe.c: int cmd_describe(int argc, const char **argv, const char *pr
     +			cp.git_cmd = 1;
     +			cp.no_stdin = 1;
     +			cp.no_stdout = 1;
    -+			run_command(&#38;cp);
    -+			strvec_clear(&#38;cp.args);
    ++			if (run_command(&#38;cp))
    ++				child_process_clear(&#38;cp);
     +
      			strvec_pushv(&#38;cp.args, diff_index_args);
      			cp.git_cmd = 1;
-- 
2.45.2.606.g9005149a4a.dirty

</pre></div></content></entry><entry><author><name>Abhijeet Sonar</name><email>abhijeet.nkt@gmail.com</email></author><title
type="html">[PATCH v4] describe: refresh the index when &#39;broken&#39; flag is used</title><updated>2024-06-26T06:42:16Z</updated><link
href="http://lore.kernel.org/git/20240626064143.18945-1-abhijeet.nkt@gmail.com/"/><id>urn:uuid:e8ca07c2-5382-92cb-72c6-b4e76b10ab60</id><thr:in-reply-to
ref="urn:uuid:8818b079-98bb-b438-6723-997011754d11"
href="http://lore.kernel.org/git/xmqq34p1813n.fsf@gitster.g/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">When describe is run with &#39;dirty&#39; flag, we refresh the index
to make sure it is in sync with the filesystem before
determining if the working tree is dirty.  However, this is
not done for the codepath where the &#39;broken&#39; flag is used.

This causes `git describe --broken --dirty` to false
positively report the worktree being dirty if a file has
different stat info than what is recorded in the index.
Running `git update-index -q --refresh` to refresh the index
before running diff-index fixes the problem.

Also add tests to deliberately update stat info of a
file before running describe to verify it behaves correctly.

Reported-by: Paul Millar &lt;paul.millar@desy.de&gt;
Suggested-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Helped-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Helped-by: Phillip Wood &lt;phillip.wood123@gmail.com&gt;
Signed-off-by: Abhijeet Sonar &lt;abhijeet.nkt@gmail.com&gt;
---
 builtin/describe.c                            |  11 ++
 t/t6120-describe.sh                           |  24 +++
 ...esh-the-index-when-broken-flag-is-us.patch | 178 ++++++++++++++++++
 3 files <a href="http://lore.kernel.org/git/20240626064143.18945-1-abhijeet.nkt@gmail.com/#related">changed</a>, 213 insertions(+)
 create mode 100644 v3-0001-describe-refresh-the-index-when-broken-flag-is-us.patch

<span
class="head">diff --git a/builtin/describe.c b/builtin/describe.c
index e5287eddf2..7cb9d50b36 100644
--- a/builtin/describe.c
+++ b/builtin/describe.c
</span><span
class="hunk">@@ -53,6 +53,10 @@ static const char *diff_index_args[] = {
</span> 	&#34;diff-index&#34;, &#34;--quiet&#34;, &#34;HEAD&#34;, &#34;--&#34;, NULL
 };
 
<span
class="add">+static const char *update_index_args[] = {
+	&#34;update-index&#34;, &#34;--unmerged&#34;, &#34;-q&#34;, &#34;--refresh&#34;, NULL
+};
+
</span> struct commit_name {
 	struct hashmap_entry entry;
 	struct object_id peeled;
<span
class="hunk">@@ -645,6 +649,13 @@ int cmd_describe(int argc, const char **argv, const char *prefix)
</span> 	if (argc == 0) {
 		if (broken) {
 			struct child_process cp = CHILD_PROCESS_INIT;
<span
class="add">+			strvec_pushv(&#38;cp.args, update_index_args);
+			cp.git_cmd = 1;
+			cp.no_stdin = 1;
+			cp.no_stdout = 1;
+			if (run_command(&#38;cp))
+				child_process_clear(&#38;cp);
+
</span> 			strvec_pushv(&#38;cp.args, diff_index_args);
 			cp.git_cmd = 1;
 			cp.no_stdin = 1;
<span
class="head">diff --git a/t/t6120-describe.sh b/t/t6120-describe.sh
index e78315d23d..6c396e7abc 100755
--- a/t/t6120-describe.sh
+++ b/t/t6120-describe.sh
</span><span
class="hunk">@@ -671,4 +671,28 @@ test_expect_success &#39;setup misleading taggerdates&#39; &#39;
</span> 
 check_describe newer-tag-older-commit~1 --contains unique-file~2
 
<span
class="add">+test_expect_success &#39;describe --dirty with a file with changed stat&#39; &#39;
+	git init stat-dirty &#38;&#38;
+	(
+		cd stat-dirty &#38;&#38;
+
+		echo A &gt;file &#38;&#38;
+		git add file &#38;&#38;
+		git commit -m A &#38;&#38;
+		git tag A -a -m A &#38;&#38;
+
+		cat file &gt;file.new &#38;&#38;
+		mv file.new file &#38;&#38;
+		git describe --dirty &gt;actual &#38;&#38;
+		echo &#34;A&#34; &gt;expected &#38;&#38;
+		test_cmp expected actual &#38;&#38;
+
+		cat file &gt;file.new &#38;&#38;
+		mv file.new file &#38;&#38;
+		git describe --dirty --broken &gt;actual &#38;&#38;
+		echo &#34;A&#34; &gt;expected &#38;&#38;
+		test_cmp expected actual
+	)
+&#39;
+
</span> test_done
<span
class="head">diff --git a/v3-0001-describe-refresh-the-index-when-broken-flag-is-us.patch b/v3-0001-describe-refresh-the-index-when-broken-flag-is-us.patch
new file mode 100644
index 0000000000..22e295d5eb
--- /dev/null
+++ b/v3-0001-describe-refresh-the-index-when-broken-flag-is-us.patch
</span><span
class="hunk">@@ -0,0 +1,178 @@
</span><span
class="add">+From 1da5fa48d913e1cefb2b6e1bc58df565076ee438 Mon Sep 17 00:00:00 2001
+From: Abhijeet Sonar &lt;abhijeet.nkt@gmail.com&gt;
+Date: Mon, 24 Jun 2024 02:57:59 +0530
+Subject: [PATCH v3] describe: refresh the index when &#39;broken&#39; flag is used
+To: git@vger.kernel.org
+
+When describe is run with &#39;dirty&#39; flag, we refresh the index
+to make sure it is in sync with the filesystem before
+determining if the working tree is dirty.  However, this is
+not done for the codepath where the &#39;broken&#39; flag is used.
+
+This causes `git describe --broken --dirty` to false
+positively report the worktree being dirty if a file has
+different stat info than what is recorded in the index.
+Running `git update-index -q --refresh` to refresh the index
+before running diff-index fixes the problem.
+
+Also add tests to deliberately update stat info of a
+file before running describe to verify it behaves correctly.
+
+Reported-by: Paul Millar &lt;paul.millar@desy.de&gt;
+Suggested-by: Junio C Hamano &lt;gitster@pobox.com&gt;
+Helped-by: Junio C Hamano &lt;gitster@pobox.com&gt;
+Helped-by: Phillip Wood &lt;phillip.wood123@gmail.com&gt;
+Signed-off-by: Abhijeet Sonar &lt;abhijeet.nkt@gmail.com&gt;
+---
+ builtin/describe.c  | 11 +++++++++++
+ t/t6120-describe.sh | 24 ++++++++++++++++++++++++
+ 2 files changed, 35 insertions(+)
+
+diff --git a/builtin/describe.c b/builtin/describe.c
+index e5287eddf2..deec19b29a 100644
+--- a/builtin/describe.c
++++ b/builtin/describe.c
+@@ -53,6 +53,10 @@ static const char *diff_index_args[] = {
+ 	&#34;diff-index&#34;, &#34;--quiet&#34;, &#34;HEAD&#34;, &#34;--&#34;, NULL
+ };
+ 
++static const char *update_index_args[] = {
++	&#34;update-index&#34;, &#34;--unmerged&#34;, &#34;-q&#34;, &#34;--refresh&#34;, NULL
++};
++
+ struct commit_name {
+ 	struct hashmap_entry entry;
+ 	struct object_id peeled;
+@@ -645,6 +649,13 @@ int cmd_describe(int argc, const char **argv, const char *prefix)
+ 	if (argc == 0) {
+ 		if (broken) {
+ 			struct child_process cp = CHILD_PROCESS_INIT;
++			strvec_pushv(&#38;cp.args, update_index_args);
++			cp.git_cmd = 1;
++			cp.no_stdin = 1;
++			cp.no_stdout = 1;
++			run_command(&#38;cp);
++			strvec_clear(&#38;cp.args);
++
+ 			strvec_pushv(&#38;cp.args, diff_index_args);
+ 			cp.git_cmd = 1;
+ 			cp.no_stdin = 1;
+diff --git a/t/t6120-describe.sh b/t/t6120-describe.sh
+index e78315d23d..6c396e7abc 100755
+--- a/t/t6120-describe.sh
++++ b/t/t6120-describe.sh
+@@ -671,4 +671,28 @@ test_expect_success &#39;setup misleading taggerdates&#39; &#39;
+ 
+ check_describe newer-tag-older-commit~1 --contains unique-file~2
+ 
++test_expect_success &#39;describe --dirty with a file with changed stat&#39; &#39;
++	git init stat-dirty &#38;&#38;
++	(
++		cd stat-dirty &#38;&#38;
++
++		echo A &gt;file &#38;&#38;
++		git add file &#38;&#38;
++		git commit -m A &#38;&#38;
++		git tag A -a -m A &#38;&#38;
++
++		cat file &gt;file.new &#38;&#38;
++		mv file.new file &#38;&#38;
++		git describe --dirty &gt;actual &#38;&#38;
++		echo &#34;A&#34; &gt;expected &#38;&#38;
++		test_cmp expected actual &#38;&#38;
++
++		cat file &gt;file.new &#38;&#38;
++		mv file.new file &#38;&#38;
++		git describe --dirty --broken &gt;actual &#38;&#38;
++		echo &#34;A&#34; &gt;expected &#38;&#38;
++		test_cmp expected actual
++	)
++&#39;
++
+ test_done
+
+Range-diff against v2:
+1:  d60fc0fa02 ! 1:  1da5fa48d9 describe: refresh the index when &#39;broken&#39; flag is used
+    @@ Commit message
+         Reported-by: Paul Millar &lt;paul.millar@desy.de&gt;
+         Suggested-by: Junio C Hamano &lt;gitster@pobox.com&gt;
+         Helped-by: Junio C Hamano &lt;gitster@pobox.com&gt;
+    +    Helped-by: Phillip Wood &lt;phillip.wood123@gmail.com&gt;
+         Signed-off-by: Abhijeet Sonar &lt;abhijeet.nkt@gmail.com&gt;
+     
+      ## builtin/describe.c ##
+    @@ builtin/describe.c: int cmd_describe(int argc, const char **argv, const char *pr
+      	if (argc == 0) {
+      		if (broken) {
+      			struct child_process cp = CHILD_PROCESS_INIT;
+    -+			struct child_process update_index_cp = CHILD_PROCESS_INIT;
+    -+
+    -+			strvec_pushv(&#38;update_index_cp.args, update_index_args);
+    -+			update_index_cp.git_cmd = 1;
+    -+			update_index_cp.no_stdin = 1;
+    -+			update_index_cp.no_stdout = 1;
+    -+			run_command(&#38;update_index_cp);
+    ++			strvec_pushv(&#38;cp.args, update_index_args);
+    ++			cp.git_cmd = 1;
+    ++			cp.no_stdin = 1;
+    ++			cp.no_stdout = 1;
+    ++			run_command(&#38;cp);
+    ++			strvec_clear(&#38;cp.args);
+     +
+      			strvec_pushv(&#38;cp.args, diff_index_args);
+      			cp.git_cmd = 1;
+    @@ t/t6120-describe.sh: test_expect_success &#39;setup misleading taggerdates&#39; &#39;
+      
+     +test_expect_success &#39;describe --dirty with a file with changed stat&#39; &#39;
+     +	git init stat-dirty &#38;&#38;
+    -+	cd stat-dirty &#38;&#38;
+    -+
+    -+	echo A &gt;file &#38;&#38;
+    -+	git add file &#38;&#38;
+    -+	git commit -m A &#38;&#38;
+    -+	git tag A -a -m A &#38;&#38;
+    -+
+    -+	cat file &gt;file.new &#38;&#38;
+    -+	mv file.new file &#38;&#38;
+    -+	git describe --dirty &gt;actual &#38;&#38;
+    -+	echo &#34;A&#34; &gt;expected &#38;&#38;
+    -+	test_cmp expected actual
+    -+&#39;
+    ++	(
+    ++		cd stat-dirty &#38;&#38;
+     +
+    -+test_expect_success &#39;describe --dirty --broken with a file with changed stat&#39; &#39;
+    -+	git init stat-dirty-broken &#38;&#38;
+    -+	cd stat-dirty-broken &#38;&#38;
+    ++		echo A &gt;file &#38;&#38;
+    ++		git add file &#38;&#38;
+    ++		git commit -m A &#38;&#38;
+    ++		git tag A -a -m A &#38;&#38;
+     +
+    -+	echo A &gt;file &#38;&#38;
+    -+	git add file &#38;&#38;
+    -+	git commit -m A &#38;&#38;
+    -+	git tag A -a -m A &#38;&#38;
+    ++		cat file &gt;file.new &#38;&#38;
+    ++		mv file.new file &#38;&#38;
+    ++		git describe --dirty &gt;actual &#38;&#38;
+    ++		echo &#34;A&#34; &gt;expected &#38;&#38;
+    ++		test_cmp expected actual &#38;&#38;
+     +
+    -+	cat file &gt;file.new &#38;&#38;
+    -+	mv file.new file &#38;&#38;
+    -+	git describe --dirty --broken &gt;actual &#38;&#38;
+    -+	echo &#34;A&#34; &gt;expected &#38;&#38;
+    -+	test_cmp expected actual
+    ++		cat file &gt;file.new &#38;&#38;
+    ++		mv file.new file &#38;&#38;
+    ++		git describe --dirty --broken &gt;actual &#38;&#38;
+    ++		echo &#34;A&#34; &gt;expected &#38;&#38;
+    ++		test_cmp expected actual
+    ++	)
+     +&#39;
+     +
+      test_done
+-- 
+2.45.2.606.g9005149a4a.dirty
+
</span>
Range-diff against v3:
1:  1da5fa48d9 ! 1:  9ff85435b1 describe: refresh the index when &#39;broken&#39; flag is used
    @@ builtin/describe.c: int cmd_describe(int argc, const char **argv, const char *pr
     +			cp.git_cmd = 1;
     +			cp.no_stdin = 1;
     +			cp.no_stdout = 1;
    -+			run_command(&#38;cp);
    -+			strvec_clear(&#38;cp.args);
    ++			if (run_command(&#38;cp))
    ++				child_process_clear(&#38;cp);
     +
      			strvec_pushv(&#38;cp.args, diff_index_args);
      			cp.git_cmd = 1;
    @@ t/t6120-describe.sh: test_expect_success &#39;setup misleading taggerdates&#39; &#39;
     +&#39;
     +
      test_done
    +
    + ## v3-0001-describe-refresh-the-index-when-broken-flag-is-us.patch (new) ##
    +@@
    ++From 1da5fa48d913e1cefb2b6e1bc58df565076ee438 Mon Sep 17 00:00:00 2001
    ++From: Abhijeet Sonar &lt;abhijeet.nkt@gmail.com&gt;
    ++Date: Mon, 24 Jun 2024 02:57:59 +0530
    ++Subject: [PATCH v3] describe: refresh the index when &#39;broken&#39; flag is used
    ++To: git@vger.kernel.org
    ++
    ++When describe is run with &#39;dirty&#39; flag, we refresh the index
    ++to make sure it is in sync with the filesystem before
    ++determining if the working tree is dirty.  However, this is
    ++not done for the codepath where the &#39;broken&#39; flag is used.
    ++
    ++This causes `git describe --broken --dirty` to false
    ++positively report the worktree being dirty if a file has
    ++different stat info than what is recorded in the index.
    ++Running `git update-index -q --refresh` to refresh the index
    ++before running diff-index fixes the problem.
    ++
    ++Also add tests to deliberately update stat info of a
    ++file before running describe to verify it behaves correctly.
    ++
    ++Reported-by: Paul Millar &lt;paul.millar@desy.de&gt;
    ++Suggested-by: Junio C Hamano &lt;gitster@pobox.com&gt;
    ++Helped-by: Junio C Hamano &lt;gitster@pobox.com&gt;
    ++Helped-by: Phillip Wood &lt;phillip.wood123@gmail.com&gt;
    ++Signed-off-by: Abhijeet Sonar &lt;abhijeet.nkt@gmail.com&gt;
    ++---
    ++ builtin/describe.c  | 11 +++++++++++
    ++ t/t6120-describe.sh | 24 ++++++++++++++++++++++++
    ++ 2 files changed, 35 insertions(+)
    ++
    ++diff --git a/builtin/describe.c b/builtin/describe.c
    ++index e5287eddf2..deec19b29a 100644
    ++--- a/builtin/describe.c
    +++++ b/builtin/describe.c
    ++@@ -53,6 +53,10 @@ static const char *diff_index_args[] = {
    ++ 	&#34;diff-index&#34;, &#34;--quiet&#34;, &#34;HEAD&#34;, &#34;--&#34;, NULL
    ++ };
    ++ 
    +++static const char *update_index_args[] = {
    +++	&#34;update-index&#34;, &#34;--unmerged&#34;, &#34;-q&#34;, &#34;--refresh&#34;, NULL
    +++};
    +++
    ++ struct commit_name {
    ++ 	struct hashmap_entry entry;
    ++ 	struct object_id peeled;
    ++@@ -645,6 +649,13 @@ int cmd_describe(int argc, const char **argv, const char *prefix)
    ++ 	if (argc == 0) {
    ++ 		if (broken) {
    ++ 			struct child_process cp = CHILD_PROCESS_INIT;
    +++			strvec_pushv(&#38;cp.args, update_index_args);
    +++			cp.git_cmd = 1;
    +++			cp.no_stdin = 1;
    +++			cp.no_stdout = 1;
    +++			run_command(&#38;cp);
    +++			strvec_clear(&#38;cp.args);
    +++
    ++ 			strvec_pushv(&#38;cp.args, diff_index_args);
    ++ 			cp.git_cmd = 1;
    ++ 			cp.no_stdin = 1;
    ++diff --git a/t/t6120-describe.sh b/t/t6120-describe.sh
    ++index e78315d23d..6c396e7abc 100755
    ++--- a/t/t6120-describe.sh
    +++++ b/t/t6120-describe.sh
    ++@@ -671,4 +671,28 @@ test_expect_success &#39;setup misleading taggerdates&#39; &#39;
    ++ 
    ++ check_describe newer-tag-older-commit~1 --contains unique-file~2
    ++ 
    +++test_expect_success &#39;describe --dirty with a file with changed stat&#39; &#39;
    +++	git init stat-dirty &#38;&#38;
    +++	(
    +++		cd stat-dirty &#38;&#38;
    +++
    +++		echo A &gt;file &#38;&#38;
    +++		git add file &#38;&#38;
    +++		git commit -m A &#38;&#38;
    +++		git tag A -a -m A &#38;&#38;
    +++
    +++		cat file &gt;file.new &#38;&#38;
    +++		mv file.new file &#38;&#38;
    +++		git describe --dirty &gt;actual &#38;&#38;
    +++		echo &#34;A&#34; &gt;expected &#38;&#38;
    +++		test_cmp expected actual &#38;&#38;
    +++
    +++		cat file &gt;file.new &#38;&#38;
    +++		mv file.new file &#38;&#38;
    +++		git describe --dirty --broken &gt;actual &#38;&#38;
    +++		echo &#34;A&#34; &gt;expected &#38;&#38;
    +++		test_cmp expected actual
    +++	)
    +++&#39;
    +++
    ++ test_done
    ++
    ++Range-diff against v2:
    ++1:  d60fc0fa02 ! 1:  1da5fa48d9 describe: refresh the index when &#39;broken&#39; flag is used
    ++    @@ Commit message
    ++         Reported-by: Paul Millar &lt;paul.millar@desy.de&gt;
    ++         Suggested-by: Junio C Hamano &lt;gitster@pobox.com&gt;
    ++         Helped-by: Junio C Hamano &lt;gitster@pobox.com&gt;
    ++    +    Helped-by: Phillip Wood &lt;phillip.wood123@gmail.com&gt;
    ++         Signed-off-by: Abhijeet Sonar &lt;abhijeet.nkt@gmail.com&gt;
    ++     
    ++      ## builtin/describe.c ##
    ++    @@ builtin/describe.c: int cmd_describe(int argc, const char **argv, const char *pr
    ++      	if (argc == 0) {
    ++      		if (broken) {
    ++      			struct child_process cp = CHILD_PROCESS_INIT;
    ++    -+			struct child_process update_index_cp = CHILD_PROCESS_INIT;
    ++    -+
    ++    -+			strvec_pushv(&#38;update_index_cp.args, update_index_args);
    ++    -+			update_index_cp.git_cmd = 1;
    ++    -+			update_index_cp.no_stdin = 1;
    ++    -+			update_index_cp.no_stdout = 1;
    ++    -+			run_command(&#38;update_index_cp);
    ++    ++			strvec_pushv(&#38;cp.args, update_index_args);
    ++    ++			cp.git_cmd = 1;
    ++    ++			cp.no_stdin = 1;
    ++    ++			cp.no_stdout = 1;
    ++    ++			run_command(&#38;cp);
    ++    ++			strvec_clear(&#38;cp.args);
    ++     +
    ++      			strvec_pushv(&#38;cp.args, diff_index_args);
    ++      			cp.git_cmd = 1;
    ++    @@ t/t6120-describe.sh: test_expect_success &#39;setup misleading taggerdates&#39; &#39;
    ++      
    ++     +test_expect_success &#39;describe --dirty with a file with changed stat&#39; &#39;
    ++     +	git init stat-dirty &#38;&#38;
    ++    -+	cd stat-dirty &#38;&#38;
    ++    -+
    ++    -+	echo A &gt;file &#38;&#38;
    ++    -+	git add file &#38;&#38;
    ++    -+	git commit -m A &#38;&#38;
    ++    -+	git tag A -a -m A &#38;&#38;
    ++    -+
    ++    -+	cat file &gt;file.new &#38;&#38;
    ++    -+	mv file.new file &#38;&#38;
    ++    -+	git describe --dirty &gt;actual &#38;&#38;
    ++    -+	echo &#34;A&#34; &gt;expected &#38;&#38;
    ++    -+	test_cmp expected actual
    ++    -+&#39;
    ++    ++	(
    ++    ++		cd stat-dirty &#38;&#38;
    ++     +
    ++    -+test_expect_success &#39;describe --dirty --broken with a file with changed stat&#39; &#39;
    ++    -+	git init stat-dirty-broken &#38;&#38;
    ++    -+	cd stat-dirty-broken &#38;&#38;
    ++    ++		echo A &gt;file &#38;&#38;
    ++    ++		git add file &#38;&#38;
    ++    ++		git commit -m A &#38;&#38;
    ++    ++		git tag A -a -m A &#38;&#38;
    ++     +
    ++    -+	echo A &gt;file &#38;&#38;
    ++    -+	git add file &#38;&#38;
    ++    -+	git commit -m A &#38;&#38;
    ++    -+	git tag A -a -m A &#38;&#38;
    ++    ++		cat file &gt;file.new &#38;&#38;
    ++    ++		mv file.new file &#38;&#38;
    ++    ++		git describe --dirty &gt;actual &#38;&#38;
    ++    ++		echo &#34;A&#34; &gt;expected &#38;&#38;
    ++    ++		test_cmp expected actual &#38;&#38;
    ++     +
    ++    -+	cat file &gt;file.new &#38;&#38;
    ++    -+	mv file.new file &#38;&#38;
    ++    -+	git describe --dirty --broken &gt;actual &#38;&#38;
    ++    -+	echo &#34;A&#34; &gt;expected &#38;&#38;
    ++    -+	test_cmp expected actual
    ++    ++		cat file &gt;file.new &#38;&#38;
    ++    ++		mv file.new file &#38;&#38;
    ++    ++		git describe --dirty --broken &gt;actual &#38;&#38;
    ++    ++		echo &#34;A&#34; &gt;expected &#38;&#38;
    ++    ++		test_cmp expected actual
    ++    ++	)
    ++     +&#39;
    ++     +
    ++      test_done
    ++-- 
    ++2.45.2.606.g9005149a4a.dirty
    ++
-- 
2.45.2.606.g9005149a4a.dirty

</pre></div></content></entry><entry><author><name>Junio C Hamano</name><email>gitster@pobox.com</email></author><title>[PATCH v4 2/2] date: detect underflow/overflow when parsing dates with timezone offset</title><updated>2024-06-25T23:13:02Z</updated><link
href="http://lore.kernel.org/git/20240625231248.4070257-3-gitster@pobox.com/"/><id>urn:uuid:651aa60f-5296-1597-cb61-1490b4467b71</id><thr:in-reply-to
ref="urn:uuid:2d616a4e-7e47-dea7-228f-f260bac3f6ea"
href="http://lore.kernel.org/git/20240625231248.4070257-1-gitster@pobox.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Darcy Burke &lt;acednes@gmail.com&gt;

Overriding the date of a commit to be close to &#34;1970-01-01 00:00:00&#34;
with a large enough positive timezone for the equivelant GMT time to be
before the epoch is considered valid by `parse_date_basic`. Similar
behaviour occurs when using a date close to &#34;2099-12-31 23:59:59&#34; (the
maximum date allowed by `tm_to_time_t`) with a large enough negative
timezone offset.

This leads to an integer underflow or underflow respectively in the
commit timestamp, which is not caught by `git-commit`, but will cause
other services to fail, such as `git-fsck`, which, for the first case,
reports &#34;badDateOverflow: invalid author/committer line - date causes
integer overflow&#34;.

Instead check the timezone offset and fail if the resulting time comes
before the epoch &#34;1970-01-01T00:00:00Z&#34; or after the maximum date
&#34;2099-12-31T23:59:59Z&#34;.

Using the REQUIRE_64BIT_TIME prerequisite, make sure that the tests
near the end of Git time (aka end of year 2099) are not attempted on
purely 32-bit systems, as they cannot express timestamp beyond 2038
anyway.

Signed-off-by: Darcy Burke &lt;acednes@gmail.com&gt;
[jc: fixups for 32-bit platforms]
Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
---
 date.c          | 12 +++++++++++-
 t/t0006-date.sh | 33 +++++++++++++++++++++++++++++++++
 2 files <a href="http://lore.kernel.org/git/20240625231248.4070257-3-gitster@pobox.com/#related">changed</a>, 44 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/date.c b/date.c
index 7365a4ad24..bee9fe8f10 100644
--- a/date.c
+++ b/date.c
</span><span
class="hunk">@@ -868,6 +868,10 @@ static int match_object_header_date(const char *date, timestamp_t *timestamp, in
</span> 	return 0;
 }
 
<span
class="add">+
+/* timestamp of 2099-12-31T23:59:59Z, including 32 leap days */
+static const timestamp_t timestamp_max = (((timestamp_t)2100 - 1970) * 365 + 32) * 24 * 60 * 60 - 1;
+
</span> /* Gr. strptime is crap for this; it doesn&#39;t have a way to require RFC2822
    (i.e. English) day/month names, and it doesn&#39;t work correctly with %z. */
 int parse_date_basic(const char *date, timestamp_t *timestamp, int *offset)
<span
class="hunk">@@ -937,8 +941,14 @@ int parse_date_basic(const char *date, timestamp_t *timestamp, int *offset)
</span> 		}
 	}
 
<span
class="del">-	if (!tm_gmt)
</span><span
class="add">+	if (!tm_gmt) {
+		if (*offset &gt; 0 &#38;&#38; *offset * 60 &gt; *timestamp)
+			return -1;
+		if (*offset &lt; 0 &#38;&#38; -*offset * 60 &gt; timestamp_max - *timestamp)
+			return -1;
</span> 		*timestamp -= *offset * 60;
<span
class="add">+	}
+
</span> 	return 0; /* success */
 }
 
<span
class="head">diff --git a/t/t0006-date.sh b/t/t0006-date.sh
index 24e8647f26..fd373e1b39 100755
--- a/t/t0006-date.sh
+++ b/t/t0006-date.sh
</span><span
class="hunk">@@ -123,6 +123,39 @@ check_parse &#39;2008-02-14 20:30:45 -05:00&#39; &#39;2008-02-14 20:30:45 -0500&#39;
</span> check_parse &#39;2008-02-14 20:30:45&#39; &#39;2008-02-14 20:30:45 -0500&#39; EST5
 check_parse &#39;Thu, 7 Apr 2005 15:14:13 -0700&#39; &#39;2005-04-07 15:14:13 -0700&#39;
 
<span
class="add">+check_parse &#39;1970-01-01 00:00:00&#39; &#39;1970-01-01 00:00:00 +0000&#39;
+check_parse &#39;1970-01-01 00:00:00 +00&#39; &#39;1970-01-01 00:00:00 +0000&#39;
+check_parse &#39;1970-01-01 00:00:00 Z&#39; &#39;1970-01-01 00:00:00 +0000&#39;
+check_parse &#39;1970-01-01 00:00:00 -01&#39; &#39;1970-01-01 00:00:00 -0100&#39;
+check_parse &#39;1970-01-01 00:00:00 +01&#39; bad
+check_parse &#39;1970-01-01 00:00:00 +11&#39; bad
+check_parse &#39;1970-01-01 00:59:59 +01&#39; bad
+check_parse &#39;1970-01-01 01:00:00 +01&#39; &#39;1970-01-01 01:00:00 +0100&#39;
+check_parse &#39;1970-01-01 01:00:00 +11&#39; bad
+check_parse &#39;1970-01-02 00:00:00 +11&#39; &#39;1970-01-02 00:00:00 +1100&#39;
+check_parse &#39;1969-12-31 23:59:59&#39; bad
+check_parse &#39;1969-12-31 23:59:59 +00&#39; bad
+check_parse &#39;1969-12-31 23:59:59 Z&#39; bad
+check_parse &#39;1969-12-31 23:59:59 +11&#39; bad
+check_parse &#39;1969-12-31 23:59:59 -11&#39; bad
+
+REQUIRE_64BIT_TIME=HAVE_64BIT_TIME
+check_parse &#39;2099-12-31 23:59:59&#39; &#39;2099-12-31 23:59:59 +0000&#39;
+check_parse &#39;2099-12-31 23:59:59 +00&#39; &#39;2099-12-31 23:59:59 +0000&#39;
+check_parse &#39;2099-12-31 23:59:59 Z&#39; &#39;2099-12-31 23:59:59 +0000&#39;
+check_parse &#39;2099-12-31 23:59:59 +01&#39; &#39;2099-12-31 23:59:59 +0100&#39;
+check_parse &#39;2099-12-31 23:59:59 -01&#39; bad
+check_parse &#39;2099-12-31 23:59:59 -11&#39; bad
+check_parse &#39;2099-12-31 23:00:00 -01&#39; bad
+check_parse &#39;2099-12-31 22:59:59 -01&#39; &#39;2099-12-31 22:59:59 -0100&#39;
+check_parse &#39;2100-00-00 00:00:00&#39; bad
+check_parse &#39;2099-12-30 00:00:00 -11&#39; &#39;2099-12-30 00:00:00 -1100&#39;
+check_parse &#39;2100-00-00 00:00:00 +00&#39; bad
+check_parse &#39;2100-00-00 00:00:00 Z&#39; bad
+check_parse &#39;2100-00-00 00:00:00 -11&#39; bad
+check_parse &#39;2100-00-00 00:00:00 +11&#39; bad
+REQUIRE_64BIT_TIME=
+
</span> check_approxidate() {
 	echo &#34;$1 -&gt; $2 +0000&#34; &gt;expect
 	test_expect_${3:-success} &#34;parse approxidate ($1)&#34; &#34;
-- 
2.45.2-796-g2ef7a3d713

</pre></div></content></entry><entry><author><name>Junio C Hamano</name><email>gitster@pobox.com</email></author><title>[PATCH v4 1/2] t0006: simplify prerequisites</title><updated>2024-06-25T23:12:52Z</updated><link
href="http://lore.kernel.org/git/20240625231248.4070257-2-gitster@pobox.com/"/><id>urn:uuid:b2fd66b7-1519-eda1-d2dd-feaf42cd47bd</id><thr:in-reply-to
ref="urn:uuid:2d616a4e-7e47-dea7-228f-f260bac3f6ea"
href="http://lore.kernel.org/git/20240625231248.4070257-1-gitster@pobox.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The system must support 64-bit time and its time_t must be 64-bit
wide to pass these tests.  Combine these two prerequisites together
to simplify the tests.  In theory, they could be fulfilled
independently and tests could require only one without the other,
but in practice, but in practice these must come hand-in-hand.

Update the &#34;check_parse&#34; test helper to pay attention to the
REQUIRE_64BIT_TIME variable, which can be set to the HAVE_64BIT_TIME
prerequisite so that a parse test can be skipped on 32-bit systems.
This will be used in the next step to skip tests for timestamps near
the end of year 2099, as 32-bit systems will not be able to express
a timestamp beyond 2038 anyway.

Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
---
 t/t0006-date.sh | 18 ++++++++++++------
 1 file <a href="http://lore.kernel.org/git/20240625231248.4070257-2-gitster@pobox.com/#related">changed</a>, 12 insertions(+), 6 deletions(-)

<span
class="head">diff --git a/t/t0006-date.sh b/t/t0006-date.sh
index 3031256d14..24e8647f26 100755
--- a/t/t0006-date.sh
+++ b/t/t0006-date.sh
</span><span
class="hunk">@@ -8,6 +8,11 @@ TEST_PASSES_SANITIZE_LEAK=true
</span> # arbitrary reference time: 2009-08-30 19:20:00
 GIT_TEST_DATE_NOW=1251660000; export GIT_TEST_DATE_NOW
 
<span
class="add">+if test_have_prereq TIME_IS_64BIT,TIME_T_IS_64BIT
+then
+	test_set_prereq HAVE_64BIT_TIME
+fi
+
</span> check_relative() {
 	t=$(($GIT_TEST_DATE_NOW - $1))
 	echo &#34;$t -&gt; $2&#34; &gt;expect
<span
class="hunk">@@ -80,14 +85,15 @@ check_show raw &#34;$TIME&#34; &#39;1466000000 -0200&#39;
</span> 
 # arbitrary time absurdly far in the future
 FUTURE=&#34;5758122296 -0400&#34;
<span
class="del">-check_show iso       &#34;$FUTURE&#34; &#34;2152-06-19 18:24:56 -0400&#34; TIME_IS_64BIT,TIME_T_IS_64BIT
-check_show iso-local &#34;$FUTURE&#34; &#34;2152-06-19 22:24:56 +0000&#34; TIME_IS_64BIT,TIME_T_IS_64BIT
</span><span
class="add">+check_show iso       &#34;$FUTURE&#34; &#34;2152-06-19 18:24:56 -0400&#34; HAVE_64BIT_TIME
+check_show iso-local &#34;$FUTURE&#34; &#34;2152-06-19 22:24:56 +0000&#34; HAVE_64BIT_TIME
</span> 
<span
class="del">-check_parse() {
</span><span
class="add">+REQUIRE_64BIT_TIME=
+check_parse () {
</span> 	echo &#34;$1 -&gt; $2&#34; &gt;expect
<span
class="del">-	test_expect_${4:-success} &#34;parse date ($1${3:+ TZ=$3})&#34; &#34;
-	TZ=${3:-$TZ} test-tool date parse &#39;$1&#39; &gt;actual &#38;&#38;
-	test_cmp expect actual
</span><span
class="add">+	test_expect_success $REQUIRE_64BIT_TIME &#34;parse date ($1${3:+ TZ=$3}) -&gt; $2&#34; &#34;
+		TZ=${3:-$TZ} test-tool date parse &#39;$1&#39; &gt;actual &#38;&#38;
+		test_cmp expect actual
</span> 	&#34;
 }
 
-- 
2.45.2-796-g2ef7a3d713

</pre></div></content></entry><entry><author><name>Junio C Hamano</name><email>gitster@pobox.com</email></author><title
type="html">[PATCH v4 0/2] Darcy&#39;s &#34;date underflow fix&#34; topic, final reroll</title><updated>2024-06-25T23:12:51Z</updated><link
href="http://lore.kernel.org/git/20240625231248.4070257-1-gitster@pobox.com/"/><id>urn:uuid:2d616a4e-7e47-dea7-228f-f260bac3f6ea</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">So it has been some time since we discussed this topic.  Let&#39;s clean
up the messy &#34;SQUASH???&#34; patches I had to queue on top of the main
patch to keep the CI working and make them into a preliminary patch.

The tree at the end of the series is identical to what has been
queued in &#39;seen&#39; for the past few weeks.  The only difference is
that we first lay groundwork to skip certain time-parsing tests on
32-bit systems first, and then use Darcy&#39;s patch with minimum
adjustments for 32-bit systems.


Darcy Burke (1):
  date: detect underflow/overflow when parsing dates with timezone offset

Junio C Hamano (1):
  t0006: simplify prerequisites

 date.c          | 12 +++++++++++-
 t/t0006-date.sh | 51 +++++++++++++++++++++++++++++++++++++++++++------
 2 files changed, 56 insertions(+), 7 deletions(-)

-- 
2.45.2-796-g2ef7a3d713

</pre></div></content></entry><entry><author><name>Taylor Blau</name><email>me@ttaylorr.com</email></author><title>[PATCH v7 16/16] bloom: introduce `deinit_bloom_filters()`</title><updated>2024-06-25T17:40:18Z</updated><link
href="http://lore.kernel.org/git/db9991f339377d64b3328cfc1b5e41548b2f8407.1719333276.git.me@ttaylorr.com/"/><id>urn:uuid:1bbf4a2d-7556-7bba-2842-c1ae79051a1e</id><thr:in-reply-to
ref="urn:uuid:b4e800cd-74de-d366-63d4-707b7970e581"
href="http://lore.kernel.org/git/cover.1719333276.git.me@ttaylorr.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">After we are done using Bloom filters, we do not currently clean up any
memory allocated by the commit slab used to store those filters in the
first place.

Besides the bloom_filter structures themselves, there is mostly nothing
to free() in the first place, since in the read-only path all Bloom
filter&#39;s `data` members point to a memory mapped region in the
commit-graph file itself.

But when generating Bloom filters from scratch (or initializing
truncated filters) we allocate additional memory to store the filter&#39;s
data.

Keep track of when we need to free() this additional chunk of memory by
using an extra pointer `to_free`. Most of the time this will be NULL
(indicating that we are representing an existing Bloom filter stored in
a memory mapped region). When it is non-NULL, free it before discarding
the Bloom filters slab.

Suggested-by: Jonathan Tan &lt;jonathantanmy@google.com&gt;
Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
---
 bloom.c        | 16 +++++++++++++++-
 bloom.h        |  3 +++
 commit-graph.c |  4 ++++
 3 files <a href="http://lore.kernel.org/git/db9991f339377d64b3328cfc1b5e41548b2f8407.1719333276.git.me@ttaylorr.com/#related">changed</a>, 22 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/bloom.c b/bloom.c
index 740c1767ea..d080a1b616 100644
--- a/bloom.c
+++ b/bloom.c
</span><span
class="hunk">@@ -92,6 +92,7 @@ int load_bloom_filter_from_graph(struct commit_graph *g,
</span> 					sizeof(unsigned char) * start_index +
 					BLOOMDATA_CHUNK_HEADER_SIZE);
 	filter-&gt;version = g-&gt;bloom_filter_settings-&gt;hash_version;
<span
class="add">+	filter-&gt;to_free = NULL;
</span> 
 	return 1;
 }
<span
class="hunk">@@ -264,6 +265,18 @@ void init_bloom_filters(void)
</span> 	init_bloom_filter_slab(&#38;bloom_filters);
 }
 
<span
class="add">+static void free_one_bloom_filter(struct bloom_filter *filter)
+{
+	if (!filter)
+		return;
+	free(filter-&gt;to_free);
+}
+
+void deinit_bloom_filters(void)
+{
+	deep_clear_bloom_filter_slab(&#38;bloom_filters, free_one_bloom_filter);
+}
+
</span> static int pathmap_cmp(const void *hashmap_cmp_fn_data UNUSED,
 		       const struct hashmap_entry *eptr,
 		       const struct hashmap_entry *entry_or_key,
<span
class="hunk">@@ -280,7 +293,7 @@ static int pathmap_cmp(const void *hashmap_cmp_fn_data UNUSED,
</span> static void init_truncated_large_filter(struct bloom_filter *filter,
 					int version)
 {
<span
class="del">-	filter-&gt;data = xmalloc(1);
</span><span
class="add">+	filter-&gt;data = filter-&gt;to_free = xmalloc(1);
</span> 	filter-&gt;data[0] = 0xFF;
 	filter-&gt;len = 1;
 	filter-&gt;version = version;
<span
class="hunk">@@ -482,6 +495,7 @@ struct bloom_filter *get_or_compute_bloom_filter(struct repository *r,
</span> 			filter-&gt;len = 1;
 		}
 		CALLOC_ARRAY(filter-&gt;data, filter-&gt;len);
<span
class="add">+		filter-&gt;to_free = filter-&gt;data;
</span> 
 		hashmap_for_each_entry(&#38;pathmap, &#38;iter, e, entry) {
 			struct bloom_key key;
<span
class="head">diff --git a/bloom.h b/bloom.h
index e3a9b68905..d20e64bfbb 100644
--- a/bloom.h
+++ b/bloom.h
</span><span
class="hunk">@@ -56,6 +56,8 @@ struct bloom_filter {
</span> 	unsigned char *data;
 	size_t len;
 	int version;
<span
class="add">+
+	void *to_free;
</span> };
 
 /*
<span
class="hunk">@@ -96,6 +98,7 @@ void add_key_to_filter(const struct bloom_key *key,
</span> 		       const struct bloom_filter_settings *settings);
 
 void init_bloom_filters(void);
<span
class="add">+void deinit_bloom_filters(void);
</span> 
 enum bloom_filter_computed {
 	BLOOM_NOT_COMPUTED = (1 &lt;&lt; 0),
<span
class="head">diff --git a/commit-graph.c b/commit-graph.c
index 2f0a08f302..c02bef7e72 100644
--- a/commit-graph.c
+++ b/commit-graph.c
</span><span
class="hunk">@@ -831,6 +831,7 @@ void close_commit_graph(struct raw_object_store *o)
</span> 		return;
 
 	clear_commit_graph_data_slab(&#38;commit_graph_data_slab);
<span
class="add">+	deinit_bloom_filters();
</span> 	free_commit_graph(o-&gt;commit_graph);
 	o-&gt;commit_graph = NULL;
 }
<span
class="hunk">@@ -2647,6 +2648,9 @@ int write_commit_graph(struct object_directory *odb,
</span> 
 	res = write_commit_graph_file(ctx);
 
<span
class="add">+	if (ctx-&gt;changed_paths)
+		deinit_bloom_filters();
+
</span> 	if (ctx-&gt;split)
 		mark_commit_graphs(ctx);
 
-- 
2.45.2.664.g446e6a2b1f
</pre></div></content></entry><entry><author><name>Taylor Blau</name><email>me@ttaylorr.com</email></author><title>[PATCH v7 15/16] commit-graph: reuse existing Bloom filters where possible</title><updated>2024-06-25T17:40:14Z</updated><link
href="http://lore.kernel.org/git/1b80023e57cc61e6d7f9bffbc0426c703ddce31a.1719333276.git.me@ttaylorr.com/"/><id>urn:uuid:d131c5f8-9cd0-ee31-9ce5-c50cb65603d7</id><thr:in-reply-to
ref="urn:uuid:b4e800cd-74de-d366-63d4-707b7970e581"
href="http://lore.kernel.org/git/cover.1719333276.git.me@ttaylorr.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">In an earlier commit, a bug was described where it&#39;s possible for Git to
produce non-murmur3 hashes when the platform&#39;s &#34;char&#34; type is signed,
and there are paths with characters whose highest bit is set (i.e. all
characters &gt;= 0x80).

That patch allows the caller to control which version of Bloom filters
are read and written. However, even on platforms with a signed &#34;char&#34;
type, it is possible to reuse existing Bloom filters if and only if
there are no changed paths in any commit&#39;s first parent tree-diff whose
characters have their highest bit set.

When this is the case, we can reuse the existing filter without having
to compute a new one. This is done by marking trees which are known to
have (or not have) any such paths. When a commit&#39;s root tree is verified
to not have any such paths, we mark it as such and declare that the
commit&#39;s Bloom filter is reusable.

Note that this heuristic only goes in one direction. If neither a commit
nor its first parent have any paths in their trees with non-ASCII
characters, then we know for certain that a path with non-ASCII
characters will not appear in a tree-diff against that commit&#39;s first
parent. The reverse isn&#39;t necessarily true: just because the tree-diff
doesn&#39;t contain any such paths does not imply that no such paths exist
in either tree.

So we end up recomputing some Bloom filters that we don&#39;t strictly have
to (i.e. their bits are the same no matter which version of murmur3 we
use). But culling these out is impossible, since we&#39;d have to perform
the full tree-diff, which is the same effort as computing the Bloom
filter from scratch.

But because we can cache our results in each tree&#39;s flag bits, we can
often avoid recomputing many filters, thereby reducing the time it takes
to run

    $ git commit-graph write --changed-paths --reachable

when upgrading from v1 to v2 Bloom filters.

To benchmark this, let&#39;s generate a commit-graph in linux.git with v1
changed-paths in generation order[^1]:

    $ git clone git@github.com:torvalds/linux.git
    $ cd linux
    $ git commit-graph write --reachable --changed-paths
    $ graph=&#34;.git/objects/info/commit-graph&#34;
    $ mv $graph{,.bak}

Then let&#39;s time how long it takes to go from v1 to v2 filters (with and
without the upgrade path enabled), resetting the state of the
commit-graph each time:

    $ git config commitGraph.changedPathsVersion 2
    $ hyperfine -p &#39;cp -f $graph.bak $graph&#39; -L v 0,1 \
        &#39;GIT_TEST_UPGRADE_BLOOM_FILTERS={v} git.compile commit-graph write --reachable --changed-paths&#39;

On linux.git (where there aren&#39;t any non-ASCII paths), the timings
indicate that this patch represents a speed-up over recomputing all
Bloom filters from scratch:

    Benchmark 1: GIT_TEST_UPGRADE_BLOOM_FILTERS=0 git.compile commit-graph write --reachable --changed-paths
      Time (mean &#177; &#963;):     124.873 s &#177;  0.316 s    [User: 124.081 s, System: 0.643 s]
      Range (min &#8230; max):   124.621 s &#8230; 125.227 s    3 runs

    Benchmark 2: GIT_TEST_UPGRADE_BLOOM_FILTERS=1 git.compile commit-graph write --reachable --changed-paths
      Time (mean &#177; &#963;):     79.271 s &#177;  0.163 s    [User: 74.611 s, System: 4.521 s]
      Range (min &#8230; max):   79.112 s &#8230; 79.437 s    3 runs

    Summary
      &#39;GIT_TEST_UPGRADE_BLOOM_FILTERS=1 git.compile commit-graph write --reachable --changed-paths&#39; ran
        1.58 &#177; 0.01 times faster than &#39;GIT_TEST_UPGRADE_BLOOM_FILTERS=0 git.compile commit-graph write --reachable --changed-paths&#39;

On git.git, we do have some non-ASCII paths, giving us a more modest
improvement from 4.163 seconds to 3.348 seconds, for a 1.24x speed-up.
On my machine, the stats for git.git are:

  - 8,285 Bloom filters computed from scratch
  - 10 Bloom filters generated as empty
  - 4 Bloom filters generated as truncated due to too many changed paths
  - 65,114 Bloom filters were reused when transitioning from v1 to v2.

[^1]: Note that this is is important, since `--stdin-packs` or
  `--stdin-commits` orders commits in the commit-graph by their pack
  position (with `--stdin-packs`) or in the raw input (with
  `--stdin-commits`).

  Since we compute Bloom filters in the same order that commits appear
  in the graph, we must see a commit&#39;s (first) parent before we process
  the commit itself. This is only guaranteed to happen when sorting
  commits by their generation number.

Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
---
 bloom.c              | 90 ++++++++++++++++++++++++++++++++++++++++++--
 bloom.h              |  1 +
 commit-graph.c       |  5 +++
 object.h             |  1 +
 t/t4216-log-bloom.sh | 39 ++++++++++++++++++-
 5 files <a href="http://lore.kernel.org/git/1b80023e57cc61e6d7f9bffbc0426c703ddce31a.1719333276.git.me@ttaylorr.com/#related">changed</a>, 132 insertions(+), 4 deletions(-)

<span
class="head">diff --git a/bloom.c b/bloom.c
index 323d8012b8..740c1767ea 100644
--- a/bloom.c
+++ b/bloom.c
</span><span
class="hunk">@@ -6,6 +6,9 @@
</span> #include &#34;commit-graph.h&#34;
 #include &#34;commit.h&#34;
 #include &#34;commit-slab.h&#34;
<span
class="add">+#include &#34;tree.h&#34;
+#include &#34;tree-walk.h&#34;
+#include &#34;config.h&#34;
</span> 
 define_commit_slab(bloom_filter_slab, struct bloom_filter);
 
<span
class="hunk">@@ -283,6 +286,73 @@ static void init_truncated_large_filter(struct bloom_filter *filter,
</span> 	filter-&gt;version = version;
 }
 
<span
class="add">+#define VISITED   (1u&lt;&lt;21)
+#define HIGH_BITS (1u&lt;&lt;22)
+
+static int has_entries_with_high_bit(struct repository *r, struct tree *t)
+{
+	if (parse_tree(t))
+		return 1;
+
+	if (!(t-&gt;object.flags &#38; VISITED)) {
+		struct tree_desc desc;
+		struct name_entry entry;
+
+		init_tree_desc(&#38;desc, &#38;t-&gt;object.oid, t-&gt;buffer, t-&gt;size);
+		while (tree_entry(&#38;desc, &#38;entry)) {
+			size_t i;
+			for (i = 0; i &lt; entry.pathlen; i++) {
+				if (entry.path[i] &#38; 0x80) {
+					t-&gt;object.flags |= HIGH_BITS;
+					goto done;
+				}
+			}
+
+			if (S_ISDIR(entry.mode)) {
+				struct tree *sub = lookup_tree(r, &#38;entry.oid);
+				if (sub &#38;&#38; has_entries_with_high_bit(r, sub)) {
+					t-&gt;object.flags |= HIGH_BITS;
+					goto done;
+				}
+			}
+
+		}
+
+done:
+		t-&gt;object.flags |= VISITED;
+	}
+
+	return !!(t-&gt;object.flags &#38; HIGH_BITS);
+}
+
+static int commit_tree_has_high_bit_paths(struct repository *r,
+					  struct commit *c)
+{
+	struct tree *t;
+	if (repo_parse_commit(r, c))
+		return 1;
+	t = repo_get_commit_tree(r, c);
+	if (!t)
+		return 1;
+	return has_entries_with_high_bit(r, t);
+}
+
+static struct bloom_filter *upgrade_filter(struct repository *r, struct commit *c,
+					   struct bloom_filter *filter,
+					   int hash_version)
+{
+	struct commit_list *p = c-&gt;parents;
+	if (commit_tree_has_high_bit_paths(r, c))
+		return NULL;
+
+	if (p &#38;&#38; commit_tree_has_high_bit_paths(r, p-&gt;item))
+		return NULL;
+
+	filter-&gt;version = hash_version;
+
+	return filter;
+}
+
</span> struct bloom_filter *get_bloom_filter(struct repository *r, struct commit *c)
 {
 	struct bloom_filter *filter;
<span
class="hunk">@@ -325,9 +395,23 @@ struct bloom_filter *get_or_compute_bloom_filter(struct repository *r,
</span> 						     filter, graph_pos);
 	}
 
<span
class="del">-	if ((filter-&gt;data &#38;&#38; filter-&gt;len) &#38;&#38;
-	    (!settings || settings-&gt;hash_version == filter-&gt;version))
-		return filter;
</span><span
class="add">+	if (filter-&gt;data &#38;&#38; filter-&gt;len) {
+		struct bloom_filter *upgrade;
+		if (!settings || settings-&gt;hash_version == filter-&gt;version)
+			return filter;
+
+		/* version mismatch, see if we can upgrade */
+		if (compute_if_not_present &#38;&#38;
+		    git_env_bool(&#34;GIT_TEST_UPGRADE_BLOOM_FILTERS&#34;, 1)) {
+			upgrade = upgrade_filter(r, c, filter,
+						 settings-&gt;hash_version);
+			if (upgrade) {
+				if (computed)
+					*computed |= BLOOM_UPGRADED;
+				return upgrade;
+			}
+		}
+	}
</span> 	if (!compute_if_not_present)
 		return NULL;
 
<span
class="head">diff --git a/bloom.h b/bloom.h
index bfe389e29c..e3a9b68905 100644
--- a/bloom.h
+++ b/bloom.h
</span><span
class="hunk">@@ -102,6 +102,7 @@ enum bloom_filter_computed {
</span> 	BLOOM_COMPUTED     = (1 &lt;&lt; 1),
 	BLOOM_TRUNC_LARGE  = (1 &lt;&lt; 2),
 	BLOOM_TRUNC_EMPTY  = (1 &lt;&lt; 3),
<span
class="add">+	BLOOM_UPGRADED     = (1 &lt;&lt; 4),
</span> };
 
 struct bloom_filter *get_or_compute_bloom_filter(struct repository *r,
<span
class="head">diff --git a/commit-graph.c b/commit-graph.c
index c1177631bb..2f0a08f302 100644
--- a/commit-graph.c
+++ b/commit-graph.c
</span><span
class="hunk">@@ -1168,6 +1168,7 @@ struct write_commit_graph_context {
</span> 	int count_bloom_filter_not_computed;
 	int count_bloom_filter_trunc_empty;
 	int count_bloom_filter_trunc_large;
<span
class="add">+	int count_bloom_filter_upgraded;
</span> };
 
 static int write_graph_chunk_fanout(struct hashfile *f,
<span
class="hunk">@@ -1775,6 +1776,8 @@ static void trace2_bloom_filter_write_statistics(struct write_commit_graph_conte
</span> 			   ctx-&gt;count_bloom_filter_trunc_empty);
 	trace2_data_intmax(&#34;commit-graph&#34;, ctx-&gt;r, &#34;filter-trunc-large&#34;,
 			   ctx-&gt;count_bloom_filter_trunc_large);
<span
class="add">+	trace2_data_intmax(&#34;commit-graph&#34;, ctx-&gt;r, &#34;filter-upgraded&#34;,
+			   ctx-&gt;count_bloom_filter_upgraded);
</span> }
 
 static void compute_bloom_filters(struct write_commit_graph_context *ctx)
<span
class="hunk">@@ -1816,6 +1819,8 @@ static void compute_bloom_filters(struct write_commit_graph_context *ctx)
</span> 				ctx-&gt;count_bloom_filter_trunc_empty++;
 			if (computed &#38; BLOOM_TRUNC_LARGE)
 				ctx-&gt;count_bloom_filter_trunc_large++;
<span
class="add">+		} else if (computed &#38; BLOOM_UPGRADED) {
+			ctx-&gt;count_bloom_filter_upgraded++;
</span> 		} else if (computed &#38; BLOOM_NOT_COMPUTED)
 			ctx-&gt;count_bloom_filter_not_computed++;
 		ctx-&gt;total_bloom_filter_data_size += filter
<span
class="head">diff --git a/object.h b/object.h
index d2f9de6bb5..0a04661a34 100644
--- a/object.h
+++ b/object.h
</span><span
class="hunk">@@ -75,6 +75,7 @@ void object_array_init(struct object_array *array);
</span>  * commit-reach.c:                                  16-----19
  * sha1-name.c:                                              20
  * list-objects-filter.c:                                      21
<span
class="add">+ * bloom.c:                                                    2122
</span>  * builtin/fsck.c:           0--3
  * builtin/gc.c:             0
  * builtin/index-pack.c:                                     2021
<span
class="head">diff --git a/t/t4216-log-bloom.sh b/t/t4216-log-bloom.sh
index cc6e5733f6..3f163dc396 100755
--- a/t/t4216-log-bloom.sh
+++ b/t/t4216-log-bloom.sh
</span><span
class="hunk">@@ -222,6 +222,10 @@ test_filter_trunc_large () {
</span> 	grep &#34;\&#34;key\&#34;:\&#34;filter-trunc-large\&#34;,\&#34;value\&#34;:\&#34;$1\&#34;&#34; $2
 }
 
<span
class="add">+test_filter_upgraded () {
+	grep &#34;\&#34;key\&#34;:\&#34;filter-upgraded\&#34;,\&#34;value\&#34;:\&#34;$1\&#34;&#34; $2
+}
+
</span> test_expect_success &#39;correctly report changes over limit&#39; &#39;
 	git init limits &#38;&#38;
 	(
<span
class="hunk">@@ -667,7 +671,14 @@ test_expect_success &#39;when writing another commit graph, preserve existing versio
</span> test_expect_success &#39;when writing commit graph, do not reuse changed-path of another version&#39; &#39;
 	git init doublewrite &#38;&#38;
 	test_commit -C doublewrite c &#34;$CENT&#34; &#38;&#38;
<span
class="add">+
</span> 	git -C doublewrite config --add commitGraph.changedPathsVersion 1 &#38;&#38;
<span
class="add">+	&gt;trace2.txt &#38;&#38;
+	GIT_TRACE2_EVENT=&#34;$(pwd)/trace2.txt&#34; \
+		git -C doublewrite commit-graph write --reachable --changed-paths &#38;&#38;
+	test_filter_computed 1 trace2.txt &#38;&#38;
+	test_filter_upgraded 0 trace2.txt &#38;&#38;
+
</span> 	git -C doublewrite commit-graph write --reachable --changed-paths &#38;&#38;
 	for v in -2 3
 	do
<span
class="hunk">@@ -678,8 +689,14 @@ test_expect_success &#39;when writing commit graph, do not reuse changed-path of ano
</span> 		EOF
 		test_cmp expect err || return 1
 	done &#38;&#38;
<span
class="add">+
</span> 	git -C doublewrite config --add commitGraph.changedPathsVersion 2 &#38;&#38;
<span
class="del">-	git -C doublewrite commit-graph write --reachable --changed-paths &#38;&#38;
</span><span
class="add">+	&gt;trace2.txt &#38;&#38;
+	GIT_TRACE2_EVENT=&#34;$(pwd)/trace2.txt&#34; \
+		git -C doublewrite commit-graph write --reachable --changed-paths &#38;&#38;
+	test_filter_computed 1 trace2.txt &#38;&#38;
+	test_filter_upgraded 0 trace2.txt &#38;&#38;
+
</span> 	(
 		cd doublewrite &#38;&#38;
 		echo &#34;c01f&#34; &gt;expect &#38;&#38;
<span
class="hunk">@@ -688,6 +705,26 @@ test_expect_success &#39;when writing commit graph, do not reuse changed-path of ano
</span> 	)
 &#39;
 
<span
class="add">+test_expect_success &#39;when writing commit graph, reuse changed-path of another version where possible&#39; &#39;
+	git init upgrade &#38;&#38;
+
+	test_commit -C upgrade base no-high-bits &#38;&#38;
+
+	git -C upgrade config --add commitGraph.changedPathsVersion 1 &#38;&#38;
+	&gt;trace2.txt &#38;&#38;
+	GIT_TRACE2_EVENT=&#34;$(pwd)/trace2.txt&#34; \
+		git -C upgrade commit-graph write --reachable --changed-paths &#38;&#38;
+	test_filter_computed 1 trace2.txt &#38;&#38;
+	test_filter_upgraded 0 trace2.txt &#38;&#38;
+
+	git -C upgrade config --add commitGraph.changedPathsVersion 2 &#38;&#38;
+	&gt;trace2.txt &#38;&#38;
+	GIT_TRACE2_EVENT=&#34;$(pwd)/trace2.txt&#34; \
+		git -C upgrade commit-graph write --reachable --changed-paths &#38;&#38;
+	test_filter_computed 0 trace2.txt &#38;&#38;
+	test_filter_upgraded 1 trace2.txt
+&#39;
+
</span> corrupt_graph () {
 	test_when_finished &#34;rm -rf $graph&#34; &#38;&#38;
 	git commit-graph write --reachable --changed-paths &#38;&#38;
-- 
2.45.2.664.g446e6a2b1f

</pre></div></content></entry><entry><author><name>Taylor Blau</name><email>me@ttaylorr.com</email></author><title>[PATCH v7 14/16] object.h: fix mis-aligned flag bits table</title><updated>2024-06-25T17:40:11Z</updated><link
href="http://lore.kernel.org/git/242f023135cfc2301576786172639cc5664d3449.1719333276.git.me@ttaylorr.com/"/><id>urn:uuid:1001200d-45a8-f99c-2f02-1bc7d2abbb21</id><thr:in-reply-to
ref="urn:uuid:b4e800cd-74de-d366-63d4-707b7970e581"
href="http://lore.kernel.org/git/cover.1719333276.git.me@ttaylorr.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Bit position 23 is one column too far to the left.

Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
---
 object.h | 2 +-
 1 file <a href="http://lore.kernel.org/git/242f023135cfc2301576786172639cc5664d3449.1719333276.git.me@ttaylorr.com/#related">changed</a>, 1 insertion(+), 1 deletion(-)

<span
class="head">diff --git a/object.h b/object.h
index 669b6a18fa..d2f9de6bb5 100644
--- a/object.h
+++ b/object.h
</span><span
class="hunk">@@ -62,7 +62,7 @@ void object_array_init(struct object_array *array);
</span> 
 /*
  * object flag allocation:
<span
class="del">- * revision.h:               0---------10         15             23------27
</span><span
class="add">+ * revision.h:               0---------10         15               23------27
</span>  * fetch-pack.c:             01    67
  * negotiator/default.c:       2--5
  * walker.c:                 0-2
-- 
2.45.2.664.g446e6a2b1f

</pre></div></content></entry><entry><author><name>Taylor Blau</name><email>me@ttaylorr.com</email></author><title>[PATCH v7 13/16] commit-graph: new Bloom filter version that fixes murmur3</title><updated>2024-06-25T17:40:07Z</updated><link
href="http://lore.kernel.org/git/2e945c3d2e3ac6b5cb3e56689691b6f251a77262.1719333276.git.me@ttaylorr.com/"/><id>urn:uuid:cd399fef-5e36-eb24-3f9e-1791d23e6f11</id><thr:in-reply-to
ref="urn:uuid:b4e800cd-74de-d366-63d4-707b7970e581"
href="http://lore.kernel.org/git/cover.1719333276.git.me@ttaylorr.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The murmur3 implementation in bloom.c has a bug when converting series
of 4 bytes into network-order integers when char is signed (which is
controllable by a compiler option, and the default signedness of char is
platform-specific). When a string contains characters with the high bit
set, this bug causes results that, although internally consistent within
Git, does not accord with other implementations of murmur3 (thus,
the changed path filters wouldn&#39;t be readable by other off-the-shelf
implementatios of murmur3) and even with Git binaries that were compiled
with different signedness of char. This bug affects both how Git writes
changed path filters to disk and how Git interprets changed path filters
on disk.

Therefore, introduce a new version (2) of changed path filters that
corrects this problem. The existing version (1) is still supported and
is still the default, but users should migrate away from it as soon
as possible.

Because this bug only manifests with characters that have the high bit
set, it may be possible that some (or all) commits in a given repo would
have the same changed path filter both before and after this fix is
applied. However, in order to determine whether this is the case, the
changed paths would first have to be computed, at which point it is not
much more expensive to just compute a new changed path filter.

So this patch does not include any mechanism to &#34;salvage&#34; changed path
filters from repositories. There is also no &#34;mixed&#34; mode - for each
invocation of Git, reading and writing changed path filters are done
with the same version number; this version number may be explicitly
stated (typically if the user knows which version they need) or
automatically determined from the version of the existing changed path
filters in the repository.

There is a change in write_commit_graph(). graph_read_bloom_data()
makes it possible for chunk_bloom_data to be non-NULL but
bloom_filter_settings to be NULL, which causes a segfault later on. I
produced such a segfault while developing this patch, but couldn&#39;t find
a way to reproduce it neither after this complete patch (or before),
but in any case it seemed like a good thing to include that might help
future patch authors.

The value in t0095 was obtained from another murmur3 implementation
using the following Go source code:

  package main

  import &#34;fmt&#34;
  import &#34;github.com/spaolacci/murmur3&#34;

  func main() {
          fmt.Printf(&#34;%x\n&#34;, murmur3.Sum32([]byte(&#34;Hello world!&#34;)))
          fmt.Printf(&#34;%x\n&#34;, murmur3.Sum32([]byte{0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff}))
  }

Signed-off-by: Jonathan Tan &lt;jonathantanmy@google.com&gt;
Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
---
 Documentation/config/commitgraph.txt |   5 +-
 bloom.c                              |  69 +++++++++++-
 bloom.h                              |   8 +-
 commit-graph.c                       |  13 ++-
 t/helper/test-bloom.c                |   9 +-
 t/t0095-bloom.sh                     |   8 ++
 t/t4216-log-bloom.sh                 | 155 ++++++++++++++++++++++++++-
 7 files <a href="http://lore.kernel.org/git/2e945c3d2e3ac6b5cb3e56689691b6f251a77262.1719333276.git.me@ttaylorr.com/#related">changed</a>, 252 insertions(+), 15 deletions(-)

<span
class="head">diff --git a/Documentation/config/commitgraph.txt b/Documentation/config/commitgraph.txt
index e68cdededa..7f8c9d6638 100644
--- a/Documentation/config/commitgraph.txt
+++ b/Documentation/config/commitgraph.txt
</span><span
class="hunk">@@ -15,7 +15,7 @@ commitGraph.readChangedPaths::
</span> 
 commitGraph.changedPathsVersion::
 	Specifies the version of the changed-path Bloom filters that Git will read and
<span
class="del">-	write. May be -1, 0 or 1. Note that values greater than 1 may be
</span><span
class="add">+	write. May be -1, 0, 1, or 2. Note that values greater than 1 may be
</span> 	incompatible with older versions of Git which do not yet understand
 	those versions. Use caution when operating in a mixed-version
 	environment.
<span
class="hunk">@@ -31,4 +31,7 @@ filters when instructed to write.
</span> If 1, Git will only read version 1 Bloom filters, and will write version 1
 Bloom filters.
 +
<span
class="add">+If 2, Git will only read version 2 Bloom filters, and will write version 2
+Bloom filters.
++
</span> See linkgit:git-commit-graph[1] for more information.
<span
class="head">diff --git a/bloom.c b/bloom.c
index c24489dbcf..323d8012b8 100644
--- a/bloom.c
+++ b/bloom.c
</span><span
class="hunk">@@ -100,7 +100,64 @@ int load_bloom_filter_from_graph(struct commit_graph *g,
</span>  * Not considered to be cryptographically secure.
  * Implemented as described in <a
href="https://en.wikipedia.org/wiki/MurmurHash#Algorithm">https://en.wikipedia.org/wiki/MurmurHash#Algorithm</a>
  */
<span
class="del">-uint32_t murmur3_seeded(uint32_t seed, const char *data, size_t len)
</span><span
class="add">+uint32_t murmur3_seeded_v2(uint32_t seed, const char *data, size_t len)
+{
+	const uint32_t c1 = 0xcc9e2d51;
+	const uint32_t c2 = 0x1b873593;
+	const uint32_t r1 = 15;
+	const uint32_t r2 = 13;
+	const uint32_t m = 5;
+	const uint32_t n = 0xe6546b64;
+	int i;
+	uint32_t k1 = 0;
+	const char *tail;
+
+	int len4 = len / sizeof(uint32_t);
+
+	uint32_t k;
+	for (i = 0; i &lt; len4; i++) {
+		uint32_t byte1 = (uint32_t)(unsigned char)data[4*i];
+		uint32_t byte2 = ((uint32_t)(unsigned char)data[4*i + 1]) &lt;&lt; 8;
+		uint32_t byte3 = ((uint32_t)(unsigned char)data[4*i + 2]) &lt;&lt; 16;
+		uint32_t byte4 = ((uint32_t)(unsigned char)data[4*i + 3]) &lt;&lt; 24;
+		k = byte1 | byte2 | byte3 | byte4;
+		k *= c1;
+		k = rotate_left(k, r1);
+		k *= c2;
+
+		seed ^= k;
+		seed = rotate_left(seed, r2) * m + n;
+	}
+
+	tail = (data + len4 * sizeof(uint32_t));
+
+	switch (len &#38; (sizeof(uint32_t) - 1)) {
+	case 3:
+		k1 ^= ((uint32_t)(unsigned char)tail[2]) &lt;&lt; 16;
+		/*-fallthrough*/
+	case 2:
+		k1 ^= ((uint32_t)(unsigned char)tail[1]) &lt;&lt; 8;
+		/*-fallthrough*/
+	case 1:
+		k1 ^= ((uint32_t)(unsigned char)tail[0]) &lt;&lt; 0;
+		k1 *= c1;
+		k1 = rotate_left(k1, r1);
+		k1 *= c2;
+		seed ^= k1;
+		break;
+	}
+
+	seed ^= (uint32_t)len;
+	seed ^= (seed &gt;&gt; 16);
+	seed *= 0x85ebca6b;
+	seed ^= (seed &gt;&gt; 13);
+	seed *= 0xc2b2ae35;
+	seed ^= (seed &gt;&gt; 16);
+
+	return seed;
+}
+
+static uint32_t murmur3_seeded_v1(uint32_t seed, const char *data, size_t len)
</span> {
 	const uint32_t c1 = 0xcc9e2d51;
 	const uint32_t c2 = 0x1b873593;
<span
class="hunk">@@ -165,8 +222,14 @@ void fill_bloom_key(const char *data,
</span> 	int i;
 	const uint32_t seed0 = 0x293ae76f;
 	const uint32_t seed1 = 0x7e646e2c;
<span
class="del">-	const uint32_t hash0 = murmur3_seeded(seed0, data, len);
-	const uint32_t hash1 = murmur3_seeded(seed1, data, len);
</span><span
class="add">+	uint32_t hash0, hash1;
+	if (settings-&gt;hash_version == 2) {
+		hash0 = murmur3_seeded_v2(seed0, data, len);
+		hash1 = murmur3_seeded_v2(seed1, data, len);
+	} else {
+		hash0 = murmur3_seeded_v1(seed0, data, len);
+		hash1 = murmur3_seeded_v1(seed1, data, len);
+	}
</span> 
 	key-&gt;hashes = (uint32_t *)xcalloc(settings-&gt;num_hashes, sizeof(uint32_t));
 	for (i = 0; i &lt; settings-&gt;num_hashes; i++)
<span
class="head">diff --git a/bloom.h b/bloom.h
index 052a993aab..bfe389e29c 100644
--- a/bloom.h
+++ b/bloom.h
</span><span
class="hunk">@@ -8,9 +8,11 @@ struct commit_graph;
</span> struct bloom_filter_settings {
 	/*
 	 * The version of the hashing technique being used.
<span
class="del">-	 * We currently only support version = 1 which is
</span><span
class="add">+	 * The newest version is 2, which is
</span> 	 * the seeded murmur3 hashing technique implemented
<span
class="del">-	 * in bloom.c.
</span><span
class="add">+	 * in bloom.c. Bloom filters of version 1 were created
+	 * with prior versions of Git, which had a bug in the
+	 * implementation of the hash function.
</span> 	 */
 	uint32_t hash_version;
 
<span
class="hunk">@@ -81,7 +83,7 @@ int load_bloom_filter_from_graph(struct commit_graph *g,
</span>  * Not considered to be cryptographically secure.
  * Implemented as described in <a
href="https://en.wikipedia.org/wiki/MurmurHash#Algorithm">https://en.wikipedia.org/wiki/MurmurHash#Algorithm</a>
  */
<span
class="del">-uint32_t murmur3_seeded(uint32_t seed, const char *data, size_t len);
</span><span
class="add">+uint32_t murmur3_seeded_v2(uint32_t seed, const char *data, size_t len);
</span> 
 void fill_bloom_key(const char *data,
 		    size_t len,
<span
class="head">diff --git a/commit-graph.c b/commit-graph.c
index 8129a4f5dc..c1177631bb 100644
--- a/commit-graph.c
+++ b/commit-graph.c
</span><span
class="hunk">@@ -344,7 +344,6 @@ static int graph_read_bloom_data(const unsigned char *chunk_start,
</span> 				  size_t chunk_size, void *data)
 {
 	struct commit_graph *g = data;
<span
class="del">-	uint32_t hash_version;
</span> 
 	if (chunk_size &lt; BLOOMDATA_CHUNK_HEADER_SIZE) {
 		warning(_(&#34;ignoring too-small changed-path chunk&#34;
<span
class="hunk">@@ -356,10 +355,9 @@ static int graph_read_bloom_data(const unsigned char *chunk_start,
</span> 
 	g-&gt;chunk_bloom_data = chunk_start;
 	g-&gt;chunk_bloom_data_size = chunk_size;
<span
class="del">-	hash_version = get_be32(chunk_start);
</span> 
 	g-&gt;bloom_filter_settings = xmalloc(sizeof(struct bloom_filter_settings));
<span
class="del">-	g-&gt;bloom_filter_settings-&gt;hash_version = hash_version;
</span><span
class="add">+	g-&gt;bloom_filter_settings-&gt;hash_version = get_be32(chunk_start);
</span> 	g-&gt;bloom_filter_settings-&gt;num_hashes = get_be32(chunk_start + 4);
 	g-&gt;bloom_filter_settings-&gt;bits_per_entry = get_be32(chunk_start + 8);
 	g-&gt;bloom_filter_settings-&gt;max_changed_paths = DEFAULT_BLOOM_MAX_CHANGES;
<span
class="hunk">@@ -2499,6 +2497,13 @@ int write_commit_graph(struct object_directory *odb,
</span> 	}
 	if (!commit_graph_compatible(r))
 		return 0;
<span
class="add">+	if (r-&gt;settings.commit_graph_changed_paths_version &lt; -1
+	    || r-&gt;settings.commit_graph_changed_paths_version &gt; 2) {
+		warning(_(&#34;attempting to write a commit-graph, but &#34;
+			  &#34;&#39;commitGraph.changedPathsVersion&#39; (%d) is not supported&#34;),
+			r-&gt;settings.commit_graph_changed_paths_version);
+		return 0;
+	}
</span> 
 	CALLOC_ARRAY(ctx, 1);
 	ctx-&gt;r = r;
<span
class="hunk">@@ -2541,7 +2546,7 @@ int write_commit_graph(struct object_directory *odb,
</span> 		g = ctx-&gt;r-&gt;objects-&gt;commit_graph;
 
 		/* We have changed-paths already. Keep them in the next graph */
<span
class="del">-		if (g &#38;&#38; g-&gt;chunk_bloom_data) {
</span><span
class="add">+		if (g &#38;&#38; g-&gt;bloom_filter_settings) {
</span> 			ctx-&gt;changed_paths = 1;
 
 			/* don&#39;t propagate the hash_version unless unspecified */
<span
class="head">diff --git a/t/helper/test-bloom.c b/t/helper/test-bloom.c
index 1281e66876..eefc1668c7 100644
--- a/t/helper/test-bloom.c
+++ b/t/helper/test-bloom.c
</span><span
class="hunk">@@ -49,6 +49,7 @@ static void get_bloom_filter_for_commit(const struct object_id *commit_oid)
</span> 
 static const char *bloom_usage = &#34;\n&#34;
 &#34;  test-tool bloom get_murmur3 &lt;string&gt;\n&#34;
<span
class="add">+&#34;  test-tool bloom get_murmur3_seven_highbit\n&#34;
</span> &#34;  test-tool bloom generate_filter &lt;string&gt; [&lt;string&gt;...]\n&#34;
 &#34;  test-tool bloom get_filter_for_commit &lt;commit-hex&gt;\n&#34;;
 
<span
class="hunk">@@ -63,7 +64,13 @@ int cmd__bloom(int argc, const char **argv)
</span> 		uint32_t hashed;
 		if (argc &lt; 3)
 			usage(bloom_usage);
<span
class="del">-		hashed = murmur3_seeded(0, argv[2], strlen(argv[2]));
</span><span
class="add">+		hashed = murmur3_seeded_v2(0, argv[2], strlen(argv[2]));
+		printf(&#34;Murmur3 Hash with seed=0:0x%08x\n&#34;, hashed);
+	}
+
+	if (!strcmp(argv[1], &#34;get_murmur3_seven_highbit&#34;)) {
+		uint32_t hashed;
+		hashed = murmur3_seeded_v2(0, &#34;\x99\xaa\xbb\xcc\xdd\xee\xff&#34;, 7);
</span> 		printf(&#34;Murmur3 Hash with seed=0:0x%08x\n&#34;, hashed);
 	}
 
<span
class="head">diff --git a/t/t0095-bloom.sh b/t/t0095-bloom.sh
index b567383eb8..c8d84ab606 100755
--- a/t/t0095-bloom.sh
+++ b/t/t0095-bloom.sh
</span><span
class="hunk">@@ -29,6 +29,14 @@ test_expect_success &#39;compute unseeded murmur3 hash for test string 2&#39; &#39;
</span> 	test_cmp expect actual
 &#39;
 
<span
class="add">+test_expect_success &#39;compute unseeded murmur3 hash for test string 3&#39; &#39;
+	cat &gt;expect &lt;&lt;-\EOF &#38;&#38;
+	Murmur3 Hash with seed=0:0xa183ccfd
+	EOF
+	test-tool bloom get_murmur3_seven_highbit &gt;actual &#38;&#38;
+	test_cmp expect actual
+&#39;
+
</span> test_expect_success &#39;compute bloom key for empty string&#39; &#39;
 	cat &gt;expect &lt;&lt;-\EOF &#38;&#38;
 	Hashes:0x5615800c|0x5b966560|0x61174ab4|0x66983008|0x6c19155c|0x7199fab0|0x771ae004|
<span
class="head">diff --git a/t/t4216-log-bloom.sh b/t/t4216-log-bloom.sh
index 49d1113171..cc6e5733f6 100755
--- a/t/t4216-log-bloom.sh
+++ b/t/t4216-log-bloom.sh
</span><span
class="hunk">@@ -488,14 +488,49 @@ test_expect_success &#39;merge graph layers with incompatible Bloom settings&#39; &#39;
</span> 	test_must_be_empty err
 &#39;
 
<span
class="add">+# chosen to be the same under all Unicode normalization forms
+CENT=$(printf &#34;\302\242&#34;)
+
+test_expect_success &#39;ensure Bloom filter with incompatible versions are ignored&#39; &#39;
+	rm &#34;$repo/$graph&#34; &#38;&#38;
+
+	git -C $repo log --oneline --no-decorate -- $CENT &gt;expect &#38;&#38;
+
+	# Compute v1 Bloom filters for commits at the bottom.
+	git -C $repo rev-parse HEAD^ &gt;in &#38;&#38;
+	git -C $repo commit-graph write --stdin-commits --changed-paths \
+		--split &lt;in &#38;&#38;
+
+	# Compute v2 Bloomfilters for the rest of the commits at the top.
+	git -C $repo rev-parse HEAD &gt;in &#38;&#38;
+	git -C $repo -c commitGraph.changedPathsVersion=2 commit-graph write \
+		--stdin-commits --changed-paths --split=no-merge &lt;in &#38;&#38;
+
+	test_line_count = 2 $repo/$chain &#38;&#38;
+
+	git -C $repo log --oneline --no-decorate -- $CENT &gt;actual 2&gt;err &#38;&#38;
+	test_cmp expect actual &#38;&#38;
+
+	layer=&#34;$(head -n 1 $repo/$chain)&#34; &#38;&#38;
+	cat &gt;expect.err &lt;&lt;-EOF &#38;&#38;
+	warning: disabling Bloom filters for commit-graph layer $SQ$layer$SQ due to incompatible settings
+	EOF
+	test_cmp expect.err err &#38;&#38;
+
+	# Merge the two layers with incompatible bloom filter versions,
+	# ensuring that the v2 filters are used.
+	&gt;trace2.txt &#38;&#38;
+	GIT_TRACE2_EVENT=&#34;$(pwd)/trace2.txt&#34; \
+		git -C $repo -c commitGraph.changedPathsVersion=2 commit-graph write --reachable --changed-paths 2&gt;err &#38;&#38;
+	grep &#34;disabling Bloom filters for commit-graph layer .$layer.&#34; err &#38;&#38;
+	grep &#34;{\&#34;hash_version\&#34;:2,\&#34;num_hashes\&#34;:7,\&#34;bits_per_entry\&#34;:10,\&#34;max_changed_paths\&#34;:512&#34; trace2.txt
+&#39;
+
</span> get_first_changed_path_filter () {
 	test-tool read-graph bloom-filters &gt;filters.dat &#38;&#38;
 	head -n 1 filters.dat
 }
 
<span
class="del">-# chosen to be the same under all Unicode normalization forms
-CENT=$(printf &#34;\302\242&#34;)
-
</span> test_expect_success &#39;set up repo with high bit path, version 1 changed-path&#39; &#39;
 	git init highbit1 &#38;&#38;
 	test_commit -C highbit1 c1 &#34;$CENT&#34; &#38;&#38;
<span
class="hunk">@@ -539,6 +574,120 @@ test_expect_success &#39;version 1 changed-path used when version 1 requested&#39; &#39;
</span> 	)
 &#39;
 
<span
class="add">+test_expect_success &#39;version 1 changed-path not used when version 2 requested&#39; &#39;
+	(
+		cd highbit1 &#38;&#38;
+		git config --add commitGraph.changedPathsVersion 2 &#38;&#38;
+		test_bloom_filters_not_used &#34;-- another$CENT&#34;
+	)
+&#39;
+
+test_expect_success &#39;version 1 changed-path used when autodetect requested&#39; &#39;
+	(
+		cd highbit1 &#38;&#38;
+		git config --add commitGraph.changedPathsVersion -1 &#38;&#38;
+		test_bloom_filters_used &#34;-- another$CENT&#34;
+	)
+&#39;
+
+test_expect_success &#39;when writing another commit graph, preserve existing version 1 of changed-path&#39; &#39;
+	test_commit -C highbit1 c1double &#34;$CENT$CENT&#34; &#38;&#38;
+	git -C highbit1 commit-graph write --reachable --changed-paths &#38;&#38;
+	(
+		cd highbit1 &#38;&#38;
+		git config --add commitGraph.changedPathsVersion -1 &#38;&#38;
+		echo &#34;options: bloom(1,10,7) read_generation_data&#34; &gt;expect &#38;&#38;
+		test-tool read-graph &gt;full &#38;&#38;
+		grep options full &gt;actual &#38;&#38;
+		test_cmp expect actual
+	)
+&#39;
+
+test_expect_success &#39;set up repo with high bit path, version 2 changed-path&#39; &#39;
+	git init highbit2 &#38;&#38;
+	git -C highbit2 config --add commitGraph.changedPathsVersion 2 &#38;&#38;
+	test_commit -C highbit2 c2 &#34;$CENT&#34; &#38;&#38;
+	git -C highbit2 commit-graph write --reachable --changed-paths
+&#39;
+
+test_expect_success &#39;check value of version 2 changed-path&#39; &#39;
+	(
+		cd highbit2 &#38;&#38;
+		echo &#34;c01f&#34; &gt;expect &#38;&#38;
+		get_first_changed_path_filter &gt;actual &#38;&#38;
+		test_cmp expect actual
+	)
+&#39;
+
+test_expect_success &#39;setup make another commit&#39; &#39;
+	# &#34;git log&#34; does not use Bloom filters for root commits - see how, in
+	# revision.c, rev_compare_tree() (the only code path that eventually calls
+	# get_bloom_filter()) is only called by try_to_simplify_commit() when the commit
+	# has one parent. Therefore, make another commit so that we perform the tests on
+	# a non-root commit.
+	test_commit -C highbit2 anotherc2 &#34;another$CENT&#34;
+&#39;
+
+test_expect_success &#39;version 2 changed-path used when version 2 requested&#39; &#39;
+	(
+		cd highbit2 &#38;&#38;
+		test_bloom_filters_used &#34;-- another$CENT&#34;
+	)
+&#39;
+
+test_expect_success &#39;version 2 changed-path not used when version 1 requested&#39; &#39;
+	(
+		cd highbit2 &#38;&#38;
+		git config --add commitGraph.changedPathsVersion 1 &#38;&#38;
+		test_bloom_filters_not_used &#34;-- another$CENT&#34;
+	)
+&#39;
+
+test_expect_success &#39;version 2 changed-path used when autodetect requested&#39; &#39;
+	(
+		cd highbit2 &#38;&#38;
+		git config --add commitGraph.changedPathsVersion -1 &#38;&#38;
+		test_bloom_filters_used &#34;-- another$CENT&#34;
+	)
+&#39;
+
+test_expect_success &#39;when writing another commit graph, preserve existing version 2 of changed-path&#39; &#39;
+	test_commit -C highbit2 c2double &#34;$CENT$CENT&#34; &#38;&#38;
+	git -C highbit2 commit-graph write --reachable --changed-paths &#38;&#38;
+	(
+		cd highbit2 &#38;&#38;
+		git config --add commitGraph.changedPathsVersion -1 &#38;&#38;
+		echo &#34;options: bloom(2,10,7) read_generation_data&#34; &gt;expect &#38;&#38;
+		test-tool read-graph &gt;full &#38;&#38;
+		grep options full &gt;actual &#38;&#38;
+		test_cmp expect actual
+	)
+&#39;
+
+test_expect_success &#39;when writing commit graph, do not reuse changed-path of another version&#39; &#39;
+	git init doublewrite &#38;&#38;
+	test_commit -C doublewrite c &#34;$CENT&#34; &#38;&#38;
+	git -C doublewrite config --add commitGraph.changedPathsVersion 1 &#38;&#38;
+	git -C doublewrite commit-graph write --reachable --changed-paths &#38;&#38;
+	for v in -2 3
+	do
+		git -C doublewrite config --add commitGraph.changedPathsVersion $v &#38;&#38;
+		git -C doublewrite commit-graph write --reachable --changed-paths 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		warning: attempting to write a commit-graph, but ${SQ}commitGraph.changedPathsVersion${SQ} ($v) is not supported
+		EOF
+		test_cmp expect err || return 1
+	done &#38;&#38;
+	git -C doublewrite config --add commitGraph.changedPathsVersion 2 &#38;&#38;
+	git -C doublewrite commit-graph write --reachable --changed-paths &#38;&#38;
+	(
+		cd doublewrite &#38;&#38;
+		echo &#34;c01f&#34; &gt;expect &#38;&#38;
+		get_first_changed_path_filter &gt;actual &#38;&#38;
+		test_cmp expect actual
+	)
+&#39;
+
</span> corrupt_graph () {
 	test_when_finished &#34;rm -rf $graph&#34; &#38;&#38;
 	git commit-graph write --reachable --changed-paths &#38;&#38;
-- 
2.45.2.664.g446e6a2b1f

</pre></div></content></entry><entry><author><name>Taylor Blau</name><email>me@ttaylorr.com</email></author><title>[PATCH v7 12/16] commit-graph: unconditionally load Bloom filters</title><updated>2024-06-25T17:40:03Z</updated><link
href="http://lore.kernel.org/git/99e66d1dba5c4d7d57859ba5f6ef9e0d349dd356.1719333276.git.me@ttaylorr.com/"/><id>urn:uuid:cd6cf3b2-1427-dac6-fba5-c5f0980a4625</id><thr:in-reply-to
ref="urn:uuid:b4e800cd-74de-d366-63d4-707b7970e581"
href="http://lore.kernel.org/git/cover.1719333276.git.me@ttaylorr.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">In an earlier commit, we began ignoring the Bloom data (&#34;BDAT&#34;) chunk
for commit-graphs whose Bloom filters were computed using a hash version
incompatible with the value of `commitGraph.changedPathVersion`.

Now that the Bloom API has been hardened to discard these incompatible
filters (with the exception of low-level APIs), we can safely load these
Bloom filters unconditionally.

We no longer want to return early from `graph_read_bloom_data()`, and
similarly do not want to set the bloom_settings&#39; `hash_version` field as
a side-effect. The latter is because we want to wait until we know which
Bloom settings we&#39;re using (either the defaults, from the GIT_TEST
variables, or from the previous commit-graph layer) before deciding what
hash_version to use.

If we detect an existing BDAT chunk, we&#39;ll infer the rest of the
settings (e.g., number of hashes, bits per entry, and maximum number of
changed paths) from the earlier graph layer. The hash_version will be
inferred from the previous layer as well, unless one has already been
specified via configuration.

Once all of that is done, we normalize the value of the hash_version to
either &#34;1&#34; or &#34;2&#34;.

Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
---
 commit-graph.c | 14 ++++++++++----
 1 file <a href="http://lore.kernel.org/git/99e66d1dba5c4d7d57859ba5f6ef9e0d349dd356.1719333276.git.me@ttaylorr.com/#related">changed</a>, 10 insertions(+), 4 deletions(-)

<span
class="head">diff --git a/commit-graph.c b/commit-graph.c
index 87b07e7b85..8129a4f5dc 100644
--- a/commit-graph.c
+++ b/commit-graph.c
</span><span
class="hunk">@@ -358,9 +358,6 @@ static int graph_read_bloom_data(const unsigned char *chunk_start,
</span> 	g-&gt;chunk_bloom_data_size = chunk_size;
 	hash_version = get_be32(chunk_start);
 
<span
class="del">-	if (hash_version != 1)
-		return 0;
-
</span> 	g-&gt;bloom_filter_settings = xmalloc(sizeof(struct bloom_filter_settings));
 	g-&gt;bloom_filter_settings-&gt;hash_version = hash_version;
 	g-&gt;bloom_filter_settings-&gt;num_hashes = get_be32(chunk_start + 4);
<span
class="hunk">@@ -2514,6 +2511,7 @@ int write_commit_graph(struct object_directory *odb,
</span> 	ctx-&gt;write_generation_data = (get_configured_generation_version(r) == 2);
 	ctx-&gt;num_generation_data_overflows = 0;
 
<span
class="add">+	bloom_settings.hash_version = r-&gt;settings.commit_graph_changed_paths_version;
</span> 	bloom_settings.bits_per_entry = git_env_ulong(&#34;GIT_TEST_BLOOM_SETTINGS_BITS_PER_ENTRY&#34;,
 						      bloom_settings.bits_per_entry);
 	bloom_settings.num_hashes = git_env_ulong(&#34;GIT_TEST_BLOOM_SETTINGS_NUM_HASHES&#34;,
<span
class="hunk">@@ -2545,10 +2543,18 @@ int write_commit_graph(struct object_directory *odb,
</span> 		/* We have changed-paths already. Keep them in the next graph */
 		if (g &#38;&#38; g-&gt;chunk_bloom_data) {
 			ctx-&gt;changed_paths = 1;
<span
class="del">-			ctx-&gt;bloom_settings = g-&gt;bloom_filter_settings;
</span><span
class="add">+
+			/* don&#39;t propagate the hash_version unless unspecified */
+			if (bloom_settings.hash_version == -1)
+				bloom_settings.hash_version = g-&gt;bloom_filter_settings-&gt;hash_version;
+			bloom_settings.bits_per_entry = g-&gt;bloom_filter_settings-&gt;bits_per_entry;
+			bloom_settings.num_hashes = g-&gt;bloom_filter_settings-&gt;num_hashes;
+			bloom_settings.max_changed_paths = g-&gt;bloom_filter_settings-&gt;max_changed_paths;
</span> 		}
 	}
 
<span
class="add">+	bloom_settings.hash_version = bloom_settings.hash_version == 2 ? 2 : 1;
+
</span> 	if (ctx-&gt;split) {
 		struct commit_graph *g = ctx-&gt;r-&gt;objects-&gt;commit_graph;
 
-- 
2.45.2.664.g446e6a2b1f

</pre></div></content></entry><entry><author><name>Taylor Blau</name><email>me@ttaylorr.com</email></author><title>[PATCH v7 11/16] bloom: prepare to discard incompatible Bloom filters</title><updated>2024-06-25T17:40:00Z</updated><link
href="http://lore.kernel.org/git/99ab9cf448eea65db1a561a79223fe70073d1be0.1719333276.git.me@ttaylorr.com/"/><id>urn:uuid:4ef7042a-3a16-f4f6-9b01-9436592aab60</id><thr:in-reply-to
ref="urn:uuid:b4e800cd-74de-d366-63d4-707b7970e581"
href="http://lore.kernel.org/git/cover.1719333276.git.me@ttaylorr.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Callers use the inline `get_bloom_filter()` implementation as a thin
wrapper around `get_or_compute_bloom_filter()`. The former calls the
latter with a value of &#34;0&#34; for `compute_if_not_present`, making
`get_bloom_filter()` the default read-only path for fetching an existing
Bloom filter.

Callers expect the value returned from `get_bloom_filter()` is usable,
that is that it&#39;s compatible with the configured value corresponding to
`commitGraph.changedPathsVersion`.

This is OK, since the commit-graph machinery only initializes its BDAT
chunk (thereby enabling it to service Bloom filter queries) when the
Bloom filter hash_version is compatible with our settings. So any value
returned by `get_bloom_filter()` is trivially useable.

However, subsequent commits will load the BDAT chunk even when the Bloom
filters are built with incompatible hash versions. Prepare to handle
this by teaching `get_bloom_filter()` to discard filters that are
incompatible with the configured hash version.

Callers who wish to read incompatible filters (e.g., for upgrading
filters from v1 to v2) may use the lower level routine,
`get_or_compute_bloom_filter()`.

Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
---
 bloom.c | 20 +++++++++++++++++++-
 bloom.h | 20 ++++++++++++++++++--
 2 files <a href="http://lore.kernel.org/git/99ab9cf448eea65db1a561a79223fe70073d1be0.1719333276.git.me@ttaylorr.com/#related">changed</a>, 37 insertions(+), 3 deletions(-)

<span
class="head">diff --git a/bloom.c b/bloom.c
index e64e53bc4c..c24489dbcf 100644
--- a/bloom.c
+++ b/bloom.c
</span><span
class="hunk">@@ -220,6 +220,23 @@ static void init_truncated_large_filter(struct bloom_filter *filter,
</span> 	filter-&gt;version = version;
 }
 
<span
class="add">+struct bloom_filter *get_bloom_filter(struct repository *r, struct commit *c)
+{
+	struct bloom_filter *filter;
+	int hash_version;
+
+	filter = get_or_compute_bloom_filter(r, c, 0, NULL, NULL);
+	if (!filter)
+		return NULL;
+
+	prepare_repo_settings(r);
+	hash_version = r-&gt;settings.commit_graph_changed_paths_version;
+
+	if (!(hash_version == -1 || hash_version == filter-&gt;version))
+		return NULL; /* unusable filter */
+	return filter;
+}
+
</span> struct bloom_filter *get_or_compute_bloom_filter(struct repository *r,
 						 struct commit *c,
 						 int compute_if_not_present,
<span
class="hunk">@@ -245,7 +262,8 @@ struct bloom_filter *get_or_compute_bloom_filter(struct repository *r,
</span> 						     filter, graph_pos);
 	}
 
<span
class="del">-	if (filter-&gt;data &#38;&#38; filter-&gt;len)
</span><span
class="add">+	if ((filter-&gt;data &#38;&#38; filter-&gt;len) &#38;&#38;
+	    (!settings || settings-&gt;hash_version == filter-&gt;version))
</span> 		return filter;
 	if (!compute_if_not_present)
 		return NULL;
<span
class="head">diff --git a/bloom.h b/bloom.h
index c9dd7d4022..052a993aab 100644
--- a/bloom.h
+++ b/bloom.h
</span><span
class="hunk">@@ -108,8 +108,24 @@ struct bloom_filter *get_or_compute_bloom_filter(struct repository *r,
</span> 						 const struct bloom_filter_settings *settings,
 						 enum bloom_filter_computed *computed);
 
<span
class="del">-#define get_bloom_filter(r, c) get_or_compute_bloom_filter( \
-	(r), (c), 0, NULL, NULL)
</span><span
class="add">+/*
+ * Find the Bloom filter associated with the given commit &#34;c&#34;.
+ *
+ * If any of the following are true
+ *
+ *   - the repository does not have a commit-graph, or
+ *   - the repository disables reading from the commit-graph, or
+ *   - the given commit does not have a Bloom filter computed, or
+ *   - there is a Bloom filter for commit &#34;c&#34;, but it cannot be read
+ *     because the filter uses an incompatible version of murmur3
+ *
+ * , then `get_bloom_filter()` will return NULL. Otherwise, the corresponding
+ * Bloom filter will be returned.
+ *
+ * For callers who wish to inspect Bloom filters with incompatible hash
+ * versions, use get_or_compute_bloom_filter().
+ */
+struct bloom_filter *get_bloom_filter(struct repository *r, struct commit *c);
</span> 
 int bloom_filter_contains(const struct bloom_filter *filter,
 			  const struct bloom_key *key,
-- 
2.45.2.664.g446e6a2b1f

</pre></div></content></entry><entry><author><name>Taylor Blau</name><email>me@ttaylorr.com</email></author><title>[PATCH v7 10/16] bloom: annotate filters with hash version</title><updated>2024-06-25T17:39:58Z</updated><link
href="http://lore.kernel.org/git/ce3a15a517aa74c77e68096499368a2dc9e5587d.1719333276.git.me@ttaylorr.com/"/><id>urn:uuid:d04cf513-c240-5a16-9dcd-a50731cf4c23</id><thr:in-reply-to
ref="urn:uuid:b4e800cd-74de-d366-63d4-707b7970e581"
href="http://lore.kernel.org/git/cover.1719333276.git.me@ttaylorr.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">In subsequent commits, we will want to load existing Bloom filters out
of a commit-graph, even when the hash version they were computed with
does not match the value of `commitGraph.changedPathVersion`.

In order to differentiate between the two, add a &#34;version&#34; field to each
Bloom filter.

Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
---
 bloom.c | 11 ++++++++---
 bloom.h |  1 +
 2 files <a href="http://lore.kernel.org/git/ce3a15a517aa74c77e68096499368a2dc9e5587d.1719333276.git.me@ttaylorr.com/#related">changed</a>, 9 insertions(+), 3 deletions(-)

<span
class="head">diff --git a/bloom.c b/bloom.c
index 401999ed3c..e64e53bc4c 100644
--- a/bloom.c
+++ b/bloom.c
</span><span
class="hunk">@@ -88,6 +88,7 @@ int load_bloom_filter_from_graph(struct commit_graph *g,
</span> 	filter-&gt;data = (unsigned char *)(g-&gt;chunk_bloom_data +
 					sizeof(unsigned char) * start_index +
 					BLOOMDATA_CHUNK_HEADER_SIZE);
<span
class="add">+	filter-&gt;version = g-&gt;bloom_filter_settings-&gt;hash_version;
</span> 
 	return 1;
 }
<span
class="hunk">@@ -210,11 +211,13 @@ static int pathmap_cmp(const void *hashmap_cmp_fn_data UNUSED,
</span> 	return strcmp(e1-&gt;path, e2-&gt;path);
 }
 
<span
class="del">-static void init_truncated_large_filter(struct bloom_filter *filter)
</span><span
class="add">+static void init_truncated_large_filter(struct bloom_filter *filter,
+					int version)
</span> {
 	filter-&gt;data = xmalloc(1);
 	filter-&gt;data[0] = 0xFF;
 	filter-&gt;len = 1;
<span
class="add">+	filter-&gt;version = version;
</span> }
 
 struct bloom_filter *get_or_compute_bloom_filter(struct repository *r,
<span
class="hunk">@@ -299,13 +302,15 @@ struct bloom_filter *get_or_compute_bloom_filter(struct repository *r,
</span> 		}
 
 		if (hashmap_get_size(&#38;pathmap) &gt; settings-&gt;max_changed_paths) {
<span
class="del">-			init_truncated_large_filter(filter);
</span><span
class="add">+			init_truncated_large_filter(filter,
+						    settings-&gt;hash_version);
</span> 			if (computed)
 				*computed |= BLOOM_TRUNC_LARGE;
 			goto cleanup;
 		}
 
 		filter-&gt;len = (hashmap_get_size(&#38;pathmap) * settings-&gt;bits_per_entry + BITS_PER_WORD - 1) / BITS_PER_WORD;
<span
class="add">+		filter-&gt;version = settings-&gt;hash_version;
</span> 		if (!filter-&gt;len) {
 			if (computed)
 				*computed |= BLOOM_TRUNC_EMPTY;
<span
class="hunk">@@ -325,7 +330,7 @@ struct bloom_filter *get_or_compute_bloom_filter(struct repository *r,
</span> 	} else {
 		for (i = 0; i &lt; diff_queued_diff.nr; i++)
 			diff_free_filepair(diff_queued_diff.queue[i]);
<span
class="del">-		init_truncated_large_filter(filter);
</span><span
class="add">+		init_truncated_large_filter(filter, settings-&gt;hash_version);
</span> 
 		if (computed)
 			*computed |= BLOOM_TRUNC_LARGE;
<span
class="head">diff --git a/bloom.h b/bloom.h
index 1e4f612d2c..c9dd7d4022 100644
--- a/bloom.h
+++ b/bloom.h
</span><span
class="hunk">@@ -53,6 +53,7 @@ struct bloom_filter_settings {
</span> struct bloom_filter {
 	unsigned char *data;
 	size_t len;
<span
class="add">+	int version;
</span> };
 
 /*
-- 
2.45.2.664.g446e6a2b1f

</pre></div></content></entry><entry><author><name>Taylor Blau</name><email>me@ttaylorr.com</email></author><title>[PATCH v7 09/16] repo-settings: introduce commitgraph.changedPathsVersion</title><updated>2024-06-25T17:39:53Z</updated><link
href="http://lore.kernel.org/git/60c063ca4aa86e0397b42f2c742f986987490683.1719333276.git.me@ttaylorr.com/"/><id>urn:uuid:9d7f5dc5-9764-e3f2-db3c-8b5a975b3a6c</id><thr:in-reply-to
ref="urn:uuid:b4e800cd-74de-d366-63d4-707b7970e581"
href="http://lore.kernel.org/git/cover.1719333276.git.me@ttaylorr.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">A subsequent commit will introduce another version of the changed-path
filter in the commit graph file. In order to control which version to
write (and read), a config variable is needed.

Therefore, introduce this config variable. For forwards compatibility,
teach Git to not read commit graphs when the config variable
is set to an unsupported version. Because we teach Git this,
commitgraph.readChangedPaths is now redundant, so deprecate it and
define its behavior in terms of the config variable we introduce.

This commit does not change the behavior of writing (Git writes changed
path filters when explicitly instructed regardless of any config
variable), but a subsequent commit will restrict Git such that it will
only write when commitgraph.changedPathsVersion is a recognized value.

Signed-off-by: Jonathan Tan &lt;jonathantanmy@google.com&gt;
Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
---
 Documentation/config/commitgraph.txt | 26 +++++++++++++++++++++++---
 commit-graph.c                       |  5 +++--
 oss-fuzz/fuzz-commit-graph.c         |  2 +-
 repo-settings.c                      |  6 +++++-
 repository.h                         |  2 +-
 5 files <a href="http://lore.kernel.org/git/60c063ca4aa86e0397b42f2c742f986987490683.1719333276.git.me@ttaylorr.com/#related">changed</a>, 33 insertions(+), 8 deletions(-)

<span
class="head">diff --git a/Documentation/config/commitgraph.txt b/Documentation/config/commitgraph.txt
index 30604e4a4c..e68cdededa 100644
--- a/Documentation/config/commitgraph.txt
+++ b/Documentation/config/commitgraph.txt
</span><span
class="hunk">@@ -9,6 +9,26 @@ commitGraph.maxNewFilters::
</span> 	commit-graph write` (c.f., linkgit:git-commit-graph[1]).
 
 commitGraph.readChangedPaths::
<span
class="del">-	If true, then git will use the changed-path Bloom filters in the
-	commit-graph file (if it exists, and they are present). Defaults to
-	true. See linkgit:git-commit-graph[1] for more information.
</span><span
class="add">+	Deprecated. Equivalent to commitGraph.changedPathsVersion=-1 if true, and
+	commitGraph.changedPathsVersion=0 if false. (If commitGraph.changedPathVersion
+	is also set, commitGraph.changedPathsVersion takes precedence.)
+
+commitGraph.changedPathsVersion::
+	Specifies the version of the changed-path Bloom filters that Git will read and
+	write. May be -1, 0 or 1. Note that values greater than 1 may be
+	incompatible with older versions of Git which do not yet understand
+	those versions. Use caution when operating in a mixed-version
+	environment.
++
+Defaults to -1.
++
+If -1, Git will use the version of the changed-path Bloom filters in the
+repository, defaulting to 1 if there are none.
++
+If 0, Git will not read any Bloom filters, and will write version 1 Bloom
+filters when instructed to write.
++
+If 1, Git will only read version 1 Bloom filters, and will write version 1
+Bloom filters.
++
+See linkgit:git-commit-graph[1] for more information.
</span><span
class="head">diff --git a/commit-graph.c b/commit-graph.c
index 3d89febae4..87b07e7b85 100644
--- a/commit-graph.c
+++ b/commit-graph.c
</span><span
class="hunk">@@ -459,7 +459,7 @@ struct commit_graph *parse_commit_graph(struct repo_settings *s,
</span> 			graph-&gt;read_generation_data = 1;
 	}
 
<span
class="del">-	if (s-&gt;commit_graph_read_changed_paths) {
</span><span
class="add">+	if (s-&gt;commit_graph_changed_paths_version) {
</span> 		read_chunk(cf, GRAPH_CHUNKID_BLOOMINDEXES,
 			   graph_read_bloom_index, graph);
 		read_chunk(cf, GRAPH_CHUNKID_BLOOMDATA,
<span
class="hunk">@@ -555,7 +555,8 @@ static void validate_mixed_bloom_settings(struct commit_graph *g)
</span> 		}
 
 		if (g-&gt;bloom_filter_settings-&gt;bits_per_entry != settings-&gt;bits_per_entry ||
<span
class="del">-		    g-&gt;bloom_filter_settings-&gt;num_hashes != settings-&gt;num_hashes) {
</span><span
class="add">+		    g-&gt;bloom_filter_settings-&gt;num_hashes != settings-&gt;num_hashes ||
+		    g-&gt;bloom_filter_settings-&gt;hash_version != settings-&gt;hash_version) {
</span> 			g-&gt;chunk_bloom_indexes = NULL;
 			g-&gt;chunk_bloom_data = NULL;
 			FREE_AND_NULL(g-&gt;bloom_filter_settings);
<span
class="head">diff --git a/oss-fuzz/fuzz-commit-graph.c b/oss-fuzz/fuzz-commit-graph.c
index 75e668a057..c4e555fbe3 100644
--- a/oss-fuzz/fuzz-commit-graph.c
+++ b/oss-fuzz/fuzz-commit-graph.c
</span><span
class="hunk">@@ -21,7 +21,7 @@ int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
</span> 	 */
 	repo_set_hash_algo(the_repository, GIT_HASH_SHA1);
 	the_repository-&gt;settings.commit_graph_generation_version = 2;
<span
class="del">-	the_repository-&gt;settings.commit_graph_read_changed_paths = 1;
</span><span
class="add">+	the_repository-&gt;settings.commit_graph_changed_paths_version = 1;
</span> 	g = parse_commit_graph(&#38;the_repository-&gt;settings, (void *)data, size);
 	repo_clear(the_repository);
 	free_commit_graph(g);
<span
class="head">diff --git a/repo-settings.c b/repo-settings.c
index a0b590bc6c..2b4e68731b 100644
--- a/repo-settings.c
+++ b/repo-settings.c
</span><span
class="hunk">@@ -23,6 +23,7 @@ void prepare_repo_settings(struct repository *r)
</span> 	int value;
 	const char *strval;
 	int manyfiles;
<span
class="add">+	int read_changed_paths;
</span> 
 	if (!r-&gt;gitdir)
 		BUG(&#34;Cannot add settings for uninitialized repository&#34;);
<span
class="hunk">@@ -54,7 +55,10 @@ void prepare_repo_settings(struct repository *r)
</span> 	/* Commit graph config or default, does not cascade (simple) */
 	repo_cfg_bool(r, &#34;core.commitgraph&#34;, &#38;r-&gt;settings.core_commit_graph, 1);
 	repo_cfg_int(r, &#34;commitgraph.generationversion&#34;, &#38;r-&gt;settings.commit_graph_generation_version, 2);
<span
class="del">-	repo_cfg_bool(r, &#34;commitgraph.readchangedpaths&#34;, &#38;r-&gt;settings.commit_graph_read_changed_paths, 1);
</span><span
class="add">+	repo_cfg_bool(r, &#34;commitgraph.readchangedpaths&#34;, &#38;read_changed_paths, 1);
+	repo_cfg_int(r, &#34;commitgraph.changedpathsversion&#34;,
+		     &#38;r-&gt;settings.commit_graph_changed_paths_version,
+		     read_changed_paths ? -1 : 0);
</span> 	repo_cfg_bool(r, &#34;gc.writecommitgraph&#34;, &#38;r-&gt;settings.gc_write_commit_graph, 1);
 	repo_cfg_bool(r, &#34;fetch.writecommitgraph&#34;, &#38;r-&gt;settings.fetch_write_commit_graph, 0);
 
<span
class="head">diff --git a/repository.h b/repository.h
index a35cd77c35..bd7a408013 100644
--- a/repository.h
+++ b/repository.h
</span><span
class="hunk">@@ -32,7 +32,7 @@ struct repo_settings {
</span> 
 	int core_commit_graph;
 	int commit_graph_generation_version;
<span
class="del">-	int commit_graph_read_changed_paths;
</span><span
class="add">+	int commit_graph_changed_paths_version;
</span> 	int gc_write_commit_graph;
 	int fetch_write_commit_graph;
 	int command_requires_full_index;
-- 
2.45.2.664.g446e6a2b1f

</pre></div></content></entry><entry><author><name>Taylor Blau</name><email>me@ttaylorr.com</email></author><title>[PATCH v7 08/16] t4216: test changed path filters with high bit paths</title><updated>2024-06-25T17:39:50Z</updated><link
href="http://lore.kernel.org/git/fbcaa686b1088544f22c883fe4437a6645d6619d.1719333276.git.me@ttaylorr.com/"/><id>urn:uuid:85a288cd-8cff-6ad4-995f-26f9f1b3e12e</id><thr:in-reply-to
ref="urn:uuid:b4e800cd-74de-d366-63d4-707b7970e581"
href="http://lore.kernel.org/git/cover.1719333276.git.me@ttaylorr.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Subsequent commits will teach Git another version of changed path
filter that has different behavior with paths that contain at least
one character with its high bit set, so test the existing behavior as
a baseline.

Signed-off-by: Jonathan Tan &lt;jonathantanmy@google.com&gt;
Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
---
 t/t4216-log-bloom.sh | 51 ++++++++++++++++++++++++++++++++++++++++++++
 1 file <a href="http://lore.kernel.org/git/fbcaa686b1088544f22c883fe4437a6645d6619d.1719333276.git.me@ttaylorr.com/#related">changed</a>, 51 insertions(+)

<span
class="head">diff --git a/t/t4216-log-bloom.sh b/t/t4216-log-bloom.sh
index c1977961d0..49d1113171 100755
--- a/t/t4216-log-bloom.sh
+++ b/t/t4216-log-bloom.sh
</span><span
class="hunk">@@ -488,6 +488,57 @@ test_expect_success &#39;merge graph layers with incompatible Bloom settings&#39; &#39;
</span> 	test_must_be_empty err
 &#39;
 
<span
class="add">+get_first_changed_path_filter () {
+	test-tool read-graph bloom-filters &gt;filters.dat &#38;&#38;
+	head -n 1 filters.dat
+}
+
+# chosen to be the same under all Unicode normalization forms
+CENT=$(printf &#34;\302\242&#34;)
+
+test_expect_success &#39;set up repo with high bit path, version 1 changed-path&#39; &#39;
+	git init highbit1 &#38;&#38;
+	test_commit -C highbit1 c1 &#34;$CENT&#34; &#38;&#38;
+	git -C highbit1 commit-graph write --reachable --changed-paths
+&#39;
+
+test_expect_success &#39;setup check value of version 1 changed-path&#39; &#39;
+	(
+		cd highbit1 &#38;&#38;
+		echo &#34;52a9&#34; &gt;expect &#38;&#38;
+		get_first_changed_path_filter &gt;actual
+	)
+&#39;
+
+# expect will not match actual if char is unsigned by default. Write the test
+# in this way, so that a user running this test script can still see if the two
+# files match. (It will appear as an ordinary success if they match, and a skip
+# if not.)
+if test_cmp highbit1/expect highbit1/actual
+then
+	test_set_prereq SIGNED_CHAR_BY_DEFAULT
+fi
+test_expect_success SIGNED_CHAR_BY_DEFAULT &#39;check value of version 1 changed-path&#39; &#39;
+	# Only the prereq matters for this test.
+	true
+&#39;
+
+test_expect_success &#39;setup make another commit&#39; &#39;
+	# &#34;git log&#34; does not use Bloom filters for root commits - see how, in
+	# revision.c, rev_compare_tree() (the only code path that eventually calls
+	# get_bloom_filter()) is only called by try_to_simplify_commit() when the commit
+	# has one parent. Therefore, make another commit so that we perform the tests on
+	# a non-root commit.
+	test_commit -C highbit1 anotherc1 &#34;another$CENT&#34;
+&#39;
+
+test_expect_success &#39;version 1 changed-path used when version 1 requested&#39; &#39;
+	(
+		cd highbit1 &#38;&#38;
+		test_bloom_filters_used &#34;-- another$CENT&#34;
+	)
+&#39;
+
</span> corrupt_graph () {
 	test_when_finished &#34;rm -rf $graph&#34; &#38;&#38;
 	git commit-graph write --reachable --changed-paths &#38;&#38;
-- 
2.45.2.664.g446e6a2b1f

</pre></div></content></entry><entry><author><name>Taylor Blau</name><email>me@ttaylorr.com</email></author><title>[PATCH v7 07/16] t/helper/test-read-graph: implement `bloom-filters` mode</title><updated>2024-06-25T17:39:47Z</updated><link
href="http://lore.kernel.org/git/0dfd1a361e93bb4eab672f94f9447b99f63fc4c0.1719333276.git.me@ttaylorr.com/"/><id>urn:uuid:6bd841c9-d177-e5c1-e534-481eb5bd6d87</id><thr:in-reply-to
ref="urn:uuid:b4e800cd-74de-d366-63d4-707b7970e581"
href="http://lore.kernel.org/git/cover.1719333276.git.me@ttaylorr.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Implement a mode of the &#34;read-graph&#34; test helper to dump out the
hexadecimal contents of the Bloom filter(s) contained in a commit-graph.

Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
Signed-off-by: Jonathan Tan &lt;jonathantanmy@google.com&gt;
Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
---
 t/helper/test-read-graph.c | 44 +++++++++++++++++++++++++++++++++-----
 1 file <a href="http://lore.kernel.org/git/0dfd1a361e93bb4eab672f94f9447b99f63fc4c0.1719333276.git.me@ttaylorr.com/#related">changed</a>, 39 insertions(+), 5 deletions(-)

<span
class="head">diff --git a/t/helper/test-read-graph.c b/t/helper/test-read-graph.c
index 3375392f6c..da9ac8584d 100644
--- a/t/helper/test-read-graph.c
+++ b/t/helper/test-read-graph.c
</span><span
class="hunk">@@ -47,10 +47,32 @@ static void dump_graph_info(struct commit_graph *graph)
</span> 	printf(&#34;\n&#34;);
 }
 
<span
class="del">-int cmd__read_graph(int argc UNUSED, const char **argv UNUSED)
</span><span
class="add">+static void dump_graph_bloom_filters(struct commit_graph *graph)
+{
+	uint32_t i;
+
+	for (i = 0; i &lt; graph-&gt;num_commits + graph-&gt;num_commits_in_base; i++) {
+		struct bloom_filter filter = { 0 };
+		size_t j;
+
+		if (load_bloom_filter_from_graph(graph, &#38;filter, i) &lt; 0) {
+			fprintf(stderr, &#34;missing Bloom filter for graph &#34;
+				&#34;position %&#34;PRIu32&#34;\n&#34;, i);
+			continue;
+		}
+
+		for (j = 0; j &lt; filter.len; j++)
+			printf(&#34;%02x&#34;, filter.data[j]);
+		if (filter.len)
+			printf(&#34;\n&#34;);
+	}
+}
+
+int cmd__read_graph(int argc, const char **argv)
</span> {
 	struct commit_graph *graph = NULL;
 	struct object_directory *odb;
<span
class="add">+	int ret = 0;
</span> 
 	setup_git_directory();
 	odb = the_repository-&gt;objects-&gt;odb;
<span
class="hunk">@@ -58,12 +80,24 @@ int cmd__read_graph(int argc UNUSED, const char **argv UNUSED)
</span> 	prepare_repo_settings(the_repository);
 
 	graph = read_commit_graph_one(the_repository, odb);
<span
class="del">-	if (!graph)
-		return 1;
</span><span
class="add">+	if (!graph) {
+		ret = 1;
+		goto done;
+	}
</span> 
<span
class="del">-	dump_graph_info(graph);
</span><span
class="add">+	if (argc &lt;= 1)
+		dump_graph_info(graph);
+	else if (!strcmp(argv[1], &#34;bloom-filters&#34;))
+		dump_graph_bloom_filters(graph);
+	else {
+		fprintf(stderr, &#34;unknown sub-command: &#39;%s&#39;\n&#34;, argv[1]);
+		ret = 1;
+	}
</span> 
<span
class="add">+done:
</span> 	UNLEAK(graph);
 
<span
class="del">-	return 0;
</span><span
class="add">+	return ret;
</span> }
<span
class="add">+
+
</span>-- 
2.45.2.664.g446e6a2b1f

</pre></div></content></entry><entry><author><name>Taylor Blau</name><email>me@ttaylorr.com</email></author><title>[PATCH v7 06/16] bloom.h: make `load_bloom_filter_from_graph()` public</title><updated>2024-06-25T17:39:44Z</updated><link
href="http://lore.kernel.org/git/ae74fbad3e1b076c97de748f72c61a6521a27391.1719333276.git.me@ttaylorr.com/"/><id>urn:uuid:649274f2-2889-abb6-6de9-d7b08edb7dcc</id><thr:in-reply-to
ref="urn:uuid:b4e800cd-74de-d366-63d4-707b7970e581"
href="http://lore.kernel.org/git/cover.1719333276.git.me@ttaylorr.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Prepare for a future commit to use the load_bloom_filter_from_graph()
function directly to load specific Bloom filters out of the commit-graph
for manual inspection (to be used during tests).

Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
Signed-off-by: Jonathan Tan &lt;jonathantanmy@google.com&gt;
Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
---
 bloom.c | 6 +++---
 bloom.h | 5 +++++
 2 files <a href="http://lore.kernel.org/git/ae74fbad3e1b076c97de748f72c61a6521a27391.1719333276.git.me@ttaylorr.com/#related">changed</a>, 8 insertions(+), 3 deletions(-)

<span
class="head">diff --git a/bloom.c b/bloom.c
index e529f7605c..401999ed3c 100644
--- a/bloom.c
+++ b/bloom.c
</span><span
class="hunk">@@ -48,9 +48,9 @@ static int check_bloom_offset(struct commit_graph *g, uint32_t pos,
</span> 	return -1;
 }
 
<span
class="del">-static int load_bloom_filter_from_graph(struct commit_graph *g,
-					struct bloom_filter *filter,
-					uint32_t graph_pos)
</span><span
class="add">+int load_bloom_filter_from_graph(struct commit_graph *g,
+				 struct bloom_filter *filter,
+				 uint32_t graph_pos)
</span> {
 	uint32_t lex_pos, start_index, end_index;
 
<span
class="head">diff --git a/bloom.h b/bloom.h
index adde6dfe21..1e4f612d2c 100644
--- a/bloom.h
+++ b/bloom.h
</span><span
class="hunk">@@ -3,6 +3,7 @@
</span> 
 struct commit;
 struct repository;
<span
class="add">+struct commit_graph;
</span> 
 struct bloom_filter_settings {
 	/*
<span
class="hunk">@@ -68,6 +69,10 @@ struct bloom_key {
</span> 	uint32_t *hashes;
 };
 
<span
class="add">+int load_bloom_filter_from_graph(struct commit_graph *g,
+				 struct bloom_filter *filter,
+				 uint32_t graph_pos);
+
</span> /*
  * Calculate the murmur3 32-bit hash value for the given data
  * using the given seed.
-- 
2.45.2.664.g446e6a2b1f

</pre></div></content></entry><entry><author><name>Taylor Blau</name><email>me@ttaylorr.com</email></author><title>[PATCH v7 05/16] t/helper/test-read-graph.c: extract `dump_graph_info()`</title><updated>2024-06-25T17:39:40Z</updated><link
href="http://lore.kernel.org/git/6e7f317551d31ee38bfb2b8abe8268898158b161.1719333276.git.me@ttaylorr.com/"/><id>urn:uuid:c2662119-d535-5695-d65d-ec24af4c9cee</id><thr:in-reply-to
ref="urn:uuid:b4e800cd-74de-d366-63d4-707b7970e581"
href="http://lore.kernel.org/git/cover.1719333276.git.me@ttaylorr.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Prepare for the &#39;read-graph&#39; test helper to perform other tasks besides
dumping high-level information about the commit-graph by extracting its
main routine into a separate function.

Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
Signed-off-by: Jonathan Tan &lt;jonathantanmy@google.com&gt;
Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
---
 t/helper/test-read-graph.c | 31 ++++++++++++++++++-------------
 1 file <a href="http://lore.kernel.org/git/6e7f317551d31ee38bfb2b8abe8268898158b161.1719333276.git.me@ttaylorr.com/#related">changed</a>, 18 insertions(+), 13 deletions(-)

<span
class="head">diff --git a/t/helper/test-read-graph.c b/t/helper/test-read-graph.c
index 8c7a83f578..3375392f6c 100644
--- a/t/helper/test-read-graph.c
+++ b/t/helper/test-read-graph.c
</span><span
class="hunk">@@ -5,20 +5,8 @@
</span> #include &#34;bloom.h&#34;
 #include &#34;setup.h&#34;
 
<span
class="del">-int cmd__read_graph(int argc UNUSED, const char **argv UNUSED)
</span><span
class="add">+static void dump_graph_info(struct commit_graph *graph)
</span> {
<span
class="del">-	struct commit_graph *graph = NULL;
-	struct object_directory *odb;
-
-	setup_git_directory();
-	odb = the_repository-&gt;objects-&gt;odb;
-
-	prepare_repo_settings(the_repository);
-
-	graph = read_commit_graph_one(the_repository, odb);
-	if (!graph)
-		return 1;
-
</span> 	printf(&#34;header: %08x %d %d %d %d\n&#34;,
 		ntohl(*(uint32_t*)graph-&gt;data),
 		*(unsigned char*)(graph-&gt;data + 4),
<span
class="hunk">@@ -57,6 +45,23 @@ int cmd__read_graph(int argc UNUSED, const char **argv UNUSED)
</span> 	if (graph-&gt;topo_levels)
 		printf(&#34; topo_levels&#34;);
 	printf(&#34;\n&#34;);
<span
class="add">+}
+
+int cmd__read_graph(int argc UNUSED, const char **argv UNUSED)
+{
+	struct commit_graph *graph = NULL;
+	struct object_directory *odb;
+
+	setup_git_directory();
+	odb = the_repository-&gt;objects-&gt;odb;
+
+	prepare_repo_settings(the_repository);
+
+	graph = read_commit_graph_one(the_repository, odb);
+	if (!graph)
+		return 1;
+
+	dump_graph_info(graph);
</span> 
 	UNLEAK(graph);
 
-- 
2.45.2.664.g446e6a2b1f

</pre></div></content></entry><entry><author><name>Taylor Blau</name><email>me@ttaylorr.com</email></author><title>[PATCH v7 04/16] gitformat-commit-graph: describe version 2 of BDAT</title><updated>2024-06-25T17:39:37Z</updated><link
href="http://lore.kernel.org/git/0041600f31d23f149c20a648bbb5cd61561d9488.1719333276.git.me@ttaylorr.com/"/><id>urn:uuid:3a8eee92-e54b-4fd4-104d-f562d244b752</id><thr:in-reply-to
ref="urn:uuid:b4e800cd-74de-d366-63d4-707b7970e581"
href="http://lore.kernel.org/git/cover.1719333276.git.me@ttaylorr.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Jonathan Tan &lt;jonathantanmy@google.com&gt;

The code change to Git to support version 2 will be done in subsequent
commits.

Signed-off-by: Jonathan Tan &lt;jonathantanmy@google.com&gt;
Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
---
 Documentation/gitformat-commit-graph.txt | 9 ++++++---
 1 file <a href="http://lore.kernel.org/git/0041600f31d23f149c20a648bbb5cd61561d9488.1719333276.git.me@ttaylorr.com/#related">changed</a>, 6 insertions(+), 3 deletions(-)

<span
class="head">diff --git a/Documentation/gitformat-commit-graph.txt b/Documentation/gitformat-commit-graph.txt
index 31cad585e2..3e906e8030 100644
--- a/Documentation/gitformat-commit-graph.txt
+++ b/Documentation/gitformat-commit-graph.txt
</span><span
class="hunk">@@ -142,13 +142,16 @@ All multi-byte numbers are in network byte order.
</span> 
 ==== Bloom Filter Data (ID: {&#39;B&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;}) [Optional]
     * It starts with header consisting of three unsigned 32-bit integers:
<span
class="del">-      - Version of the hash algorithm being used. We currently only support
-	value 1 which corresponds to the 32-bit version of the murmur3 hash
</span><span
class="add">+      - Version of the hash algorithm being used. We currently support
+	value 2 which corresponds to the 32-bit version of the murmur3 hash
</span> 	implemented exactly as described in
 	<a
href="https://en.wikipedia.org/wiki/MurmurHash#Algorithm">https://en.wikipedia.org/wiki/MurmurHash#Algorithm</a> and the double
 	hashing technique using seed values 0x293ae76f and 0x7e646e2 as
 	described in <a
href="https://doi.org/10.1007/978-3-540-30494-4_26">https://doi.org/10.1007/978-3-540-30494-4_26</a> &#34;Bloom Filters
<span
class="del">-	in Probabilistic Verification&#34;
</span><span
class="add">+	in Probabilistic Verification&#34;. Version 1 Bloom filters have a bug that appears
+	when char is signed and the repository has path names that have characters &gt;=
+	0x80; Git supports reading and writing them, but this ability will be removed
+	in a future version of Git.
</span>       - The number of times a path is hashed and hence the number of bit positions
 	      that cumulatively determine whether a file is present in the commit.
       - The minimum number of bits &#39;b&#39; per entry in the Bloom filter. If the filter
-- 
2.45.2.664.g446e6a2b1f

</pre></div></content></entry><entry><author><name>Taylor Blau</name><email>me@ttaylorr.com</email></author><title>[PATCH v7 03/16] commit-graph: ensure Bloom filters are read with consistent settings</title><updated>2024-06-25T17:39:19Z</updated><link
href="http://lore.kernel.org/git/f6cf5bfc4eae2945cf2811172ccdb1293d4b0499.1719333276.git.me@ttaylorr.com/"/><id>urn:uuid:2fe8337e-df97-3ff9-3537-1eb1e6869552</id><thr:in-reply-to
ref="urn:uuid:b4e800cd-74de-d366-63d4-707b7970e581"
href="http://lore.kernel.org/git/cover.1719333276.git.me@ttaylorr.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The changed-path Bloom filter mechanism is parameterized by a couple of
variables, notably the number of bits per hash (typically &#34;m&#34; in Bloom
filter literature) and the number of hashes themselves (typically &#34;k&#34;).

It is critically important that filters are read with the Bloom filter
settings that they were written with. Failing to do so would mean that
each query is liable to compute different fingerprints, meaning that the
filter itself could return a false negative. This goes against a basic
assumption of using Bloom filters (that they may return false positives,
but never false negatives) and can lead to incorrect results.

We have some existing logic to carry forward existing Bloom filter
settings from one layer to the next. In `write_commit_graph()`, we have
something like:

    if (!(flags &#38; COMMIT_GRAPH_NO_WRITE_BLOOM_FILTERS)) {
        struct commit_graph *g = ctx-&gt;r-&gt;objects-&gt;commit_graph;

        /* We have changed-paths already. Keep them in the next graph */
        if (g &#38;&#38; g-&gt;chunk_bloom_data) {
            ctx-&gt;changed_paths = 1;
            ctx-&gt;bloom_settings = g-&gt;bloom_filter_settings;
        }
    }

, which drags forward Bloom filter settings across adjacent layers.

This doesn&#39;t quite address all cases, however, since it is possible for
intermediate layers to contain no Bloom filters at all. For example,
suppose we have two layers in a commit-graph chain, say, {G1, G2}. If G1
contains Bloom filters, but G2 doesn&#39;t, a new G3 (whose base graph is
G2) may be written with arbitrary Bloom filter settings, because we only
check the immediately adjacent layer&#39;s settings for compatibility.

This behavior has existed since the introduction of changed-path Bloom
filters. But in practice, this is not such a big deal, since the only
way up until this point to modify the Bloom filter settings at write
time is with the undocumented environment variables:

  - GIT_TEST_BLOOM_SETTINGS_BITS_PER_ENTRY
  - GIT_TEST_BLOOM_SETTINGS_NUM_HASHES
  - GIT_TEST_BLOOM_SETTINGS_MAX_CHANGED_PATHS

(it is still possible to tweak MAX_CHANGED_PATHS between layers, but
this does not affect reads, so is allowed to differ across multiple
graph layers).

But in future commits, we will introduce another parameter to change the
hash algorithm used to compute Bloom fingerprints itself. This will be
exposed via a configuration setting, making this foot-gun easier to use.

To prevent this potential issue, validate that all layers of a split
commit-graph have compatible settings with the newest layer which
contains Bloom filters.

Reported-by: SZEDER G&#225;bor &lt;szeder.dev@gmail.com&gt;
Original-test-by: SZEDER G&#225;bor &lt;szeder.dev@gmail.com&gt;
Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
---
 commit-graph.c       | 25 ++++++++++++++++
 t/t4216-log-bloom.sh | 68 +++++++++++++++++++++++++++++++++++++++++++-
 2 files <a href="http://lore.kernel.org/git/f6cf5bfc4eae2945cf2811172ccdb1293d4b0499.1719333276.git.me@ttaylorr.com/#related">changed</a>, 92 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/commit-graph.c b/commit-graph.c
index 595a349c56..3d89febae4 100644
--- a/commit-graph.c
+++ b/commit-graph.c
</span><span
class="hunk">@@ -543,6 +543,30 @@ static int validate_mixed_generation_chain(struct commit_graph *g)
</span> 	return 0;
 }
 
<span
class="add">+static void validate_mixed_bloom_settings(struct commit_graph *g)
+{
+	struct bloom_filter_settings *settings = NULL;
+	for (; g; g = g-&gt;base_graph) {
+		if (!g-&gt;bloom_filter_settings)
+			continue;
+		if (!settings) {
+			settings = g-&gt;bloom_filter_settings;
+			continue;
+		}
+
+		if (g-&gt;bloom_filter_settings-&gt;bits_per_entry != settings-&gt;bits_per_entry ||
+		    g-&gt;bloom_filter_settings-&gt;num_hashes != settings-&gt;num_hashes) {
+			g-&gt;chunk_bloom_indexes = NULL;
+			g-&gt;chunk_bloom_data = NULL;
+			FREE_AND_NULL(g-&gt;bloom_filter_settings);
+
+			warning(_(&#34;disabling Bloom filters for commit-graph &#34;
+				  &#34;layer &#39;%s&#39; due to incompatible settings&#34;),
+				oid_to_hex(&#38;g-&gt;oid));
+		}
+	}
+}
+
</span> static int add_graph_to_chain(struct commit_graph *g,
 			      struct commit_graph *chain,
 			      struct object_id *oids,
<span
class="hunk">@@ -666,6 +690,7 @@ struct commit_graph *load_commit_graph_chain_fd_st(struct repository *r,
</span> 	}
 
 	validate_mixed_generation_chain(graph_chain);
<span
class="add">+	validate_mixed_bloom_settings(graph_chain);
</span> 
 	free(oids);
 	fclose(fp);
<span
class="head">diff --git a/t/t4216-log-bloom.sh b/t/t4216-log-bloom.sh
index cc6ebc8140..c1977961d0 100755
--- a/t/t4216-log-bloom.sh
+++ b/t/t4216-log-bloom.sh
</span><span
class="hunk">@@ -421,8 +421,74 @@ test_expect_success &#39;Bloom generation backfills empty commits&#39; &#39;
</span> 	)
 &#39;
 
<span
class="add">+graph=.git/objects/info/commit-graph
+graphdir=.git/objects/info/commit-graphs
+chain=$graphdir/commit-graph-chain
+
+test_expect_success &#39;setup for mixed Bloom setting tests&#39; &#39;
+	repo=mixed-bloom-settings &#38;&#38;
+
+	git init $repo &#38;&#38;
+	for i in one two three
+	do
+		test_commit -C $repo $i file || return 1
+	done
+&#39;
+
+test_expect_success &#39;ensure Bloom filters with incompatible settings are ignored&#39; &#39;
+	# Compute Bloom filters with &#34;unusual&#34; settings.
+	git -C $repo rev-parse one &gt;in &#38;&#38;
+	GIT_TEST_BLOOM_SETTINGS_NUM_HASHES=3 git -C $repo commit-graph write \
+		--stdin-commits --changed-paths --split &lt;in &#38;&#38;
+	layer=$(head -n 1 $repo/$chain) &#38;&#38;
+
+	# A commit-graph layer without Bloom filters &#34;hides&#34; the layers
+	# below ...
+	git -C $repo rev-parse two &gt;in &#38;&#38;
+	git -C $repo commit-graph write --stdin-commits --no-changed-paths \
+		--split=no-merge &lt;in &#38;&#38;
+
+	# Another commit-graph layer that has Bloom filters, but with
+	# standard settings, and is thus incompatible with the base
+	# layer written above.
+	git -C $repo rev-parse HEAD &gt;in &#38;&#38;
+	git -C $repo commit-graph write --stdin-commits --changed-paths \
+		--split=no-merge &lt;in &#38;&#38;
+
+	test_line_count = 3 $repo/$chain &#38;&#38;
+
+	# Ensure that incompatible Bloom filters are ignored.
+	git -C $repo -c core.commitGraph=false log --oneline --no-decorate -- file \
+		&gt;expect 2&gt;err &#38;&#38;
+	git -C $repo log --oneline --no-decorate -- file &gt;actual 2&gt;err &#38;&#38;
+	test_cmp expect actual &#38;&#38;
+	grep &#34;disabling Bloom filters for commit-graph layer .$layer.&#34; err
+&#39;
+
+test_expect_success &#39;merge graph layers with incompatible Bloom settings&#39; &#39;
+	# Ensure that incompatible Bloom filters are ignored when
+	# merging existing layers.
+	&gt;trace2.txt &#38;&#38;
+	GIT_TRACE2_EVENT=&#34;$(pwd)/trace2.txt&#34; \
+		git -C $repo commit-graph write --reachable --changed-paths 2&gt;err &#38;&#38;
+	grep &#34;disabling Bloom filters for commit-graph layer .$layer.&#34; err &#38;&#38;
+	grep &#34;{\&#34;hash_version\&#34;:1,\&#34;num_hashes\&#34;:7,\&#34;bits_per_entry\&#34;:10,\&#34;max_changed_paths\&#34;:512&#34; trace2.txt &#38;&#38;
+
+	test_path_is_file $repo/$graph &#38;&#38;
+	test_dir_is_empty $repo/$graphdir &#38;&#38;
+
+	git -C $repo -c core.commitGraph=false log --oneline --no-decorate -- \
+		file &gt;expect &#38;&#38;
+	trace_out=&#34;$(pwd)/trace.perf&#34; &#38;&#38;
+	GIT_TRACE2_PERF=&#34;$trace_out&#34; \
+		git -C $repo log --oneline --no-decorate -- file &gt;actual 2&gt;err &#38;&#38;
+
+	test_cmp expect actual &#38;&#38;
+	grep &#34;statistics:{\&#34;filter_not_present\&#34;:0,&#34; trace.perf &#38;&#38;
+	test_must_be_empty err
+&#39;
+
</span> corrupt_graph () {
<span
class="del">-	graph=.git/objects/info/commit-graph &#38;&#38;
</span> 	test_when_finished &#34;rm -rf $graph&#34; &#38;&#38;
 	git commit-graph write --reachable --changed-paths &#38;&#38;
 	corrupt_chunk_file $graph &#34;$@&#34;
-- 
2.45.2.664.g446e6a2b1f

</pre></div></content></entry><entry><author><name>Taylor Blau</name><email>me@ttaylorr.com</email></author><title>[PATCH v7 02/16] revision.c: consult Bloom filters for root commits</title><updated>2024-06-25T17:39:16Z</updated><link
href="http://lore.kernel.org/git/5d88ad6c905c040322f360884b756ece83eefa66.1719333276.git.me@ttaylorr.com/"/><id>urn:uuid:39826d0c-410b-cf78-46fd-5a02879aab65</id><thr:in-reply-to
ref="urn:uuid:b4e800cd-74de-d366-63d4-707b7970e581"
href="http://lore.kernel.org/git/cover.1719333276.git.me@ttaylorr.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The commit-graph stores changed-path Bloom filters which represent the
set of paths included in a tree-level diff between a commit&#39;s root tree
and that of its parent.

When a commit has no parents, the tree-diff is computed against that
commit&#39;s root tree and the empty tree. In other words, every path in
that commit&#39;s tree is stored in the Bloom filter (since they all appear
in the diff).

Consult these filters during pathspec-limited traversals in the function
`rev_same_tree_as_empty()`. Doing so yields a performance improvement
where we can avoid enumerating the full set of paths in a parentless
commit&#39;s root tree when we know that the path(s) of interest were not
listed in that commit&#39;s changed-path Bloom filter.

Suggested-by: SZEDER G&#225;bor &lt;szeder.dev@gmail.com&gt;
Original-patch-by: Jonathan Tan &lt;jonathantanmy@google.com&gt;
Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
---
 revision.c           | 26 ++++++++++++++++++++++----
 t/t4216-log-bloom.sh |  8 ++++++--
 2 files <a href="http://lore.kernel.org/git/5d88ad6c905c040322f360884b756ece83eefa66.1719333276.git.me@ttaylorr.com/#related">changed</a>, 28 insertions(+), 6 deletions(-)

<span
class="head">diff --git a/revision.c b/revision.c
index c68deb57ce..6931665b95 100644
--- a/revision.c
+++ b/revision.c
</span><span
class="hunk">@@ -845,17 +845,28 @@ static int rev_compare_tree(struct rev_info *revs,
</span> 	return tree_difference;
 }
 
<span
class="del">-static int rev_same_tree_as_empty(struct rev_info *revs, struct commit *commit)
</span><span
class="add">+static int rev_same_tree_as_empty(struct rev_info *revs, struct commit *commit,
+				  int nth_parent)
</span> {
 	struct tree *t1 = repo_get_commit_tree(the_repository, commit);
<span
class="add">+	int bloom_ret = -1;
</span> 
 	if (!t1)
 		return 0;
 
<span
class="add">+	if (!nth_parent &#38;&#38; revs-&gt;bloom_keys_nr) {
+		bloom_ret = check_maybe_different_in_bloom_filter(revs, commit);
+		if (!bloom_ret)
+			return 1;
+	}
+
</span> 	tree_difference = REV_TREE_SAME;
 	revs-&gt;pruning.flags.has_changes = 0;
 	diff_tree_oid(NULL, &#38;t1-&gt;object.oid, &#34;&#34;, &#38;revs-&gt;pruning);
 
<span
class="add">+	if (bloom_ret == 1 &#38;&#38; tree_difference == REV_TREE_SAME)
+		count_bloom_filter_false_positive++;
+
</span> 	return tree_difference == REV_TREE_SAME;
 }
 
<span
class="hunk">@@ -893,7 +904,7 @@ static int compact_treesame(struct rev_info *revs, struct commit *commit, unsign
</span> 		if (nth_parent != 0)
 			die(&#34;compact_treesame %u&#34;, nth_parent);
 		old_same = !!(commit-&gt;object.flags &#38; TREESAME);
<span
class="del">-		if (rev_same_tree_as_empty(revs, commit))
</span><span
class="add">+		if (rev_same_tree_as_empty(revs, commit, nth_parent))
</span> 			commit-&gt;object.flags |= TREESAME;
 		else
 			commit-&gt;object.flags &#38;= ~TREESAME;
<span
class="hunk">@@ -989,7 +1000,14 @@ static void try_to_simplify_commit(struct rev_info *revs, struct commit *commit)
</span> 		return;
 
 	if (!commit-&gt;parents) {
<span
class="del">-		if (rev_same_tree_as_empty(revs, commit))
</span><span
class="add">+		/*
+		 * Pretend as if we are comparing ourselves to the
+		 * (non-existent) first parent of this commit object. Even
+		 * though no such parent exists, its changed-path Bloom filter
+		 * (if one exists) is relative to the empty tree, using Bloom
+		 * filters is allowed here.
+		 */
+		if (rev_same_tree_as_empty(revs, commit, 0))
</span> 			commit-&gt;object.flags |= TREESAME;
 		return;
 	}
<span
class="hunk">@@ -1070,7 +1088,7 @@ static void try_to_simplify_commit(struct rev_info *revs, struct commit *commit)
</span> 
 		case REV_TREE_NEW:
 			if (revs-&gt;remove_empty_trees &#38;&#38;
<span
class="del">-			    rev_same_tree_as_empty(revs, p)) {
</span><span
class="add">+			    rev_same_tree_as_empty(revs, p, nth_parent)) {
</span> 				/* We are adding all the specified
 				 * paths from this parent, so the
 				 * history beyond this parent is not
<span
class="head">diff --git a/t/t4216-log-bloom.sh b/t/t4216-log-bloom.sh
index b7baf49d62..cc6ebc8140 100755
--- a/t/t4216-log-bloom.sh
+++ b/t/t4216-log-bloom.sh
</span><span
class="hunk">@@ -88,7 +88,11 @@ test_bloom_filters_not_used () {
</span> 		# if the Bloom filter system is initialized, ensure that no
 		# filters were used
 		data=&#34;statistics:{&#34;
<span
class="del">-		data=&#34;$data\&#34;filter_not_present\&#34;:0,&#34;
</span><span
class="add">+		# unusable filters (e.g., those computed with a
+		# different value of commitGraph.changedPathsVersion)
+		# are counted in the filter_not_present bucket, so any
+		# value is OK there.
+		data=&#34;$data\&#34;filter_not_present\&#34;:[0-9][0-9]*,&#34;
</span> 		data=&#34;$data\&#34;maybe\&#34;:0,&#34;
 		data=&#34;$data\&#34;definitely_not\&#34;:0,&#34;
 		data=&#34;$data\&#34;false_positive\&#34;:0}&#34;
<span
class="hunk">@@ -175,7 +179,7 @@ test_expect_success &#39;setup - add commit-graph to the chain with Bloom filters&#39; &#39;
</span> 
 test_bloom_filters_used_when_some_filters_are_missing () {
 	log_args=$1
<span
class="del">-	bloom_trace_prefix=&#34;statistics:{\&#34;filter_not_present\&#34;:3,\&#34;maybe\&#34;:6,\&#34;definitely_not\&#34;:9&#34;
</span><span
class="add">+	bloom_trace_prefix=&#34;statistics:{\&#34;filter_not_present\&#34;:3,\&#34;maybe\&#34;:6,\&#34;definitely_not\&#34;:10&#34;
</span> 	setup &#34;$log_args&#34; &#38;&#38;
 	grep -q &#34;$bloom_trace_prefix&#34; &#34;$TRASH_DIRECTORY/trace.perf&#34; &#38;&#38;
 	test_cmp log_wo_bloom log_w_bloom
-- 
2.45.2.664.g446e6a2b1f

</pre></div></content></entry><entry><author><name>Taylor Blau</name><email>me@ttaylorr.com</email></author><title>[PATCH v7 01/16] t/t4216-log-bloom.sh: harden `test_bloom_filters_not_used()`</title><updated>2024-06-25T17:39:12Z</updated><link
href="http://lore.kernel.org/git/ee651fee33d5788295ae8ca785d5a283c92481e7.1719333276.git.me@ttaylorr.com/"/><id>urn:uuid:4d179bfd-ff15-5213-7033-ccf97d38fb42</id><thr:in-reply-to
ref="urn:uuid:b4e800cd-74de-d366-63d4-707b7970e581"
href="http://lore.kernel.org/git/cover.1719333276.git.me@ttaylorr.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The existing implementation of test_bloom_filters_not_used() asserts
that the Bloom filter sub-system has not been initialized at all, by
checking for the absence of any data from it from trace2.

In the following commit, it will become possible to load Bloom filters
without using them (e.g., because the `commitGraph.changedPathVersion`
introduced later in this series is incompatible with the hash version
with which the commit-graph&#39;s Bloom filters were written).

When this is the case, it&#39;s possible to initialize the Bloom filter
sub-system, while still not using any Bloom filters. When this is the
case, check that the data dump from the Bloom sub-system is all zeros,
indicating that no filters were used.

Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
---
 t/t4216-log-bloom.sh | 14 +++++++++++++-
 1 file <a href="http://lore.kernel.org/git/ee651fee33d5788295ae8ca785d5a283c92481e7.1719333276.git.me@ttaylorr.com/#related">changed</a>, 13 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/t/t4216-log-bloom.sh b/t/t4216-log-bloom.sh
index 2ba0324a69..b7baf49d62 100755
--- a/t/t4216-log-bloom.sh
+++ b/t/t4216-log-bloom.sh
</span><span
class="hunk">@@ -82,7 +82,19 @@ test_bloom_filters_used () {
</span> test_bloom_filters_not_used () {
 	log_args=$1
 	setup &#34;$log_args&#34; &#38;&#38;
<span
class="del">-	! grep -q &#34;statistics:{\&#34;filter_not_present\&#34;:&#34; &#34;$TRASH_DIRECTORY/trace.perf&#34; &#38;&#38;
</span><span
class="add">+
+	if grep -q &#34;statistics:{\&#34;filter_not_present\&#34;:&#34; &#34;$TRASH_DIRECTORY/trace.perf&#34;
+	then
+		# if the Bloom filter system is initialized, ensure that no
+		# filters were used
+		data=&#34;statistics:{&#34;
+		data=&#34;$data\&#34;filter_not_present\&#34;:0,&#34;
+		data=&#34;$data\&#34;maybe\&#34;:0,&#34;
+		data=&#34;$data\&#34;definitely_not\&#34;:0,&#34;
+		data=&#34;$data\&#34;false_positive\&#34;:0}&#34;
+
+		grep -q &#34;$data&#34; &#34;$TRASH_DIRECTORY/trace.perf&#34;
+	fi &#38;&#38;
</span> 	test_cmp log_wo_bloom log_w_bloom
 }
 
-- 
2.45.2.664.g446e6a2b1f

</pre></div></content></entry><entry><author><name>Taylor Blau</name><email>me@ttaylorr.com</email></author><title
type="html">[PATCH v7 00/16] bloom: changed-path Bloom filters v2 (&#38; sundries)</title><updated>2024-06-25T17:39:08Z</updated><link
href="http://lore.kernel.org/git/cover.1719333276.git.me@ttaylorr.com/"/><id>urn:uuid:b4e800cd-74de-d366-63d4-707b7970e581</id><thr:in-reply-to
ref="urn:uuid:d31bf1d9-7267-e588-bbfc-6e76ea4e9933"
href="http://lore.kernel.org/git/cover.1706741516.git.me@ttaylorr.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">(Rebased onto the tip of &#39;master&#39;, which is now 1e1586e4ed (The
sixteenth batch, 2024-06-24) at the time of writing).

This series is another minor reroll of the combined efforts of [1] and
[2] to introduce the v2 changed-path Bloom filters, which fixes a bug in
our existing implementation of murmur3 paths with non-ASCII characters
(when the &#34;char&#34; type is signed).

This version addresses the remaining comments from SZEDER around more
thorough testing of merging commit-graph layers with incompatible Bloom
filters versions, and ensuring the result is as expected.

Thanks again to Jonathan, Peff, and SZEDER who have helped a great deal
in assembling these patches. As usual, a range-diff is included below.

Thanks in advance for your review!

[1]: <a
href="https://lore.kernel.org/git/cover.1684790529.git.jonathantanmy@google.com/">https://lore.kernel.org/git/cover.1684790529.git.jonathantanmy@google.com/</a>
[2]: <a
href="https://lore.kernel.org/git/cover.1691426160.git.me@ttaylorr.com/">https://lore.kernel.org/git/cover.1691426160.git.me@ttaylorr.com/</a>

Jonathan Tan (1):
  gitformat-commit-graph: describe version 2 of BDAT

Taylor Blau (15):
  t/t4216-log-bloom.sh: harden `test_bloom_filters_not_used()`
  revision.c: consult Bloom filters for root commits
  commit-graph: ensure Bloom filters are read with consistent settings
  t/helper/test-read-graph.c: extract `dump_graph_info()`
  bloom.h: make `load_bloom_filter_from_graph()` public
  t/helper/test-read-graph: implement `bloom-filters` mode
  t4216: test changed path filters with high bit paths
  repo-settings: introduce commitgraph.changedPathsVersion
  bloom: annotate filters with hash version
  bloom: prepare to discard incompatible Bloom filters
  commit-graph: unconditionally load Bloom filters
  commit-graph: new Bloom filter version that fixes murmur3
  object.h: fix mis-aligned flag bits table
  commit-graph: reuse existing Bloom filters where possible
  bloom: introduce `deinit_bloom_filters()`

 Documentation/config/commitgraph.txt     |  29 +-
 Documentation/gitformat-commit-graph.txt |   9 +-
 bloom.c                                  | 208 ++++++++++++++-
 bloom.h                                  |  38 ++-
 commit-graph.c                           |  64 ++++-
 object.h                                 |   3 +-
 oss-fuzz/fuzz-commit-graph.c             |   2 +-
 repo-settings.c                          |   6 +-
 repository.h                             |   2 +-
 revision.c                               |  26 +-
 t/helper/test-bloom.c                    |   9 +-
 t/helper/test-read-graph.c               |  67 ++++-
 t/t0095-bloom.sh                         |   8 +
 t/t4216-log-bloom.sh                     | 325 ++++++++++++++++++++++-
 14 files changed, 738 insertions(+), 58 deletions(-)

Range-diff against v6:
 1:  9df34a2f4f =  1:  ee651fee33 t/t4216-log-bloom.sh: harden `test_bloom_filters_not_used()`
 2:  a6dc377f1b =  2:  5d88ad6c90 revision.c: consult Bloom filters for root commits
 3:  a77ab941bc !  3:  f6cf5bfc4e commit-graph: ensure Bloom filters are read with consistent settings
    @@ t/t4216-log-bloom.sh: test_expect_success &#39;Bloom generation backfills empty comm
     +test_expect_success &#39;merge graph layers with incompatible Bloom settings&#39; &#39;
     +	# Ensure that incompatible Bloom filters are ignored when
     +	# merging existing layers.
    -+	git -C $repo commit-graph write --reachable --changed-paths 2&gt;err &#38;&#38;
    ++	&gt;trace2.txt &#38;&#38;
    ++	GIT_TRACE2_EVENT=&#34;$(pwd)/trace2.txt&#34; \
    ++		git -C $repo commit-graph write --reachable --changed-paths 2&gt;err &#38;&#38;
     +	grep &#34;disabling Bloom filters for commit-graph layer .$layer.&#34; err &#38;&#38;
    ++	grep &#34;{\&#34;hash_version\&#34;:1,\&#34;num_hashes\&#34;:7,\&#34;bits_per_entry\&#34;:10,\&#34;max_changed_paths\&#34;:512&#34; trace2.txt &#38;&#38;
     +
     +	test_path_is_file $repo/$graph &#38;&#38;
     +	test_dir_is_empty $repo/$graphdir &#38;&#38;
 4:  56a9fdaff0 =  4:  0041600f31 gitformat-commit-graph: describe version 2 of BDAT
 5:  7484a82f7f =  5:  6e7f317551 t/helper/test-read-graph.c: extract `dump_graph_info()`
 6:  48343f93a2 =  6:  ae74fbad3e bloom.h: make `load_bloom_filter_from_graph()` public
 7:  286fd7dcdb =  7:  0dfd1a361e t/helper/test-read-graph: implement `bloom-filters` mode
 8:  7de7b89da0 =  8:  fbcaa686b1 t4216: test changed path filters with high bit paths
 9:  b13c9b8ff9 !  9:  60c063ca4a repo-settings: introduce commitgraph.changedPathsVersion
    @@ commit-graph.c: static void validate_mixed_bloom_settings(struct commit_graph *g
     
      ## oss-fuzz/fuzz-commit-graph.c ##
     @@ oss-fuzz/fuzz-commit-graph.c: int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
    - 	 * possible.
      	 */
    + 	repo_set_hash_algo(the_repository, GIT_HASH_SHA1);
      	the_repository-&gt;settings.commit_graph_generation_version = 2;
     -	the_repository-&gt;settings.commit_graph_read_changed_paths = 1;
     +	the_repository-&gt;settings.commit_graph_changed_paths_version = 1;
10:  09c44c51a5 = 10:  ce3a15a517 bloom: annotate filters with hash version
11:  d4995ef600 = 11:  99ab9cf448 bloom: prepare to discard incompatible Bloom filters
12:  c8e9bb7c88 = 12:  99e66d1dba commit-graph: unconditionally load Bloom filters
13:  d2f11c082d ! 13:  2e945c3d2e commit-graph: new Bloom filter version that fixes murmur3
    @@ commit-graph.c: int write_commit_graph(struct object_directory *odb,
     +	if (r-&gt;settings.commit_graph_changed_paths_version &lt; -1
     +	    || r-&gt;settings.commit_graph_changed_paths_version &gt; 2) {
     +		warning(_(&#34;attempting to write a commit-graph, but &#34;
    -+			  &#34;&#39;commitgraph.changedPathsVersion&#39; (%d) is not supported&#34;),
    ++			  &#34;&#39;commitGraph.changedPathsVersion&#39; (%d) is not supported&#34;),
     +			r-&gt;settings.commit_graph_changed_paths_version);
     +		return 0;
     +	}
    @@ t/t4216-log-bloom.sh: test_expect_success &#39;merge graph layers with incompatible
      	test_must_be_empty err
      &#39;
      
    ++# chosen to be the same under all Unicode normalization forms
    ++CENT=$(printf &#34;\302\242&#34;)
    ++
     +test_expect_success &#39;ensure Bloom filter with incompatible versions are ignored&#39; &#39;
     +	rm &#34;$repo/$graph&#34; &#38;&#38;
     +
    @@ t/t4216-log-bloom.sh: test_expect_success &#39;merge graph layers with incompatible
     +	cat &gt;expect.err &lt;&lt;-EOF &#38;&#38;
     +	warning: disabling Bloom filters for commit-graph layer $SQ$layer$SQ due to incompatible settings
     +	EOF
    -+	test_cmp expect.err err
    ++	test_cmp expect.err err &#38;&#38;
    ++
    ++	# Merge the two layers with incompatible bloom filter versions,
    ++	# ensuring that the v2 filters are used.
    ++	&gt;trace2.txt &#38;&#38;
    ++	GIT_TRACE2_EVENT=&#34;$(pwd)/trace2.txt&#34; \
    ++		git -C $repo -c commitGraph.changedPathsVersion=2 commit-graph write --reachable --changed-paths 2&gt;err &#38;&#38;
    ++	grep &#34;disabling Bloom filters for commit-graph layer .$layer.&#34; err &#38;&#38;
    ++	grep &#34;{\&#34;hash_version\&#34;:2,\&#34;num_hashes\&#34;:7,\&#34;bits_per_entry\&#34;:10,\&#34;max_changed_paths\&#34;:512&#34; trace2.txt
     +&#39;
     +
      get_first_changed_path_filter () {
      	test-tool read-graph bloom-filters &gt;filters.dat &#38;&#38;
      	head -n 1 filters.dat
    + }
    + 
    +-# chosen to be the same under all Unicode normalization forms
    +-CENT=$(printf &#34;\302\242&#34;)
    +-
    + test_expect_success &#39;set up repo with high bit path, version 1 changed-path&#39; &#39;
    + 	git init highbit1 &#38;&#38;
    + 	test_commit -C highbit1 c1 &#34;$CENT&#34; &#38;&#38;
     @@ t/t4216-log-bloom.sh: test_expect_success &#39;version 1 changed-path used when version 1 requested&#39; &#39;
      	)
      &#39;
    @@ t/t4216-log-bloom.sh: test_expect_success &#39;version 1 changed-path used when vers
     +test_expect_success &#39;version 1 changed-path not used when version 2 requested&#39; &#39;
     +	(
     +		cd highbit1 &#38;&#38;
    -+		git config --add commitgraph.changedPathsVersion 2 &#38;&#38;
    ++		git config --add commitGraph.changedPathsVersion 2 &#38;&#38;
     +		test_bloom_filters_not_used &#34;-- another$CENT&#34;
     +	)
     +&#39;
    @@ t/t4216-log-bloom.sh: test_expect_success &#39;version 1 changed-path used when vers
     +test_expect_success &#39;version 1 changed-path used when autodetect requested&#39; &#39;
     +	(
     +		cd highbit1 &#38;&#38;
    -+		git config --add commitgraph.changedPathsVersion -1 &#38;&#38;
    ++		git config --add commitGraph.changedPathsVersion -1 &#38;&#38;
     +		test_bloom_filters_used &#34;-- another$CENT&#34;
     +	)
     +&#39;
    @@ t/t4216-log-bloom.sh: test_expect_success &#39;version 1 changed-path used when vers
     +	git -C highbit1 commit-graph write --reachable --changed-paths &#38;&#38;
     +	(
     +		cd highbit1 &#38;&#38;
    -+		git config --add commitgraph.changedPathsVersion -1 &#38;&#38;
    ++		git config --add commitGraph.changedPathsVersion -1 &#38;&#38;
     +		echo &#34;options: bloom(1,10,7) read_generation_data&#34; &gt;expect &#38;&#38;
     +		test-tool read-graph &gt;full &#38;&#38;
     +		grep options full &gt;actual &#38;&#38;
    @@ t/t4216-log-bloom.sh: test_expect_success &#39;version 1 changed-path used when vers
     +
     +test_expect_success &#39;set up repo with high bit path, version 2 changed-path&#39; &#39;
     +	git init highbit2 &#38;&#38;
    -+	git -C highbit2 config --add commitgraph.changedPathsVersion 2 &#38;&#38;
    ++	git -C highbit2 config --add commitGraph.changedPathsVersion 2 &#38;&#38;
     +	test_commit -C highbit2 c2 &#34;$CENT&#34; &#38;&#38;
     +	git -C highbit2 commit-graph write --reachable --changed-paths
     +&#39;
    @@ t/t4216-log-bloom.sh: test_expect_success &#39;version 1 changed-path used when vers
     +test_expect_success &#39;version 2 changed-path not used when version 1 requested&#39; &#39;
     +	(
     +		cd highbit2 &#38;&#38;
    -+		git config --add commitgraph.changedPathsVersion 1 &#38;&#38;
    ++		git config --add commitGraph.changedPathsVersion 1 &#38;&#38;
     +		test_bloom_filters_not_used &#34;-- another$CENT&#34;
     +	)
     +&#39;
    @@ t/t4216-log-bloom.sh: test_expect_success &#39;version 1 changed-path used when vers
     +test_expect_success &#39;version 2 changed-path used when autodetect requested&#39; &#39;
     +	(
     +		cd highbit2 &#38;&#38;
    -+		git config --add commitgraph.changedPathsVersion -1 &#38;&#38;
    ++		git config --add commitGraph.changedPathsVersion -1 &#38;&#38;
     +		test_bloom_filters_used &#34;-- another$CENT&#34;
     +	)
     +&#39;
    @@ t/t4216-log-bloom.sh: test_expect_success &#39;version 1 changed-path used when vers
     +	git -C highbit2 commit-graph write --reachable --changed-paths &#38;&#38;
     +	(
     +		cd highbit2 &#38;&#38;
    -+		git config --add commitgraph.changedPathsVersion -1 &#38;&#38;
    ++		git config --add commitGraph.changedPathsVersion -1 &#38;&#38;
     +		echo &#34;options: bloom(2,10,7) read_generation_data&#34; &gt;expect &#38;&#38;
     +		test-tool read-graph &gt;full &#38;&#38;
     +		grep options full &gt;actual &#38;&#38;
    @@ t/t4216-log-bloom.sh: test_expect_success &#39;version 1 changed-path used when vers
     +test_expect_success &#39;when writing commit graph, do not reuse changed-path of another version&#39; &#39;
     +	git init doublewrite &#38;&#38;
     +	test_commit -C doublewrite c &#34;$CENT&#34; &#38;&#38;
    -+	git -C doublewrite config --add commitgraph.changedPathsVersion 1 &#38;&#38;
    ++	git -C doublewrite config --add commitGraph.changedPathsVersion 1 &#38;&#38;
     +	git -C doublewrite commit-graph write --reachable --changed-paths &#38;&#38;
     +	for v in -2 3
     +	do
    -+		git -C doublewrite config --add commitgraph.changedPathsVersion $v &#38;&#38;
    ++		git -C doublewrite config --add commitGraph.changedPathsVersion $v &#38;&#38;
     +		git -C doublewrite commit-graph write --reachable --changed-paths 2&gt;err &#38;&#38;
     +		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
    -+		warning: attempting to write a commit-graph, but ${SQ}commitgraph.changedPathsVersion${SQ} ($v) is not supported
    ++		warning: attempting to write a commit-graph, but ${SQ}commitGraph.changedPathsVersion${SQ} ($v) is not supported
     +		EOF
     +		test_cmp expect err || return 1
     +	done &#38;&#38;
    -+	git -C doublewrite config --add commitgraph.changedPathsVersion 2 &#38;&#38;
    ++	git -C doublewrite config --add commitGraph.changedPathsVersion 2 &#38;&#38;
     +	git -C doublewrite commit-graph write --reachable --changed-paths &#38;&#38;
     +	(
     +		cd doublewrite &#38;&#38;
14:  9f54a376fb = 14:  242f023135 object.h: fix mis-aligned flag bits table
15:  67991dea7c ! 15:  1b80023e57 commit-graph: reuse existing Bloom filters where possible
    @@ bloom.c: static void init_truncated_large_filter(struct bloom_filter *filter,
     +		struct tree_desc desc;
     +		struct name_entry entry;
     +
    -+		init_tree_desc(&#38;desc, t-&gt;buffer, t-&gt;size);
    ++		init_tree_desc(&#38;desc, &#38;t-&gt;object.oid, t-&gt;buffer, t-&gt;size);
     +		while (tree_entry(&#38;desc, &#38;entry)) {
     +			size_t i;
     +			for (i = 0; i &lt; entry.pathlen; i++) {
    @@ t/t4216-log-bloom.sh: test_expect_success &#39;when writing another commit graph, pr
      	git init doublewrite &#38;&#38;
      	test_commit -C doublewrite c &#34;$CENT&#34; &#38;&#38;
     +
    - 	git -C doublewrite config --add commitgraph.changedPathsVersion 1 &#38;&#38;
    + 	git -C doublewrite config --add commitGraph.changedPathsVersion 1 &#38;&#38;
    ++	&gt;trace2.txt &#38;&#38;
     +	GIT_TRACE2_EVENT=&#34;$(pwd)/trace2.txt&#34; \
     +		git -C doublewrite commit-graph write --reachable --changed-paths &#38;&#38;
     +	test_filter_computed 1 trace2.txt &#38;&#38;
    @@ t/t4216-log-bloom.sh: test_expect_success &#39;when writing commit graph, do not reu
      		test_cmp expect err || return 1
      	done &#38;&#38;
     +
    - 	git -C doublewrite config --add commitgraph.changedPathsVersion 2 &#38;&#38;
    + 	git -C doublewrite config --add commitGraph.changedPathsVersion 2 &#38;&#38;
     -	git -C doublewrite commit-graph write --reachable --changed-paths &#38;&#38;
    ++	&gt;trace2.txt &#38;&#38;
     +	GIT_TRACE2_EVENT=&#34;$(pwd)/trace2.txt&#34; \
     +		git -C doublewrite commit-graph write --reachable --changed-paths &#38;&#38;
     +	test_filter_computed 1 trace2.txt &#38;&#38;
    @@ t/t4216-log-bloom.sh: test_expect_success &#39;when writing commit graph, do not reu
     +
     +	test_commit -C upgrade base no-high-bits &#38;&#38;
     +
    -+	git -C upgrade config --add commitgraph.changedPathsVersion 1 &#38;&#38;
    ++	git -C upgrade config --add commitGraph.changedPathsVersion 1 &#38;&#38;
    ++	&gt;trace2.txt &#38;&#38;
     +	GIT_TRACE2_EVENT=&#34;$(pwd)/trace2.txt&#34; \
     +		git -C upgrade commit-graph write --reachable --changed-paths &#38;&#38;
     +	test_filter_computed 1 trace2.txt &#38;&#38;
     +	test_filter_upgraded 0 trace2.txt &#38;&#38;
     +
    -+	git -C upgrade config --add commitgraph.changedPathsVersion 2 &#38;&#38;
    ++	git -C upgrade config --add commitGraph.changedPathsVersion 2 &#38;&#38;
    ++	&gt;trace2.txt &#38;&#38;
     +	GIT_TRACE2_EVENT=&#34;$(pwd)/trace2.txt&#34; \
     +		git -C upgrade commit-graph write --reachable --changed-paths &#38;&#38;
     +	test_filter_computed 0 trace2.txt &#38;&#38;
16:  12058a074d = 16:  db9991f339 bloom: introduce `deinit_bloom_filters()`

base-commit: 1e1586e4ed626bde864339c10570bc0e73f0ab97
-- 
2.45.2.664.g446e6a2b1f
</pre></div></content></entry><entry><author><name>Abhijeet Sonar</name><email>abhijeet.nkt@gmail.com</email></author><title
type="html">[PATCH v3] describe: refresh the index when &#39;broken&#39; flag is used</title><updated>2024-06-25T13:36:30Z</updated><link
href="http://lore.kernel.org/git/20240625133534.223579-1-abhijeet.nkt@gmail.com/"/><id>urn:uuid:9ff2bc64-2d23-280a-99fa-9acdc3384f13</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">When describe is run with &#39;dirty&#39; flag, we refresh the index
to make sure it is in sync with the filesystem before
determining if the working tree is dirty.  However, this is
not done for the codepath where the &#39;broken&#39; flag is used.

This causes `git describe --broken --dirty` to false
positively report the worktree being dirty if a file has
different stat info than what is recorded in the index.
Running `git update-index -q --refresh` to refresh the index
before running diff-index fixes the problem.

Also add tests to deliberately update stat info of a
file before running describe to verify it behaves correctly.

Reported-by: Paul Millar &lt;paul.millar@desy.de&gt;
Suggested-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Helped-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Helped-by: Phillip Wood &lt;phillip.wood123@gmail.com&gt;
Signed-off-by: Abhijeet Sonar &lt;abhijeet.nkt@gmail.com&gt;
---
 builtin/describe.c  | 11 +++++++++++
 t/t6120-describe.sh | 24 ++++++++++++++++++++++++
 2 files <a href="http://lore.kernel.org/git/20240625133534.223579-1-abhijeet.nkt@gmail.com/#related">changed</a>, 35 insertions(+)

<span
class="head">diff --git a/builtin/describe.c b/builtin/describe.c
index e5287eddf2..deec19b29a 100644
--- a/builtin/describe.c
+++ b/builtin/describe.c
</span><span
class="hunk">@@ -53,6 +53,10 @@ static const char *diff_index_args[] = {
</span> 	&#34;diff-index&#34;, &#34;--quiet&#34;, &#34;HEAD&#34;, &#34;--&#34;, NULL
 };
 
<span
class="add">+static const char *update_index_args[] = {
+	&#34;update-index&#34;, &#34;--unmerged&#34;, &#34;-q&#34;, &#34;--refresh&#34;, NULL
+};
+
</span> struct commit_name {
 	struct hashmap_entry entry;
 	struct object_id peeled;
<span
class="hunk">@@ -645,6 +649,13 @@ int cmd_describe(int argc, const char **argv, const char *prefix)
</span> 	if (argc == 0) {
 		if (broken) {
 			struct child_process cp = CHILD_PROCESS_INIT;
<span
class="add">+			strvec_pushv(&#38;cp.args, update_index_args);
+			cp.git_cmd = 1;
+			cp.no_stdin = 1;
+			cp.no_stdout = 1;
+			run_command(&#38;cp);
+			strvec_clear(&#38;cp.args);
+
</span> 			strvec_pushv(&#38;cp.args, diff_index_args);
 			cp.git_cmd = 1;
 			cp.no_stdin = 1;
<span
class="head">diff --git a/t/t6120-describe.sh b/t/t6120-describe.sh
index e78315d23d..6c396e7abc 100755
--- a/t/t6120-describe.sh
+++ b/t/t6120-describe.sh
</span><span
class="hunk">@@ -671,4 +671,28 @@ test_expect_success &#39;setup misleading taggerdates&#39; &#39;
</span> 
 check_describe newer-tag-older-commit~1 --contains unique-file~2
 
<span
class="add">+test_expect_success &#39;describe --dirty with a file with changed stat&#39; &#39;
+	git init stat-dirty &#38;&#38;
+	(
+		cd stat-dirty &#38;&#38;
+
+		echo A &gt;file &#38;&#38;
+		git add file &#38;&#38;
+		git commit -m A &#38;&#38;
+		git tag A -a -m A &#38;&#38;
+
+		cat file &gt;file.new &#38;&#38;
+		mv file.new file &#38;&#38;
+		git describe --dirty &gt;actual &#38;&#38;
+		echo &#34;A&#34; &gt;expected &#38;&#38;
+		test_cmp expected actual &#38;&#38;
+
+		cat file &gt;file.new &#38;&#38;
+		mv file.new file &#38;&#38;
+		git describe --dirty --broken &gt;actual &#38;&#38;
+		echo &#34;A&#34; &gt;expected &#38;&#38;
+		test_cmp expected actual
+	)
+&#39;
+
</span> test_done

Range-diff against v2:
1:  d60fc0fa02 ! 1:  1da5fa48d9 describe: refresh the index when &#39;broken&#39; flag is used
    @@ Commit message
         Reported-by: Paul Millar &lt;paul.millar@desy.de&gt;
         Suggested-by: Junio C Hamano &lt;gitster@pobox.com&gt;
         Helped-by: Junio C Hamano &lt;gitster@pobox.com&gt;
    +    Helped-by: Phillip Wood &lt;phillip.wood123@gmail.com&gt;
         Signed-off-by: Abhijeet Sonar &lt;abhijeet.nkt@gmail.com&gt;
     
      ## builtin/describe.c ##
    @@ builtin/describe.c: int cmd_describe(int argc, const char **argv, const char *pr
      	if (argc == 0) {
      		if (broken) {
      			struct child_process cp = CHILD_PROCESS_INIT;
    -+			struct child_process update_index_cp = CHILD_PROCESS_INIT;
    -+
    -+			strvec_pushv(&#38;update_index_cp.args, update_index_args);
    -+			update_index_cp.git_cmd = 1;
    -+			update_index_cp.no_stdin = 1;
    -+			update_index_cp.no_stdout = 1;
    -+			run_command(&#38;update_index_cp);
    ++			strvec_pushv(&#38;cp.args, update_index_args);
    ++			cp.git_cmd = 1;
    ++			cp.no_stdin = 1;
    ++			cp.no_stdout = 1;
    ++			run_command(&#38;cp);
    ++			strvec_clear(&#38;cp.args);
     +
      			strvec_pushv(&#38;cp.args, diff_index_args);
      			cp.git_cmd = 1;
    @@ t/t6120-describe.sh: test_expect_success &#39;setup misleading taggerdates&#39; &#39;
      
     +test_expect_success &#39;describe --dirty with a file with changed stat&#39; &#39;
     +	git init stat-dirty &#38;&#38;
    -+	cd stat-dirty &#38;&#38;
    -+
    -+	echo A &gt;file &#38;&#38;
    -+	git add file &#38;&#38;
    -+	git commit -m A &#38;&#38;
    -+	git tag A -a -m A &#38;&#38;
    -+
    -+	cat file &gt;file.new &#38;&#38;
    -+	mv file.new file &#38;&#38;
    -+	git describe --dirty &gt;actual &#38;&#38;
    -+	echo &#34;A&#34; &gt;expected &#38;&#38;
    -+	test_cmp expected actual
    -+&#39;
    ++	(
    ++		cd stat-dirty &#38;&#38;
     +
    -+test_expect_success &#39;describe --dirty --broken with a file with changed stat&#39; &#39;
    -+	git init stat-dirty-broken &#38;&#38;
    -+	cd stat-dirty-broken &#38;&#38;
    ++		echo A &gt;file &#38;&#38;
    ++		git add file &#38;&#38;
    ++		git commit -m A &#38;&#38;
    ++		git tag A -a -m A &#38;&#38;
     +
    -+	echo A &gt;file &#38;&#38;
    -+	git add file &#38;&#38;
    -+	git commit -m A &#38;&#38;
    -+	git tag A -a -m A &#38;&#38;
    ++		cat file &gt;file.new &#38;&#38;
    ++		mv file.new file &#38;&#38;
    ++		git describe --dirty &gt;actual &#38;&#38;
    ++		echo &#34;A&#34; &gt;expected &#38;&#38;
    ++		test_cmp expected actual &#38;&#38;
     +
    -+	cat file &gt;file.new &#38;&#38;
    -+	mv file.new file &#38;&#38;
    -+	git describe --dirty --broken &gt;actual &#38;&#38;
    -+	echo &#34;A&#34; &gt;expected &#38;&#38;
    -+	test_cmp expected actual
    ++		cat file &gt;file.new &#38;&#38;
    ++		mv file.new file &#38;&#38;
    ++		git describe --dirty --broken &gt;actual &#38;&#38;
    ++		echo &#34;A&#34; &gt;expected &#38;&#38;
    ++		test_cmp expected actual
    ++	)
     +&#39;
     +
      test_done
-- 
2.45.2.606.g9005149a4a.dirty

</pre></div></content></entry><entry><author><name>Abhijeet Sonar</name><email>abhijeet.nkt@gmail.com</email></author><title
type="html">[PATCH v2] describe: refresh the index when &#39;broken&#39; flag is used</title><updated>2024-06-25T06:45:33Z</updated><link
href="http://lore.kernel.org/git/20240625064504.58286-1-abhijeet.nkt@gmail.com/"/><id>urn:uuid:0547732a-992c-7f1f-02a0-f26a01094188</id><thr:in-reply-to
ref="urn:uuid:c832c237-257a-ae56-fc20-a3e6989aabf7"
href="http://lore.kernel.org/git/xmqqsex2b4ti.fsf@gitster.g/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">When describe is run with &#39;dirty&#39; flag, we refresh the index
to make sure it is in sync with the filesystem before
determining if the working tree is dirty.  However, this is
not done for the codepath where the &#39;broken&#39; flag is used.

This causes `git describe --broken --dirty` to false
positively report the worktree being dirty if a file has
different stat info than what is recorded in the index.
Running `git update-index -q --refresh` to refresh the index
before running diff-index fixes the problem.

Also add tests to deliberately update stat info of a
file before running describe to verify it behaves correctly.

Reported-by: Paul Millar &lt;paul.millar@desy.de&gt;
Suggested-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Helped-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Signed-off-by: Abhijeet Sonar &lt;abhijeet.nkt@gmail.com&gt;
---
 builtin/describe.c  | 12 ++++++++++++
 t/t6120-describe.sh | 32 ++++++++++++++++++++++++++++++++
 2 files <a href="http://lore.kernel.org/git/20240625064504.58286-1-abhijeet.nkt@gmail.com/#related">changed</a>, 44 insertions(+)

<span
class="head">diff --git a/builtin/describe.c b/builtin/describe.c
index e5287eddf2..3e751f1239 100644
--- a/builtin/describe.c
+++ b/builtin/describe.c
</span><span
class="hunk">@@ -53,6 +53,10 @@ static const char *diff_index_args[] = {
</span> 	&#34;diff-index&#34;, &#34;--quiet&#34;, &#34;HEAD&#34;, &#34;--&#34;, NULL
 };
 
<span
class="add">+static const char *update_index_args[] = {
+	&#34;update-index&#34;, &#34;--unmerged&#34;, &#34;-q&#34;, &#34;--refresh&#34;, NULL
+};
+
</span> struct commit_name {
 	struct hashmap_entry entry;
 	struct object_id peeled;
<span
class="hunk">@@ -645,6 +649,14 @@ int cmd_describe(int argc, const char **argv, const char *prefix)
</span> 	if (argc == 0) {
 		if (broken) {
 			struct child_process cp = CHILD_PROCESS_INIT;
<span
class="add">+			struct child_process update_index_cp = CHILD_PROCESS_INIT;
+
+			strvec_pushv(&#38;update_index_cp.args, update_index_args);
+			update_index_cp.git_cmd = 1;
+			update_index_cp.no_stdin = 1;
+			update_index_cp.no_stdout = 1;
+			run_command(&#38;update_index_cp);
+
</span> 			strvec_pushv(&#38;cp.args, diff_index_args);
 			cp.git_cmd = 1;
 			cp.no_stdin = 1;
<span
class="head">diff --git a/t/t6120-describe.sh b/t/t6120-describe.sh
index e78315d23d..ac781a7b52 100755
--- a/t/t6120-describe.sh
+++ b/t/t6120-describe.sh
</span><span
class="hunk">@@ -671,4 +671,36 @@ test_expect_success &#39;setup misleading taggerdates&#39; &#39;
</span> 
 check_describe newer-tag-older-commit~1 --contains unique-file~2
 
<span
class="add">+test_expect_success &#39;describe --dirty with a file with changed stat&#39; &#39;
+	git init stat-dirty &#38;&#38;
+	cd stat-dirty &#38;&#38;
+
+	echo A &gt;file &#38;&#38;
+	git add file &#38;&#38;
+	git commit -m A &#38;&#38;
+	git tag A -a -m A &#38;&#38;
+
+	cat file &gt;file.new &#38;&#38;
+	mv file.new file &#38;&#38;
+	git describe --dirty &gt;actual &#38;&#38;
+	echo &#34;A&#34; &gt;expected &#38;&#38;
+	test_cmp expected actual
+&#39;
+
+test_expect_success &#39;describe --dirty --broken with a file with changed stat&#39; &#39;
+	git init stat-dirty-broken &#38;&#38;
+	cd stat-dirty-broken &#38;&#38;
+
+	echo A &gt;file &#38;&#38;
+	git add file &#38;&#38;
+	git commit -m A &#38;&#38;
+	git tag A -a -m A &#38;&#38;
+
+	cat file &gt;file.new &#38;&#38;
+	mv file.new file &#38;&#38;
+	git describe --dirty --broken &gt;actual &#38;&#38;
+	echo &#34;A&#34; &gt;expected &#38;&#38;
+	test_cmp expected actual
+&#39;
+
</span> test_done
-- 
2.45.2.606.g9005149a4a.dirty

</pre></div></content></entry><entry><author><name>Ren&#233; Scharfe</name><email>l.s.r@web.de</email></author><title>[PATCH v2] diff: allow --color-moved with --no-ext-diff</title><updated>2024-06-24T19:15:58Z</updated><link
href="http://lore.kernel.org/git/fee1815c-80bb-42a4-97f3-d3f8e9b3a6ca@web.de/"/><id>urn:uuid:160e85ff-2677-3de3-59c9-f7f7170a148f</id><thr:in-reply-to
ref="urn:uuid:cca9531c-3f2b-5b07-1ea5-2905add8ed95"
href="http://lore.kernel.org/git/trinity-acbdb8fc-3dc3-4dca-890c-8bcb37405782-1719050465639@msvc-mesg-gmx004/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">We ignore the option --color-moved if an external diff program is
configured, presumably because its overhead is unnecessary in that case.
Respect the option if we don&#39;t actually use the external diff, though.

Reported-by: lolligerhans@gmx.de
Helped-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Signed-off-by: Ren&#233; Scharfe &lt;l.s.r@web.de&gt;
---
Changes since v1:
* use single word colors, leaving the background unchanged, as they are
  easier to read,
* run git diff to generate the expected content instead of reusing the
  output of the previous test ...
* ... and put the common arguments in a variable to make clear that we
  compare diff with and without a diff.external/--no-ext-diff dance,
* use echo instead of false as the (unused) external diff command to
  avoid giving the wrong impression that diff.external is a boolean
  option we turn off here.

  diff --git a/t/t4015-diff-whitespace.sh b/t/t4015-diff-whitespace.sh
  index a1478680b6..851cfe4f32 100755
  --- a/t/t4015-diff-whitespace.sh
  +++ b/t/t4015-diff-whitespace.sh
  @@ -1185,11 +1185,11 @@ test_expect_success &#39;detect moved code, complete file&#39; &#39;
   &#39;

   test_expect_success &#39;--color-moved with --no-ext-diff&#39; &#39;
  -	test_config color.diff.oldMoved &#34;normal red&#34; &#38;&#38;
  -	test_config color.diff.newMoved &#34;normal green&#34; &#38;&#38;
  -	cp actual.raw expect &#38;&#38;
  -	git -c diff.external=false diff HEAD --no-ext-diff \
  -		--color-moved=zebra --color --no-renames &gt;actual &#38;&#38;
  +	test_config color.diff.oldMoved &#34;yellow&#34; &#38;&#38;
  +	test_config color.diff.newMoved &#34;blue&#34; &#38;&#38;
  +	args=&#34;--color --color-moved=zebra --no-renames HEAD&#34; &#38;&#38;
  +	git diff $args &gt;expect &#38;&#38;
  +	git -c diff.external=echo diff --no-ext-diff $args &gt;actual &#38;&#38;
   	test_cmp expect actual
   &#39;


 diff.c                     | 3 ++-
 t/t4015-diff-whitespace.sh | 9 +++++++++
 2 files <a href="http://lore.kernel.org/git/fee1815c-80bb-42a4-97f3-d3f8e9b3a6ca@web.de/#related">changed</a>, 11 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/diff.c b/diff.c
index 6e432cb8fc..aa0fb77761 100644
--- a/diff.c
+++ b/diff.c
</span><span
class="hunk">@@ -4965,7 +4965,8 @@ void diff_setup_done(struct diff_options *options)
</span> 	if (options-&gt;flags.follow_renames)
 		diff_check_follow_pathspec(&#38;options-&gt;pathspec, 1);

<span
class="del">-	if (!options-&gt;use_color || external_diff())
</span><span
class="add">+	if (!options-&gt;use_color ||
+	    (options-&gt;flags.allow_external &#38;&#38; external_diff()))
</span> 		options-&gt;color_moved = 0;

 	if (options-&gt;filter_not) {
<span
class="head">diff --git a/t/t4015-diff-whitespace.sh b/t/t4015-diff-whitespace.sh
index b443626afd..851cfe4f32 100755
--- a/t/t4015-diff-whitespace.sh
+++ b/t/t4015-diff-whitespace.sh
</span><span
class="hunk">@@ -1184,6 +1184,15 @@ test_expect_success &#39;detect moved code, complete file&#39; &#39;
</span> 	test_cmp expected actual
 &#39;

<span
class="add">+test_expect_success &#39;--color-moved with --no-ext-diff&#39; &#39;
+	test_config color.diff.oldMoved &#34;yellow&#34; &#38;&#38;
+	test_config color.diff.newMoved &#34;blue&#34; &#38;&#38;
+	args=&#34;--color --color-moved=zebra --no-renames HEAD&#34; &#38;&#38;
+	git diff $args &gt;expect &#38;&#38;
+	git -c diff.external=echo diff --no-ext-diff $args &gt;actual &#38;&#38;
+	test_cmp expect actual
+&#39;
+
</span> test_expect_success &#39;detect malicious moved code, inside file&#39; &#39;
 	test_config color.diff.oldMoved &#34;normal red&#34; &#38;&#38;
 	test_config color.diff.newMoved &#34;normal green&#34; &#38;&#38;
<span
class="del">--
</span>2.45.2
</pre></div></content></entry><entry><author><name>Abhijeet Sonar</name><email>abhijeet.nkt@gmail.com</email></author><title
type="html">[PATCH] describe: refresh the index when &#39;broken&#39; flag is used</title><updated>2024-06-23T21:43:23Z</updated><link
href="http://lore.kernel.org/git/20240623214301.143796-1-abhijeet.nkt@gmail.com/"/><id>urn:uuid:ea9b9a34-24d5-1e72-e55f-73acbfd5d7a1</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">When describe is run with &#39;dirty&#39; flag, we refresh the index
to make sure it is in sync with the filesystem before
determining if the working tree is dirty.  However, this is
not done for the codepath where the &#39;broken&#39; flag is used.

This causes `git describe --broken --dirty` to false
positively report the worktree being dirty.  Refreshing the
index before running diff-index fixes the problem.

Signed-off-by: Abhijeet Sonar &lt;abhijeet.nkt@gmail.com&gt;
Reported-by: Paul Millar &lt;paul.millar@desy.de&gt;
Suggested-by: Junio C Hamano &lt;gitster@pobox.com&gt;
---
 builtin/describe.c | 14 ++++++++++++++
 1 file <a href="http://lore.kernel.org/git/20240623214301.143796-1-abhijeet.nkt@gmail.com/#related">changed</a>, 14 insertions(+)

<span
class="head">diff --git a/builtin/describe.c b/builtin/describe.c
index e5287eddf2..2b443c155e 100644
--- a/builtin/describe.c
+++ b/builtin/describe.c
</span><span
class="hunk">@@ -645,6 +645,20 @@ int cmd_describe(int argc, const char **argv, const char *prefix)
</span> 	if (argc == 0) {
 		if (broken) {
 			struct child_process cp = CHILD_PROCESS_INIT;
<span
class="add">+			struct lock_file index_lock = LOCK_INIT;
+			int fd;
+
+			setup_work_tree();
+			prepare_repo_settings(the_repository);
+			repo_read_index(the_repository);
+			refresh_index(the_repository-&gt;index, REFRESH_QUIET|REFRESH_UNMERGED,
+				      NULL, NULL, NULL);
+			fd = repo_hold_locked_index(the_repository,
+						    &#38;index_lock, 0);
+			if (0 &lt;= fd)
+				repo_update_index_if_able(the_repository, &#38;index_lock);
+
+
</span> 			strvec_pushv(&#38;cp.args, diff_index_args);
 			cp.git_cmd = 1;
 			cp.no_stdin = 1;
-- 
2.45.GIT

</pre></div></content></entry><entry><author><name>Shane Sun via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH] doc: fix case error of eol attribute in example</title><updated>2024-06-23T21:40:20Z</updated><link
href="http://lore.kernel.org/git/pull.1736.git.git.1719178817386.gitgitgadget@gmail.com/"/><id>urn:uuid:bef37f6b-88bd-c451-0d0d-6a269b16852a</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Shane Sun &lt;github@waterlemons2k.com&gt;

The eol attribute only accepts &#34;crlf&#34; and &#34;lf&#34;,
but the example incorrectly capitalizes &#34;crlf&#34;.

References:

- <a
href="https://git-scm.com/docs/gitattributes#_eol">https://git-scm.com/docs/gitattributes#_eol</a>
- <a
href="https://github.com/git/git/blob/v2.45.2/convert.c#L1278">https://github.com/git/git/blob/v2.45.2/convert.c#L1278</a>

Signed-off-by: Shane Sun &lt;github@waterlemons2k.com&gt;
---
    doc: fix case error of eol attribute in example

Published-As: <a
href="https://github.com/gitgitgadget/git/releases/tag/pr-git-1736%2FWaterLemons2k%2Ffix-case-error-v1">https://github.com/gitgitgadget/git/releases/tag/pr-git-1736%2FWaterLemons2k%2Ffix-case-error-v1</a>
Fetch-It-Via: git fetch <a
href="https://github.com/gitgitgadget/git">https://github.com/gitgitgadget/git</a> pr-git-1736/WaterLemons2k/fix-case-error-v1
Pull-Request: <a
href="https://github.com/git/git/pull/1736">https://github.com/git/git/pull/1736</a>

 Documentation/gitattributes.txt | 2 +-
 1 file <a href="http://lore.kernel.org/git/pull.1736.git.git.1719178817386.gitgitgadget@gmail.com/#related">changed</a>, 1 insertion(+), 1 deletion(-)

<span
class="head">diff --git a/Documentation/gitattributes.txt b/Documentation/gitattributes.txt
index 80cae17f37d..e6150595af8 100644
--- a/Documentation/gitattributes.txt
+++ b/Documentation/gitattributes.txt
</span><span
class="hunk">@@ -374,7 +374,7 @@ explicitly define the line endings with `eol` if the `working-tree-encoding`
</span> attribute is used to avoid ambiguity.
 
 ------------------------
<span
class="del">-*.ps1		text working-tree-encoding=UTF-16LE eol=CRLF
</span><span
class="add">+*.ps1		text working-tree-encoding=UTF-16LE eol=crlf
</span> ------------------------
 
 You can get a list of all available encodings on your platform with the

base-commit: 9005149a4a77e2d3409c6127bf4fd1a0893c3495
-- 
gitgitgadget
</pre></div></content></entry><entry><author><name>Piotr Szlazak via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH] doc: update http.cookieFile with in-memory cookie processing</title><updated>2024-06-23T21:24:10Z</updated><link
href="http://lore.kernel.org/git/pull.1733.git.git.1719177846725.gitgitgadget@gmail.com/"/><id>urn:uuid:0390c86a-5d26-293d-23c7-21d74025eff8</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Piotr Szlazak &lt;piotr.szlazak@gmail.com&gt;

Information added how to enable in-memory cookies
processing. Cookies from server will be accepted and send
back in successive requests within same connection.

At the moment documentation only mentions how to read
cookies from the given file and how to save them to the file
using http.saveCookies.

curl / libcurl will process cookies in memory if file name
is blank. Check curl manpage:
<a
href="https://curl.se/docs/manpage.html#-b">https://curl.se/docs/manpage.html#-b</a>
This is described here in more details:
<a
href="https://everything.curl.dev/http/cookies/engine.html">https://everything.curl.dev/http/cookies/engine.html</a>
And also explained here:
<a
href="https://www.youtube.com/watch?v=V5vZWHP-RqU&#38;t=11459s">https://www.youtube.com/watch?v=V5vZWHP-RqU&#38;t=11459s</a>

Git documentation was updated to include suggestion how to
enable this by setting empty value for http.cookieFile.

Signed-off-by: Piotr Szlazak &lt;piotr.szlazak@gmail.com&gt;
---
    Update http.cookieFile with in-memory cookie processing

Published-As: <a
href="https://github.com/gitgitgadget/git/releases/tag/pr-git-1733%2Fpszlazak%2Fdocumentation-cookieFile-in-memory-v1">https://github.com/gitgitgadget/git/releases/tag/pr-git-1733%2Fpszlazak%2Fdocumentation-cookieFile-in-memory-v1</a>
Fetch-It-Via: git fetch <a
href="https://github.com/gitgitgadget/git">https://github.com/gitgitgadget/git</a> pr-git-1733/pszlazak/documentation-cookieFile-in-memory-v1
Pull-Request: <a
href="https://github.com/git/git/pull/1733">https://github.com/git/git/pull/1733</a>

 Documentation/config/http.txt | 8 ++++----
 1 file <a href="http://lore.kernel.org/git/pull.1733.git.git.1719177846725.gitgitgadget@gmail.com/#related">changed</a>, 4 insertions(+), 4 deletions(-)

<span
class="head">diff --git a/Documentation/config/http.txt b/Documentation/config/http.txt
index 2d4e0c9b869..228bed32ec1 100644
--- a/Documentation/config/http.txt
+++ b/Documentation/config/http.txt
</span><span
class="hunk">@@ -78,10 +78,10 @@ http.extraHeader::
</span> 
 http.cookieFile::
 	The pathname of a file containing previously stored cookie lines,
<span
class="del">-	which should be used
-	in the Git http session, if they match the server. The file format
-	of the file to read cookies from should be plain HTTP headers or
-	the Netscape/Mozilla cookie file format (see `curl(1)`).
</span><span
class="add">+	which should be used in the Git http session, if they match the server.
+	The file format of the file to read cookies from should be plain HTTP
+	headers or the Netscape/Mozilla cookie file format (see `curl(1)`).
+	Set it to empty value, to enable in-memory cookies processing.
</span> 	NOTE that the file specified with http.cookieFile is used only as
 	input unless http.saveCookies is set.
 

base-commit: 66ac6e4bcd111be3fa9c2a6b3fafea718d00678d
-- 
gitgitgadget
</pre></div></content></entry><entry><author><name>lolligerhans</name><email>lolligerhans@gmx.de</email></author><title>Aw: [PATCH] diff: allow --color-moved with --no-ext-diff</title><updated>2024-06-23T09:17:16Z</updated><link
href="http://lore.kernel.org/git/trinity-5166e20d-147e-4205-99b7-f13a007ed5f9-1719134235233@3c-app-gmx-bap30/"/><id>urn:uuid:d6a0aca6-e3f5-f0e6-bf9c-9b862edbdd76</id><thr:in-reply-to
ref="urn:uuid:23bedb44-ff30-3c7d-a651-d7a1f3ccee78"
href="http://lore.kernel.org/git/8a8bd51e-9ce5-4a68-bfbe-f16dcbb7e89c@web.de/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Hello Ren&#233;,

using red/green coloration is the current buggy behavior. When setting oldMOved and newMoved I would expect the correct behaviour to the the same as the buggy one.

Could this test pass despite the bug?
</pre></div></content></entry><entry><author><name>Rub&#233;n Justo</name><email>rjusto@gmail.com</email></author><title>[PATCH v4] pager: die when paging to non-existing command</title><updated>2024-06-23T07:09:21Z</updated><link
href="http://lore.kernel.org/git/392deded-9eb2-42fa-b6f9-54c22d3ffd33@gmail.com/"/><id>urn:uuid:7851a559-1b20-21cf-3b6b-e050d1c7eb28</id><thr:in-reply-to
ref="urn:uuid:d73f260e-2071-9489-86f6-42c0db1d39e1"
href="http://lore.kernel.org/git/6850f558-ad20-403a-ae1e-5b9826c53790@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">When trying to execute a non-existent program from GIT_PAGER, we display
an error.  However, we also send the complete text to the terminal
and return a successful exit code.  This can be confusing for the user
and the displayed error could easily become obscured by a lengthy
text.

For example, here the error message would be very far above after
sending 50 MB of text:

    $ GIT_PAGER=non-existent t/test-terminal.perl git log | wc -c
    error: cannot run non-existent: No such file or directory
    50314363

Let&#39;s make the error clear by aborting the process and return an error
so that the user can easily correct their mistake.

This will be the result of the change:

    $ GIT_PAGER=non-existent t/test-terminal.perl git log | wc -c
    error: cannot run non-existent: No such file or directory
    fatal: unable to execute pager &#39;non-existent&#39;
    0

The behavior change we&#39;re introducing in this commit affects two tests
in t7006, which is a good sign regarding test coverage and requires us
to address it.

The first test is &#39;git skips paging non-existing command&#39;.  This test
comes from f7991f01f2 (t7006: clean up SIGPIPE handling in trace2 tests,
2021-11-21,) where a modification was made to a test that was originally
introduced in c24b7f6736 (pager: test for exit code with and without
SIGPIPE, 2021-02-02).  That original test was, IMHO, in the same
direction we&#39;re going in this commit.

At any rate, this test obviously needs to be adjusted to check the new
behavior we are introducing.  Do it.

The second test being affected is: &#39;non-existent pager doesnt cause
crash&#39;, introduced in f917f57f40 (pager: fix crash when pager program
doesn&#39;t exist, 2021-11-24).  As its name states, it has the intention of
checking that we don&#39;t introduce a regression that produces a crash when
GIT_PAGER points to a nonexistent program.

This test could be considered redundant nowadays, due to us already
having several tests checking implicitly what a non-existent command in
GIT_PAGER produces.  However, let&#39;s maintain a good belt-and-suspenders
strategy; adapt it to the new world.

Finally, it&#39;s worth noting that we are not changing the behavior if the
command specified in GIT_PAGER is a shell command.  In such cases, it
is:

    $ GIT_PAGER=:\;non-existent t/test-terminal.perl git log
    :;non-existent: 1: non-existent: not found
    died of signal 13 at t/test-terminal.perl line 33.

Signed-off-by: Rub&#233;n Justo &lt;rjusto@gmail.com&gt;
---

Error pointed out by Hannes in:

<a
href="https://lore.kernel.org/git/f031c152-1b97-4598-92f3-a72aefd701a4@kdbg.org">https://lore.kernel.org/git/f031c152-1b97-4598-92f3-a72aefd701a4@kdbg.org</a>

Thanks!

Range-diff against v2:
1:  60e852bffb ! 1:  93d6074a17 pager: die when paging to non-existing command
    @@ Commit message
     
             $ GIT_PAGER=non-existent t/test-terminal.perl git log | wc -c
             error: cannot run non-existent: No such file or directory
    -        fatal: unable to start the pager: &#39;non-existent&#39;
    +        fatal: unable to execute pager &#39;non-existent&#39;
             0
     
         The behavior change we&#39;re introducing in this commit affects two tests

 pager.c          |  2 +-
 t/t7006-pager.sh | 17 +++++------------
 2 files <a href="http://lore.kernel.org/git/392deded-9eb2-42fa-b6f9-54c22d3ffd33@gmail.com/#related">changed</a>, 6 insertions(+), 13 deletions(-)

<span
class="head">diff --git a/pager.c b/pager.c
index e9e121db69..be6f4ee59f 100644
--- a/pager.c
+++ b/pager.c
</span><span
class="hunk">@@ -137,7 +137,7 @@ void setup_pager(void)
</span> 	pager_process.in = -1;
 	strvec_push(&#38;pager_process.env, &#34;GIT_PAGER_IN_USE&#34;);
 	if (start_command(&#38;pager_process))
<span
class="del">-		return;
</span><span
class="add">+		die(&#34;unable to execute pager &#39;%s&#39;&#34;, pager);
</span> 
 	/* original process continues, but writes to the pipe */
 	dup2(pager_process.in, 1);
<span
class="head">diff --git a/t/t7006-pager.sh b/t/t7006-pager.sh
index e56ca5b0fa..932c26cb45 100755
--- a/t/t7006-pager.sh
+++ b/t/t7006-pager.sh
</span><span
class="hunk">@@ -725,18 +725,11 @@ test_expect_success TTY &#39;git discards pager non-zero exit without SIGPIPE&#39; &#39;
</span> 	test_path_is_file pager-used
 &#39;
 
<span
class="del">-test_expect_success TTY &#39;git skips paging nonexisting command&#39; &#39;
-	test_when_finished &#34;rm trace.normal&#34; &#38;&#38;
</span><span
class="add">+test_expect_success TTY &#39;git errors when asked to execute nonexisting pager&#39; &#39;
+	test_when_finished &#34;rm -f err&#34; &#38;&#38;
</span> 	test_config core.pager &#34;does-not-exist&#34; &#38;&#38;
<span
class="del">-	GIT_TRACE2=&#34;$(pwd)/trace.normal&#34; &#38;&#38;
-	export GIT_TRACE2 &#38;&#38;
-	test_when_finished &#34;unset GIT_TRACE2&#34; &#38;&#38;
-
-	test_terminal git log &#38;&#38;
-
-	grep child_exit trace.normal &gt;child-exits &#38;&#38;
-	test_line_count = 1 child-exits &#38;&#38;
-	grep &#34; code:-1 &#34; child-exits
</span><span
class="add">+	test_must_fail test_terminal git log 2&gt;err &#38;&#38;
+	test_grep &#34;unable to execute pager&#34; err
</span> &#39;
 
 test_expect_success TTY &#39;git returns SIGPIPE on propagated signals from pager&#39; &#39;
<span
class="hunk">@@ -762,7 +755,7 @@ test_expect_success TTY &#39;git returns SIGPIPE on propagated signals from pager&#39; &#39;
</span> 
 test_expect_success TTY &#39;non-existent pager doesnt cause crash&#39; &#39;
 	test_config pager.show invalid-pager &#38;&#38;
<span
class="del">-	test_terminal git show
</span><span
class="add">+	test_must_fail test_terminal git show
</span> &#39;
 
 test_done
-- 
2.45.1
</pre></div></content></entry><entry><author><name>Ren&#233; Scharfe</name><email>l.s.r@web.de</email></author><title>[PATCH] diff: allow --color-moved with --no-ext-diff</title><updated>2024-06-22T19:41:32Z</updated><link
href="http://lore.kernel.org/git/8a8bd51e-9ce5-4a68-bfbe-f16dcbb7e89c@web.de/"/><id>urn:uuid:23bedb44-ff30-3c7d-a651-d7a1f3ccee78</id><thr:in-reply-to
ref="urn:uuid:cca9531c-3f2b-5b07-1ea5-2905add8ed95"
href="http://lore.kernel.org/git/trinity-acbdb8fc-3dc3-4dca-890c-8bcb37405782-1719050465639@msvc-mesg-gmx004/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Since the option --color-moved was added by 2e2d5ac184 (diff.c: color
moved lines differently, 2017-06-30) we have been ignoring it if an
external diff program is configured, presumably because its overhead is
unnecessary in that case.

Do respect --color-moved if we don&#39;t actually use the configured
external diff, though.

Reported-by: lolligerhans@gmx.de
Signed-off-by: Ren&#233; Scharfe &lt;l.s.r@web.de&gt;
---
 diff.c                     | 3 ++-
 t/t4015-diff-whitespace.sh | 9 +++++++++
 2 files <a href="http://lore.kernel.org/git/8a8bd51e-9ce5-4a68-bfbe-f16dcbb7e89c@web.de/#related">changed</a>, 11 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/diff.c b/diff.c
index 6e432cb8fc..aa0fb77761 100644
--- a/diff.c
+++ b/diff.c
</span><span
class="hunk">@@ -4965,7 +4965,8 @@ void diff_setup_done(struct diff_options *options)
</span> 	if (options-&gt;flags.follow_renames)
 		diff_check_follow_pathspec(&#38;options-&gt;pathspec, 1);

<span
class="del">-	if (!options-&gt;use_color || external_diff())
</span><span
class="add">+	if (!options-&gt;use_color ||
+	    (options-&gt;flags.allow_external &#38;&#38; external_diff()))
</span> 		options-&gt;color_moved = 0;

 	if (options-&gt;filter_not) {
<span
class="head">diff --git a/t/t4015-diff-whitespace.sh b/t/t4015-diff-whitespace.sh
index b443626afd..a1478680b6 100755
--- a/t/t4015-diff-whitespace.sh
+++ b/t/t4015-diff-whitespace.sh
</span><span
class="hunk">@@ -1184,6 +1184,15 @@ test_expect_success &#39;detect moved code, complete file&#39; &#39;
</span> 	test_cmp expected actual
 &#39;

<span
class="add">+test_expect_success &#39;--color-moved with --no-ext-diff&#39; &#39;
+	test_config color.diff.oldMoved &#34;normal red&#34; &#38;&#38;
+	test_config color.diff.newMoved &#34;normal green&#34; &#38;&#38;
+	cp actual.raw expect &#38;&#38;
+	git -c diff.external=false diff HEAD --no-ext-diff \
+		--color-moved=zebra --color --no-renames &gt;actual &#38;&#38;
+	test_cmp expect actual
+&#39;
+
</span> test_expect_success &#39;detect malicious moved code, inside file&#39; &#39;
 	test_config color.diff.oldMoved &#34;normal red&#34; &#38;&#38;
 	test_config color.diff.newMoved &#34;normal green&#34; &#38;&#38;
<span
class="del">--
</span>2.45.2
</pre></div></content></entry><entry><author><name>Junio C Hamano</name><email>gitster@pobox.com</email></author><title>[PATCH] fuzz: minimum fuzzers environment lacks libcURL</title><updated>2024-06-22T05:08:48Z</updated><link
href="http://lore.kernel.org/git/xmqqwmmhimxx.fsf@gitster.g/"/><id>urn:uuid:3351be5d-ea70-7b37-08fe-81fbc271528c</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The &#34;fuzz smoke test&#34; job compiles various .o files to create
libgit.a and others, but the final build product of the fuzzer build
is *not* &#34;git&#34;.  Since the job is not interested in building a
working &#34;git&#34;, it does not define any build flags, and among the
notable ones that are missing is NO_CURL---even though the CI
environment that runs the job does not have libcURL development
package installed.

This obviously leads to a build failure.

Pass NO_CURL=NoThanks to &#34;make&#34; to make sure things will build
correctly, if we add any conditional compilation with &#34;#ifdef
NO_CURL ... #endif&#34; in the codebase.

Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
---
 ci/run-build-and-minimal-fuzzers.sh | 1 +
 1 file <a href="http://lore.kernel.org/git/xmqqwmmhimxx.fsf@gitster.g/#related">changed</a>, 1 insertion(+)

<span
class="head">diff --git a/ci/run-build-and-minimal-fuzzers.sh b/ci/run-build-and-minimal-fuzzers.sh
index a51076d18d..bcf2ed54d2 100755
--- a/ci/run-build-and-minimal-fuzzers.sh
+++ b/ci/run-build-and-minimal-fuzzers.sh
</span><span
class="hunk">@@ -6,6 +6,7 @@
</span> . ${0%/*}/lib.sh
 
 group &#34;Build fuzzers&#34; make \
<span
class="add">+	NO_CURL=NoThanks \
</span> 	CC=clang \
 	CXX=clang++ \
 	CFLAGS=&#34;-fsanitize=fuzzer-no-link,address&#34; \
-- 
2.45.2-789-g52a439864c

</pre></div></content></entry><entry><author><name>Eric Wong</name><email>e@80x24.org</email></author><title>[PATCH] object-file: fix leak on conversion failure</title><updated>2024-06-22T04:36:54Z</updated><link
href="http://lore.kernel.org/git/20240622043648.M78681@dcvr/"/><id>urn:uuid:84fd5ee6-d86c-b561-46db-2c6b152e60bf</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">I&#39;m not sure exactly how to trigger the leak, but it seems fairly
obvious that the `content&#39; buffer should be freed even if
convert_object_file() fails.  Noticed while working in this area
on unrelated things.

Signed-off-by: Eric Wong &lt;e@80x24.org&gt;
---
 object-file.c | 2 +-
 1 file <a href="http://lore.kernel.org/git/20240622043648.M78681@dcvr/#related">changed</a>, 1 insertion(+), 1 deletion(-)

<span
class="head">diff --git a/object-file.c b/object-file.c
index d3cf4b8b2e..00c8f1039b 100644
--- a/object-file.c
+++ b/object-file.c
</span><span
class="hunk">@@ -1711,9 +1711,9 @@ static int oid_object_info_convert(struct repository *r,
</span> 			ret = convert_object_file(&#38;outbuf,
 						  the_hash_algo, input_algo,
 						  content, size, type, !do_die);
<span
class="add">+			free(content);
</span> 			if (ret == -1)
 				return -1;
<span
class="del">-			free(content);
</span> 			size = outbuf.len;
 			content = strbuf_detach(&#38;outbuf, NULL);
 		}
</pre></div></content></entry><entry><author><name>Rub&#233;n Justo</name><email>rjusto@gmail.com</email></author><title>[PATCH v3] pager: die when paging to non-existing command</title><updated>2024-06-21T23:31:08Z</updated><link
href="http://lore.kernel.org/git/6850f558-ad20-403a-ae1e-5b9826c53790@gmail.com/"/><id>urn:uuid:d73f260e-2071-9489-86f6-42c0db1d39e1</id><thr:in-reply-to
ref="urn:uuid:d848290f-a8ab-92a9-022a-4bb8538c4787"
href="http://lore.kernel.org/git/0df06a80-723f-4ad7-9f2e-74c8fb5b8283@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">When trying to execute a non-existent program from GIT_PAGER, we display
an error.  However, we also send the complete text to the terminal
and return a successful exit code.  This can be confusing for the user
and the displayed error could easily become obscured by a lengthy
text.

For example, here the error message would be very far above after
sending 50 MB of text:

    $ GIT_PAGER=non-existent t/test-terminal.perl git log | wc -c
    error: cannot run non-existent: No such file or directory
    50314363

Let&#39;s make the error clear by aborting the process and return an error
so that the user can easily correct their mistake.

This will be the result of the change:

    $ GIT_PAGER=non-existent t/test-terminal.perl git log | wc -c
    error: cannot run non-existent: No such file or directory
    fatal: unable to start the pager: &#39;non-existent&#39;
    0

The behavior change we&#39;re introducing in this commit affects two tests
in t7006, which is a good sign regarding test coverage and requires us
to address it.

The first test is &#39;git skips paging non-existing command&#39;.  This test
comes from f7991f01f2 (t7006: clean up SIGPIPE handling in trace2 tests,
2021-11-21,) where a modification was made to a test that was originally
introduced in c24b7f6736 (pager: test for exit code with and without
SIGPIPE, 2021-02-02).  That original test was, IMHO, in the same
direction we&#39;re going in this commit.

At any rate, this test obviously needs to be adjusted to check the new
behavior we are introducing.  Do it.

The second test being affected is: &#39;non-existent pager doesnt cause
crash&#39;, introduced in f917f57f40 (pager: fix crash when pager program
doesn&#39;t exist, 2021-11-24).  As its name states, it has the intention of
checking that we don&#39;t introduce a regression that produces a crash when
GIT_PAGER points to a nonexistent program.

This test could be considered redundant nowadays, due to us already
having several tests checking implicitly what a non-existent command in
GIT_PAGER produces.  However, let&#39;s maintain a good belt-and-suspenders
strategy; adapt it to the new world.

Finally, it&#39;s worth noting that we are not changing the behavior if the
command specified in GIT_PAGER is a shell command.  In such cases, it
is:

    $ GIT_PAGER=:\;non-existent t/test-terminal.perl git log
    :;non-existent: 1: non-existent: not found
    died of signal 13 at t/test-terminal.perl line 33.

Signed-off-by: Rub&#233;n Justo &lt;rjusto@gmail.com&gt;
---

This is a response to
<a
href="https://lore.kernel.org/git/xmqqed8pkhkn.fsf@gitster.g/">https://lore.kernel.org/git/xmqqed8pkhkn.fsf@gitster.g/</a>

Range-diff against v2:
1:  95a2f36d18 ! 1:  60e852bffb pager: die when paging to non-existing command
    @@ Commit message
         Signed-off-by: Rub&#233;n Justo &lt;rjusto@gmail.com&gt;
     
      ## pager.c ##
    -@@
    - #include &#34;git-compat-util.h&#34;
    - #include &#34;config.h&#34;
    - #include &#34;editor.h&#34;
    -+#include &#34;gettext.h&#34;
    - #include &#34;pager.h&#34;
    - #include &#34;run-command.h&#34;
    - #include &#34;sigchain.h&#34;
     @@ pager.c: void setup_pager(void)
      	pager_process.in = -1;
      	strvec_push(&#38;pager_process.env, &#34;GIT_PAGER_IN_USE&#34;);
      	if (start_command(&#38;pager_process))
     -		return;
    -+		die(_(&#34;unable to execute pager &#39;%s&#39;&#34;), pager);
    ++		die(&#34;unable to execute pager &#39;%s&#39;&#34;, pager);
      
      	/* original process continues, but writes to the pipe */
      	dup2(pager_process.in, 1);

 pager.c          |  2 +-
 t/t7006-pager.sh | 17 +++++------------
 2 files <a href="http://lore.kernel.org/git/6850f558-ad20-403a-ae1e-5b9826c53790@gmail.com/#related">changed</a>, 6 insertions(+), 13 deletions(-)

<span
class="head">diff --git a/pager.c b/pager.c
index e9e121db69..be6f4ee59f 100644
--- a/pager.c
+++ b/pager.c
</span><span
class="hunk">@@ -137,7 +137,7 @@ void setup_pager(void)
</span> 	pager_process.in = -1;
 	strvec_push(&#38;pager_process.env, &#34;GIT_PAGER_IN_USE&#34;);
 	if (start_command(&#38;pager_process))
<span
class="del">-		return;
</span><span
class="add">+		die(&#34;unable to execute pager &#39;%s&#39;&#34;, pager);
</span> 
 	/* original process continues, but writes to the pipe */
 	dup2(pager_process.in, 1);
<span
class="head">diff --git a/t/t7006-pager.sh b/t/t7006-pager.sh
index e56ca5b0fa..932c26cb45 100755
--- a/t/t7006-pager.sh
+++ b/t/t7006-pager.sh
</span><span
class="hunk">@@ -725,18 +725,11 @@ test_expect_success TTY &#39;git discards pager non-zero exit without SIGPIPE&#39; &#39;
</span> 	test_path_is_file pager-used
 &#39;
 
<span
class="del">-test_expect_success TTY &#39;git skips paging nonexisting command&#39; &#39;
-	test_when_finished &#34;rm trace.normal&#34; &#38;&#38;
</span><span
class="add">+test_expect_success TTY &#39;git errors when asked to execute nonexisting pager&#39; &#39;
+	test_when_finished &#34;rm -f err&#34; &#38;&#38;
</span> 	test_config core.pager &#34;does-not-exist&#34; &#38;&#38;
<span
class="del">-	GIT_TRACE2=&#34;$(pwd)/trace.normal&#34; &#38;&#38;
-	export GIT_TRACE2 &#38;&#38;
-	test_when_finished &#34;unset GIT_TRACE2&#34; &#38;&#38;
-
-	test_terminal git log &#38;&#38;
-
-	grep child_exit trace.normal &gt;child-exits &#38;&#38;
-	test_line_count = 1 child-exits &#38;&#38;
-	grep &#34; code:-1 &#34; child-exits
</span><span
class="add">+	test_must_fail test_terminal git log 2&gt;err &#38;&#38;
+	test_grep &#34;unable to execute pager&#34; err
</span> &#39;
 
 test_expect_success TTY &#39;git returns SIGPIPE on propagated signals from pager&#39; &#39;
<span
class="hunk">@@ -762,7 +755,7 @@ test_expect_success TTY &#39;git returns SIGPIPE on propagated signals from pager&#39; &#39;
</span> 
 test_expect_success TTY &#39;non-existent pager doesnt cause crash&#39; &#39;
 	test_config pager.show invalid-pager &#38;&#38;
<span
class="del">-	test_terminal git show
</span><span
class="add">+	test_must_fail test_terminal git show
</span> &#39;
 
 test_done
-- 
2.45.1
</pre></div></content></entry><entry><author><name>Junio C Hamano</name><email>gitster@pobox.com</email></author><title>[PATCH 4/5] patch-id: rewrite code that detects the beginning of a patch</title><updated>2024-06-21T23:18:45Z</updated><link
href="http://lore.kernel.org/git/20240621231826.3280338-5-gitster@pobox.com/"/><id>urn:uuid:8b4e221b-b485-6dec-9be6-3141cdbed4f5</id><thr:in-reply-to
ref="urn:uuid:75be9119-0d73-6e50-b8ef-76503bd4a0d2"
href="http://lore.kernel.org/git/20240621231826.3280338-1-gitster@pobox.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The get_one_patchid() function reads input lines until it finds a
patch header (the line that begins a patch), whose beginning is one
of:

 (1) an &#34;&lt;object name&gt;&#34;, which is &#34;git diff-tree --stdin&#34; shows;
 (2) &#34;commit &lt;object name&gt;&#34;, which is &#34;git log&#34; shows; or
 (3) &#34;From &lt;object name&gt;&#34;,  which is &#34;git log --format=email&#34; gives.

When it finds such a line, it returns to the caller, reporting the
&lt;object name&gt; it found, and the size of the &#34;patch&#34; it processed.

The caller then calls the function again, which then ignores the
commit log message, and then processes the lines in the patch part
until it hits another &#34;beginning of a patch&#34;.

The above logic was fairly easy to see until 2bb73ae8 (patch-id: use
starts_with() and skip_prefix(), 2016-05-28) reorganized the code,
which made another logic that has nothing to do with the &#34;where does
the next patch begin?&#34; logic, which came from 2485eab5
(git-patch-id: do not trip over &#34;no newline&#34; markers, 2011-02-17)
that ignores the &#34;\ No newline at the end&#34;, rolled into the same
single if() statement.

Let&#39;s split it out.  The &#34;\ No newline at the end&#34; marker is part of
the patch, should not appear before we start reading the patch part,
and does not belong to the detection of patch header.

Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
---
 builtin/patch-id.c | 29 +++++++++++++++++++++--------
 1 file <a href="http://lore.kernel.org/git/20240621231826.3280338-5-gitster@pobox.com/#related">changed</a>, 21 insertions(+), 8 deletions(-)

<span
class="head">diff --git a/builtin/patch-id.c b/builtin/patch-id.c
index 128e0997d8..a649966f31 100644
--- a/builtin/patch-id.c
+++ b/builtin/patch-id.c
</span><span
class="hunk">@@ -80,16 +80,19 @@ static int get_one_patchid(struct object_id *next_oid, struct object_id *result,
</span> 		const char *p = line;
 		int len;
 
<span
class="del">-		/* Possibly skip over the prefix added by &#34;log&#34; or &#34;format-patch&#34; */
-		if (!skip_prefix(line, &#34;commit &#34;, &#38;p) &#38;&#38;
-		    !skip_prefix(line, &#34;From &#34;, &#38;p) &#38;&#38;
-		    starts_with(line, &#34;\\ &#34;) &#38;&#38; 12 &lt; strlen(line)) {
</span><span
class="add">+		/*
+		 * If we see a line that begins with &#34;&lt;object name&gt;&#34;,
+		 * &#34;commit &lt;object name&gt;&#34; or &#34;From &lt;object name&gt;&#34;, it is
+		 * the beginning of a patch.  Return to the caller, as
+		 * we are done with the one we have been processing.
+		 */
+		if (skip_prefix(line, &#34;commit &#34;, &#38;p))
+			;
+		else if (skip_prefix(line, &#34;From &#34;, &#38;p))
+			;
+		if (!get_oid_hex(p, next_oid)) {
</span> 			if (verbatim)
 				the_hash_algo-&gt;update_fn(&#38;ctx, line, strlen(line));
<span
class="del">-			continue;
-		}
-
-		if (!get_oid_hex(p, next_oid)) {
</span> 			found_next = 1;
 			break;
 		}
<span
class="hunk">@@ -130,6 +133,16 @@ static int get_one_patchid(struct object_id *next_oid, struct object_id *result,
</span> 				break;
 		}
 
<span
class="add">+		/*
+		 * A hunk about an incomplete line may have this
+		 * marker at the end, which should just be ignored.
+		 */
+		if (starts_with(line, &#34;\\ &#34;) &#38;&#38; 12 &lt; strlen(line)) {
+			if (verbatim)
+				the_hash_algo-&gt;update_fn(&#38;ctx, line, strlen(line));
+			continue;
+		}
+
</span> 		if (diff_is_binary) {
 			if (starts_with(line, &#34;diff &#34;)) {
 				diff_is_binary = 0;
-- 
2.45.2-786-g49444cbe9a

</pre></div></content></entry><entry><author><name>Junio C Hamano</name><email>gitster@pobox.com</email></author><title>[PATCH 5/5] patch-id: tighten code to detect the patch header</title><updated>2024-06-21T23:18:43Z</updated><link
href="http://lore.kernel.org/git/20240621231826.3280338-6-gitster@pobox.com/"/><id>urn:uuid:9507820d-9fb2-ca02-3c57-dcd3f0ecdc2b</id><thr:in-reply-to
ref="urn:uuid:75be9119-0d73-6e50-b8ef-76503bd4a0d2"
href="http://lore.kernel.org/git/20240621231826.3280338-1-gitster@pobox.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The get_one_patchid() function unconditionally takes a line that
matches the patch header (namely, a line that begins with a full
object name, possibly prefixed by &#34;commit&#34; or &#34;From&#34; plus a space)
as the beginning of a patch.  Even when it is *not* looking for one
(namely, when the previous call found the patch header and returned,
and then we are called again to skip the log message and process the
patch whose header was found by the previous invocation).

As a consequence, a line in the commit log message that begins with
one of these patterns can be mistaken to start another patch, with
current message entirely skipped (because we haven&#39;t even reached
the patch at all).

Allow the caller to tell us if it called us already and saw the
patch header (in which case we shouldn&#39;t be looking for another one,
until we see the &#34;diff&#34; part of the patch; instead we simply should
be skipping these lines as part of the commit log message), and skip
the header processing logic when that is the case.  In the helper
function, it also needs to flip this &#34;are we looking for a header?&#34;
bit, once it finished skipping the commit log message and started
processing the patches, as the patch header of the _next_ message is
the only clue in the input that the current patch is done.

Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
---
 builtin/patch-id.c  | 43 ++++++++++++++++++++++++++++++-------------
 t/t4204-patch-id.sh | 17 +++++++++++++++++
 2 files <a href="http://lore.kernel.org/git/20240621231826.3280338-6-gitster@pobox.com/#related">changed</a>, 47 insertions(+), 13 deletions(-)

<span
class="head">diff --git a/builtin/patch-id.c b/builtin/patch-id.c
index a649966f31..0e6aab1ca2 100644
--- a/builtin/patch-id.c
+++ b/builtin/patch-id.c
</span><span
class="hunk">@@ -60,12 +60,14 @@ static int scan_hunk_header(const char *p, int *p_before, int *p_after)
</span> 
 #define GOPID_STABLE   01
 #define GOPID_VERBATIM 02
<span
class="add">+#define GOPID_FIND_HEADER 04
</span> 
 static int get_one_patchid(struct object_id *next_oid, struct object_id *result,
 			   struct strbuf *line_buf, unsigned flags)
 {
 	int stable = flags &#38; GOPID_STABLE;
 	int verbatim = flags &#38; GOPID_VERBATIM;
<span
class="add">+	int find_header = flags &#38; GOPID_FIND_HEADER;
</span> 	int patchlen = 0, found_next = 0;
 	int before = -1, after = -1;
 	int diff_is_binary = 0;
<span
class="hunk">@@ -81,26 +83,39 @@ static int get_one_patchid(struct object_id *next_oid, struct object_id *result,
</span> 		int len;
 
 		/*
<span
class="del">-		 * If we see a line that begins with &#34;&lt;object name&gt;&#34;,
-		 * &#34;commit &lt;object name&gt;&#34; or &#34;From &lt;object name&gt;&#34;, it is
-		 * the beginning of a patch.  Return to the caller, as
-		 * we are done with the one we have been processing.
</span><span
class="add">+		 * The caller hasn&#39;t seen us find a patch header and
+		 * return to it, or we have started processing patch
+		 * and may encounter the beginning of the next patch.
</span> 		 */
<span
class="del">-		if (skip_prefix(line, &#34;commit &#34;, &#38;p))
-			;
-		else if (skip_prefix(line, &#34;From &#34;, &#38;p))
-			;
-		if (!get_oid_hex(p, next_oid)) {
-			if (verbatim)
-				the_hash_algo-&gt;update_fn(&#38;ctx, line, strlen(line));
-			found_next = 1;
-			break;
</span><span
class="add">+		if (find_header) {
+			/*
+			 * If we see a line that begins with &#34;&lt;object name&gt;&#34;,
+			 * &#34;commit &lt;object name&gt;&#34; or &#34;From &lt;object name&gt;&#34;, it is
+			 * the beginning of a patch.  Return to the caller, as
+			 * we are done with the one we have been processing.
+			 */
+			if (skip_prefix(line, &#34;commit &#34;, &#38;p))
+				;
+			else if (skip_prefix(line, &#34;From &#34;, &#38;p))
+				;
+			if (!get_oid_hex(p, next_oid)) {
+				if (verbatim)
+					the_hash_algo-&gt;update_fn(&#38;ctx, line, strlen(line));
+				found_next = 1;
+				break;
+			}
</span> 		}
 
 		/* Ignore commit comments */
 		if (!patchlen &#38;&#38; !starts_with(line, &#34;diff &#34;))
 			continue;
 
<span
class="add">+		/*
+		 * We are past the commit log message.  Prepare to
+		 * stop at the beginning of the next patch header.
+		 */
+		find_header = 1;
+
</span> 		/* Parsing diff header?  */
 		if (before == -1) {
 			if (starts_with(line, &#34;GIT binary patch&#34;) ||
<span
class="hunk">@@ -196,11 +211,13 @@ static void generate_id_list(unsigned flags)
</span> 	struct strbuf line_buf = STRBUF_INIT;
 
 	oidclr(&#38;oid);
<span
class="add">+	flags |= GOPID_FIND_HEADER;
</span> 	while (!feof(stdin)) {
 		patchlen = get_one_patchid(&#38;n, &#38;result, &#38;line_buf, flags);
 		if (patchlen)
 			flush_current_id(&#38;oid, &#38;result);
 		oidcpy(&#38;oid, &#38;n);
<span
class="add">+		flags &#38;= ~GOPID_FIND_HEADER;
</span> 	}
 	strbuf_release(&#38;line_buf);
 }
<span
class="head">diff --git a/t/t4204-patch-id.sh b/t/t4204-patch-id.sh
index 1627fdda1b..b1d98d4110 100755
--- a/t/t4204-patch-id.sh
+++ b/t/t4204-patch-id.sh
</span><span
class="hunk">@@ -137,6 +137,23 @@ test_expect_success &#39;patch-id computes the same for various formats&#39; &#39;
</span> 	test_cmp actual expect
 &#39;
 
<span
class="add">+hash=$(git rev-parse same:)
+for cruft in &#34;$hash&#34; &#34;commit $hash is bad&#34; &#34;From $hash status&#34;
+do
+	test_expect_success &#34;patch-id with &lt;$cruft&gt; in log message&#34; &#39;
+		git format-patch -1 --stdout same &gt;patch-0 &#38;&#38;
+		git patch-id &lt;patch-0 &gt;expect &#38;&#38;
+
+		{
+			sed -e &#34;/^$/q&#34; patch-0 &#38;&#38;
+			printf &#34;random message\n%s\n\n&#34; &#34;$cruft&#34; &#38;&#38;
+			sed -e &#34;1,/^$/d&#34; patch-0
+		} &gt;patch-cruft &#38;&#38;
+		git patch-id &lt;patch-cruft &gt;actual &#38;&#38;
+		test_cmp actual expect
+	&#39;
+done
+
</span> test_expect_success &#39;whitespace is irrelevant in footer&#39; &#39;
 	get_patch_id main &#38;&#38;
 	git checkout same &#38;&#38;
-- 
2.45.2-786-g49444cbe9a

</pre></div></content></entry><entry><author><name>Junio C Hamano</name><email>gitster@pobox.com</email></author><title>[PATCH 3/5] patch-id: make get_one_patchid() more extensible</title><updated>2024-06-21T23:18:38Z</updated><link
href="http://lore.kernel.org/git/20240621231826.3280338-4-gitster@pobox.com/"/><id>urn:uuid:d09358af-609c-12ba-c280-b3ddbb7be643</id><thr:in-reply-to
ref="urn:uuid:75be9119-0d73-6e50-b8ef-76503bd4a0d2"
href="http://lore.kernel.org/git/20240621231826.3280338-1-gitster@pobox.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">We pass two independent Boolean flags (i.e. do we want the stable
variant of patch-id?  do we want to hash the stuff verbatim?) into
the function as two separate parameters.  Before adding the third
one and make the interface even wider, let&#39;s consolidate them into
a single flag word.

No changes in behaviour.  Just a trivial interface change.

Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
---
 builtin/patch-id.c | 20 +++++++++++++++-----
 1 file <a href="http://lore.kernel.org/git/20240621231826.3280338-4-gitster@pobox.com/#related">changed</a>, 15 insertions(+), 5 deletions(-)

<span
class="head">diff --git a/builtin/patch-id.c b/builtin/patch-id.c
index 0f262e7a03..128e0997d8 100644
--- a/builtin/patch-id.c
+++ b/builtin/patch-id.c
</span><span
class="hunk">@@ -58,9 +58,14 @@ static int scan_hunk_header(const char *p, int *p_before, int *p_after)
</span> 	return 1;
 }
 
<span
class="add">+#define GOPID_STABLE   01
+#define GOPID_VERBATIM 02
+
</span> static int get_one_patchid(struct object_id *next_oid, struct object_id *result,
<span
class="del">-			   struct strbuf *line_buf, int stable, int verbatim)
</span><span
class="add">+			   struct strbuf *line_buf, unsigned flags)
</span> {
<span
class="add">+	int stable = flags &#38; GOPID_STABLE;
+	int verbatim = flags &#38; GOPID_VERBATIM;
</span> 	int patchlen = 0, found_next = 0;
 	int before = -1, after = -1;
 	int diff_is_binary = 0;
<span
class="hunk">@@ -171,7 +176,7 @@ static int get_one_patchid(struct object_id *next_oid, struct object_id *result,
</span> 	return patchlen;
 }
 
<span
class="del">-static void generate_id_list(int stable, int verbatim)
</span><span
class="add">+static void generate_id_list(unsigned flags)
</span> {
 	struct object_id oid, n, result;
 	int patchlen;
<span
class="hunk">@@ -179,7 +184,7 @@ static void generate_id_list(int stable, int verbatim)
</span> 
 	oidclr(&#38;oid);
 	while (!feof(stdin)) {
<span
class="del">-		patchlen = get_one_patchid(&#38;n, &#38;result, &#38;line_buf, stable, verbatim);
</span><span
class="add">+		patchlen = get_one_patchid(&#38;n, &#38;result, &#38;line_buf, flags);
</span> 		if (patchlen)
 			flush_current_id(&#38;oid, &#38;result);
 		oidcpy(&#38;oid, &#38;n);
<span
class="hunk">@@ -218,6 +223,7 @@ int cmd_patch_id(int argc, const char **argv, const char *prefix)
</span> 	/* if nothing is set, default to unstable */
 	struct patch_id_opts config = {0, 0};
 	int opts = 0;
<span
class="add">+	unsigned flags = 0;
</span> 	struct option builtin_patch_id_options[] = {
 		OPT_CMDMODE(0, &#34;unstable&#34;, &#38;opts,
 		    N_(&#34;use the unstable patch-id algorithm&#34;), 1),
<span
class="hunk">@@ -237,7 +243,11 @@ int cmd_patch_id(int argc, const char **argv, const char *prefix)
</span> 	argc = parse_options(argc, argv, prefix, builtin_patch_id_options,
 			     patch_id_usage, 0);
 
<span
class="del">-	generate_id_list(opts ? opts &gt; 1 : config.stable,
-			 opts ? opts == 3 : config.verbatim);
</span><span
class="add">+	if (opts ? opts &gt; 1 : config.stable)
+		flags |= GOPID_STABLE;
+	if (opts ? opts == 3 : config.verbatim)
+		flags |= GOPID_VERBATIM;
+	generate_id_list(flags);
+
</span> 	return 0;
 }
-- 
2.45.2-786-g49444cbe9a

</pre></div></content></entry><entry><author><name>Junio C Hamano</name><email>gitster@pobox.com</email></author><title>[PATCH 2/5] patch-id: call flush_current_id() only when needed</title><updated>2024-06-21T23:18:36Z</updated><link
href="http://lore.kernel.org/git/20240621231826.3280338-3-gitster@pobox.com/"/><id>urn:uuid:9d765294-ca29-f9c4-6d5a-be711c4e8923</id><thr:in-reply-to
ref="urn:uuid:75be9119-0d73-6e50-b8ef-76503bd4a0d2"
href="http://lore.kernel.org/git/20240621231826.3280338-1-gitster@pobox.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The caller passes a flag that is used to become no-op when calling
flush_current_id().  Instead of calling something that becomes a
no-op, teach the caller not to call it in the first place.

Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
---
 builtin/patch-id.c | 8 ++++----
 1 file <a href="http://lore.kernel.org/git/20240621231826.3280338-3-gitster@pobox.com/#related">changed</a>, 4 insertions(+), 4 deletions(-)

<span
class="head">diff --git a/builtin/patch-id.c b/builtin/patch-id.c
index 3894d2b970..0f262e7a03 100644
--- a/builtin/patch-id.c
+++ b/builtin/patch-id.c
</span><span
class="hunk">@@ -6,10 +6,9 @@
</span> #include &#34;hex.h&#34;
 #include &#34;parse-options.h&#34;
 
<span
class="del">-static void flush_current_id(int patchlen, struct object_id *id, struct object_id *result)
</span><span
class="add">+static void flush_current_id(struct object_id *id, struct object_id *result)
</span> {
<span
class="del">-	if (patchlen)
-		printf(&#34;%s %s\n&#34;, oid_to_hex(result), oid_to_hex(id));
</span><span
class="add">+	printf(&#34;%s %s\n&#34;, oid_to_hex(result), oid_to_hex(id));
</span> }
 
 static int remove_space(char *line)
<span
class="hunk">@@ -181,7 +180,8 @@ static void generate_id_list(int stable, int verbatim)
</span> 	oidclr(&#38;oid);
 	while (!feof(stdin)) {
 		patchlen = get_one_patchid(&#38;n, &#38;result, &#38;line_buf, stable, verbatim);
<span
class="del">-		flush_current_id(patchlen, &#38;oid, &#38;result);
</span><span
class="add">+		if (patchlen)
+			flush_current_id(&#38;oid, &#38;result);
</span> 		oidcpy(&#38;oid, &#38;n);
 	}
 	strbuf_release(&#38;line_buf);
-- 
2.45.2-786-g49444cbe9a

</pre></div></content></entry><entry><author><name>Junio C Hamano</name><email>gitster@pobox.com</email></author><title>[PATCH 1/5] t4204: patch-id supports various input format</title><updated>2024-06-21T23:18:30Z</updated><link
href="http://lore.kernel.org/git/20240621231826.3280338-2-gitster@pobox.com/"/><id>urn:uuid:97ab9714-8731-6f6c-32f0-bf37eac2455d</id><thr:in-reply-to
ref="urn:uuid:75be9119-0d73-6e50-b8ef-76503bd4a0d2"
href="http://lore.kernel.org/git/20240621231826.3280338-1-gitster@pobox.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">&#34;git patch-id&#34; was first developed to read from &#34;git diff-tree
--stdin -p&#34; output.  Later it was enhanced to read from &#34;git
diff-tree --stdin -p -v&#34;, which was the downstream of an early
imitation of &#34;git log&#34; (&#34;git rev-list&#34; run in the upstream of a pipe
to feed the &#34;diff-tree&#34;).  These days, we also read from &#34;git
format-patch&#34;.

Their output begins slightly differently, but the patch-id computed
over them for the same commit should be the same.  Ensure that we
won&#39;t accidentally break this expectation.

Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
---
 t/t4204-patch-id.sh | 23 +++++++++++++++++++++++
 1 file <a href="http://lore.kernel.org/git/20240621231826.3280338-2-gitster@pobox.com/#related">changed</a>, 23 insertions(+)

<span
class="head">diff --git a/t/t4204-patch-id.sh b/t/t4204-patch-id.sh
index a7fa94ce0a..1627fdda1b 100755
--- a/t/t4204-patch-id.sh
+++ b/t/t4204-patch-id.sh
</span><span
class="hunk">@@ -114,6 +114,29 @@ test_expect_success &#39;patch-id supports git-format-patch output&#39; &#39;
</span> 	test &#34;$2&#34; = $(git rev-parse HEAD)
 &#39;
 
<span
class="add">+test_expect_success &#39;patch-id computes the same for various formats&#39; &#39;
+	# This test happens to consider &#34;git log -p -1&#34; output
+	# the canonical input format, so use it as the norm.
+	git log -1 -p same &gt;log-p.output &#38;&#38;
+	git patch-id &lt;log-p.output &gt;expect &#38;&#38;
+
+	# format-patch begins with &#34;From &lt;commit object name&gt;&#34;
+	git format-patch -1 --stdout same &gt;format-patch.output &#38;&#38;
+	git patch-id &lt;format-patch.output &gt;actual &#38;&#38;
+	test_cmp actual expect &#38;&#38;
+
+	# &#34;diff-tree --stdin -p&#34; begins with &#34;&lt;commit object name&gt;&#34;
+	same=$(git rev-parse same) &#38;&#38;
+	echo $same | git diff-tree --stdin -p &gt;diff-tree.output &#38;&#38;
+	git patch-id &lt;diff-tree.output &gt;actual &#38;&#38;
+	test_cmp actual expect &#38;&#38;
+
+	# &#34;diff-tree --stdin -v -p&#34; begins with &#34;commit &lt;commit object name&gt;&#34;
+	echo $same | git diff-tree --stdin -p -v &gt;diff-tree-v.output &#38;&#38;
+	git patch-id &lt;diff-tree-v.output &gt;actual &#38;&#38;
+	test_cmp actual expect
+&#39;
+
</span> test_expect_success &#39;whitespace is irrelevant in footer&#39; &#39;
 	get_patch_id main &#38;&#38;
 	git checkout same &#38;&#38;
-- 
2.45.2-786-g49444cbe9a

</pre></div></content></entry><entry><author><name>Junio C Hamano</name><email>gitster@pobox.com</email></author><title>[PATCH 0/5] Tighten patch header parsing in patch-id</title><updated>2024-06-21T23:18:29Z</updated><link
href="http://lore.kernel.org/git/20240621231826.3280338-1-gitster@pobox.com/"/><id>urn:uuid:75be9119-0d73-6e50-b8ef-76503bd4a0d2</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The patch-id command loops over a series of patches, picking up the
origin commit object name (which is on the &#34;patch header&#34; line) and
then computing the patch identifier out of the &#34;patch&#34; (series of
&#34;diff&#34;) that follows the &#34;patch header&#34;.

The parser is structured in a bit &#34;strange&#34; way.  It repeatedly
calls a single helper function get_one_patchid() that returns when a
patch header is recognised, or skips until the &#34;patch&#34; part begins
and then computes the &#34;patch id&#34; over the &#34;patch&#34; part, until it
sees a patch header.  The caller knows that it gets just the &#34;patch
header&#34; for the first patch with its first call, and the second call
is about computing the patch id for the first patch, whose
originating commit was obtained from the first call, etc.

During the second and subsequent call (i.e. after finding a patch
header which caused the get_one_patchid() to return, calling the
helper again, expecting it to skip the commit log and find the patch
for which we are asked to compute the patch id), we shouldn&#39;t look
for the patch header at all.  Otherwise, a line that looks like a
patch header in the log message can easily be mistaken to be the
beginning of a new patch header, as if the current message did not
have any patch text.

This 5-patch series is organized as follows:

 - patch 1 is about setting the baseline.  We need to recognise the
   patch header produced by format-patch, log, and diff-tree --stdin.

 - patch 2 to patch 4 are bit of code restructuring without changing
   the behaviour.

 - patch 5 stops looking for a patch header when we shouldn&#39;t, and
   adds tests.

Junio C Hamano (5):
  t4204: patch-id supports various input format
  patch-id: call flush_current_id() only when needed
  patch-id: make get_one_patchid() more extensible
  patch-id: rewrite code that detects the beginning of a patch
  patch-id: tighten code to detect the patch header

 builtin/patch-id.c  | 82 +++++++++++++++++++++++++++++++++------------
 t/t4204-patch-id.sh | 40 ++++++++++++++++++++++
 2 files changed, 101 insertions(+), 21 deletions(-)

-- 
2.45.2-786-g49444cbe9a

</pre></div></content></entry><entry><author><name>Rub&#233;n Justo</name><email>rjusto@gmail.com</email></author><title>[PATCH v2] pager: die when paging to non-existing command</title><updated>2024-06-21T21:29:19Z</updated><link
href="http://lore.kernel.org/git/0df06a80-723f-4ad7-9f2e-74c8fb5b8283@gmail.com/"/><id>urn:uuid:d848290f-a8ab-92a9-022a-4bb8538c4787</id><thr:in-reply-to
ref="urn:uuid:c624439a-7bd7-1946-eabe-66791b07f813"
href="http://lore.kernel.org/git/f7106878-5ec5-4fe7-940b-2fb1d9707f7d@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">When trying to execute a non-existent program from GIT_PAGER, we display
an error.  However, we also send the complete text to the terminal
and return a successful exit code.  This can be confusing for the user
and the displayed error could easily become obscured by a lengthy
text.

For example, here the error message would be very far above after
sending 50 MB of text:

    $ GIT_PAGER=non-existent t/test-terminal.perl git log | wc -c
    error: cannot run non-existent: No such file or directory
    50314363

Let&#39;s make the error clear by aborting the process and return an error
so that the user can easily correct their mistake.

This will be the result of the change:

    $ GIT_PAGER=non-existent t/test-terminal.perl git log | wc -c
    error: cannot run non-existent: No such file or directory
    fatal: unable to start the pager: &#39;non-existent&#39;
    0

The behavior change we&#39;re introducing in this commit affects two tests
in t7006, which is a good sign regarding test coverage and requires us
to address it.

The first test is &#39;git skips paging non-existing command&#39;.  This test
comes from f7991f01f2 (t7006: clean up SIGPIPE handling in trace2 tests,
2021-11-21,) where a modification was made to a test that was originally
introduced in c24b7f6736 (pager: test for exit code with and without
SIGPIPE, 2021-02-02).  That original test was, IMHO, in the same
direction we&#39;re going in this commit.

At any rate, this test obviously needs to be adjusted to check the new
behavior we are introducing.  Do it.

The second test being affected is: &#39;non-existent pager doesnt cause
crash&#39;, introduced in f917f57f40 (pager: fix crash when pager program
doesn&#39;t exist, 2021-11-24).  As its name states, it has the intention of
checking that we don&#39;t introduce a regression that produces a crash when
GIT_PAGER points to a nonexistent program.

This test could be considered redundant nowadays, due to us already
having several tests checking implicitly what a non-existent command in
GIT_PAGER produces.  However, let&#39;s maintain a good belt-and-suspenders
strategy; adapt it to the new world.

Finally, it&#39;s worth noting that we are not changing the behavior if the
command specified in GIT_PAGER is a shell command.  In such cases, it
is:

    $ GIT_PAGER=:\;non-existent t/test-terminal.perl git log
    :;non-existent: 1: non-existent: not found
    died of signal 13 at t/test-terminal.perl line 33.

Signed-off-by: Rub&#233;n Justo &lt;rjusto@gmail.com&gt;
---

This iteration, v2, is just to &#34;revert&#34; to the original error message
lost by ea27a18c. 

For those not yet used to it, the range-diff is at the end of the
message. ;)

Thanks!


 pager.c          |  3 ++-
 t/t7006-pager.sh | 17 +++++------------
 2 files <a href="http://lore.kernel.org/git/0df06a80-723f-4ad7-9f2e-74c8fb5b8283@gmail.com/#related">changed</a>, 7 insertions(+), 13 deletions(-)

<span
class="head">diff --git a/pager.c b/pager.c
index e9e121db69..f5b6dc9b60 100644
--- a/pager.c
+++ b/pager.c
</span><span
class="hunk">@@ -1,6 +1,7 @@
</span> #include &#34;git-compat-util.h&#34;
 #include &#34;config.h&#34;
 #include &#34;editor.h&#34;
<span
class="add">+#include &#34;gettext.h&#34;
</span> #include &#34;pager.h&#34;
 #include &#34;run-command.h&#34;
 #include &#34;sigchain.h&#34;
<span
class="hunk">@@ -137,7 +138,7 @@ void setup_pager(void)
</span> 	pager_process.in = -1;
 	strvec_push(&#38;pager_process.env, &#34;GIT_PAGER_IN_USE&#34;);
 	if (start_command(&#38;pager_process))
<span
class="del">-		return;
</span><span
class="add">+		die(_(&#34;unable to execute pager &#39;%s&#39;&#34;), pager);
</span> 
 	/* original process continues, but writes to the pipe */
 	dup2(pager_process.in, 1);
<span
class="head">diff --git a/t/t7006-pager.sh b/t/t7006-pager.sh
index e56ca5b0fa..932c26cb45 100755
--- a/t/t7006-pager.sh
+++ b/t/t7006-pager.sh
</span><span
class="hunk">@@ -725,18 +725,11 @@ test_expect_success TTY &#39;git discards pager non-zero exit without SIGPIPE&#39; &#39;
</span> 	test_path_is_file pager-used
 &#39;
 
<span
class="del">-test_expect_success TTY &#39;git skips paging nonexisting command&#39; &#39;
-	test_when_finished &#34;rm trace.normal&#34; &#38;&#38;
</span><span
class="add">+test_expect_success TTY &#39;git errors when asked to execute nonexisting pager&#39; &#39;
+	test_when_finished &#34;rm -f err&#34; &#38;&#38;
</span> 	test_config core.pager &#34;does-not-exist&#34; &#38;&#38;
<span
class="del">-	GIT_TRACE2=&#34;$(pwd)/trace.normal&#34; &#38;&#38;
-	export GIT_TRACE2 &#38;&#38;
-	test_when_finished &#34;unset GIT_TRACE2&#34; &#38;&#38;
-
-	test_terminal git log &#38;&#38;
-
-	grep child_exit trace.normal &gt;child-exits &#38;&#38;
-	test_line_count = 1 child-exits &#38;&#38;
-	grep &#34; code:-1 &#34; child-exits
</span><span
class="add">+	test_must_fail test_terminal git log 2&gt;err &#38;&#38;
+	test_grep &#34;unable to execute pager&#34; err
</span> &#39;
 
 test_expect_success TTY &#39;git returns SIGPIPE on propagated signals from pager&#39; &#39;
<span
class="hunk">@@ -762,7 +755,7 @@ test_expect_success TTY &#39;git returns SIGPIPE on propagated signals from pager&#39; &#39;
</span> 
 test_expect_success TTY &#39;non-existent pager doesnt cause crash&#39; &#39;
 	test_config pager.show invalid-pager &#38;&#38;
<span
class="del">-	test_terminal git show
</span><span
class="add">+	test_must_fail test_terminal git show
</span> &#39;
 
 test_done

Range-diff against v1:
1:  5c7997810c ! 1:  95a2f36d18 pager: die when paging to non-existing command
    @@ Commit message
         Signed-off-by: Rub&#233;n Justo &lt;rjusto@gmail.com&gt;
     
      ## pager.c ##
    +@@
    + #include &#34;git-compat-util.h&#34;
    + #include &#34;config.h&#34;
    + #include &#34;editor.h&#34;
    ++#include &#34;gettext.h&#34;
    + #include &#34;pager.h&#34;
    + #include &#34;run-command.h&#34;
    + #include &#34;sigchain.h&#34;
     @@ pager.c: void setup_pager(void)
      	pager_process.in = -1;
      	strvec_push(&#38;pager_process.env, &#34;GIT_PAGER_IN_USE&#34;);
      	if (start_command(&#38;pager_process))
     -		return;
    -+		die(&#34;unable to start the pager: &#39;%s&#39;&#34;, pager);
    ++		die(_(&#34;unable to execute pager &#39;%s&#39;&#34;), pager);
      
      	/* original process continues, but writes to the pipe */
      	dup2(pager_process.in, 1);
    @@ t/t7006-pager.sh: test_expect_success TTY &#39;git discards pager non-zero exit with
     -test_expect_success TTY &#39;git skips paging nonexisting command&#39; &#39;
     -	test_when_finished &#34;rm trace.normal&#34; &#38;&#38;
     +test_expect_success TTY &#39;git errors when asked to execute nonexisting pager&#39; &#39;
    ++	test_when_finished &#34;rm -f err&#34; &#38;&#38;
      	test_config core.pager &#34;does-not-exist&#34; &#38;&#38;
     -	GIT_TRACE2=&#34;$(pwd)/trace.normal&#34; &#38;&#38;
     -	export GIT_TRACE2 &#38;&#38;
    @@ t/t7006-pager.sh: test_expect_success TTY &#39;git discards pager non-zero exit with
     -	grep child_exit trace.normal &gt;child-exits &#38;&#38;
     -	test_line_count = 1 child-exits &#38;&#38;
     -	grep &#34; code:-1 &#34; child-exits
    -+	test_must_fail test_terminal git log
    ++	test_must_fail test_terminal git log 2&gt;err &#38;&#38;
    ++	test_grep &#34;unable to execute pager&#34; err
      &#39;
      
      test_expect_success TTY &#39;git returns SIGPIPE on propagated signals from pager&#39; &#39;
-- 
2.45.2.562.g737041e583
</pre></div></content></entry><entry><author><name>Randall S. Becker</name><email>the.n.e.key@gmail.com</email></author><title>[PATCH v2 1/2] Teach git version --build-options about libcurl</title><updated>2024-06-21T18:10:23Z</updated><link
href="http://lore.kernel.org/git/20240621180947.64419-2-randall.becker@nexbridge.ca/"/><id>urn:uuid:ac4196f2-bf47-1f27-9618-d69a1ea8a045</id><thr:in-reply-to
ref="urn:uuid:b7f580c0-103d-244a-1973-e239c6aa6e03"
href="http://lore.kernel.org/git/20240621180947.64419-1-randall.becker@nexbridge.ca/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This change uses the libcurl LIBCURL_VERSION #define text macro. No
stringification is required for the variable&#39;s use. If the #define
is not present, that version is not reported.

Signed-off-by: Randall S. Becker &lt;rsbecker@nexbridge.com&gt;
---
 help.c | 4 ++++
 1 file <a href="http://lore.kernel.org/git/20240621180947.64419-2-randall.becker@nexbridge.ca/#related">changed</a>, 4 insertions(+)

<span
class="head">diff --git a/help.c b/help.c
index 1d057aa607..bf74e935b9 100644
--- a/help.c
+++ b/help.c
</span><span
class="hunk">@@ -1,4 +1,5 @@
</span> #include &#34;git-compat-util.h&#34;
<span
class="add">+#include &#34;git-curl-compat.h&#34; /* For LIBCURL_VERSION only */
</span> #include &#34;config.h&#34;
 #include &#34;builtin.h&#34;
 #include &#34;exec-cmd.h&#34;
<span
class="hunk">@@ -757,6 +758,9 @@ void get_version_info(struct strbuf *buf, int show_build_options)
</span> 
 		if (fsmonitor_ipc__is_supported())
 			strbuf_addstr(buf, &#34;feature: fsmonitor--daemon\n&#34;);
<span
class="add">+#if defined LIBCURL_VERSION
+		strbuf_addf(buf, &#34;libcurl: %s\n&#34;, LIBCURL_VERSION);
+#endif
</span> 	}
 }
 
-- 
2.43.0

</pre></div></content></entry><entry><author><name>Randall S. Becker</name><email>the.n.e.key@gmail.com</email></author><title>[PATCH v2 2/2] Teach git version --build-options about zlib versions.</title><updated>2024-06-21T18:10:23Z</updated><link
href="http://lore.kernel.org/git/20240621180947.64419-3-randall.becker@nexbridge.ca/"/><id>urn:uuid:db999af2-5d8d-6e9d-c6ea-88763b29368d</id><thr:in-reply-to
ref="urn:uuid:b7f580c0-103d-244a-1973-e239c6aa6e03"
href="http://lore.kernel.org/git/20240621180947.64419-1-randall.becker@nexbridge.ca/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This change uses the zlib ZLIB_VERSION #define text macro. No
stringification is required for the variable&#39;s use. If the #define
is not present, that version is not reported.

Signed-off-by: Randall S. Becker &lt;rsbecker@nexbridge.com&gt;
---
 help.c | 3 +++
 1 file <a href="http://lore.kernel.org/git/20240621180947.64419-3-randall.becker@nexbridge.ca/#related">changed</a>, 3 insertions(+)

<span
class="head">diff --git a/help.c b/help.c
index bf74e935b9..f378750af4 100644
--- a/help.c
+++ b/help.c
</span><span
class="hunk">@@ -760,6 +760,9 @@ void get_version_info(struct strbuf *buf, int show_build_options)
</span> 			strbuf_addstr(buf, &#34;feature: fsmonitor--daemon\n&#34;);
 #if defined LIBCURL_VERSION
 		strbuf_addf(buf, &#34;libcurl: %s\n&#34;, LIBCURL_VERSION);
<span
class="add">+#endif
+#if defined ZLIB_VERSION
+		strbuf_addf(buf, &#34;zlib: %s\n&#34;, ZLIB_VERSION);
</span> #endif
 	}
 }
-- 
2.43.0

</pre></div></content></entry><entry><author><name>Randall S. Becker</name><email>the.n.e.key@gmail.com</email></author><title>[PATCH v2 0/2] Teach git version --build-options about zlib+libcurl</title><updated>2024-06-21T18:10:22Z</updated><link
href="http://lore.kernel.org/git/20240621180947.64419-1-randall.becker@nexbridge.ca/"/><id>urn:uuid:b7f580c0-103d-244a-1973-e239c6aa6e03</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This simple series adds the zlib and libcurl versions, if any, used
during a git build.

As an example, the following is appended to the git version --build-options
report:
	libcurl: 8.7.1
	zlib: 1.3.1

Randall S. Becker (2):
  Teach git version --build-options to know about libcurl versions.
  Teach git version --build-options to know about zlib versions.

 help.c | 7 +++++++
 1 file changed, 7 insertions(+)

-- 
2.43.0

</pre></div></content></entry><entry><author><name>Randall S. Becker</name><email>the.n.e.key@gmail.com</email></author><title>[PATCH v0 1/1] Teach git version --build-options about zlib+libcurl</title><updated>2024-06-21T15:46:28Z</updated><link
href="http://lore.kernel.org/git/20240621154552.62038-2-randall.becker@nexbridge.ca/"/><id>urn:uuid:01550646-3f1c-591a-6960-c4e2f14efce0</id><thr:in-reply-to
ref="urn:uuid:571d17c8-a431-45d2-b673-64195629b343"
href="http://lore.kernel.org/git/20240621154552.62038-1-randall.becker@nexbridge.ca/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This change uses the zlib supplied ZLIB_VERSION #define supplied text
macro and the libcurl LIBCURL_VERSION #define text macro. No
stringification is required for either variable&#39;s use. If either of
the #define is not present, that version is not reported.

Signed-off-by: Randall S. Becker &lt;rsbecker@nexbridge.com&gt;
---
 help.c | 7 +++++++
 1 file <a href="http://lore.kernel.org/git/20240621154552.62038-2-randall.becker@nexbridge.ca/#related">changed</a>, 7 insertions(+)

<span
class="head">diff --git a/help.c b/help.c
index 1d057aa607..f378750af4 100644
--- a/help.c
+++ b/help.c
</span><span
class="hunk">@@ -1,4 +1,5 @@
</span> #include &#34;git-compat-util.h&#34;
<span
class="add">+#include &#34;git-curl-compat.h&#34;
</span> #include &#34;config.h&#34;
 #include &#34;builtin.h&#34;
 #include &#34;exec-cmd.h&#34;
<span
class="hunk">@@ -757,6 +758,12 @@ void get_version_info(struct strbuf *buf, int show_build_options)
</span> 
 		if (fsmonitor_ipc__is_supported())
 			strbuf_addstr(buf, &#34;feature: fsmonitor--daemon\n&#34;);
<span
class="add">+#if defined LIBCURL_VERSION
+		strbuf_addf(buf, &#34;libcurl: %s\n&#34;, LIBCURL_VERSION);
+#endif
+#if defined ZLIB_VERSION
+		strbuf_addf(buf, &#34;zlib: %s\n&#34;, ZLIB_VERSION);
+#endif
</span> 	}
 }
 
-- 
2.43.0

</pre></div></content></entry><entry><author><name>Randall S. Becker</name><email>the.n.e.key@gmail.com</email></author><title>[PATCH v0 0/1] Teach git version --build-options about zlib+libcurl</title><updated>2024-06-21T15:46:27Z</updated><link
href="http://lore.kernel.org/git/20240621154552.62038-1-randall.becker@nexbridge.ca/"/><id>urn:uuid:571d17c8-a431-45d2-b673-64195629b343</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This simple series adds the zlib and libcurl versions, if any, used during a git
build.

As an example, the following is appended to the git version --build-options
report:

        libcurl: 8.7.1
	zlib: 1.3.1

Randall S. Becker (1):
  Teach git version --build-options to know about zlib and libcurl
    versions.

 help.c | 7 +++++++
 1 file changed, 7 insertions(+)

-- 
2.43.0

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 11/11] t-reftable-record: add tests for reftable_log_record_compare_key()</title><updated>2024-06-21T11:58:16Z</updated><link
href="http://lore.kernel.org/git/20240621115708.3626-12-chandrapratap3519@gmail.com/"/><id>urn:uuid:9e033a82-7473-beec-ffa4-dc9b0197538f</id><thr:in-reply-to
ref="urn:uuid:35e5cec5-b4d7-a105-49b4-d31b36613714"
href="http://lore.kernel.org/git/20240621115708.3626-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">reftable_log_record_compare_key() is a function defined by
reftable/record.{c, h} and is used to compare the keys of two
log records when sorting multiple log records using &#39;qsort&#39;.
In the current testing setup, this function is left unexercised.
Add a testing function for the same.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-record.c | 25 +++++++++++++++++++++++++
 1 file <a href="http://lore.kernel.org/git/20240621115708.3626-12-chandrapratap3519@gmail.com/#related">changed</a>, 25 insertions(+)

<span
class="head">diff --git a/t/unit-tests/t-reftable-record.c b/t/unit-tests/t-reftable-record.c
index b949617c88..d480cc438a 100644
--- a/t/unit-tests/t-reftable-record.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -214,6 +214,30 @@ static void test_reftable_log_record_comparison(void)
</span> 		reftable_record_release(&#38;in[i]);
 }
 
<span
class="add">+static void test_reftable_log_record_compare_key(void)
+{
+	struct reftable_log_record logs[14] = { 0 };
+	size_t N = ARRAY_SIZE(logs), i;
+
+	for (i = 0; i &lt; N; i++) {
+		if (i &lt; N / 2) {
+			logs[i].refname = xstrfmt(&#34;%02&#34;PRIuMAX, (uintmax_t)i);
+			logs[i].update_index = i;
+		} else {
+			logs[i].refname = xstrdup(&#34;refs/heads/master&#34;);
+			logs[i].update_index = i;
+		}
+	}
+
+	QSORT(logs, N, reftable_log_record_compare_key);
+
+	for (i = 1; i &lt; N; i++)
+		check(reftable_log_record_compare_key(&#38;logs[i - 1], &#38;logs[i]) &lt; 0);
+
+	for (i = 0; i &lt; N; i++)
+		reftable_log_record_release(&#38;logs[i]);
+}
+
</span> static void test_reftable_log_record_roundtrip(void)
 {
 	struct reftable_log_record in[] = {
<span
class="hunk">@@ -519,6 +543,7 @@ int cmd_main(int argc, const char *argv[])
</span> 	TEST(test_reftable_index_record_comparison(), &#34;comparison operations work on index record&#34;);
 	TEST(test_reftable_obj_record_comparison(), &#34;comparison operations work on obj record&#34;);
 	TEST(test_reftable_ref_record_compare_name(), &#34;reftable_ref_record_compare_name works&#34;);
<span
class="add">+	TEST(test_reftable_log_record_compare_key(), &#34;reftable_log_record_compare_key works&#34;);
</span> 	TEST(test_reftable_log_record_roundtrip(), &#34;record operations work on log record&#34;);
 	TEST(test_reftable_ref_record_roundtrip(), &#34;record operations work on ref record&#34;);
 	TEST(test_varint_roundtrip(), &#34;put_var_int and get_var_int work&#34;);
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 10/11] t-reftable-record: add tests for reftable_ref_record_compare_name()</title><updated>2024-06-21T11:58:13Z</updated><link
href="http://lore.kernel.org/git/20240621115708.3626-11-chandrapratap3519@gmail.com/"/><id>urn:uuid:f75df4ac-acd4-85cd-98d9-ed0758305dc5</id><thr:in-reply-to
ref="urn:uuid:35e5cec5-b4d7-a105-49b4-d31b36613714"
href="http://lore.kernel.org/git/20240621115708.3626-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">reftable_ref_record_compare_name() is a function defined by
reftable/record.{c, h} and is used to compare the refname of two
ref records when sorting multiple ref records using &#39;qsort&#39;.
In the current testing setup, this function is left unexercised.
Add a testing function for the same.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-record.c | 18 ++++++++++++++++++
 1 file <a href="http://lore.kernel.org/git/20240621115708.3626-11-chandrapratap3519@gmail.com/#related">changed</a>, 18 insertions(+)

<span
class="head">diff --git a/t/unit-tests/t-reftable-record.c b/t/unit-tests/t-reftable-record.c
index 99ebfafe0b..b949617c88 100644
--- a/t/unit-tests/t-reftable-record.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -101,6 +101,23 @@ static void test_reftable_ref_record_comparison(void)
</span> 		reftable_record_release(&#38;in[i]);
 }
 
<span
class="add">+static void test_reftable_ref_record_compare_name(void)
+{
+	struct reftable_ref_record recs[14] = { 0 };
+	size_t N = ARRAY_SIZE(recs), i;
+
+	for (i = 0; i &lt; N; i++)
+		recs[i].refname = xstrfmt(&#34;%02&#34;PRIuMAX, (uintmax_t)i);
+
+	QSORT(recs, N, reftable_ref_record_compare_name);
+
+	for (i = 1; i &lt; N; i++)
+		check(reftable_ref_record_compare_name(&#38;recs[i - 1], &#38;recs[i]) &lt; 0);
+
+	for (i = 0; i &lt; N; i++)
+		reftable_ref_record_release(&#38;recs[i]);
+}
+
</span> static void test_reftable_ref_record_roundtrip(void)
 {
 	struct strbuf scratch = STRBUF_INIT;
<span
class="hunk">@@ -501,6 +518,7 @@ int cmd_main(int argc, const char *argv[])
</span> 	TEST(test_reftable_log_record_comparison(), &#34;comparison operations work on log record&#34;);
 	TEST(test_reftable_index_record_comparison(), &#34;comparison operations work on index record&#34;);
 	TEST(test_reftable_obj_record_comparison(), &#34;comparison operations work on obj record&#34;);
<span
class="add">+	TEST(test_reftable_ref_record_compare_name(), &#34;reftable_ref_record_compare_name works&#34;);
</span> 	TEST(test_reftable_log_record_roundtrip(), &#34;record operations work on log record&#34;);
 	TEST(test_reftable_ref_record_roundtrip(), &#34;record operations work on ref record&#34;);
 	TEST(test_varint_roundtrip(), &#34;put_var_int and get_var_int work&#34;);
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 09/11] t-reftable-record: add index tests for reftable_record_is_deletion()</title><updated>2024-06-21T11:58:09Z</updated><link
href="http://lore.kernel.org/git/20240621115708.3626-10-chandrapratap3519@gmail.com/"/><id>urn:uuid:e9b6bf25-13ff-f4de-0544-5666ae6e1e82</id><thr:in-reply-to
ref="urn:uuid:35e5cec5-b4d7-a105-49b4-d31b36613714"
href="http://lore.kernel.org/git/20240621115708.3626-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">reftable_record_is_deletion() is a function defined in
reftable/record.{c, h} that determines whether a record is of
type deletion or not. In the current testing setup, this function
is left untested for all the four record types (ref, log, obj, index).

Add tests for this function in the case of index records.
Note that since index records cannot be of type deletion, this function
must always return &#39;0&#39; when called on an index record.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-record.c | 1 +
 1 file <a href="http://lore.kernel.org/git/20240621115708.3626-10-chandrapratap3519@gmail.com/#related">changed</a>, 1 insertion(+)

<span
class="head">diff --git a/t/unit-tests/t-reftable-record.c b/t/unit-tests/t-reftable-record.c
index 766431ca67..99ebfafe0b 100644
--- a/t/unit-tests/t-reftable-record.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -477,6 +477,7 @@ static void test_reftable_index_record_roundtrip(void)
</span> 	reftable_record_key(&#38;in, &#38;key);
 	test_copy(&#38;in);
 
<span
class="add">+	check(!reftable_record_is_deletion(&#38;in));
</span> 	check(!strbuf_cmp(&#38;key, &#38;in.u.idx.last_key));
 	n = reftable_record_encode(&#38;in, dest, GIT_SHA1_RAWSZ);
 	check_int(n, &gt;, 0);
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 08/11] t-reftable-record: add obj tests for reftable_record_is_deletion()</title><updated>2024-06-21T11:58:06Z</updated><link
href="http://lore.kernel.org/git/20240621115708.3626-9-chandrapratap3519@gmail.com/"/><id>urn:uuid:f85b79f0-8619-f816-0da4-7cb9a14f4d8b</id><thr:in-reply-to
ref="urn:uuid:35e5cec5-b4d7-a105-49b4-d31b36613714"
href="http://lore.kernel.org/git/20240621115708.3626-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">reftable_record_is_deletion() is a function defined in
reftable/record.{c, h} that determines whether a record is of
type deletion or not. In the current testing setup, this function
is left untested for all the four record types (ref, log, obj, index).

Add tests for this function in the case of obj records.
Note that since obj records cannot be of type deletion, this function
must always return &#39;0&#39; when called on an obj record.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-record.c | 1 +
 1 file <a href="http://lore.kernel.org/git/20240621115708.3626-9-chandrapratap3519@gmail.com/#related">changed</a>, 1 insertion(+)

<span
class="head">diff --git a/t/unit-tests/t-reftable-record.c b/t/unit-tests/t-reftable-record.c
index b2e1a892c0..766431ca67 100644
--- a/t/unit-tests/t-reftable-record.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -395,6 +395,7 @@ static void test_reftable_obj_record_roundtrip(void)
</span> 		int n, m;
 		uint8_t extra;
 
<span
class="add">+		check(!reftable_record_is_deletion(&#38;in));
</span> 		test_copy(&#38;in);
 		reftable_record_key(&#38;in, &#38;key);
 		n = reftable_record_encode(&#38;in, dest, GIT_SHA1_RAWSZ);
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 07/11] t-reftable-record: add log tests for reftable_record_is_deletion()</title><updated>2024-06-21T11:58:03Z</updated><link
href="http://lore.kernel.org/git/20240621115708.3626-8-chandrapratap3519@gmail.com/"/><id>urn:uuid:b317e0c8-b019-d131-e816-b6cc11e5b87d</id><thr:in-reply-to
ref="urn:uuid:35e5cec5-b4d7-a105-49b4-d31b36613714"
href="http://lore.kernel.org/git/20240621115708.3626-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">reftable_record_is_deletion() is a function defined in
reftable/record.{c, h} that determines whether a record is of
type deletion or not. In the current testing setup, this function
is left untested for all the four record types (ref, log, obj, index).

Add tests for this function in the case of log records.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-record.c | 4 ++++
 1 file <a href="http://lore.kernel.org/git/20240621115708.3626-8-chandrapratap3519@gmail.com/#related">changed</a>, 4 insertions(+)

<span
class="head">diff --git a/t/unit-tests/t-reftable-record.c b/t/unit-tests/t-reftable-record.c
index cbc2ce93b2..b2e1a892c0 100644
--- a/t/unit-tests/t-reftable-record.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -231,6 +231,10 @@ static void test_reftable_log_record_roundtrip(void)
</span> 	set_hash(in[2].value.update.new_hash, 3);
 	set_hash(in[2].value.update.old_hash, 4);
 
<span
class="add">+	check(!reftable_log_record_is_deletion(&#38;in[0]));
+	check(reftable_log_record_is_deletion(&#38;in[1]));
+	check(!reftable_log_record_is_deletion(&#38;in[2]));
+
</span> 	for (size_t i = 0; i &lt; ARRAY_SIZE(in); i++) {
 		struct reftable_record rec = { .type = BLOCK_TYPE_LOG };
 		struct strbuf key = STRBUF_INIT;
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 06/11] t-reftable-record: add ref tests for reftable_record_is_deletion()</title><updated>2024-06-21T11:58:00Z</updated><link
href="http://lore.kernel.org/git/20240621115708.3626-7-chandrapratap3519@gmail.com/"/><id>urn:uuid:a1615e22-b5cd-beec-fcab-59a9c3919ce9</id><thr:in-reply-to
ref="urn:uuid:35e5cec5-b4d7-a105-49b4-d31b36613714"
href="http://lore.kernel.org/git/20240621115708.3626-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">reftable_record_is_deletion() is a function defined in
reftable/record.{c, h} that determines whether a record is of
type deletion or not. In the current testing setup, this function
is left untested for all the four record types (ref, log, obj, index).

Add tests for this function in the case of ref records.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-record.c | 5 +++++
 1 file <a href="http://lore.kernel.org/git/20240621115708.3626-7-chandrapratap3519@gmail.com/#related">changed</a>, 5 insertions(+)

<span
class="head">diff --git a/t/unit-tests/t-reftable-record.c b/t/unit-tests/t-reftable-record.c
index 1f9c830631..cbc2ce93b2 100644
--- a/t/unit-tests/t-reftable-record.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -108,6 +108,7 @@ static void test_reftable_ref_record_roundtrip(void)
</span> 	for (int i = REFTABLE_REF_DELETION; i &lt; REFTABLE_NR_REF_VALUETYPES; i++) {
 		struct reftable_record in = {
 			.type = BLOCK_TYPE_REF,
<span
class="add">+			.u.ref.value_type = i,
</span> 		};
 		struct reftable_record out = { .type = BLOCK_TYPE_REF };
 		struct strbuf key = STRBUF_INIT;
<span
class="hunk">@@ -121,15 +122,19 @@ static void test_reftable_ref_record_roundtrip(void)
</span> 		in.u.ref.value_type = i;
 		switch (i) {
 		case REFTABLE_REF_DELETION:
<span
class="add">+			check(reftable_record_is_deletion(&#38;in));
</span> 			break;
 		case REFTABLE_REF_VAL1:
<span
class="add">+			check(!reftable_record_is_deletion(&#38;in));
</span> 			set_hash(in.u.ref.value.val1, 1);
 			break;
 		case REFTABLE_REF_VAL2:
<span
class="add">+			check(!reftable_record_is_deletion(&#38;in));
</span> 			set_hash(in.u.ref.value.val2.value, 1);
 			set_hash(in.u.ref.value.val2.target_value, 2);
 			break;
 		case REFTABLE_REF_SYMREF:
<span
class="add">+			check(!reftable_record_is_deletion(&#38;in));
</span> 			in.u.ref.value.symref = xstrdup(&#34;target&#34;);
 			break;
 		}
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 05/11] t-reftable-record: add comparison tests for obj records</title><updated>2024-06-21T11:57:57Z</updated><link
href="http://lore.kernel.org/git/20240621115708.3626-6-chandrapratap3519@gmail.com/"/><id>urn:uuid:bf31eb06-d965-7293-16ac-4094d7a256f3</id><thr:in-reply-to
ref="urn:uuid:35e5cec5-b4d7-a105-49b4-d31b36613714"
href="http://lore.kernel.org/git/20240621115708.3626-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">In the current testing setup for obj records, the comparison
functions for obj records, reftable_obj_record_cmp_void() and
reftable_obj_record_equal_void() are left untested.

Add tests for the same by using the wrapper functions
reftable_record_cmp() and reftable_record_equal() for
reftable_index_record_cmp_void() and reftable_index_record_equal_void()
respectively.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-record.c | 39 ++++++++++++++++++++++++++++++++
 1 file <a href="http://lore.kernel.org/git/20240621115708.3626-6-chandrapratap3519@gmail.com/#related">changed</a>, 39 insertions(+)

<span
class="head">diff --git a/t/unit-tests/t-reftable-record.c b/t/unit-tests/t-reftable-record.c
index 9644f1de71..1f9c830631 100644
--- a/t/unit-tests/t-reftable-record.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -307,6 +307,44 @@ static void test_key_roundtrip(void)
</span> 	strbuf_release(&#38;roundtrip);
 }
 
<span
class="add">+static void test_reftable_obj_record_comparison(void)
+{
+
+	uint8_t id_bytes[] = { 0, 1, 2, 3, 4, 5, 6 };
+	uint64_t offsets[] = { 0, 16, 32, 48, 64, 80, 96, 112};
+	struct reftable_record in[3] = {
+		{
+			.type = BLOCK_TYPE_OBJ,
+			.u.obj.hash_prefix = id_bytes,
+			.u.obj.hash_prefix_len = 7,
+			.u.obj.offsets = offsets,
+			.u.obj.offset_len = 8,
+		},
+		{
+			.type = BLOCK_TYPE_OBJ,
+			.u.obj.hash_prefix = id_bytes,
+			.u.obj.hash_prefix_len = 7,
+			.u.obj.offsets = offsets,
+			.u.obj.offset_len = 5,
+		},
+		{
+			.type = BLOCK_TYPE_OBJ,
+			.u.obj.hash_prefix = id_bytes,
+			.u.obj.hash_prefix_len = 5,
+		},
+	};
+
+	check(!reftable_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
+	check(!reftable_record_cmp(&#38;in[0], &#38;in[1]));
+
+	check(!reftable_record_equal(&#38;in[1], &#38;in[2], GIT_SHA1_RAWSZ));
+	check_int(reftable_record_cmp(&#38;in[1], &#38;in[2]), &gt;, 0);
+
+	in[1].u.obj.offset_len = in[0].u.obj.offset_len;
+	check(reftable_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
+	check(!reftable_record_cmp(&#38;in[0], &#38;in[1]));
+}
+
</span> static void test_reftable_obj_record_roundtrip(void)
 {
 	uint8_t testHash1[GIT_SHA1_RAWSZ] = { 1, 2, 3, 4, 0 };
<span
class="hunk">@@ -451,6 +489,7 @@ int cmd_main(int argc, const char *argv[])
</span> 	TEST(test_reftable_ref_record_comparison(), &#34;comparison operations work on ref record&#34;);
 	TEST(test_reftable_log_record_comparison(), &#34;comparison operations work on log record&#34;);
 	TEST(test_reftable_index_record_comparison(), &#34;comparison operations work on index record&#34;);
<span
class="add">+	TEST(test_reftable_obj_record_comparison(), &#34;comparison operations work on obj record&#34;);
</span> 	TEST(test_reftable_log_record_roundtrip(), &#34;record operations work on log record&#34;);
 	TEST(test_reftable_ref_record_roundtrip(), &#34;record operations work on ref record&#34;);
 	TEST(test_varint_roundtrip(), &#34;put_var_int and get_var_int work&#34;);
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 04/11] t-reftable-record: add comparison tests for index records</title><updated>2024-06-21T11:57:54Z</updated><link
href="http://lore.kernel.org/git/20240621115708.3626-5-chandrapratap3519@gmail.com/"/><id>urn:uuid:2d23e9dd-ba42-ef50-e7bb-96186077dd47</id><thr:in-reply-to
ref="urn:uuid:35e5cec5-b4d7-a105-49b4-d31b36613714"
href="http://lore.kernel.org/git/20240621115708.3626-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">In the current testing setup for index records, the comparison
functions for index records, reftable_index_record_cmp() and
reftable_index_record_equal() are left untested.

Add tests for the same by using the wrapper functions
reftable_record_cmp() and reftable_record_equal() for
reftable_index_record_cmp() and reftable_index_record_equal()
respectively.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-record.c | 38 ++++++++++++++++++++++++++++++++
 1 file <a href="http://lore.kernel.org/git/20240621115708.3626-5-chandrapratap3519@gmail.com/#related">changed</a>, 38 insertions(+)

<span
class="head">diff --git a/t/unit-tests/t-reftable-record.c b/t/unit-tests/t-reftable-record.c
index c74fdbecf8..9644f1de71 100644
--- a/t/unit-tests/t-reftable-record.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -365,6 +365,43 @@ static void test_reftable_obj_record_roundtrip(void)
</span> 	strbuf_release(&#38;scratch);
 }
 
<span
class="add">+static void test_reftable_index_record_comparison(void)
+{
+	struct reftable_record in[3] = {
+		{
+			.type = BLOCK_TYPE_INDEX,
+			.u.idx.offset = 22,
+			.u.idx.last_key = STRBUF_INIT,
+		},
+		{
+			.type = BLOCK_TYPE_INDEX,
+			.u.idx.offset = 32,
+			.u.idx.last_key = STRBUF_INIT,
+		},
+		{
+			.type = BLOCK_TYPE_INDEX,
+			.u.idx.offset = 32,
+			.u.idx.last_key = STRBUF_INIT,
+		},
+	};
+	strbuf_addstr(&#38;in[0].u.idx.last_key, &#34;refs/heads/master&#34;);
+	strbuf_addstr(&#38;in[1].u.idx.last_key, &#34;refs/heads/master&#34;);
+	strbuf_addstr(&#38;in[2].u.idx.last_key, &#34;refs/heads/branch&#34;);
+
+	check(!reftable_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
+	check(!reftable_record_cmp(&#38;in[0], &#38;in[1]));
+
+	check(!reftable_record_equal(&#38;in[1], &#38;in[2], GIT_SHA1_RAWSZ));
+	check_int(reftable_record_cmp(&#38;in[1], &#38;in[2]), &gt;, 0);
+
+	in[1].u.idx.offset = in[0].u.idx.offset;
+	check(reftable_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
+	check(!reftable_record_cmp(&#38;in[0], &#38;in[1]));
+
+	for (size_t i = 0; i &lt; ARRAY_SIZE(in); i++)
+		reftable_record_release(&#38;in[i]);
+}
+
</span> static void test_reftable_index_record_roundtrip(void)
 {
 	struct reftable_record in = {
<span
class="hunk">@@ -413,6 +450,7 @@ int cmd_main(int argc, const char *argv[])
</span> {
 	TEST(test_reftable_ref_record_comparison(), &#34;comparison operations work on ref record&#34;);
 	TEST(test_reftable_log_record_comparison(), &#34;comparison operations work on log record&#34;);
<span
class="add">+	TEST(test_reftable_index_record_comparison(), &#34;comparison operations work on index record&#34;);
</span> 	TEST(test_reftable_log_record_roundtrip(), &#34;record operations work on log record&#34;);
 	TEST(test_reftable_ref_record_roundtrip(), &#34;record operations work on ref record&#34;);
 	TEST(test_varint_roundtrip(), &#34;put_var_int and get_var_int work&#34;);
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 03/11] t-reftable-record: add comparison tests for ref records</title><updated>2024-06-21T11:57:51Z</updated><link
href="http://lore.kernel.org/git/20240621115708.3626-4-chandrapratap3519@gmail.com/"/><id>urn:uuid:045517bc-b4f3-6633-aa18-d539b1a440d5</id><thr:in-reply-to
ref="urn:uuid:35e5cec5-b4d7-a105-49b4-d31b36613714"
href="http://lore.kernel.org/git/20240621115708.3626-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">In the current testing setup for ref records, the comparison
functions for ref records, reftable_ref_record_cmp_void() and
reftable_ref_record_equal() are left untested.

Add tests for the same by using the wrapper functions
reftable_record_cmp() and reftable_record_equal() for
reftable_ref_record_cmp_void() and reftable_ref_record_equal()
respectively.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-record.c | 36 ++++++++++++++++++++++++++++++++
 1 file <a href="http://lore.kernel.org/git/20240621115708.3626-4-chandrapratap3519@gmail.com/#related">changed</a>, 36 insertions(+)

<span
class="head">diff --git a/t/unit-tests/t-reftable-record.c b/t/unit-tests/t-reftable-record.c
index 0cf223e51b..c74fdbecf8 100644
--- a/t/unit-tests/t-reftable-record.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -66,6 +66,41 @@ static void set_hash(uint8_t *h, int j)
</span> 		h[i] = (j &gt;&gt; i) &#38; 0xff;
 }
 
<span
class="add">+static void test_reftable_ref_record_comparison(void)
+{
+	struct reftable_record in[3] = {
+		{
+			.type = BLOCK_TYPE_REF,
+			.u.ref.refname = xstrdup(&#34;refs/heads/master&#34;),
+			.u.ref.value_type = REFTABLE_REF_VAL1,
+		},
+		{
+			.type = BLOCK_TYPE_REF,
+			.u.ref.refname = xstrdup(&#34;refs/heads/master&#34;),
+			.u.ref.value_type = REFTABLE_REF_DELETION,
+		},
+		{
+			.type = BLOCK_TYPE_REF,
+			.u.ref.refname = xstrdup(&#34;HEAD&#34;),
+			.u.ref.value_type = REFTABLE_REF_SYMREF,
+			.u.ref.value.symref = xstrdup(&#34;refs/heads/master&#34;),
+		},
+	};
+
+	check(!reftable_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
+	check(!reftable_record_cmp(&#38;in[0], &#38;in[1]));
+
+	check(!reftable_record_equal(&#38;in[1], &#38;in[2], GIT_SHA1_RAWSZ));
+	check_int(reftable_record_cmp(&#38;in[1], &#38;in[2]), &gt;, 0);
+
+	in[1].u.ref.value_type = in[0].u.ref.value_type;
+	check(reftable_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
+	check(!reftable_record_cmp(&#38;in[0], &#38;in[1]));
+
+	for (size_t i = 0; i &lt; ARRAY_SIZE(in); i++)
+		reftable_record_release(&#38;in[i]);
+}
+
</span> static void test_reftable_ref_record_roundtrip(void)
 {
 	struct strbuf scratch = STRBUF_INIT;
<span
class="hunk">@@ -376,6 +411,7 @@ static void test_reftable_index_record_roundtrip(void)
</span> 
 int cmd_main(int argc, const char *argv[])
 {
<span
class="add">+	TEST(test_reftable_ref_record_comparison(), &#34;comparison operations work on ref record&#34;);
</span> 	TEST(test_reftable_log_record_comparison(), &#34;comparison operations work on log record&#34;);
 	TEST(test_reftable_log_record_roundtrip(), &#34;record operations work on log record&#34;);
 	TEST(test_reftable_ref_record_roundtrip(), &#34;record operations work on ref record&#34;);
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 02/11] t-reftable-record: add reftable_record_cmp() tests for log records</title><updated>2024-06-21T11:57:48Z</updated><link
href="http://lore.kernel.org/git/20240621115708.3626-3-chandrapratap3519@gmail.com/"/><id>urn:uuid:c934c3aa-0cf2-b20f-1fc7-0d2b125f4af2</id><thr:in-reply-to
ref="urn:uuid:35e5cec5-b4d7-a105-49b4-d31b36613714"
href="http://lore.kernel.org/git/20240621115708.3626-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">In the current testing setup for log records, only
reftable_log_record_equal() among log record&#39;s comparison functions
is tested.

Modify the existing tests to exercise reftable_log_record_cmp_void()
(using the wrapper function reftable_record_cmp()) alongside
reftable_log_record_equal().
Note that to achieve this, we&#39;ll need to replace instances of
reftable_log_record_equal() with the wrapper function
reftable_record_equal().

Rename the now modified test to reflect its nature of exercising
all comparison operations, not just equality.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-record.c | 40 +++++++++++++++++++++-----------
 1 file <a href="http://lore.kernel.org/git/20240621115708.3626-3-chandrapratap3519@gmail.com/#related">changed</a>, 27 insertions(+), 13 deletions(-)

<span
class="head">diff --git a/t/unit-tests/t-reftable-record.c b/t/unit-tests/t-reftable-record.c
index 1b357e6c7f..0cf223e51b 100644
--- a/t/unit-tests/t-reftable-record.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -123,24 +123,38 @@ static void test_reftable_ref_record_roundtrip(void)
</span> 	strbuf_release(&#38;scratch);
 }
 
<span
class="del">-static void test_reftable_log_record_equal(void)
</span><span
class="add">+static void test_reftable_log_record_comparison(void)
</span> {
<span
class="del">-	struct reftable_log_record in[2] = {
</span><span
class="add">+	struct reftable_record in[3] = {
</span> 		{
<span
class="del">-			.refname = xstrdup(&#34;refs/heads/master&#34;),
-			.update_index = 42,
</span><span
class="add">+			.type = BLOCK_TYPE_LOG,
+			.u.log.refname = xstrdup(&#34;refs/heads/master&#34;),
+			.u.log.update_index = 42,
</span> 		},
 		{
<span
class="del">-			.refname = xstrdup(&#34;refs/heads/master&#34;),
-			.update_index = 22,
-		}
</span><span
class="add">+			.type = BLOCK_TYPE_LOG,
+			.u.log.refname = xstrdup(&#34;refs/heads/master&#34;),
+			.u.log.update_index = 22,
+		},
+		{
+			.type = BLOCK_TYPE_LOG,
+			.u.log.refname = xstrdup(&#34;refs/heads/main&#34;),
+			.u.log.update_index = 22,
+		},
</span> 	};
 
<span
class="del">-	check(!reftable_log_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
-	in[1].update_index = in[0].update_index;
-	check(reftable_log_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
-	reftable_log_record_release(&#38;in[0]);
-	reftable_log_record_release(&#38;in[1]);
</span><span
class="add">+	check(!reftable_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
+	check(!reftable_record_equal(&#38;in[1], &#38;in[2], GIT_SHA1_RAWSZ));
+	check_int(reftable_record_cmp(&#38;in[1], &#38;in[2]), &gt;, 0);
+	/* comparison should be reversed for equal keys */
+	check_int(reftable_record_cmp(&#38;in[0], &#38;in[1]), &lt;, 0);
+
+	in[1].u.log.update_index = in[0].u.log.update_index;
+	check(reftable_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
+	check(!reftable_record_cmp(&#38;in[0], &#38;in[1]));
+
+	for (size_t i = 0; i &lt; ARRAY_SIZE(in); i++)
+		reftable_record_release(&#38;in[i]);
</span> }
 
 static void test_reftable_log_record_roundtrip(void)
<span
class="hunk">@@ -362,7 +376,7 @@ static void test_reftable_index_record_roundtrip(void)
</span> 
 int cmd_main(int argc, const char *argv[])
 {
<span
class="del">-	TEST(test_reftable_log_record_equal(), &#34;reftable_log_record_equal works&#34;);
</span><span
class="add">+	TEST(test_reftable_log_record_comparison(), &#34;comparison operations work on log record&#34;);
</span> 	TEST(test_reftable_log_record_roundtrip(), &#34;record operations work on log record&#34;);
 	TEST(test_reftable_ref_record_roundtrip(), &#34;record operations work on ref record&#34;);
 	TEST(test_varint_roundtrip(), &#34;put_var_int and get_var_int work&#34;);
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 01/11] t: move reftable/record_test.c to the unit testing framework</title><updated>2024-06-21T11:57:45Z</updated><link
href="http://lore.kernel.org/git/20240621115708.3626-2-chandrapratap3519@gmail.com/"/><id>urn:uuid:774c0ea8-d0eb-1aaf-79d7-2ca954d5003c</id><thr:in-reply-to
ref="urn:uuid:35e5cec5-b4d7-a105-49b4-d31b36613714"
href="http://lore.kernel.org/git/20240621115708.3626-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">reftable/record_test.c exercises the functions defined in
reftable/record.{c, h}. Migrate reftable/record_test.c to the
unit testing framework. Migration involves refactoring the tests
to use the unit testing framework instead of reftable&#39;s test
framework.
While at it, change the type of index variable &#39;i&#39; to &#39;size_t&#39;
from &#39;int&#39;. This is because &#39;i&#39; is used in comparison against
&#39;ARRAY_SIZE(x)&#39; which is of type &#39;size_t&#39;.

Also, use set_hash() which is defined locally in the test file
instead of set_test_hash() which is defined by
reftable/test_framework.{c, h}. This is fine to do as both these
functions are similarly implemented, and
reftable/test_framework.{c, h} is not #included in the ported test.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 Makefile                                      |   2 +-
 t/helper/test-reftable.c                      |   1 -
 .../unit-tests/t-reftable-record.c            | 106 ++++++++----------
 3 files <a href="http://lore.kernel.org/git/20240621115708.3626-2-chandrapratap3519@gmail.com/#related">changed</a>, 50 insertions(+), 59 deletions(-)
 rename reftable/record_test.c =&gt; t/unit-tests/t-reftable-record.c (77%)

<span
class="head">diff --git a/Makefile b/Makefile
index f25b2e80a1..def3700b4d 100644
--- a/Makefile
+++ b/Makefile
</span><span
class="hunk">@@ -1338,6 +1338,7 @@ UNIT_TEST_PROGRAMS += t-hash
</span> UNIT_TEST_PROGRAMS += t-mem-pool
 UNIT_TEST_PROGRAMS += t-prio-queue
 UNIT_TEST_PROGRAMS += t-reftable-basics
<span
class="add">+UNIT_TEST_PROGRAMS += t-reftable-record
</span> UNIT_TEST_PROGRAMS += t-strbuf
 UNIT_TEST_PROGRAMS += t-strcmp-offset
 UNIT_TEST_PROGRAMS += t-strvec
<span
class="hunk">@@ -2678,7 +2679,6 @@ REFTABLE_TEST_OBJS += reftable/block_test.o
</span> REFTABLE_TEST_OBJS += reftable/dump.o
 REFTABLE_TEST_OBJS += reftable/merged_test.o
 REFTABLE_TEST_OBJS += reftable/pq_test.o
<span
class="del">-REFTABLE_TEST_OBJS += reftable/record_test.o
</span> REFTABLE_TEST_OBJS += reftable/readwrite_test.o
 REFTABLE_TEST_OBJS += reftable/stack_test.o
 REFTABLE_TEST_OBJS += reftable/test_framework.o
<span
class="head">diff --git a/t/helper/test-reftable.c b/t/helper/test-reftable.c
index 9160bc5da6..aa6538a8da 100644
--- a/t/helper/test-reftable.c
+++ b/t/helper/test-reftable.c
</span><span
class="hunk">@@ -5,7 +5,6 @@
</span> int cmd__reftable(int argc, const char **argv)
 {
 	/* test from simple to complex. */
<span
class="del">-	record_test_main(argc, argv);
</span> 	block_test_main(argc, argv);
 	tree_test_main(argc, argv);
 	pq_test_main(argc, argv);
<span
class="head">diff --git a/reftable/record_test.c b/t/unit-tests/t-reftable-record.c
similarity index 77%
rename from reftable/record_test.c
rename to t/unit-tests/t-reftable-record.c
index 58290bdba3..1b357e6c7f 100644
--- a/reftable/record_test.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -6,13 +6,9 @@
</span>   <a
href="https://developers.google.com/open-source/licenses/bsd">https://developers.google.com/open-source/licenses/bsd</a>
 */
 
<span
class="del">-#include &#34;record.h&#34;
-
-#include &#34;system.h&#34;
-#include &#34;basics.h&#34;
-#include &#34;constants.h&#34;
-#include &#34;test_framework.h&#34;
-#include &#34;reftable-tests.h&#34;
</span><span
class="add">+#include &#34;test-lib.h&#34;
+#include &#34;reftable/constants.h&#34;
+#include &#34;reftable/record.h&#34;
</span> 
 static void test_copy(struct reftable_record *rec)
 {
<span
class="hunk">@@ -24,9 +20,9 @@ static void test_copy(struct reftable_record *rec)
</span> 	reftable_record_copy_from(&#38;copy, rec, GIT_SHA1_RAWSZ);
 	/* do it twice to catch memory leaks */
 	reftable_record_copy_from(&#38;copy, rec, GIT_SHA1_RAWSZ);
<span
class="del">-	EXPECT(reftable_record_equal(rec, &#38;copy, GIT_SHA1_RAWSZ));
</span><span
class="add">+	check(reftable_record_equal(rec, &#38;copy, GIT_SHA1_RAWSZ));
</span> 
<span
class="del">-	puts(&#34;testing print coverage:\n&#34;);
</span><span
class="add">+	test_msg(&#34;testing print coverage:&#34;);
</span> 	reftable_record_print(&#38;copy, GIT_SHA1_RAWSZ);
 
 	reftable_record_release(&#38;copy);
<span
class="hunk">@@ -43,8 +39,8 @@ static void test_varint_roundtrip(void)
</span> 			      4096,
 			      ((uint64_t)1 &lt;&lt; 63),
 			      ((uint64_t)1 &lt;&lt; 63) + ((uint64_t)1 &lt;&lt; 63) - 1 };
<span
class="del">-	int i = 0;
-	for (i = 0; i &lt; ARRAY_SIZE(inputs); i++) {
</span><span
class="add">+
+	for (size_t i = 0; i &lt; ARRAY_SIZE(inputs); i++) {
</span> 		uint8_t dest[10];
 
 		struct string_view out = {
<span
class="hunk">@@ -55,29 +51,26 @@ static void test_varint_roundtrip(void)
</span> 		int n = put_var_int(&#38;out, in);
 		uint64_t got = 0;
 
<span
class="del">-		EXPECT(n &gt; 0);
</span><span
class="add">+		check_int(n, &gt;, 0);
</span> 		out.len = n;
 		n = get_var_int(&#38;got, &#38;out);
<span
class="del">-		EXPECT(n &gt; 0);
</span><span
class="add">+		check_int(n, &gt;, 0);
</span> 
<span
class="del">-		EXPECT(got == in);
</span><span
class="add">+		check_int(got, ==, in);
</span> 	}
 }
 
 static void set_hash(uint8_t *h, int j)
 {
<span
class="del">-	int i = 0;
-	for (i = 0; i &lt; hash_size(GIT_SHA1_FORMAT_ID); i++) {
</span><span
class="add">+	for (int i = 0; i &lt; hash_size(GIT_SHA1_FORMAT_ID); i++)
</span> 		h[i] = (j &gt;&gt; i) &#38; 0xff;
<span
class="del">-	}
</span> }
 
 static void test_reftable_ref_record_roundtrip(void)
 {
 	struct strbuf scratch = STRBUF_INIT;
<span
class="del">-	int i = 0;
</span> 
<span
class="del">-	for (i = REFTABLE_REF_DELETION; i &lt; REFTABLE_NR_REF_VALUETYPES; i++) {
</span><span
class="add">+	for (int i = REFTABLE_REF_DELETION; i &lt; REFTABLE_NR_REF_VALUETYPES; i++) {
</span> 		struct reftable_record in = {
 			.type = BLOCK_TYPE_REF,
 		};
<span
class="hunk">@@ -109,17 +102,17 @@ static void test_reftable_ref_record_roundtrip(void)
</span> 
 		test_copy(&#38;in);
 
<span
class="del">-		EXPECT(reftable_record_val_type(&#38;in) == i);
</span><span
class="add">+		check_int(reftable_record_val_type(&#38;in), ==, i);
</span> 
 		reftable_record_key(&#38;in, &#38;key);
 		n = reftable_record_encode(&#38;in, dest, GIT_SHA1_RAWSZ);
<span
class="del">-		EXPECT(n &gt; 0);
</span><span
class="add">+		check_int(n, &gt;, 0);
</span> 
 		/* decode into a non-zero reftable_record to test for leaks. */
 		m = reftable_record_decode(&#38;out, key, i, dest, GIT_SHA1_RAWSZ, &#38;scratch);
<span
class="del">-		EXPECT(n == m);
</span><span
class="add">+		check_int(n, ==, m);
</span> 
<span
class="del">-		EXPECT(reftable_ref_record_equal(&#38;in.u.ref, &#38;out.u.ref,
</span><span
class="add">+		check(reftable_ref_record_equal(&#38;in.u.ref, &#38;out.u.ref,
</span> 						 GIT_SHA1_RAWSZ));
 		reftable_record_release(&#38;in);
 
<span
class="hunk">@@ -143,16 +136,15 @@ static void test_reftable_log_record_equal(void)
</span> 		}
 	};
 
<span
class="del">-	EXPECT(!reftable_log_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
</span><span
class="add">+	check(!reftable_log_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
</span> 	in[1].update_index = in[0].update_index;
<span
class="del">-	EXPECT(reftable_log_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
</span><span
class="add">+	check(reftable_log_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
</span> 	reftable_log_record_release(&#38;in[0]);
 	reftable_log_record_release(&#38;in[1]);
 }
 
 static void test_reftable_log_record_roundtrip(void)
 {
<span
class="del">-	int i;
</span> 	struct reftable_log_record in[] = {
 		{
 			.refname = xstrdup(&#34;refs/heads/master&#34;),
<span
class="hunk">@@ -180,12 +172,12 @@ static void test_reftable_log_record_roundtrip(void)
</span> 		}
 	};
 	struct strbuf scratch = STRBUF_INIT;
<span
class="add">+	set_hash(in[0].value.update.new_hash, 1);
+	set_hash(in[0].value.update.old_hash, 2);
+	set_hash(in[2].value.update.new_hash, 3);
+	set_hash(in[2].value.update.old_hash, 4);
</span> 
<span
class="del">-	set_test_hash(in[0].value.update.new_hash, 1);
-	set_test_hash(in[0].value.update.old_hash, 2);
-	set_test_hash(in[2].value.update.new_hash, 3);
-	set_test_hash(in[2].value.update.old_hash, 4);
-	for (i = 0; i &lt; ARRAY_SIZE(in); i++) {
</span><span
class="add">+	for (size_t i = 0; i &lt; ARRAY_SIZE(in); i++) {
</span> 		struct reftable_record rec = { .type = BLOCK_TYPE_LOG };
 		struct strbuf key = STRBUF_INIT;
 		uint8_t buffer[1024] = { 0 };
<span
class="hunk">@@ -217,13 +209,13 @@ static void test_reftable_log_record_roundtrip(void)
</span> 		reftable_record_key(&#38;rec, &#38;key);
 
 		n = reftable_record_encode(&#38;rec, dest, GIT_SHA1_RAWSZ);
<span
class="del">-		EXPECT(n &gt;= 0);
</span><span
class="add">+		check_int(n, &gt;=, 0);
</span> 		valtype = reftable_record_val_type(&#38;rec);
 		m = reftable_record_decode(&#38;out, key, valtype, dest,
 					   GIT_SHA1_RAWSZ, &#38;scratch);
<span
class="del">-		EXPECT(n == m);
</span><span
class="add">+		check_int(n, ==, m);
</span> 
<span
class="del">-		EXPECT(reftable_log_record_equal(&#38;in[i], &#38;out.u.log,
</span><span
class="add">+		check(reftable_log_record_equal(&#38;in[i], &#38;out.u.log,
</span> 						 GIT_SHA1_RAWSZ));
 		reftable_log_record_release(&#38;in[i]);
 		strbuf_release(&#38;key);
<span
class="hunk">@@ -252,14 +244,14 @@ static void test_key_roundtrip(void)
</span> 	strbuf_addstr(&#38;key, &#34;refs/tags/bla&#34;);
 	extra = 6;
 	n = reftable_encode_key(&#38;restart, dest, last_key, key, extra);
<span
class="del">-	EXPECT(!restart);
-	EXPECT(n &gt; 0);
</span><span
class="add">+	check(!restart);
+	check_int(n, &gt;, 0);
</span> 
 	strbuf_addstr(&#38;roundtrip, &#34;refs/heads/master&#34;);
 	m = reftable_decode_key(&#38;roundtrip, &#38;rt_extra, dest);
<span
class="del">-	EXPECT(n == m);
-	EXPECT(0 == strbuf_cmp(&#38;key, &#38;roundtrip));
-	EXPECT(rt_extra == extra);
</span><span
class="add">+	check_int(n, ==, m);
+	check(!strbuf_cmp(&#38;key, &#38;roundtrip));
+	check_int(rt_extra, ==, extra);
</span> 
 	strbuf_release(&#38;last_key);
 	strbuf_release(&#38;key);
<span
class="hunk">@@ -289,9 +281,8 @@ static void test_reftable_obj_record_roundtrip(void)
</span> 		},
 	};
 	struct strbuf scratch = STRBUF_INIT;
<span
class="del">-	int i = 0;
</span> 
<span
class="del">-	for (i = 0; i &lt; ARRAY_SIZE(recs); i++) {
</span><span
class="add">+	for (size_t i = 0; i &lt; ARRAY_SIZE(recs); i++) {
</span> 		uint8_t buffer[1024] = { 0 };
 		struct string_view dest = {
 			.buf = buffer,
<span
class="hunk">@@ -311,13 +302,13 @@ static void test_reftable_obj_record_roundtrip(void)
</span> 		test_copy(&#38;in);
 		reftable_record_key(&#38;in, &#38;key);
 		n = reftable_record_encode(&#38;in, dest, GIT_SHA1_RAWSZ);
<span
class="del">-		EXPECT(n &gt; 0);
</span><span
class="add">+		check_int(n, &gt;, 0);
</span> 		extra = reftable_record_val_type(&#38;in);
 		m = reftable_record_decode(&#38;out, key, extra, dest,
 					   GIT_SHA1_RAWSZ, &#38;scratch);
<span
class="del">-		EXPECT(n == m);
</span><span
class="add">+		check_int(n, ==, m);
</span> 
<span
class="del">-		EXPECT(reftable_record_equal(&#38;in, &#38;out, GIT_SHA1_RAWSZ));
</span><span
class="add">+		check(reftable_record_equal(&#38;in, &#38;out, GIT_SHA1_RAWSZ));
</span> 		strbuf_release(&#38;key);
 		reftable_record_release(&#38;out);
 	}
<span
class="hunk">@@ -352,16 +343,16 @@ static void test_reftable_index_record_roundtrip(void)
</span> 	reftable_record_key(&#38;in, &#38;key);
 	test_copy(&#38;in);
 
<span
class="del">-	EXPECT(0 == strbuf_cmp(&#38;key, &#38;in.u.idx.last_key));
</span><span
class="add">+	check(!strbuf_cmp(&#38;key, &#38;in.u.idx.last_key));
</span> 	n = reftable_record_encode(&#38;in, dest, GIT_SHA1_RAWSZ);
<span
class="del">-	EXPECT(n &gt; 0);
</span><span
class="add">+	check_int(n, &gt;, 0);
</span> 
 	extra = reftable_record_val_type(&#38;in);
 	m = reftable_record_decode(&#38;out, key, extra, dest, GIT_SHA1_RAWSZ,
 				   &#38;scratch);
<span
class="del">-	EXPECT(m == n);
</span><span
class="add">+	check_int(m, ==, n);
</span> 
<span
class="del">-	EXPECT(reftable_record_equal(&#38;in, &#38;out, GIT_SHA1_RAWSZ));
</span><span
class="add">+	check(reftable_record_equal(&#38;in, &#38;out, GIT_SHA1_RAWSZ));
</span> 
 	reftable_record_release(&#38;out);
 	strbuf_release(&#38;key);
<span
class="hunk">@@ -369,14 +360,15 @@ static void test_reftable_index_record_roundtrip(void)
</span> 	strbuf_release(&#38;in.u.idx.last_key);
 }
 
<span
class="del">-int record_test_main(int argc, const char *argv[])
</span><span
class="add">+int cmd_main(int argc, const char *argv[])
</span> {
<span
class="del">-	RUN_TEST(test_reftable_log_record_equal);
-	RUN_TEST(test_reftable_log_record_roundtrip);
-	RUN_TEST(test_reftable_ref_record_roundtrip);
-	RUN_TEST(test_varint_roundtrip);
-	RUN_TEST(test_key_roundtrip);
-	RUN_TEST(test_reftable_obj_record_roundtrip);
-	RUN_TEST(test_reftable_index_record_roundtrip);
-	return 0;
</span><span
class="add">+	TEST(test_reftable_log_record_equal(), &#34;reftable_log_record_equal works&#34;);
+	TEST(test_reftable_log_record_roundtrip(), &#34;record operations work on log record&#34;);
+	TEST(test_reftable_ref_record_roundtrip(), &#34;record operations work on ref record&#34;);
+	TEST(test_varint_roundtrip(), &#34;put_var_int and get_var_int work&#34;);
+	TEST(test_key_roundtrip(), &#34;reftable_encode_key and reftable_decode_key work&#34;);
+	TEST(test_reftable_obj_record_roundtrip(), &#34;record operations work on obj record&#34;);
+	TEST(test_reftable_index_record_roundtrip(), &#34;record operations work on index record&#34;);
+
+	return test_done();
</span> }
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[GSoC][PATCH 0/11] t: port reftable/record_test.c to the unit testing framework</title><updated>2024-06-21T11:57:41Z</updated><link
href="http://lore.kernel.org/git/20240621115708.3626-1-chandrapratap3519@gmail.com/"/><id>urn:uuid:35e5cec5-b4d7-a105-49b4-d31b36613714</id><thr:in-reply-to
ref="urn:uuid:6e1c823b-0ade-ca29-8eb3-e51a2304dd20"
href="http://lore.kernel.org/git/20240621060018.12795-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">In the recent codebase update (commit 8bf6fbd, 2023-12-09), a new unit
testing framework written entirely in C was introduced to the Git project
aimed at simplifying testing and reducing test run times.
Currently, tests for the reftable refs-backend are performed by a custom
testing framework defined by reftable/test_framework.{c, h}. Port
reftable/record_test.c to the unit testing framework and improve upon
the ported test.

The first patch in the series moves the test to the unit testing framework,
and the rest of the patches improve upon the ported test.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;

---
CI/PR: <a
href="https://github.com/gitgitgadget/git/pull/1750">https://github.com/gitgitgadget/git/pull/1750</a>

Chandra Pratap (11):
t: move reftable/record_test.c to the unit testing framework
t-reftable-record: add reftable_record_cmp() tests for log records
t-reftable-record: add comparison tests for ref records
t-reftable-record: add comparison tests for index records
t-reftable-record: add comparison tests for obj records
t-reftable-record: add reftable_record_is_deletion() test for ref records
t-reftable-record: add reftable_record_is_deletion() test for log records
t-reftable-record: add reftable_record_is_deletion() test for obj records
t-reftable-record: add reftable_record_is_deletion() test for index records
t-reftable-record: add tests for reftable_ref_record_compare_name()
t-reftable-record: add tests for reftable_log_record_compare_key()

Makefile                         |   2 +-
reftable/record_test.c           | 382 -------------------------
t/helper/test-reftable.c         |   1 -
t/unit-tests/t-reftable-record.c | 554 +++++++++++++++++++++++++++++++++++++++++++++
</pre></div></content></entry><entry><author><name>Rob Linden</name><email>rlinden@redhat.com</email></author><title>problem with parsing of patch files for patch-id</title><updated>2024-06-21T10:33:28Z</updated><link
href="http://lore.kernel.org/git/CAP0H_AEd1jFNB_dO=HRjwEUKzFqnjntss_1wskKU6hE1VmBs+A@mail.gmail.com/"/><id>urn:uuid:18117af7-5c8e-b36b-0e6b-f3d3c21937de</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap"><a
href="http://lore.kernel.org/git/CAP0H_AEd1jFNB_dO=HRjwEUKzFqnjntss_1wskKU6hE1VmBs+A@mail.gmail.com/1-a.txt">[-- Attachment #1: Type: text/plain, Size: 2144 bytes --]</a>

Hello!

We noticed a problem with the parsing of a patch file for &#34;git
patch-id&#34;. I understand that the patch file format is very difficult
and unpredictable and probably it&#39;s not even possible to correctly
parse all of them (mostly due to missing restrictions on or escaping
of commit messages).

But in our specific case it can be improved to handle it correctly.

I attached an example patch file. When feeding that to &#34;git patch-id&#34;
(with git version 2.45.2.561.g66ac6e4bcd) the output is:

068a8a30a5b0e55b93fdc16b2a7dcd6886e420f3
1111111111111111111111111111111111111111
818756276fff2c6075da8effe36c65d25e6ed592
dcc59dffa5116bf96618065cd60742cb660224b8
b033e3eca8a60741bb414689ddfe00a0c1a09de5
3333333333333333333333333333333333333333

But it should be:

068a8a30a5b0e55b93fdc16b2a7dcd6886e420f3
1111111111111111111111111111111111111111
818756276fff2c6075da8effe36c65d25e6ed592
2222222222222222222222222222222222222222
b033e3eca8a60741bb414689ddfe00a0c1a09de5
3333333333333333333333333333333333333333

The reason is that the commit message of the second patch contains
commit hashes which are parsed as if they were the commit hash for the
patch, and not just some message.

This patch (also attached) fixes it by only considering commit hashes
in a &#34;From xxxxx...&#34; line:

<span
class="head">diff --git a/builtin/patch-id.c b/builtin/patch-id.c
index 583099cacf..4b8a41bde8 100644
--- a/builtin/patch-id.c
+++ b/builtin/patch-id.c
</span><span
class="hunk">@@ -86,7 +86,7 @@ static int get_one_patchid(struct object_id
</span>*next_oid, struct object_id *result,
                        continue;
                }

<span
class="del">-               if (!get_oid_hex(p, next_oid)) {
</span><span
class="add">+               if (starts_with(p-5, &#34;From &#34;) &#38;&#38; !get_oid_hex(p, next_oid)) {
</span>                        found_next = 1;
                        break;
                }

But I&#39;m not sure it is ok in all other cases [which are handled
correctly now, i.e. it only makes it better for cases like ours,
without making it worse for anything else). The unit-tests pass ok but
I didn&#39;t check how comprehensive they are.
Can somebody please have a look and tell me what they think about
patch file parsing?

Thanks &#38; all the best,
rob

<a
href="http://lore.kernel.org/git/CAP0H_AEd1jFNB_dO=HRjwEUKzFqnjntss_1wskKU6hE1VmBs+A@mail.gmail.com/2-test.patch">[-- Attachment #2: test.patch --]
[-- Type: text/x-patch, Size: 3119 bytes --]</a>

From 1111111111111111111111111111111111111111 Mon Sep 17 00:00:00 2001
From: rlinden@redhat.com
Date: Wed, 24 Jan 2024 14:49:21 +0100
Subject: [PATCH 1/3] foo foo

Resolves: bug-123
---
 test/units/testsuite-07.main-PID-change.sh | 2 ++
 1 file <a href="http://lore.kernel.org/git/CAP0H_AEd1jFNB_dO=HRjwEUKzFqnjntss_1wskKU6hE1VmBs+A@mail.gmail.com/#related">changed</a>, 2 insertions(+)

<span
class="head">diff --git a/test/units/testsuite-07.main-PID-change.sh b/test/units/testsuite-07.main-PID-change.sh
index be4631f10d..bd5a63a272 100755
--- a/test/units/testsuite-07.main-PID-change.sh
+++ b/test/units/testsuite-07.main-PID-change.sh
</span><span
class="hunk">@@ -151,6 +151,8 @@ systemd-run --unit=test-mainpidsh3.service \
</span>             -p RuntimeDirectory=mainpidsh3 \
             -p PIDFile=/run/mainpidsh3/pid \
             -p DynamicUser=1 \
<span
class="add">+            `# Make sanitizers happy when DynamicUser=1 pulls in instrumented systemd NSS modules` \
+            -p EnvironmentFile=-/usr/lib/systemd/systemd-asan-env \
</span>             -p TimeoutStartSec=2s \
             /dev/shm/test-mainpid3.sh \
     &#38;&#38; { echo &#39;unexpected success&#39;; exit 1; }

From 2222222222222222222222222222222222222222 Mon Sep 17 00:00:00 2001
From: rlinden@redhat.com
Date: Wed, 24 Jan 2024 15:49:21 +0100
Subject: [PATCH 2/3] bar bar

we should not mention these other commits in our commit message like this:
55d337de1940076855c1687ffd588498d068724e
dcc59dffa5116bf96618065cd60742cb660224b8

<span
class="del">---
</span> test/units/testsuite-07.main-PID-change.sh | 2 ++
 1 file changed, 2 insertions(+)

<span
class="head">diff --git a/test/units/testsuite-07.main-PID-change.sh b/test/units/testsuite-07.main-PID-change.sh
index be4631f10d..bd5a63a272 100755
--- a/test/units/testsuite-07.main-PID-change.sh
+++ b/test/units/testsuite-07.main-PID-change.sh
</span><span
class="hunk">@@ -151,6 +151,8 @@ systemd-run --unit=test-mainpidsh3.service \
</span>             -p RuntimeDirectory=mainpidsh3 \
             -p PIDFile=/run/mainpidsh3/pid \
             -p DynamicUser=1 \
<span
class="add">+            `# Make sanitizers happy when DynamicUser=1 pulls in instrumented systemd NSS modules` \
+            -p EnvironmentFile=-/usr/share/lib/systemd/systemd-asan-env \
</span>             -p TimeoutStartSec=2s \
             /dev/shm/test-mainpid3.sh \
     &#38;&#38; { echo &#39;unexpected success&#39;; exit 1; }

From 3333333333333333333333333333333333333333 Mon Sep 17 00:00:00 2001
From: rlinden@redhat.com
Date: Wed, 24 Jan 2024 16:49:21 +0100
Subject: [PATCH 3/3] baz baz

that&#39;s it
<span
class="del">---
</span> test/units/testsuite-07.main-PID-change.sh | 2 ++
 1 file changed, 2 insertions(+)

<span
class="head">diff --git a/test/units/testsuite-07.main-PID-change.sh b/test/units/testsuite-07.main-PID-change.sh
index be4631f10d..bd5a63a272 100755
--- a/test/units/testsuite-07.main-PID-change.sh
+++ b/test/units/testsuite-07.main-PID-change.sh
</span><span
class="hunk">@@ -151,6 +151,8 @@ systemd-run --unit=test-mainpidsh3.service \
</span>             -p RuntimeDirectory=mainpidsh3 \
             -p PIDFile=/run/mainpidsh3/pid \
             -p DynamicUser=1 \
<span
class="add">+            `# Make sanitizers happy when DynamicUser=1 pulls in instrumented systemd NSS modules` \
+            -p EnvironmentFile=-/usr/local/lib/systemd/systemd-asan-env \
</span>             -p TimeoutStartSec=2s \
             /dev/shm/test-mainpid3.sh \
     &#38;&#38; { echo &#39;unexpected success&#39;; exit 1; }

<a
href="http://lore.kernel.org/git/CAP0H_AEd1jFNB_dO=HRjwEUKzFqnjntss_1wskKU6hE1VmBs+A@mail.gmail.com/3-fix.patch">[-- Attachment #3: fix.patch --]
[-- Type: text/x-patch, Size: 396 bytes --]</a>

<span
class="head">diff --git a/builtin/patch-id.c b/builtin/patch-id.c
index 583099cacf..4b8a41bde8 100644
--- a/builtin/patch-id.c
+++ b/builtin/patch-id.c
</span><span
class="hunk">@@ -86,7 +86,7 @@ static int get_one_patchid(struct object_id *next_oid, struct object_id *result,
</span> 			continue;
 		}
 
<span
class="del">-		if (!get_oid_hex(p, next_oid)) {
</span><span
class="add">+		if (starts_with(p-5, &#34;From &#34;) &#38;&#38; !get_oid_hex(p, next_oid)) {
</span> 			found_next = 1;
 			break;
 		}
</pre></div></content></entry><entry><author><name>Cs&#243;k&#225;s, Bence</name><email>csokas.bence@prolan.hu</email></author><title>[PATCH resend] git-send-email: Use sanitized address when reading mbox body</title><updated>2024-06-21T09:28:34Z</updated><link
href="http://lore.kernel.org/git/20240621092721.2980939-2-csokas.bence@prolan.hu/"/><id>urn:uuid:59a8a522-b8cf-d391-879d-0587f409fcbd</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Commas and other punctuation marks in &#39;Cc: &#39;, &#39;Signed-off-by: &#39;
etc. lines mess with git-send-email. In parsing the mbox headers,
this is handled by calling `sanitize_address()`. This function
is called when parsing the message body as well, but was only
used for comparing it to $author. Now we add it to @cc too.

Signed-off-by: Cs&#243;k&#225;s, Bence &lt;csokas.bence@prolan.hu&gt;
---
 git-send-email.perl | 4 ++--
 1 file <a href="http://lore.kernel.org/git/20240621092721.2980939-2-csokas.bence@prolan.hu/#related">changed</a>, 2 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/git-send-email.perl b/git-send-email.perl
index f0be4b4560..72044e5ef3 100755
--- a/git-send-email.perl
+++ b/git-send-email.perl
</span><span
class="hunk">@@ -1847,9 +1847,9 @@ sub pre_process_file {
</span> 					$what, $_) unless $quiet;
 				next;
 			}
<span
class="del">-			push @cc, $c;
</span><span
class="add">+			push @cc, $sc;
</span> 			printf(__(&#34;(body) Adding cc: %s from line &#39;%s&#39;\n&#34;),
<span
class="del">-				$c, $_) unless $quiet;
</span><span
class="add">+				$sc, $_) unless $quiet;
</span> 		}
 	}
 	close $fh;
-- 
2.34.1


</pre></div></content></entry><entry><author><name>Toon Claes</name><email>toon@iotcl.com</email></author><title>[PATCH] bundle-uri.c: Fix double increment in depth</title><updated>2024-06-21T09:23:19Z</updated><link
href="http://lore.kernel.org/git/20240621092258.1557258-1-toon@iotcl.com/"/><id>urn:uuid:2fb2d7af-d0fb-7357-7822-a5b952d812da</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">A bundle URI can serve a gitformat-bundle(5) or a bundle list. This
plain text file is in the Git config format containing other bundle
URIs. To avoid these bundle lists to nest too deep, we&#39;ve set a limit
with `max_bundle_uri_depth`. Although, when walk through the tree of
bundles, the current depth is incremented in download_bundle_list() and
then calls download_bundle_to_file(), which also increments the depth.
Remove the increment in download_bundle_to_file().

Signed-off-by: Toon Claes &lt;toon@iotcl.com&gt;
---
 bundle-uri.c                |  2 +-
 t/t5558-clone-bundle-uri.sh | 62 +++++++++++++++++++++++++++++++++++++
 2 files <a href="http://lore.kernel.org/git/20240621092258.1557258-1-toon@iotcl.com/#related">changed</a>, 63 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/bundle-uri.c b/bundle-uri.c
index 91b3319a5c..7b1a711919 100644
--- a/bundle-uri.c
+++ b/bundle-uri.c
</span><span
class="hunk">@@ -436,7 +436,7 @@ static int download_bundle_to_file(struct remote_bundle_info *bundle, void *data
</span> 	if (ctx-&gt;mode == BUNDLE_MODE_ANY &#38;&#38; ctx-&gt;count)
 		return 0;

<span
class="del">-	res = fetch_bundle_uri_internal(ctx-&gt;r, bundle, ctx-&gt;depth + 1, ctx-&gt;list);
</span><span
class="add">+	res = fetch_bundle_uri_internal(ctx-&gt;r, bundle, ctx-&gt;depth, ctx-&gt;list);
</span>
 	/*
 	 * Only increment count if the download succeeded. If our mode is
<span
class="head">diff --git a/t/t5558-clone-bundle-uri.sh b/t/t5558-clone-bundle-uri.sh
index 1ca5f745e7..f3a8494297 100755
--- a/t/t5558-clone-bundle-uri.sh
+++ b/t/t5558-clone-bundle-uri.sh
</span><span
class="hunk">@@ -259,6 +259,68 @@ test_expect_success &#39;clone bundle list (file, any mode, all failures)&#39; &#39;
</span> 	! grep &#34;refs/bundles/&#34; refs
 &#39;

<span
class="add">+test_expect_success &#39;clone bundle list (file, above max depth)&#39; &#39;
+	cat &gt;bundle-list-1 &lt;&lt;-EOF &#38;&#38;
+	[bundle]
+		version = 1
+		mode = any
+
+	[bundle &#34;bundle-list-2&#34;]
+		uri = file://$(pwd)/bundle-list-2
+	EOF
+
+	cat &gt;bundle-list-2 &lt;&lt;-EOF &#38;&#38;
+	[bundle]
+		version = 1
+		mode = any
+
+	[bundle &#34;bundle-list-3&#34;]
+		uri = file://$(pwd)/bundle-list-3
+	EOF
+
+	cat &gt;bundle-list-3 &lt;&lt;-EOF &#38;&#38;
+	[bundle]
+		version = 1
+		mode = any
+
+	[bundle &#34;bundle-list-4&#34;]
+		uri = file://$(pwd)/bundle-list-4
+	EOF
+
+	cat &gt;bundle-list-4 &lt;&lt;-EOF &#38;&#38;
+	[bundle]
+		version = 1
+		mode = any
+
+	[bundle &#34;bundle-0&#34;]
+		uri = file://$(pwd)/clone-from/bundle-0.bundle
+	EOF
+
+	git clone --bundle-uri=&#34;file://$(pwd)/bundle-list-1&#34; \
+		clone-from clone-too-deep 2&gt;err &#38;&#38;
+	! grep &#34;fatal&#34; err &#38;&#38;
+	grep &#34;warning: exceeded bundle URI recursion limit&#34; err &#38;&#38;
+
+	git -C clone-from for-each-ref --format=&#34;%(objectname)&#34; &gt;oids &#38;&#38;
+	git -C clone-too-deep cat-file --batch-check &lt;oids &#38;&#38;
+
+	git -C clone-too-deep for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
+	! grep &#34;refs/bundles/&#34; refs
+&#39;
+
+test_expect_success &#39;clone bundle list (file, below max depth)&#39; &#39;
+	git clone --bundle-uri=&#34;file://$(pwd)/bundle-list-2&#34; \
+		clone-from clone-max-depth 2&gt;err &#38;&#38;
+	! grep &#34;fatal&#34; err &#38;&#38;
+	! grep &#34;warning: exceeded bundle URI recursion limit&#34; err &#38;&#38;
+
+	git -C clone-from for-each-ref --format=&#34;%(objectname)&#34; &gt;oids &#38;&#38;
+	git -C clone-max-depth cat-file --batch-check &lt;oids &#38;&#38;
+
+	git -C clone-max-depth for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
+	! grep &#34;refs/bundles/&#34; refs
+&#39;
+
</span> #########################################################################
 # HTTP tests begin here

<span
class="del">--
</span>2.45.0
</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 11/11] t-reftable-record: add tests for reftable_log_record_compare_key()</title><updated>2024-06-21T06:02:14Z</updated><link
href="http://lore.kernel.org/git/20240621060018.12795-12-chandrapratap3519@gmail.com/"/><id>urn:uuid:d157ecbf-6316-ce78-2316-9912df00a341</id><thr:in-reply-to
ref="urn:uuid:6e1c823b-0ade-ca29-8eb3-e51a2304dd20"
href="http://lore.kernel.org/git/20240621060018.12795-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">reftable_log_record_compare_key() is a function defined by
reftable/record.{c, h} and is used to compare the keys of two
log records when sorting multiple log records using &#39;qsort&#39;.
In the current testing setup, this function is left unexercised.
Add a testing function for the same.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-record.c | 27 +++++++++++++++++++++++++++
 1 file <a href="http://lore.kernel.org/git/20240621060018.12795-12-chandrapratap3519@gmail.com/#related">changed</a>, 27 insertions(+)

<span
class="head">diff --git a/t/unit-tests/t-reftable-record.c b/t/unit-tests/t-reftable-record.c
index e04aac8d7d..2765701214 100644
--- a/t/unit-tests/t-reftable-record.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -211,6 +211,32 @@ static void test_reftable_log_record_comparison(void)
</span> 	check(!reftable_record_cmp(&#38;in[0], &#38;in[1]));
 }
 
<span
class="add">+static void test_reftable_log_record_compare_key(void)
+{
+	struct reftable_log_record logs[14] = { 0 };
+	size_t N = ARRAY_SIZE(logs), i;
+	char refname[100];
+
+	for (i = 0; i &lt; N; i++) {
+		if (i &lt; N / 2) {
+			xsnprintf(refname, sizeof(refname), &#34;%02&#34;PRIuMAX, (uintmax_t)i);
+			logs[i].refname = xstrdup(refname);
+			logs[i].update_index = i;
+		} else {
+			logs[i].refname = xstrdup(&#34;refs/heads/master&#34;);
+			logs[i].update_index = i;
+		}
+	}
+
+	QSORT(logs, N, reftable_log_record_compare_key);
+
+	for (i = 1; i &lt; N; i++)
+		check(reftable_log_record_compare_key(&#38;logs[i - 1], &#38;logs[i]) &lt; 0);
+
+	for (i = 0; i &lt; N; i++)
+		reftable_log_record_release(&#38;logs[i]);
+}
+
</span> static void test_reftable_log_record_roundtrip(void)
 {
 	struct reftable_log_record in[] = {
<span
class="hunk">@@ -516,6 +542,7 @@ int cmd_main(int argc, const char *argv[])
</span> 	TEST(test_reftable_index_record_comparison(), &#34;comparison operations work on index record&#34;);
 	TEST(test_reftable_obj_record_comparison(), &#34;comparison operations work on obj record&#34;);
 	TEST(test_reftable_ref_record_compare_name(), &#34;reftable_ref_record_compare_name works&#34;);
<span
class="add">+	TEST(test_reftable_log_record_compare_key(), &#34;reftable_log_record_compare_key works&#34;);
</span> 	TEST(test_reftable_log_record_roundtrip(), &#34;record operations work on log record&#34;);
 	TEST(test_reftable_ref_record_roundtrip(), &#34;record operations work on ref record&#34;);
 	TEST(test_varint_roundtrip(), &#34;put_var_int and get_var_int work&#34;);
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 10/11] t-reftable-record: add tests for reftable_ref_record_compare_name()</title><updated>2024-06-21T06:02:11Z</updated><link
href="http://lore.kernel.org/git/20240621060018.12795-11-chandrapratap3519@gmail.com/"/><id>urn:uuid:3e671393-dbbc-bc6b-c19b-735143832d23</id><thr:in-reply-to
ref="urn:uuid:6e1c823b-0ade-ca29-8eb3-e51a2304dd20"
href="http://lore.kernel.org/git/20240621060018.12795-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">reftable_ref_record_compare_name() is a function defined by
reftable/record.{c, h} and is used to compare the refname of two
ref records when sorting multiple ref records using &#39;qsort&#39;.
In the current testing setup, this function is left unexercised.
Add a testing function for the same.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-record.c | 21 +++++++++++++++++++++
 1 file <a href="http://lore.kernel.org/git/20240621060018.12795-11-chandrapratap3519@gmail.com/#related">changed</a>, 21 insertions(+)

<span
class="head">diff --git a/t/unit-tests/t-reftable-record.c b/t/unit-tests/t-reftable-record.c
index bb2986eef6..e04aac8d7d 100644
--- a/t/unit-tests/t-reftable-record.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -98,6 +98,26 @@ static void test_reftable_ref_record_comparison(void)
</span> 	check(!reftable_record_cmp(&#38;in[0], &#38;in[1]));
 }
 
<span
class="add">+static void test_reftable_ref_record_compare_name(void)
+{
+	struct reftable_ref_record recs[14] = { 0 };
+	size_t N = ARRAY_SIZE(recs), i;
+	char refname[100];
+
+	for (i = 0; i &lt; N; i++) {
+		xsnprintf(refname, sizeof(refname), &#34;%02&#34;PRIuMAX, (uintmax_t)i);
+		recs[i].refname = xstrdup(refname);
+	}
+
+	QSORT(recs, N, reftable_ref_record_compare_name);
+
+	for (i = 1; i &lt; N; i++)
+		check(reftable_ref_record_compare_name(&#38;recs[i - 1], &#38;recs[i]) &lt; 0);
+
+	for (i = 0; i &lt; N; i++)
+		reftable_ref_record_release(&#38;recs[i]);
+}
+
</span> static void test_reftable_ref_record_roundtrip(void)
 {
 	struct strbuf scratch = STRBUF_INIT;
<span
class="hunk">@@ -495,6 +515,7 @@ int cmd_main(int argc, const char *argv[])
</span> 	TEST(test_reftable_log_record_comparison(), &#34;comparison operations work on log record&#34;);
 	TEST(test_reftable_index_record_comparison(), &#34;comparison operations work on index record&#34;);
 	TEST(test_reftable_obj_record_comparison(), &#34;comparison operations work on obj record&#34;);
<span
class="add">+	TEST(test_reftable_ref_record_compare_name(), &#34;reftable_ref_record_compare_name works&#34;);
</span> 	TEST(test_reftable_log_record_roundtrip(), &#34;record operations work on log record&#34;);
 	TEST(test_reftable_ref_record_roundtrip(), &#34;record operations work on ref record&#34;);
 	TEST(test_varint_roundtrip(), &#34;put_var_int and get_var_int work&#34;);
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 09/11] t-reftable-record: add reftable_record_is_deletion() test for index records</title><updated>2024-06-21T06:02:07Z</updated><link
href="http://lore.kernel.org/git/20240621060018.12795-10-chandrapratap3519@gmail.com/"/><id>urn:uuid:b216392f-3339-d0ba-dd2a-b1f7626b2fed</id><thr:in-reply-to
ref="urn:uuid:6e1c823b-0ade-ca29-8eb3-e51a2304dd20"
href="http://lore.kernel.org/git/20240621060018.12795-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">reftable_record_is_deletion() is a function defined in
reftable/record.{c, h} which determines whether a record is of
type deletion or not. Since index records can never be of type deletion,
this function must always return 0 when called on an index record.
In the current testing setup for index records, this functionality is
left untested. Add a test for the same.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-record.c | 1 +
 1 file <a href="http://lore.kernel.org/git/20240621060018.12795-10-chandrapratap3519@gmail.com/#related">changed</a>, 1 insertion(+)

<span
class="head">diff --git a/t/unit-tests/t-reftable-record.c b/t/unit-tests/t-reftable-record.c
index 204a673260..bb2986eef6 100644
--- a/t/unit-tests/t-reftable-record.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -471,6 +471,7 @@ static void test_reftable_index_record_roundtrip(void)
</span> 	reftable_record_key(&#38;in, &#38;key);
 	test_copy(&#38;in);
 
<span
class="add">+	check(!reftable_record_is_deletion(&#38;in));
</span> 	check(!strbuf_cmp(&#38;key, &#38;in.u.idx.last_key));
 	n = reftable_record_encode(&#38;in, dest, GIT_SHA1_RAWSZ);
 	check_int(n, &gt;, 0);
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 08/11] t-reftable-record: add reftable_record_is_deletion() test for obj records</title><updated>2024-06-21T06:02:04Z</updated><link
href="http://lore.kernel.org/git/20240621060018.12795-9-chandrapratap3519@gmail.com/"/><id>urn:uuid:f2796ba9-8e86-c4c6-e3c6-12aac05e5378</id><thr:in-reply-to
ref="urn:uuid:6e1c823b-0ade-ca29-8eb3-e51a2304dd20"
href="http://lore.kernel.org/git/20240621060018.12795-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">reftable_record_is_deletion() is a function defined in
reftable/record.{c, h} which determines whether a record is of
type deletion or not. Since obj records can never be of type deletion,
this function must always return 0 when called on an obj record.
In the current testing setup for obj records, this functionality is
left untested. Add a test for the same.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-record.c | 1 +
 1 file <a href="http://lore.kernel.org/git/20240621060018.12795-9-chandrapratap3519@gmail.com/#related">changed</a>, 1 insertion(+)

<span
class="head">diff --git a/t/unit-tests/t-reftable-record.c b/t/unit-tests/t-reftable-record.c
index 70c1db6756..204a673260 100644
--- a/t/unit-tests/t-reftable-record.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -389,6 +389,7 @@ static void test_reftable_obj_record_roundtrip(void)
</span> 		int n, m;
 		uint8_t extra;
 
<span
class="add">+		check(!reftable_record_is_deletion(&#38;in));
</span> 		test_copy(&#38;in);
 		reftable_record_key(&#38;in, &#38;key);
 		n = reftable_record_encode(&#38;in, dest, GIT_SHA1_RAWSZ);
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 07/11] t-reftable-record: add reftable_record_is_deletion() test for log records</title><updated>2024-06-21T06:02:00Z</updated><link
href="http://lore.kernel.org/git/20240621060018.12795-8-chandrapratap3519@gmail.com/"/><id>urn:uuid:911bf9ff-ffb1-f4aa-7e3e-c84b06f056a0</id><thr:in-reply-to
ref="urn:uuid:6e1c823b-0ade-ca29-8eb3-e51a2304dd20"
href="http://lore.kernel.org/git/20240621060018.12795-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">reftable_log_record_is_deletion() is a function defined in
reftable/record.{c, h} which determines whether a log record is of
type deletion or not. In the current testing setup for log records,
this function is left untested. Add tests for the same.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-record.c | 4 ++++
 1 file <a href="http://lore.kernel.org/git/20240621060018.12795-8-chandrapratap3519@gmail.com/#related">changed</a>, 4 insertions(+)

<span
class="head">diff --git a/t/unit-tests/t-reftable-record.c b/t/unit-tests/t-reftable-record.c
index fe12fd2201..70c1db6756 100644
--- a/t/unit-tests/t-reftable-record.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -225,6 +225,10 @@ static void test_reftable_log_record_roundtrip(void)
</span> 	set_hash(in[2].value.update.new_hash, 3);
 	set_hash(in[2].value.update.old_hash, 4);
 
<span
class="add">+	check(!reftable_log_record_is_deletion(&#38;in[0]));
+	check(reftable_log_record_is_deletion(&#38;in[1]));
+	check(!reftable_log_record_is_deletion(&#38;in[2]));
+
</span> 	for (size_t i = 0; i &lt; ARRAY_SIZE(in); i++) {
 		struct reftable_record rec = { .type = BLOCK_TYPE_LOG };
 		struct strbuf key = STRBUF_INIT;
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 06/11] t-reftable-record: add reftable_record_is_deletion() test for ref records</title><updated>2024-06-21T06:01:57Z</updated><link
href="http://lore.kernel.org/git/20240621060018.12795-7-chandrapratap3519@gmail.com/"/><id>urn:uuid:0339a5c3-b8f8-bd23-4b37-f52261bbb73b</id><thr:in-reply-to
ref="urn:uuid:6e1c823b-0ade-ca29-8eb3-e51a2304dd20"
href="http://lore.kernel.org/git/20240621060018.12795-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">reftable_ref_record_is_deletion() is a function defined in
reftable/record.{c, h} that determines whether a ref record is of
type deletion or not. In the current testing setup for ref records,
this function is left untested.

Add tests for the same by using the wrapper function
reftable_record_is_deletion().

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-record.c | 5 +++++
 1 file <a href="http://lore.kernel.org/git/20240621060018.12795-7-chandrapratap3519@gmail.com/#related">changed</a>, 5 insertions(+)

<span
class="head">diff --git a/t/unit-tests/t-reftable-record.c b/t/unit-tests/t-reftable-record.c
index d7490db5e5..fe12fd2201 100644
--- a/t/unit-tests/t-reftable-record.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -105,6 +105,7 @@ static void test_reftable_ref_record_roundtrip(void)
</span> 	for (int i = REFTABLE_REF_DELETION; i &lt; REFTABLE_NR_REF_VALUETYPES; i++) {
 		struct reftable_record in = {
 			.type = BLOCK_TYPE_REF,
<span
class="add">+			.u.ref.value_type = i,
</span> 		};
 		struct reftable_record out = { .type = BLOCK_TYPE_REF };
 		struct strbuf key = STRBUF_INIT;
<span
class="hunk">@@ -118,15 +119,19 @@ static void test_reftable_ref_record_roundtrip(void)
</span> 		in.u.ref.value_type = i;
 		switch (i) {
 		case REFTABLE_REF_DELETION:
<span
class="add">+			check(reftable_record_is_deletion(&#38;in));
</span> 			break;
 		case REFTABLE_REF_VAL1:
<span
class="add">+			check(!reftable_record_is_deletion(&#38;in));
</span> 			set_hash(in.u.ref.value.val1, 1);
 			break;
 		case REFTABLE_REF_VAL2:
<span
class="add">+			check(!reftable_record_is_deletion(&#38;in));
</span> 			set_hash(in.u.ref.value.val2.value, 1);
 			set_hash(in.u.ref.value.val2.target_value, 2);
 			break;
 		case REFTABLE_REF_SYMREF:
<span
class="add">+			check(!reftable_record_is_deletion(&#38;in));
</span> 			in.u.ref.value.symref = xstrdup(&#34;target&#34;);
 			break;
 		}
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 05/11] t-reftable-record: add comparison tests for obj records</title><updated>2024-06-21T06:01:53Z</updated><link
href="http://lore.kernel.org/git/20240621060018.12795-6-chandrapratap3519@gmail.com/"/><id>urn:uuid:adf0c187-e8c0-0630-a6a0-7c460add845a</id><thr:in-reply-to
ref="urn:uuid:6e1c823b-0ade-ca29-8eb3-e51a2304dd20"
href="http://lore.kernel.org/git/20240621060018.12795-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">In the current testing setup for obj records, the comparison
functions for obj records, reftable_obj_record_cmp_void() and
reftable_obj_record_equal_void() are left untested.

Add tests for the same by using the wrapper functions
reftable_record_cmp() and reftable_record_equal() for
reftable_index_record_cmp_void() and reftable_index_record_equal_void()
respectively.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-record.c | 39 ++++++++++++++++++++++++++++++++
 1 file <a href="http://lore.kernel.org/git/20240621060018.12795-6-chandrapratap3519@gmail.com/#related">changed</a>, 39 insertions(+)

<span
class="head">diff --git a/t/unit-tests/t-reftable-record.c b/t/unit-tests/t-reftable-record.c
index 1d102fb547..d7490db5e5 100644
--- a/t/unit-tests/t-reftable-record.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -301,6 +301,44 @@ static void test_key_roundtrip(void)
</span> 	strbuf_release(&#38;roundtrip);
 }
 
<span
class="add">+static void test_reftable_obj_record_comparison(void)
+{
+
+	uint8_t id_bytes[] = { 0, 1, 2, 3, 4, 5, 6 };
+	uint64_t offsets[] = { 0, 16, 32, 48, 64, 80, 96, 112};
+	struct reftable_record in[3] = {
+		{
+			.type = BLOCK_TYPE_OBJ,
+			.u.obj.hash_prefix = id_bytes,
+			.u.obj.hash_prefix_len = 7,
+			.u.obj.offsets = offsets,
+			.u.obj.offset_len = 8,
+		},
+		{
+			.type = BLOCK_TYPE_OBJ,
+			.u.obj.hash_prefix = id_bytes,
+			.u.obj.hash_prefix_len = 7,
+			.u.obj.offsets = offsets,
+			.u.obj.offset_len = 5,
+		},
+		{
+			.type = BLOCK_TYPE_OBJ,
+			.u.obj.hash_prefix = id_bytes,
+			.u.obj.hash_prefix_len = 5,
+		},
+	};
+
+	check(!reftable_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
+	check(!reftable_record_cmp(&#38;in[0], &#38;in[1]));
+
+	check(!reftable_record_equal(&#38;in[1], &#38;in[2], GIT_SHA1_RAWSZ));
+	check_int(reftable_record_cmp(&#38;in[1], &#38;in[2]), &gt;, 0);
+
+	in[1].u.obj.offset_len = in[0].u.obj.offset_len;
+	check(reftable_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
+	check(!reftable_record_cmp(&#38;in[0], &#38;in[1]));
+}
+
</span> static void test_reftable_obj_record_roundtrip(void)
 {
 	uint8_t testHash1[GIT_SHA1_RAWSZ] = { 1, 2, 3, 4, 0 };
<span
class="hunk">@@ -445,6 +483,7 @@ int cmd_main(int argc, const char *argv[])
</span> 	TEST(test_reftable_ref_record_comparison(), &#34;comparison operations work on ref record&#34;);
 	TEST(test_reftable_log_record_comparison(), &#34;comparison operations work on log record&#34;);
 	TEST(test_reftable_index_record_comparison(), &#34;comparison operations work on index record&#34;);
<span
class="add">+	TEST(test_reftable_obj_record_comparison(), &#34;comparison operations work on obj record&#34;);
</span> 	TEST(test_reftable_log_record_roundtrip(), &#34;record operations work on log record&#34;);
 	TEST(test_reftable_ref_record_roundtrip(), &#34;record operations work on ref record&#34;);
 	TEST(test_varint_roundtrip(), &#34;put_var_int and get_var_int work&#34;);
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 04/11] t-reftable-record: add comparison tests for index records</title><updated>2024-06-21T06:01:50Z</updated><link
href="http://lore.kernel.org/git/20240621060018.12795-5-chandrapratap3519@gmail.com/"/><id>urn:uuid:8bc6dbd1-bc9c-e99a-3aa0-0a2bd679f669</id><thr:in-reply-to
ref="urn:uuid:6e1c823b-0ade-ca29-8eb3-e51a2304dd20"
href="http://lore.kernel.org/git/20240621060018.12795-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">In the current testing setup for index records, the comparison
functions for index records, reftable_index_record_cmp() and
reftable_index_record_equal() are left untested.

Add tests for the same by using the wrapper functions
reftable_record_cmp() and reftable_record_equal() for
reftable_index_record_cmp() and reftable_index_record_equal()
respectively.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-record.c | 38 ++++++++++++++++++++++++++++++++
 1 file <a href="http://lore.kernel.org/git/20240621060018.12795-5-chandrapratap3519@gmail.com/#related">changed</a>, 38 insertions(+)

<span
class="head">diff --git a/t/unit-tests/t-reftable-record.c b/t/unit-tests/t-reftable-record.c
index d25d11c7e1..1d102fb547 100644
--- a/t/unit-tests/t-reftable-record.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -359,6 +359,43 @@ static void test_reftable_obj_record_roundtrip(void)
</span> 	strbuf_release(&#38;scratch);
 }
 
<span
class="add">+static void test_reftable_index_record_comparison(void)
+{
+	struct reftable_record in[3] = {
+		{
+			.type = BLOCK_TYPE_INDEX,
+			.u.idx.offset = 22,
+			.u.idx.last_key = STRBUF_INIT,
+		},
+		{
+			.type = BLOCK_TYPE_INDEX,
+			.u.idx.offset = 32,
+			.u.idx.last_key = STRBUF_INIT,
+		},
+		{
+			.type = BLOCK_TYPE_INDEX,
+			.u.idx.offset = 32,
+			.u.idx.last_key = STRBUF_INIT,
+		},
+	};
+	strbuf_addstr(&#38;in[0].u.idx.last_key, &#34;refs/heads/master&#34;);
+	strbuf_addstr(&#38;in[1].u.idx.last_key, &#34;refs/heads/master&#34;);
+	strbuf_addstr(&#38;in[2].u.idx.last_key, &#34;refs/heads/branch&#34;);
+
+	check(!reftable_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
+	check(!reftable_record_cmp(&#38;in[0], &#38;in[1]));
+
+	check(!reftable_record_equal(&#38;in[1], &#38;in[2], GIT_SHA1_RAWSZ));
+	check_int(reftable_record_cmp(&#38;in[1], &#38;in[2]), &gt;, 0);
+
+	in[1].u.idx.offset = in[0].u.idx.offset;
+	check(reftable_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
+	check(!reftable_record_cmp(&#38;in[0], &#38;in[1]));
+
+	for (size_t i = 0; i &lt; ARRAY_SIZE(in); i++)
+		reftable_record_release(&#38;in[i]);
+}
+
</span> static void test_reftable_index_record_roundtrip(void)
 {
 	struct reftable_record in = {
<span
class="hunk">@@ -407,6 +444,7 @@ int cmd_main(int argc, const char *argv[])
</span> {
 	TEST(test_reftable_ref_record_comparison(), &#34;comparison operations work on ref record&#34;);
 	TEST(test_reftable_log_record_comparison(), &#34;comparison operations work on log record&#34;);
<span
class="add">+	TEST(test_reftable_index_record_comparison(), &#34;comparison operations work on index record&#34;);
</span> 	TEST(test_reftable_log_record_roundtrip(), &#34;record operations work on log record&#34;);
 	TEST(test_reftable_ref_record_roundtrip(), &#34;record operations work on ref record&#34;);
 	TEST(test_varint_roundtrip(), &#34;put_var_int and get_var_int work&#34;);
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 03/11] t-reftable-record: add comparison tests for ref records</title><updated>2024-06-21T06:01:47Z</updated><link
href="http://lore.kernel.org/git/20240621060018.12795-4-chandrapratap3519@gmail.com/"/><id>urn:uuid:fa9c6ac4-30ea-2205-7df0-fe469725b358</id><thr:in-reply-to
ref="urn:uuid:6e1c823b-0ade-ca29-8eb3-e51a2304dd20"
href="http://lore.kernel.org/git/20240621060018.12795-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">In the current testing setup for ref records, the comparison
functions for ref records, reftable_ref_record_cmp_void() and
reftable_ref_record_equal() are left untested.

Add tests for the same by using the wrapper functions
reftable_record_cmp() and reftable_record_equal() for
reftable_ref_record_cmp_void() and reftable_ref_record_equal()
respectively.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-record.c | 33 ++++++++++++++++++++++++++++++++
 1 file <a href="http://lore.kernel.org/git/20240621060018.12795-4-chandrapratap3519@gmail.com/#related">changed</a>, 33 insertions(+)

<span
class="head">diff --git a/t/unit-tests/t-reftable-record.c b/t/unit-tests/t-reftable-record.c
index 4913a82441..d25d11c7e1 100644
--- a/t/unit-tests/t-reftable-record.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -66,6 +66,38 @@ static void set_hash(uint8_t *h, int j)
</span> 		h[i] = (j &gt;&gt; i) &#38; 0xff;
 }
 
<span
class="add">+static void test_reftable_ref_record_comparison(void)
+{
+	struct reftable_record in[3] = {
+		{
+			.type = BLOCK_TYPE_REF,
+			.u.ref.refname = &#34;refs/heads/master&#34;,
+			.u.ref.value_type = REFTABLE_REF_VAL1,
+		},
+		{
+			.type = BLOCK_TYPE_REF,
+			.u.ref.refname = &#34;refs/heads/master&#34;,
+			.u.ref.value_type = REFTABLE_REF_DELETION,
+		},
+		{
+			.type = BLOCK_TYPE_REF,
+			.u.ref.refname = &#34;HEAD&#34;,
+			.u.ref.value_type = REFTABLE_REF_SYMREF,
+			.u.ref.value.symref = &#34;refs/heads/master&#34;,
+		},
+	};
+
+	check(!reftable_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
+	check(!reftable_record_cmp(&#38;in[0], &#38;in[1]));
+
+	check(!reftable_record_equal(&#38;in[1], &#38;in[2], GIT_SHA1_RAWSZ));
+	check_int(reftable_record_cmp(&#38;in[1], &#38;in[2]), &gt;, 0);
+
+	in[1].u.ref.value_type = in[0].u.ref.value_type;
+	check(reftable_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
+	check(!reftable_record_cmp(&#38;in[0], &#38;in[1]));
+}
+
</span> static void test_reftable_ref_record_roundtrip(void)
 {
 	struct strbuf scratch = STRBUF_INIT;
<span
class="hunk">@@ -373,6 +405,7 @@ static void test_reftable_index_record_roundtrip(void)
</span> 
 int cmd_main(int argc, const char *argv[])
 {
<span
class="add">+	TEST(test_reftable_ref_record_comparison(), &#34;comparison operations work on ref record&#34;);
</span> 	TEST(test_reftable_log_record_comparison(), &#34;comparison operations work on log record&#34;);
 	TEST(test_reftable_log_record_roundtrip(), &#34;record operations work on log record&#34;);
 	TEST(test_reftable_ref_record_roundtrip(), &#34;record operations work on ref record&#34;);
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 02/11] t-reftable-record: add reftable_record_cmp() tests for log records</title><updated>2024-06-21T06:01:43Z</updated><link
href="http://lore.kernel.org/git/20240621060018.12795-3-chandrapratap3519@gmail.com/"/><id>urn:uuid:5c666075-0985-0352-66d3-36a052c98be1</id><thr:in-reply-to
ref="urn:uuid:6e1c823b-0ade-ca29-8eb3-e51a2304dd20"
href="http://lore.kernel.org/git/20240621060018.12795-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">In the current testing setup for log records, only
reftable_log_record_equal() among log record&#39;s comparison functions
is tested. Modify the existing tests to exercise
reftable_log_record_cmp_void() as well.

This can be achieved by using the wrapper functions
reftable_record_cmp() and reftable_record_equal() instead of
reftable_log_record_cmp_void() and reftable_log_record_equal()
respectively.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-record.c | 37 +++++++++++++++++++++-----------
 1 file <a href="http://lore.kernel.org/git/20240621060018.12795-3-chandrapratap3519@gmail.com/#related">changed</a>, 24 insertions(+), 13 deletions(-)

<span
class="head">diff --git a/t/unit-tests/t-reftable-record.c b/t/unit-tests/t-reftable-record.c
index 1b357e6c7f..4913a82441 100644
--- a/t/unit-tests/t-reftable-record.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -123,24 +123,35 @@ static void test_reftable_ref_record_roundtrip(void)
</span> 	strbuf_release(&#38;scratch);
 }
 
<span
class="del">-static void test_reftable_log_record_equal(void)
</span><span
class="add">+static void test_reftable_log_record_comparison(void)
</span> {
<span
class="del">-	struct reftable_log_record in[2] = {
</span><span
class="add">+	struct reftable_record in[3] = {
</span> 		{
<span
class="del">-			.refname = xstrdup(&#34;refs/heads/master&#34;),
-			.update_index = 42,
</span><span
class="add">+			.type = BLOCK_TYPE_LOG,
+			.u.log.refname = &#34;refs/heads/master&#34;,
+			.u.log.update_index = 42,
</span> 		},
 		{
<span
class="del">-			.refname = xstrdup(&#34;refs/heads/master&#34;),
-			.update_index = 22,
-		}
</span><span
class="add">+			.type = BLOCK_TYPE_LOG,
+			.u.log.refname = &#34;refs/heads/master&#34;,
+			.u.log.update_index = 22,
+		},
+		{
+			.type = BLOCK_TYPE_LOG,
+			.u.log.refname = &#34;refs/heads/main&#34;,
+			.u.log.update_index = 22,
+		},
</span> 	};
 
<span
class="del">-	check(!reftable_log_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
-	in[1].update_index = in[0].update_index;
-	check(reftable_log_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
-	reftable_log_record_release(&#38;in[0]);
-	reftable_log_record_release(&#38;in[1]);
</span><span
class="add">+	check(!reftable_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
+	check(!reftable_record_equal(&#38;in[1], &#38;in[2], GIT_SHA1_RAWSZ));
+	check_int(reftable_record_cmp(&#38;in[1], &#38;in[2]), &gt;, 0);
+	/* comparison should be reversed for equal keys */
+	check_int(reftable_record_cmp(&#38;in[0], &#38;in[1]), &lt;, 0);
+
+	in[1].u.log.update_index = in[0].u.log.update_index;
+	check(reftable_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
+	check(!reftable_record_cmp(&#38;in[0], &#38;in[1]));
</span> }
 
 static void test_reftable_log_record_roundtrip(void)
<span
class="hunk">@@ -362,7 +373,7 @@ static void test_reftable_index_record_roundtrip(void)
</span> 
 int cmd_main(int argc, const char *argv[])
 {
<span
class="del">-	TEST(test_reftable_log_record_equal(), &#34;reftable_log_record_equal works&#34;);
</span><span
class="add">+	TEST(test_reftable_log_record_comparison(), &#34;comparison operations work on log record&#34;);
</span> 	TEST(test_reftable_log_record_roundtrip(), &#34;record operations work on log record&#34;);
 	TEST(test_reftable_ref_record_roundtrip(), &#34;record operations work on ref record&#34;);
 	TEST(test_varint_roundtrip(), &#34;put_var_int and get_var_int work&#34;);
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH 01/11] t: move reftable/record_test.c to the unit testing framework</title><updated>2024-06-21T06:01:40Z</updated><link
href="http://lore.kernel.org/git/20240621060018.12795-2-chandrapratap3519@gmail.com/"/><id>urn:uuid:78a2fed8-6351-c068-9d2f-1725cce3b08c</id><thr:in-reply-to
ref="urn:uuid:6e1c823b-0ade-ca29-8eb3-e51a2304dd20"
href="http://lore.kernel.org/git/20240621060018.12795-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">reftable/record_test.c exercises the functions defined in
reftable/record.{c, h}. Migrate reftable/record_test.c to the
unit testing framework. Migration involves refactoring the tests
to use the unit testing framework instead of reftable&#39;s test
framework.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 Makefile                                      |   2 +-
 t/helper/test-reftable.c                      |   1 -
 .../unit-tests/t-reftable-record.c            | 106 ++++++++----------
 3 files <a href="http://lore.kernel.org/git/20240621060018.12795-2-chandrapratap3519@gmail.com/#related">changed</a>, 50 insertions(+), 59 deletions(-)
 rename reftable/record_test.c =&gt; t/unit-tests/t-reftable-record.c (77%)

<span
class="head">diff --git a/Makefile b/Makefile
index f25b2e80a1..def3700b4d 100644
--- a/Makefile
+++ b/Makefile
</span><span
class="hunk">@@ -1338,6 +1338,7 @@ UNIT_TEST_PROGRAMS += t-hash
</span> UNIT_TEST_PROGRAMS += t-mem-pool
 UNIT_TEST_PROGRAMS += t-prio-queue
 UNIT_TEST_PROGRAMS += t-reftable-basics
<span
class="add">+UNIT_TEST_PROGRAMS += t-reftable-record
</span> UNIT_TEST_PROGRAMS += t-strbuf
 UNIT_TEST_PROGRAMS += t-strcmp-offset
 UNIT_TEST_PROGRAMS += t-strvec
<span
class="hunk">@@ -2678,7 +2679,6 @@ REFTABLE_TEST_OBJS += reftable/block_test.o
</span> REFTABLE_TEST_OBJS += reftable/dump.o
 REFTABLE_TEST_OBJS += reftable/merged_test.o
 REFTABLE_TEST_OBJS += reftable/pq_test.o
<span
class="del">-REFTABLE_TEST_OBJS += reftable/record_test.o
</span> REFTABLE_TEST_OBJS += reftable/readwrite_test.o
 REFTABLE_TEST_OBJS += reftable/stack_test.o
 REFTABLE_TEST_OBJS += reftable/test_framework.o
<span
class="head">diff --git a/t/helper/test-reftable.c b/t/helper/test-reftable.c
index 9160bc5da6..aa6538a8da 100644
--- a/t/helper/test-reftable.c
+++ b/t/helper/test-reftable.c
</span><span
class="hunk">@@ -5,7 +5,6 @@
</span> int cmd__reftable(int argc, const char **argv)
 {
 	/* test from simple to complex. */
<span
class="del">-	record_test_main(argc, argv);
</span> 	block_test_main(argc, argv);
 	tree_test_main(argc, argv);
 	pq_test_main(argc, argv);
<span
class="head">diff --git a/reftable/record_test.c b/t/unit-tests/t-reftable-record.c
similarity index 77%
rename from reftable/record_test.c
rename to t/unit-tests/t-reftable-record.c
index 58290bdba3..1b357e6c7f 100644
--- a/reftable/record_test.c
+++ b/t/unit-tests/t-reftable-record.c
</span><span
class="hunk">@@ -6,13 +6,9 @@
</span>   <a
href="https://developers.google.com/open-source/licenses/bsd">https://developers.google.com/open-source/licenses/bsd</a>
 */
 
<span
class="del">-#include &#34;record.h&#34;
-
-#include &#34;system.h&#34;
-#include &#34;basics.h&#34;
-#include &#34;constants.h&#34;
-#include &#34;test_framework.h&#34;
-#include &#34;reftable-tests.h&#34;
</span><span
class="add">+#include &#34;test-lib.h&#34;
+#include &#34;reftable/constants.h&#34;
+#include &#34;reftable/record.h&#34;
</span> 
 static void test_copy(struct reftable_record *rec)
 {
<span
class="hunk">@@ -24,9 +20,9 @@ static void test_copy(struct reftable_record *rec)
</span> 	reftable_record_copy_from(&#38;copy, rec, GIT_SHA1_RAWSZ);
 	/* do it twice to catch memory leaks */
 	reftable_record_copy_from(&#38;copy, rec, GIT_SHA1_RAWSZ);
<span
class="del">-	EXPECT(reftable_record_equal(rec, &#38;copy, GIT_SHA1_RAWSZ));
</span><span
class="add">+	check(reftable_record_equal(rec, &#38;copy, GIT_SHA1_RAWSZ));
</span> 
<span
class="del">-	puts(&#34;testing print coverage:\n&#34;);
</span><span
class="add">+	test_msg(&#34;testing print coverage:&#34;);
</span> 	reftable_record_print(&#38;copy, GIT_SHA1_RAWSZ);
 
 	reftable_record_release(&#38;copy);
<span
class="hunk">@@ -43,8 +39,8 @@ static void test_varint_roundtrip(void)
</span> 			      4096,
 			      ((uint64_t)1 &lt;&lt; 63),
 			      ((uint64_t)1 &lt;&lt; 63) + ((uint64_t)1 &lt;&lt; 63) - 1 };
<span
class="del">-	int i = 0;
-	for (i = 0; i &lt; ARRAY_SIZE(inputs); i++) {
</span><span
class="add">+
+	for (size_t i = 0; i &lt; ARRAY_SIZE(inputs); i++) {
</span> 		uint8_t dest[10];
 
 		struct string_view out = {
<span
class="hunk">@@ -55,29 +51,26 @@ static void test_varint_roundtrip(void)
</span> 		int n = put_var_int(&#38;out, in);
 		uint64_t got = 0;
 
<span
class="del">-		EXPECT(n &gt; 0);
</span><span
class="add">+		check_int(n, &gt;, 0);
</span> 		out.len = n;
 		n = get_var_int(&#38;got, &#38;out);
<span
class="del">-		EXPECT(n &gt; 0);
</span><span
class="add">+		check_int(n, &gt;, 0);
</span> 
<span
class="del">-		EXPECT(got == in);
</span><span
class="add">+		check_int(got, ==, in);
</span> 	}
 }
 
 static void set_hash(uint8_t *h, int j)
 {
<span
class="del">-	int i = 0;
-	for (i = 0; i &lt; hash_size(GIT_SHA1_FORMAT_ID); i++) {
</span><span
class="add">+	for (int i = 0; i &lt; hash_size(GIT_SHA1_FORMAT_ID); i++)
</span> 		h[i] = (j &gt;&gt; i) &#38; 0xff;
<span
class="del">-	}
</span> }
 
 static void test_reftable_ref_record_roundtrip(void)
 {
 	struct strbuf scratch = STRBUF_INIT;
<span
class="del">-	int i = 0;
</span> 
<span
class="del">-	for (i = REFTABLE_REF_DELETION; i &lt; REFTABLE_NR_REF_VALUETYPES; i++) {
</span><span
class="add">+	for (int i = REFTABLE_REF_DELETION; i &lt; REFTABLE_NR_REF_VALUETYPES; i++) {
</span> 		struct reftable_record in = {
 			.type = BLOCK_TYPE_REF,
 		};
<span
class="hunk">@@ -109,17 +102,17 @@ static void test_reftable_ref_record_roundtrip(void)
</span> 
 		test_copy(&#38;in);
 
<span
class="del">-		EXPECT(reftable_record_val_type(&#38;in) == i);
</span><span
class="add">+		check_int(reftable_record_val_type(&#38;in), ==, i);
</span> 
 		reftable_record_key(&#38;in, &#38;key);
 		n = reftable_record_encode(&#38;in, dest, GIT_SHA1_RAWSZ);
<span
class="del">-		EXPECT(n &gt; 0);
</span><span
class="add">+		check_int(n, &gt;, 0);
</span> 
 		/* decode into a non-zero reftable_record to test for leaks. */
 		m = reftable_record_decode(&#38;out, key, i, dest, GIT_SHA1_RAWSZ, &#38;scratch);
<span
class="del">-		EXPECT(n == m);
</span><span
class="add">+		check_int(n, ==, m);
</span> 
<span
class="del">-		EXPECT(reftable_ref_record_equal(&#38;in.u.ref, &#38;out.u.ref,
</span><span
class="add">+		check(reftable_ref_record_equal(&#38;in.u.ref, &#38;out.u.ref,
</span> 						 GIT_SHA1_RAWSZ));
 		reftable_record_release(&#38;in);
 
<span
class="hunk">@@ -143,16 +136,15 @@ static void test_reftable_log_record_equal(void)
</span> 		}
 	};
 
<span
class="del">-	EXPECT(!reftable_log_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
</span><span
class="add">+	check(!reftable_log_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
</span> 	in[1].update_index = in[0].update_index;
<span
class="del">-	EXPECT(reftable_log_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
</span><span
class="add">+	check(reftable_log_record_equal(&#38;in[0], &#38;in[1], GIT_SHA1_RAWSZ));
</span> 	reftable_log_record_release(&#38;in[0]);
 	reftable_log_record_release(&#38;in[1]);
 }
 
 static void test_reftable_log_record_roundtrip(void)
 {
<span
class="del">-	int i;
</span> 	struct reftable_log_record in[] = {
 		{
 			.refname = xstrdup(&#34;refs/heads/master&#34;),
<span
class="hunk">@@ -180,12 +172,12 @@ static void test_reftable_log_record_roundtrip(void)
</span> 		}
 	};
 	struct strbuf scratch = STRBUF_INIT;
<span
class="add">+	set_hash(in[0].value.update.new_hash, 1);
+	set_hash(in[0].value.update.old_hash, 2);
+	set_hash(in[2].value.update.new_hash, 3);
+	set_hash(in[2].value.update.old_hash, 4);
</span> 
<span
class="del">-	set_test_hash(in[0].value.update.new_hash, 1);
-	set_test_hash(in[0].value.update.old_hash, 2);
-	set_test_hash(in[2].value.update.new_hash, 3);
-	set_test_hash(in[2].value.update.old_hash, 4);
-	for (i = 0; i &lt; ARRAY_SIZE(in); i++) {
</span><span
class="add">+	for (size_t i = 0; i &lt; ARRAY_SIZE(in); i++) {
</span> 		struct reftable_record rec = { .type = BLOCK_TYPE_LOG };
 		struct strbuf key = STRBUF_INIT;
 		uint8_t buffer[1024] = { 0 };
<span
class="hunk">@@ -217,13 +209,13 @@ static void test_reftable_log_record_roundtrip(void)
</span> 		reftable_record_key(&#38;rec, &#38;key);
 
 		n = reftable_record_encode(&#38;rec, dest, GIT_SHA1_RAWSZ);
<span
class="del">-		EXPECT(n &gt;= 0);
</span><span
class="add">+		check_int(n, &gt;=, 0);
</span> 		valtype = reftable_record_val_type(&#38;rec);
 		m = reftable_record_decode(&#38;out, key, valtype, dest,
 					   GIT_SHA1_RAWSZ, &#38;scratch);
<span
class="del">-		EXPECT(n == m);
</span><span
class="add">+		check_int(n, ==, m);
</span> 
<span
class="del">-		EXPECT(reftable_log_record_equal(&#38;in[i], &#38;out.u.log,
</span><span
class="add">+		check(reftable_log_record_equal(&#38;in[i], &#38;out.u.log,
</span> 						 GIT_SHA1_RAWSZ));
 		reftable_log_record_release(&#38;in[i]);
 		strbuf_release(&#38;key);
<span
class="hunk">@@ -252,14 +244,14 @@ static void test_key_roundtrip(void)
</span> 	strbuf_addstr(&#38;key, &#34;refs/tags/bla&#34;);
 	extra = 6;
 	n = reftable_encode_key(&#38;restart, dest, last_key, key, extra);
<span
class="del">-	EXPECT(!restart);
-	EXPECT(n &gt; 0);
</span><span
class="add">+	check(!restart);
+	check_int(n, &gt;, 0);
</span> 
 	strbuf_addstr(&#38;roundtrip, &#34;refs/heads/master&#34;);
 	m = reftable_decode_key(&#38;roundtrip, &#38;rt_extra, dest);
<span
class="del">-	EXPECT(n == m);
-	EXPECT(0 == strbuf_cmp(&#38;key, &#38;roundtrip));
-	EXPECT(rt_extra == extra);
</span><span
class="add">+	check_int(n, ==, m);
+	check(!strbuf_cmp(&#38;key, &#38;roundtrip));
+	check_int(rt_extra, ==, extra);
</span> 
 	strbuf_release(&#38;last_key);
 	strbuf_release(&#38;key);
<span
class="hunk">@@ -289,9 +281,8 @@ static void test_reftable_obj_record_roundtrip(void)
</span> 		},
 	};
 	struct strbuf scratch = STRBUF_INIT;
<span
class="del">-	int i = 0;
</span> 
<span
class="del">-	for (i = 0; i &lt; ARRAY_SIZE(recs); i++) {
</span><span
class="add">+	for (size_t i = 0; i &lt; ARRAY_SIZE(recs); i++) {
</span> 		uint8_t buffer[1024] = { 0 };
 		struct string_view dest = {
 			.buf = buffer,
<span
class="hunk">@@ -311,13 +302,13 @@ static void test_reftable_obj_record_roundtrip(void)
</span> 		test_copy(&#38;in);
 		reftable_record_key(&#38;in, &#38;key);
 		n = reftable_record_encode(&#38;in, dest, GIT_SHA1_RAWSZ);
<span
class="del">-		EXPECT(n &gt; 0);
</span><span
class="add">+		check_int(n, &gt;, 0);
</span> 		extra = reftable_record_val_type(&#38;in);
 		m = reftable_record_decode(&#38;out, key, extra, dest,
 					   GIT_SHA1_RAWSZ, &#38;scratch);
<span
class="del">-		EXPECT(n == m);
</span><span
class="add">+		check_int(n, ==, m);
</span> 
<span
class="del">-		EXPECT(reftable_record_equal(&#38;in, &#38;out, GIT_SHA1_RAWSZ));
</span><span
class="add">+		check(reftable_record_equal(&#38;in, &#38;out, GIT_SHA1_RAWSZ));
</span> 		strbuf_release(&#38;key);
 		reftable_record_release(&#38;out);
 	}
<span
class="hunk">@@ -352,16 +343,16 @@ static void test_reftable_index_record_roundtrip(void)
</span> 	reftable_record_key(&#38;in, &#38;key);
 	test_copy(&#38;in);
 
<span
class="del">-	EXPECT(0 == strbuf_cmp(&#38;key, &#38;in.u.idx.last_key));
</span><span
class="add">+	check(!strbuf_cmp(&#38;key, &#38;in.u.idx.last_key));
</span> 	n = reftable_record_encode(&#38;in, dest, GIT_SHA1_RAWSZ);
<span
class="del">-	EXPECT(n &gt; 0);
</span><span
class="add">+	check_int(n, &gt;, 0);
</span> 
 	extra = reftable_record_val_type(&#38;in);
 	m = reftable_record_decode(&#38;out, key, extra, dest, GIT_SHA1_RAWSZ,
 				   &#38;scratch);
<span
class="del">-	EXPECT(m == n);
</span><span
class="add">+	check_int(m, ==, n);
</span> 
<span
class="del">-	EXPECT(reftable_record_equal(&#38;in, &#38;out, GIT_SHA1_RAWSZ));
</span><span
class="add">+	check(reftable_record_equal(&#38;in, &#38;out, GIT_SHA1_RAWSZ));
</span> 
 	reftable_record_release(&#38;out);
 	strbuf_release(&#38;key);
<span
class="hunk">@@ -369,14 +360,15 @@ static void test_reftable_index_record_roundtrip(void)
</span> 	strbuf_release(&#38;in.u.idx.last_key);
 }
 
<span
class="del">-int record_test_main(int argc, const char *argv[])
</span><span
class="add">+int cmd_main(int argc, const char *argv[])
</span> {
<span
class="del">-	RUN_TEST(test_reftable_log_record_equal);
-	RUN_TEST(test_reftable_log_record_roundtrip);
-	RUN_TEST(test_reftable_ref_record_roundtrip);
-	RUN_TEST(test_varint_roundtrip);
-	RUN_TEST(test_key_roundtrip);
-	RUN_TEST(test_reftable_obj_record_roundtrip);
-	RUN_TEST(test_reftable_index_record_roundtrip);
-	return 0;
</span><span
class="add">+	TEST(test_reftable_log_record_equal(), &#34;reftable_log_record_equal works&#34;);
+	TEST(test_reftable_log_record_roundtrip(), &#34;record operations work on log record&#34;);
+	TEST(test_reftable_ref_record_roundtrip(), &#34;record operations work on ref record&#34;);
+	TEST(test_varint_roundtrip(), &#34;put_var_int and get_var_int work&#34;);
+	TEST(test_key_roundtrip(), &#34;reftable_encode_key and reftable_decode_key work&#34;);
+	TEST(test_reftable_obj_record_roundtrip(), &#34;record operations work on obj record&#34;);
+	TEST(test_reftable_index_record_roundtrip(), &#34;record operations work on index record&#34;);
+
+	return test_done();
</span> }
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[GSoC][PATCH 0/11] t: port reftable/record_test.c to the unit testing framework</title><updated>2024-06-21T06:01:37Z</updated><link
href="http://lore.kernel.org/git/20240621060018.12795-1-chandrapratap3519@gmail.com/"/><id>urn:uuid:6e1c823b-0ade-ca29-8eb3-e51a2304dd20</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">In the recent codebase update (commit 8bf6fbd, 2023-12-09), a new unit
testing framework written entirely in C was introduced to the Git project
aimed at simplifying testing and reducing test run times.
Currently, tests for the reftable refs-backend are performed by a custom
testing framework defined by reftable/test_framework.{c, h}. Port
reftable/record_test.c to the unit testing framework and improve upon
the ported test.

The first patch in the series moves the test to the unit testing framework,
and the rest of the patches improve upon the ported test.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;

---
CI/PR: <a
href="https://github.com/gitgitgadget/git/pull/1750">https://github.com/gitgitgadget/git/pull/1750</a>

Chandra Pratap (11):
t: move reftable/record_test.c to the unit testing framework
t-reftable-record: add reftable_record_cmp() tests for log records
t-reftable-record: add comparison tests for ref records
t-reftable-record: add comparison tests for index records
t-reftable-record: add comparison tests for obj records
t-reftable-record: add reftable_record_is_deletion() test for ref records
t-reftable-record: add reftable_record_is_deletion() test for log records
t-reftable-record: add reftable_record_is_deletion() test for obj records
t-reftable-record: add reftable_record_is_deletion() test for index records
t-reftable-record: add tests for reftable_ref_record_compare_name()
t-reftable-record: add tests for reftable_log_record_compare_key()

Makefile                         |   2 +-
reftable/record_test.c           | 382 -------------------------
t/helper/test-reftable.c         |   1 -
t/unit-tests/t-reftable-record.c | 554 +++++++++++++++++++++++++++++++++++++++++++++
</pre></div></content></entry><entry><author><name>Eric Wong</name><email>e@80x24.org</email></author><title>[PATCH] cat-file: reduce write calls for unfiltered blobs</title><updated>2024-06-21T02:05:04Z</updated><link
href="http://lore.kernel.org/git/20240621020457.1081233-1-e@80x24.org/"/><id>urn:uuid:561b59f2-79d9-24e3-cd08-b23360b87342</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">While the --buffer switch is useful for non-interactive batch use,
buffering doesn&#39;t work with processes using request-response loops since
idle times are unpredictable between requests.

For unfiltered blobs, our streaming interface now appends the initial
blob data directly into the scratch buffer used for object info.
Furthermore, the final blob chunk can hold the output delimiter before
making the final write(2).

While the same syscall reduction can be done with stdio buffering by
adding fflush(3) after writing the output delimiter, stdio use requires
additional memory copies for the blob contents since it&#39;s not possible
for our streaming interface to write directly to stdio internal buffers.

For the reader process, this reduces read(2) syscalls by up to 67% in
the best case for small blobs.  Unfortunately my real-world tests on
normal data only showed only a ~20% reduction in read(2) syscalls on the
reader side due to larger blobs and scheduler unpredictability.  Time
improvements only came out to roughly 0.5% on my laptop, but this may be
more noticeable on systems where syscalls are more expensive.

writev(2) was also considered, but it is not portable and detrimental
given the way our streaming API works.  writev(2) might make more sense
for filtered outputs or reading non-blob data.

Signed-off-by: Eric Wong &lt;e@80x24.org&gt;
---
 builtin/cat-file.c | 36 +++++++++++++++++++++------------
 streaming.c        | 50 ++++++++++++++++++++++++++++++++++++++++++++++
 streaming.h        |  1 +
 3 files <a href="http://lore.kernel.org/git/20240621020457.1081233-1-e@80x24.org/#related">changed</a>, 74 insertions(+), 13 deletions(-)

<span
class="head">diff --git a/builtin/cat-file.c b/builtin/cat-file.c
index 43a1d7ac49..23db5c6a7a 100644
--- a/builtin/cat-file.c
+++ b/builtin/cat-file.c
</span><span
class="hunk">@@ -87,9 +87,10 @@ static int filter_object(const char *path, unsigned mode,
</span> 	return 0;
 }
 
<span
class="del">-static int stream_blob(const struct object_id *oid)
</span><span
class="add">+static int stream_blob(struct strbuf *scratch, const struct object_id *oid)
</span> {
<span
class="del">-	if (stream_blob_to_fd(1, oid, NULL, 0))
</span><span
class="add">+	if (scratch ? stream_blob_to_strbuf_fd(1, scratch, oid) :
+			stream_blob_to_fd(1, oid, NULL, 0))
</span> 		die(&#34;unable to stream %s to stdout&#34;, oid_to_hex(oid));
 	return 0;
 }
<span
class="hunk">@@ -195,7 +196,7 @@ static int cat_one_file(int opt, const char *exp_type, const char *obj_name,
</span> 		}
 
 		if (type == OBJ_BLOB) {
<span
class="del">-			ret = stream_blob(&#38;oid);
</span><span
class="add">+			ret = stream_blob(NULL, &#38;oid);
</span> 			goto cleanup;
 		}
 		buf = repo_read_object_file(the_repository, &#38;oid, &#38;type,
<span
class="hunk">@@ -237,7 +238,7 @@ static int cat_one_file(int opt, const char *exp_type, const char *obj_name,
</span> 				oidcpy(&#38;blob_oid, &#38;oid);
 
 			if (oid_object_info(the_repository, &#38;blob_oid, NULL) == OBJ_BLOB) {
<span
class="del">-				ret = stream_blob(&#38;blob_oid);
</span><span
class="add">+				ret = stream_blob(NULL, &#38;blob_oid);
</span> 				goto cleanup;
 			}
 			/*
<span
class="hunk">@@ -376,7 +377,15 @@ static void batch_write(struct batch_options *opt, const void *data, int len)
</span> 		write_or_die(1, data, len);
 }
 
<span
class="del">-static void print_object_or_die(struct batch_options *opt, struct expand_data *data)
</span><span
class="add">+static void flush_scratch(struct batch_options *opt, struct strbuf *scratch)
+{
+	batch_write(opt, scratch-&gt;buf, scratch-&gt;len);
+	strbuf_reset(scratch);
+}
+
+static void print_object_or_die(struct strbuf *scratch,
+				struct batch_options *opt,
+				struct expand_data *data)
</span> {
 	const struct object_id *oid = &#38;data-&gt;oid;
 
<span
class="hunk">@@ -389,6 +398,8 @@ static void print_object_or_die(struct batch_options *opt, struct expand_data *d
</span> 			char *contents;
 			unsigned long size;
 
<span
class="add">+			flush_scratch(opt, scratch);
+
</span> 			if (!data-&gt;rest)
 				die(&#34;missing path for &#39;%s&#39;&#34;, oid_to_hex(oid));
 
<span
class="hunk">@@ -414,7 +425,7 @@ static void print_object_or_die(struct batch_options *opt, struct expand_data *d
</span> 			batch_write(opt, contents, size);
 			free(contents);
 		} else {
<span
class="del">-			stream_blob(oid);
</span><span
class="add">+			stream_blob(scratch, oid);
</span> 		}
 	}
 	else {
<span
class="hunk">@@ -422,6 +433,8 @@ static void print_object_or_die(struct batch_options *opt, struct expand_data *d
</span> 		unsigned long size;
 		void *contents;
 
<span
class="add">+		flush_scratch(opt, scratch);
+
</span> 		contents = repo_read_object_file(the_repository, oid, &#38;type,
 						 &#38;size);
 		if (!contents)
<span
class="hunk">@@ -498,8 +511,6 @@ static void batch_object_write(const char *obj_name,
</span> 		}
 	}
 
<span
class="del">-	strbuf_reset(scratch);
-
</span> 	if (!opt-&gt;format) {
 		print_default_format(scratch, data, opt);
 	} else {
<span
class="hunk">@@ -507,12 +518,11 @@ static void batch_object_write(const char *obj_name,
</span> 		strbuf_addch(scratch, opt-&gt;output_delim);
 	}
 
<span
class="del">-	batch_write(opt, scratch-&gt;buf, scratch-&gt;len);
-
</span> 	if (opt-&gt;batch_mode == BATCH_MODE_CONTENTS) {
<span
class="del">-		print_object_or_die(opt, data);
-		batch_write(opt, &#38;opt-&gt;output_delim, 1);
</span><span
class="add">+		print_object_or_die(scratch, opt, data);
+		strbuf_addch(scratch, opt-&gt;output_delim);
</span> 	}
<span
class="add">+	flush_scratch(opt, scratch);
</span> }
 
 static void batch_one_object(const char *obj_name,
<span
class="hunk">@@ -787,7 +797,7 @@ static int batch_objects(struct batch_options *opt)
</span> 		      opt-&gt;format ? opt-&gt;format : DEFAULT_FORMAT,
 		      &#38;data);
 	data.mark_query = 0;
<span
class="del">-	strbuf_release(&#38;output);
</span><span
class="add">+	strbuf_reset(&#38;output);
</span> 	if (opt-&gt;transform_mode)
 		data.split_on_whitespace = 1;
 
<span
class="head">diff --git a/streaming.c b/streaming.c
index 10adf625b2..9787449c50 100644
--- a/streaming.c
+++ b/streaming.c
</span><span
class="hunk">@@ -10,6 +10,8 @@
</span> #include &#34;object-store-ll.h&#34;
 #include &#34;replace-object.h&#34;
 #include &#34;packfile.h&#34;
<span
class="add">+#include &#34;strbuf.h&#34;
+#include &#34;hex.h&#34;
</span> 
 typedef int (*open_istream_fn)(struct git_istream *,
 			       struct repository *,
<span
class="hunk">@@ -546,3 +548,51 @@ int stream_blob_to_fd(int fd, const struct object_id *oid, struct stream_filter
</span> 	close_istream(st);
 	return result;
 }
<span
class="add">+
+/*
+ * stdio buffering requires extra data copies, using strbuf
+ * allows us to read_istream directly into a scratch buffer
+ */
+int stream_blob_to_strbuf_fd(int fd, struct strbuf *sb,
+				const struct object_id *oid)
+{
+	size_t bufsz = 16 * 1024;
+	struct git_istream *st;
+	enum object_type type;
+	unsigned long sz;
+	int result = -1;
+
+	st = open_istream(the_repository, oid, &#38;type, &#38;sz, NULL);
+	if (!st)
+		return result;
+	if (type != OBJ_BLOB)
+		goto close_and_exit;
+	if (bufsz &gt; sz)
+		bufsz = sz;
+	strbuf_grow(sb, bufsz + 1); /* extra byte for output_delim */
+	while (sz) {
+		ssize_t readlen = read_istream(st, sb-&gt;buf + sb-&gt;len, bufsz);
+
+		if (readlen &lt; 0)
+			goto close_and_exit;
+		if (readlen == 0)
+			die(&#34;unexpected EOF from %s\n&#34;, oid_to_hex(oid));
+		sz -= readlen;
+		if (!sz) {
+			/*
+			 * done, keep the last bit buffered for caller to
+			 * append output_delim
+			 */
+			strbuf_setlen(sb, sb-&gt;len + readlen);
+			break;
+		}
+		if (write_in_full(fd, sb-&gt;buf, sb-&gt;len + readlen) &lt; 0)
+			goto close_and_exit;
+		strbuf_reset(sb);
+	}
+	result = 0;
+
+ close_and_exit:
+	close_istream(st);
+	return result;
+}
</span><span
class="head">diff --git a/streaming.h b/streaming.h
index bd27f59e57..3cba4fe016 100644
--- a/streaming.h
+++ b/streaming.h
</span><span
class="hunk">@@ -17,5 +17,6 @@ int close_istream(struct git_istream *);
</span> ssize_t read_istream(struct git_istream *, void *, size_t);
 
 int stream_blob_to_fd(int fd, const struct object_id *, struct stream_filter *, int can_seek);
<span
class="add">+int stream_blob_to_strbuf_fd(int fd, struct strbuf *, const struct object_id *);
</span> 
 #endif /* STREAMING_H */
</pre></div></content></entry><entry><author><name>Rub&#233;n Justo</name><email>rjusto@gmail.com</email></author><title>[PATCH] pager: die when paging to non-existing command</title><updated>2024-06-20T17:25:46Z</updated><link
href="http://lore.kernel.org/git/f7106878-5ec5-4fe7-940b-2fb1d9707f7d@gmail.com/"/><id>urn:uuid:c624439a-7bd7-1946-eabe-66791b07f813</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">When trying to execute a non-existent program from GIT_PAGER, we display
an error.  However, we also send the complete text to the terminal
and return a successful exit code.  This can be confusing for the user
and the displayed error could easily become obscured by a lengthy
text.

For example, here the error message would be very far above after
sending 50 MB of text:

    $ GIT_PAGER=non-existent t/test-terminal.perl git log | wc -c
    error: cannot run non-existent: No such file or directory
    50314363

Let&#39;s make the error clear by aborting the process and return an error
so that the user can easily correct their mistake.

This will be the result of the change:

    $ GIT_PAGER=non-existent t/test-terminal.perl git log | wc -c
    error: cannot run non-existent: No such file or directory
    fatal: unable to start the pager: &#39;non-existent&#39;
    0

The behavior change we&#39;re introducing in this commit affects two tests
in t7006, which is a good sign regarding test coverage and requires us
to address it.

The first test is &#39;git skips paging non-existing command&#39;.  This test
comes from f7991f01f2 (t7006: clean up SIGPIPE handling in trace2 tests,
2021-11-21,) where a modification was made to a test that was originally
introduced in c24b7f6736 (pager: test for exit code with and without
SIGPIPE, 2021-02-02).  That original test was, IMHO, in the same
direction we&#39;re going in this commit.

At any rate, this test obviously needs to be adjusted to check the new
behavior we are introducing.  Do it.

The second test being affected is: &#39;non-existent pager doesnt cause
crash&#39;, introduced in f917f57f40 (pager: fix crash when pager program
doesn&#39;t exist, 2021-11-24).  As its name states, it has the intention of
checking that we don&#39;t introduce a regression that produces a crash when
GIT_PAGER points to a nonexistent program.

This test could be considered redundant nowadays, due to us already
having several tests checking implicitly what a non-existent command in
GIT_PAGER produces.  However, let&#39;s maintain a good belt-and-suspenders
strategy; adapt it to the new world.

Finally, it&#39;s worth noting that we are not changing the behavior if the
command specified in GIT_PAGER is a shell command.  In such cases, it
is:

    $ GIT_PAGER=:\;non-existent t/test-terminal.perl git log
    :;non-existent: 1: non-existent: not found
    died of signal 13 at t/test-terminal.perl line 33.

Signed-off-by: Rub&#233;n Justo &lt;rjusto@gmail.com&gt;
---
 pager.c          |  2 +-
 t/t7006-pager.sh | 15 +++------------
 2 files <a href="http://lore.kernel.org/git/f7106878-5ec5-4fe7-940b-2fb1d9707f7d@gmail.com/#related">changed</a>, 4 insertions(+), 13 deletions(-)

<span
class="head">diff --git a/pager.c b/pager.c
index e9e121db69..e4291cd0aa 100644
--- a/pager.c
+++ b/pager.c
</span><span
class="hunk">@@ -137,7 +137,7 @@ void setup_pager(void)
</span> 	pager_process.in = -1;
 	strvec_push(&#38;pager_process.env, &#34;GIT_PAGER_IN_USE&#34;);
 	if (start_command(&#38;pager_process))
<span
class="del">-		return;
</span><span
class="add">+		die(&#34;unable to start the pager: &#39;%s&#39;&#34;, pager);
</span> 
 	/* original process continues, but writes to the pipe */
 	dup2(pager_process.in, 1);
<span
class="head">diff --git a/t/t7006-pager.sh b/t/t7006-pager.sh
index e56ca5b0fa..80ffed59d9 100755
--- a/t/t7006-pager.sh
+++ b/t/t7006-pager.sh
</span><span
class="hunk">@@ -725,18 +725,9 @@ test_expect_success TTY &#39;git discards pager non-zero exit without SIGPIPE&#39; &#39;
</span> 	test_path_is_file pager-used
 &#39;
 
<span
class="del">-test_expect_success TTY &#39;git skips paging nonexisting command&#39; &#39;
-	test_when_finished &#34;rm trace.normal&#34; &#38;&#38;
</span><span
class="add">+test_expect_success TTY &#39;git errors when asked to execute nonexisting pager&#39; &#39;
</span> 	test_config core.pager &#34;does-not-exist&#34; &#38;&#38;
<span
class="del">-	GIT_TRACE2=&#34;$(pwd)/trace.normal&#34; &#38;&#38;
-	export GIT_TRACE2 &#38;&#38;
-	test_when_finished &#34;unset GIT_TRACE2&#34; &#38;&#38;
-
-	test_terminal git log &#38;&#38;
-
-	grep child_exit trace.normal &gt;child-exits &#38;&#38;
-	test_line_count = 1 child-exits &#38;&#38;
-	grep &#34; code:-1 &#34; child-exits
</span><span
class="add">+	test_must_fail test_terminal git log
</span> &#39;
 
 test_expect_success TTY &#39;git returns SIGPIPE on propagated signals from pager&#39; &#39;
<span
class="hunk">@@ -762,7 +753,7 @@ test_expect_success TTY &#39;git returns SIGPIPE on propagated signals from pager&#39; &#39;
</span> 
 test_expect_success TTY &#39;non-existent pager doesnt cause crash&#39; &#39;
 	test_config pager.show invalid-pager &#38;&#38;
<span
class="del">-	test_terminal git show
</span><span
class="add">+	test_must_fail test_terminal git show
</span> &#39;
 
 test_done
-- 
2.45.2.562.g334133e685
</pre></div></content></entry><entry><author><name>Derrick Stolee via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH 5/5] sparse-index: improve lstat caching of sparse paths</title><updated>2024-06-20T16:11:25Z</updated><link
href="http://lore.kernel.org/git/2654fcb7142a606c5684c762ed28bb5e8d9b4712.1718899877.git.gitgitgadget@gmail.com/"/><id>urn:uuid:7d5fb94f-57a6-c7ca-0315-6a01bb2922ea</id><thr:in-reply-to
ref="urn:uuid:0a3e9f9b-e887-e20a-cd21-226c7be2a265"
href="http://lore.kernel.org/git/pull.1754.git.1718899877.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Derrick Stolee &lt;stolee@gmail.com&gt;

The clear_skip_worktree_from_present_files() method was first introduced
in af6a51875a (repo_read_index: clear SKIP_WORKTREE bit from files
present in worktree, 2022-01-14) to allow better interaction with the
working directory in the presence of paths outside of the
sparse-checkout cone. The initial implementation would lstat() every
single sparse tree to see if it existed, and if one did, then the sparse
index would expand and every sparse file would be checked.

Since these lstat() calls were very expensive, this was improved in
d79d299352 (Accelerate clear_skip_worktree_from_present_files() by
caching, 2022-01-14) by caching directories that do not exist. However,
there are some inefficiencies in that caching mechanism.

The caching mechanism stored only the parent directory as not existing,
even if a higher parent directory also does not exist. This means that
wasted lstat() calls would occur when the sparse files change immediate
parent directories but within the same root directory that does not
exist.

To set up a scenario that triggers this code in an interesting way, we
need a sparse-checkout in cone mode and a sparse index. To trigger the
full index expansion and a call to the
clear_skip_worktree_from_present_files_full() method, we need one of the
sparse trees to actually exist on disk. The performance test script
p2000-sparse-operations.sh takes the sample repository and copies its
HEAD to several copies nested in directories of the form f&lt;i&gt;/f&lt;j&gt;/f&lt;k&gt;
where i, j, and k are numbers from 1 to 4. The sparse-checkout cone is
then selected as &#34;f2/f4/&#34;. Creating &#34;f1/f1/&#34; will trigger the behavior
and also lead to some interesting cases for the caching algorithm since
&#34;f1/f1/&#34; exists but &#34;f1/f2/&#34; and &#34;f3/&#34; do not.

This is difficult to notice when running performance tests using the Git
repository (or a blow-up of the Git repository, as in
p2000-sparse-operations.sh) because Git has a very shallow directory
structure.

This change reorganizes the caching algorithm to focus on storing both
the deepest _existing_ directory and the next-level non-existing
directory. By doing a little extra work on the first sparse file, we can
short-circuit all of the sparse files that exist in that non-existing
directory. When in a repository where the first sparse file is likely to
have a much deeper path than the first non-existing directory, this can
realize significant gains.

The details of this algorithm require careful attention, so the new
implementation of path_found() has detailed comments, including the use
of a new max_common_dir_prefix() method that may be of independent
interest.

It&#39;s worth noting that this is not universally positive, since we are
doing extra lstat() calls to establish the exact path to cache. In the
blow-up of the Git repository, we can see that the lstat count
_increases_ from 28 to 31. However, these numbers were already
artificially low.

Using an internal monorepo with over two million paths at HEAD and a
typical sparse-checkout cone such that the index contains ~190,000
entries (including over two thousand sparse trees), I was able to
measure these lstat counts when one sparse directory actually exists on
disk:

  Sparse files in expanded index: 1,841,997
       full_lstat_count (before):   173,259
       full_lstat_count  (after):     6,521

This resulted in this absolute time change, on a warm disk:

      Time in full loop (before): 2.527 s
      Time in full loop  (after): 0.071 s

(These times were calculated on a Windows machine, where lstat() is
slower than a similar Linux machine.)

Signed-off-by: Derrick Stolee &lt;stolee@gmail.com&gt;
---
 sparse-index.c | 118 ++++++++++++++++++++++++++++++++++++++-----------
 1 file <a href="http://lore.kernel.org/git/2654fcb7142a606c5684c762ed28bb5e8d9b4712.1718899877.git.gitgitgadget@gmail.com/#related">changed</a>, 93 insertions(+), 25 deletions(-)

<span
class="head">diff --git a/sparse-index.c b/sparse-index.c
index 8577fa726b8..cccd8550dfe 100644
--- a/sparse-index.c
+++ b/sparse-index.c
</span><span
class="hunk">@@ -440,14 +440,21 @@ void ensure_correct_sparsity(struct index_state *istate)
</span> }
 
 struct path_found_data {
<span
class="add">+	/**
+	 * The path stored in &#39;dir&#39;, if non-empty, corresponds to the most-
+	 * recent path that we checked where:
+	 *
+	 *   1. The path should be a directory, according to the index.
+	 *   2. The path does not exist.
+	 *   3. The parent path _does_ exist. (This may be the root of the
+	 *      working directory.)
+	 */
</span> 	struct strbuf dir;
<span
class="del">-	int dir_found;
</span> 	size_t lstat_count;
 };
 
 #define PATH_FOUND_DATA_INIT { \
<span
class="del">-	.dir = STRBUF_INIT, \
-	.dir_found = 1 \
</span><span
class="add">+	.dir = STRBUF_INIT \
</span> }
 
 static void clear_path_found_data(struct path_found_data *data)
<span
class="hunk">@@ -455,50 +462,111 @@ static void clear_path_found_data(struct path_found_data *data)
</span> 	strbuf_release(&#38;data-&gt;dir);
 }
 
<span
class="add">+/**
+ * Return the length of the largest common substring that ends in a
+ * slash (&#39;/&#39;) to indicate the largest common parent directory. Returns
+ * zero if no common directory exists.
+ */
+static size_t max_common_dir_prefix(const char *path1, const char *path2)
+{
+	size_t common_prefix = 0;
+	for (size_t i = 0; path1[i] &#38;&#38; path2[i]; i++) {
+		if (path1[i] != path2[i])
+			break;
+
+		/*
+		 * If they agree at a directory separator, then add one
+		 * to make sure it is included in the common prefix string.
+		 */
+		if (path1[i] == &#39;/&#39;)
+			common_prefix = i + 1;
+	}
+
+	return common_prefix;
+}
+
</span> static int path_found(const char *path, struct path_found_data *data)
 {
 	struct stat st;
<span
class="del">-	char *newdir;
</span><span
class="add">+	size_t common_prefix;
</span> 
 	/*
<span
class="del">-	 * If dirname corresponds to a directory that doesn&#39;t exist, and this
-	 * path starts with dirname, then path can&#39;t exist.
</span><span
class="add">+	 * If data-&gt;dir is non-empty, then it contains a path that doesn&#39;t
+	 * exist, including an ending slash (&#39;/&#39;). If it is a prefix of &#39;path&#39;,
+	 * then we can return 0.
</span> 	 */
<span
class="del">-	if (!data-&gt;dir_found &#38;&#38; !memcmp(path, data-&gt;dir.buf, data-&gt;dir.len))
</span><span
class="add">+	if (data-&gt;dir.len &#38;&#38; !memcmp(path, data-&gt;dir.buf, data-&gt;dir.len))
</span> 		return 0;
 
 	/*
<span
class="del">-	 * If path itself exists, return 1.
</span><span
class="add">+	 * Otherwise, we must check if the current path exists. If it does, then
+	 * return 1. The cached directory will be skipped until we come across
+	 * a missing path again.
</span> 	 */
 	data-&gt;lstat_count++;
 	if (!lstat(path, &#38;st))
 		return 1;
 
 	/*
<span
class="del">-	 * Otherwise, path does not exist so we&#39;ll return 0...but we&#39;ll first
-	 * determine some info about its parent directory so we can avoid
-	 * lstat calls for future cache entries.
</span><span
class="add">+	 * At this point, we know that &#39;path&#39; doesn&#39;t exist, and we know that
+	 * the parent directory of &#39;data-&gt;dir&#39; does exist. Let&#39;s set &#39;data-&gt;dir&#39;
+	 * to be the top-most non-existing directory of &#39;path&#39;. If the first
+	 * parent of &#39;path&#39; exists, then we will act ast though &#39;path&#39;
+	 * corresponds to a directory (by adding a slash).
</span> 	 */
<span
class="del">-	newdir = strrchr(path, &#39;/&#39;);
-	if (!newdir)
-		return 0; /* Didn&#39;t find a parent dir; just return 0 now. */
</span><span
class="add">+	common_prefix = max_common_dir_prefix(path, data-&gt;dir.buf);
</span> 
 	/*
<span
class="del">-	 * If path starts with directory (which we already lstat&#39;ed and found),
-	 * then no need to lstat parent directory again.
</span><span
class="add">+	 * At this point, &#39;path&#39; and &#39;data-&gt;dir&#39; have a common existing parent
+	 * directory given by path[0..common_prefix] (which could have length 0).
+	 * We &#34;grow&#34; the data-&gt;dir buffer by checking for existing directories
+	 * along &#39;path&#39;.
</span> 	 */
<span
class="del">-	if (data-&gt;dir_found &#38;&#38; data-&gt;dir.buf &#38;&#38;
-	    memcmp(path, data-&gt;dir.buf, data-&gt;dir.len))
-		return 0;
</span> 
<span
class="del">-	/* Free previous dirname, and cache path&#39;s dirname */
-	strbuf_reset(&#38;data-&gt;dir);
-	strbuf_add(&#38;data-&gt;dir, path, newdir - path + 1);
</span><span
class="add">+	strbuf_setlen(&#38;data-&gt;dir, common_prefix);
+	while (1) {
+		/* Find the next directory in &#39;path&#39;. */
+		const char *next_slash = strchr(path + data-&gt;dir.len, &#39;/&#39;);
</span> 
<span
class="del">-	data-&gt;lstat_count++;
-	data-&gt;dir_found = !lstat(data-&gt;dir.buf, &#38;st);
</span><span
class="add">+		/*
+		 * If there are no more slashes, then &#39;path&#39; doesn&#39;t contain a
+		 * non-existent _parent_ directory. Set &#39;data-&gt;dir&#39; to be equal
+		 * to &#39;path&#39; plus an additional slash, so it can be used for
+		 * caching in the future. The filename of &#39;path&#39; is considered
+		 * a non-existent directory.
+		 *
+		 * Note: if &#34;{path}/&#34; exists as a directory, then it will never
+		 * appear as a prefix of other callers to this method, assuming
+		 * the context from the clear_skip_worktree... methods. If this
+		 * method is reused, then this must be reconsidered.
+		 */
+		if (!next_slash) {
+			strbuf_addstr(&#38;data-&gt;dir, path + data-&gt;dir.len);
+			strbuf_addch(&#38;data-&gt;dir, &#39;/&#39;);
+			break;
+		}
</span> 
<span
class="del">-	return 0;
</span><span
class="add">+		/*
+		 * Now that we have a slash, let&#39;s grow &#39;data-&gt;dir&#39; to include
+		 * this slash, then test if we should stop.
+		 */
+		strbuf_add(&#38;data-&gt;dir, path + data-&gt;dir.len,
+			   (next_slash - path) - data-&gt;dir.len + 1);
+
+		/* If the path doesn&#39;t exist, then stop here. */
+		data-&gt;lstat_count++;
+		if (lstat(data-&gt;dir.buf, &#38;st))
+			return 0;
+	}
+
+	/*
+	 * At this point, &#39;data-&gt;dir&#39; is equal to &#39;path&#39; plus a slash character,
+	 * and the parent directory of &#39;path&#39; definitely exists. Let&#39;s return
+	 * the case of whether &#39;path&#39; exists.
+	 */
+
+	data-&gt;lstat_count++;
+	return !lstat(path, &#38;st);
</span> }
 
 static int clear_skip_worktree_from_present_files_sparse(struct index_state *istate)
-- 
gitgitgadget
</pre></div></content></entry><entry><author><name>Derrick Stolee via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH 4/5] sparse-index: count lstat() calls</title><updated>2024-06-20T16:11:24Z</updated><link
href="http://lore.kernel.org/git/88a3145e585169fde8cd7d43a435daa07eb82667.1718899877.git.gitgitgadget@gmail.com/"/><id>urn:uuid:c3ccb4b2-3bf7-1447-abe7-7e6f0ed2f4ae</id><thr:in-reply-to
ref="urn:uuid:0a3e9f9b-e887-e20a-cd21-226c7be2a265"
href="http://lore.kernel.org/git/pull.1754.git.1718899877.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Derrick Stolee &lt;stolee@gmail.com&gt;

The clear_skip_worktree.. methods already report some statistics about
how many cache entries are checked against path_found() due to having
the skip-worktree bit set. However, due to path_found() performing some
caching, this isn&#39;t the only information that would be helpful to
report.

Add a new lstat_count member to the path_found_data struct to count the
number of times path_found() calls lstat(). This will be helpful to help
explain performance problems in this method as well as to demonstrate
future changes to the caching algorithm in a more concrete way than
end-to-end timings.

Signed-off-by: Derrick Stolee &lt;stolee@gmail.com&gt;
---
 sparse-index.c | 7 +++++++
 1 file <a href="http://lore.kernel.org/git/88a3145e585169fde8cd7d43a435daa07eb82667.1718899877.git.gitgitgadget@gmail.com/#related">changed</a>, 7 insertions(+)

<span
class="head">diff --git a/sparse-index.c b/sparse-index.c
index fec4f393360..8577fa726b8 100644
--- a/sparse-index.c
+++ b/sparse-index.c
</span><span
class="hunk">@@ -442,6 +442,7 @@ void ensure_correct_sparsity(struct index_state *istate)
</span> struct path_found_data {
 	struct strbuf dir;
 	int dir_found;
<span
class="add">+	size_t lstat_count;
</span> };
 
 #define PATH_FOUND_DATA_INIT { \
<span
class="hunk">@@ -469,6 +470,7 @@ static int path_found(const char *path, struct path_found_data *data)
</span> 	/*
 	 * If path itself exists, return 1.
 	 */
<span
class="add">+	data-&gt;lstat_count++;
</span> 	if (!lstat(path, &#38;st))
 		return 1;
 
<span
class="hunk">@@ -493,6 +495,7 @@ static int path_found(const char *path, struct path_found_data *data)
</span> 	strbuf_reset(&#38;data-&gt;dir);
 	strbuf_add(&#38;data-&gt;dir, path, newdir - path + 1);
 
<span
class="add">+	data-&gt;lstat_count++;
</span> 	data-&gt;dir_found = !lstat(data-&gt;dir.buf, &#38;st);
 
 	return 0;
<span
class="hunk">@@ -524,6 +527,8 @@ static int clear_skip_worktree_from_present_files_sparse(struct index_state *ist
</span> 
 	trace2_data_intmax(&#34;index&#34;, istate-&gt;repo,
 			   &#34;sparse_path_count&#34;, path_count);
<span
class="add">+	trace2_data_intmax(&#34;index&#34;, istate-&gt;repo,
+			   &#34;sparse_lstat_count&#34;, data.lstat_count);
</span> 	trace2_region_leave(&#34;index&#34;, &#34;clear_skip_worktree_from_present_files_sparse&#34;,
 			    istate-&gt;repo);
 	clear_path_found_data(&#38;data);
<span
class="hunk">@@ -553,6 +558,8 @@ static void clear_skip_worktree_from_present_files_full(struct index_state *ista
</span> 
 	trace2_data_intmax(&#34;index&#34;, istate-&gt;repo,
 			   &#34;full_path_count&#34;, path_count);
<span
class="add">+	trace2_data_intmax(&#34;index&#34;, istate-&gt;repo,
+			   &#34;full_lstat_count&#34;, data.lstat_count);
</span> 	trace2_region_leave(&#34;index&#34;, &#34;clear_skip_worktree_from_present_files_full&#34;,
 			    istate-&gt;repo);
 	clear_path_found_data(&#38;data);
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Derrick Stolee via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH 3/5] sparse-index: use strbuf in path_found()</title><updated>2024-06-20T16:11:24Z</updated><link
href="http://lore.kernel.org/git/217594ffb103969c1a6debc07a6c7f72f6ee4749.1718899877.git.gitgitgadget@gmail.com/"/><id>urn:uuid:0f6e2ab2-730d-b7b1-2755-5b8e37aa9406</id><thr:in-reply-to
ref="urn:uuid:0a3e9f9b-e887-e20a-cd21-226c7be2a265"
href="http://lore.kernel.org/git/pull.1754.git.1718899877.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Derrick Stolee &lt;stolee@gmail.com&gt;

The path_found() method previously reused strings from the cache entries
the calling methods were using. This prevents string manipulation in
place and causes some odd reallocation before the final lstat() call in
the method.

Refactor the method to use strbufs and copy the path into the strbuf,
but also only the parent directory and not the whole path. This looks
like extra copying when assigning the path to the strbuf, but we save an
allocation by dropping the &#39;tmp&#39; string, and we are &#34;reusing&#34; the copy
from &#39;tmp&#39; to put the data in the strbuf.

Signed-off-by: Derrick Stolee &lt;stolee@gmail.com&gt;
---
 sparse-index.c | 21 +++++++++------------
 1 file <a href="http://lore.kernel.org/git/217594ffb103969c1a6debc07a6c7f72f6ee4749.1718899877.git.gitgitgadget@gmail.com/#related">changed</a>, 9 insertions(+), 12 deletions(-)

<span
class="head">diff --git a/sparse-index.c b/sparse-index.c
index de6e727f5c1..fec4f393360 100644
--- a/sparse-index.c
+++ b/sparse-index.c
</span><span
class="hunk">@@ -440,31 +440,30 @@ void ensure_correct_sparsity(struct index_state *istate)
</span> }
 
 struct path_found_data {
<span
class="del">-	const char *dirname;
-	size_t dir_len;
</span><span
class="add">+	struct strbuf dir;
</span> 	int dir_found;
 };
 
 #define PATH_FOUND_DATA_INIT { \
<span
class="add">+	.dir = STRBUF_INIT, \
</span> 	.dir_found = 1 \
 }
 
 static void clear_path_found_data(struct path_found_data *data)
 {
<span
class="del">-	return;
</span><span
class="add">+	strbuf_release(&#38;data-&gt;dir);
</span> }
 
 static int path_found(const char *path, struct path_found_data *data)
 {
 	struct stat st;
 	char *newdir;
<span
class="del">-	char *tmp;
</span> 
 	/*
 	 * If dirname corresponds to a directory that doesn&#39;t exist, and this
 	 * path starts with dirname, then path can&#39;t exist.
 	 */
<span
class="del">-	if (!data-&gt;dir_found &#38;&#38; !memcmp(path, data-&gt;dirname, data-&gt;dir_len))
</span><span
class="add">+	if (!data-&gt;dir_found &#38;&#38; !memcmp(path, data-&gt;dir.buf, data-&gt;dir.len))
</span> 		return 0;
 
 	/*
<span
class="hunk">@@ -486,17 +485,15 @@ static int path_found(const char *path, struct path_found_data *data)
</span> 	 * If path starts with directory (which we already lstat&#39;ed and found),
 	 * then no need to lstat parent directory again.
 	 */
<span
class="del">-	if (data-&gt;dir_found &#38;&#38; data-&gt;dirname &#38;&#38;
-	    memcmp(path, data-&gt;dirname, data-&gt;dir_len))
</span><span
class="add">+	if (data-&gt;dir_found &#38;&#38; data-&gt;dir.buf &#38;&#38;
+	    memcmp(path, data-&gt;dir.buf, data-&gt;dir.len))
</span> 		return 0;
 
 	/* Free previous dirname, and cache path&#39;s dirname */
<span
class="del">-	data-&gt;dirname = path;
-	data-&gt;dir_len = newdir - path + 1;
</span><span
class="add">+	strbuf_reset(&#38;data-&gt;dir);
+	strbuf_add(&#38;data-&gt;dir, path, newdir - path + 1);
</span> 
<span
class="del">-	tmp = xstrndup(path, data-&gt;dir_len);
-	data-&gt;dir_found = !lstat(tmp, &#38;st);
-	free(tmp);
</span><span
class="add">+	data-&gt;dir_found = !lstat(data-&gt;dir.buf, &#38;st);
</span> 
 	return 0;
 }
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Derrick Stolee via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH 2/5] sparse-index: refactor path_found()</title><updated>2024-06-20T16:11:22Z</updated><link
href="http://lore.kernel.org/git/7c3b545ee5ea3a0e6686594afe582fa1a19929f6.1718899877.git.gitgitgadget@gmail.com/"/><id>urn:uuid:5a97f388-3d97-c025-3509-13fd81860057</id><thr:in-reply-to
ref="urn:uuid:0a3e9f9b-e887-e20a-cd21-226c7be2a265"
href="http://lore.kernel.org/git/pull.1754.git.1718899877.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Derrick Stolee &lt;stolee@gmail.com&gt;

In advance of changing the behavior of path_found(), take all of the
intermediate data values and group them into a single struct. This
simplifies the method prototype as well as the initialization. Future
changes can be made directly to the struct and method without changing
the callers with this approach.

Note that the clear_path_found_data() method is currently empty, as
there is nothing to free. However, this will change in the future, so
place the method and its callers for now.

Signed-off-by: Derrick Stolee &lt;stolee@gmail.com&gt;
---
 sparse-index.c | 45 +++++++++++++++++++++++++++++----------------
 1 file <a href="http://lore.kernel.org/git/7c3b545ee5ea3a0e6686594afe582fa1a19929f6.1718899877.git.gitgitgadget@gmail.com/#related">changed</a>, 29 insertions(+), 16 deletions(-)

<span
class="head">diff --git a/sparse-index.c b/sparse-index.c
index e0457c87fff..de6e727f5c1 100644
--- a/sparse-index.c
+++ b/sparse-index.c
</span><span
class="hunk">@@ -439,8 +439,22 @@ void ensure_correct_sparsity(struct index_state *istate)
</span> 		ensure_full_index(istate);
 }
 
<span
class="del">-static int path_found(const char *path, const char **dirname, size_t *dir_len,
-		      int *dir_found)
</span><span
class="add">+struct path_found_data {
+	const char *dirname;
+	size_t dir_len;
+	int dir_found;
+};
+
+#define PATH_FOUND_DATA_INIT { \
+	.dir_found = 1 \
+}
+
+static void clear_path_found_data(struct path_found_data *data)
+{
+	return;
+}
+
+static int path_found(const char *path, struct path_found_data *data)
</span> {
 	struct stat st;
 	char *newdir;
<span
class="hunk">@@ -450,7 +464,7 @@ static int path_found(const char *path, const char **dirname, size_t *dir_len,
</span> 	 * If dirname corresponds to a directory that doesn&#39;t exist, and this
 	 * path starts with dirname, then path can&#39;t exist.
 	 */
<span
class="del">-	if (!*dir_found &#38;&#38; !memcmp(path, *dirname, *dir_len))
</span><span
class="add">+	if (!data-&gt;dir_found &#38;&#38; !memcmp(path, data-&gt;dirname, data-&gt;dir_len))
</span> 		return 0;
 
 	/*
<span
class="hunk">@@ -472,15 +486,16 @@ static int path_found(const char *path, const char **dirname, size_t *dir_len,
</span> 	 * If path starts with directory (which we already lstat&#39;ed and found),
 	 * then no need to lstat parent directory again.
 	 */
<span
class="del">-	if (*dir_found &#38;&#38; *dirname &#38;&#38; memcmp(path, *dirname, *dir_len))
</span><span
class="add">+	if (data-&gt;dir_found &#38;&#38; data-&gt;dirname &#38;&#38;
+	    memcmp(path, data-&gt;dirname, data-&gt;dir_len))
</span> 		return 0;
 
 	/* Free previous dirname, and cache path&#39;s dirname */
<span
class="del">-	*dirname = path;
-	*dir_len = newdir - path + 1;
</span><span
class="add">+	data-&gt;dirname = path;
+	data-&gt;dir_len = newdir - path + 1;
</span> 
<span
class="del">-	tmp = xstrndup(path, *dir_len);
-	*dir_found = !lstat(tmp, &#38;st);
</span><span
class="add">+	tmp = xstrndup(path, data-&gt;dir_len);
+	data-&gt;dir_found = !lstat(tmp, &#38;st);
</span> 	free(tmp);
 
 	return 0;
<span
class="hunk">@@ -488,9 +503,7 @@ static int path_found(const char *path, const char **dirname, size_t *dir_len,
</span> 
 static int clear_skip_worktree_from_present_files_sparse(struct index_state *istate)
 {
<span
class="del">-	const char *last_dirname = NULL;
-	size_t dir_len = 0;
-	int dir_found = 1;
</span><span
class="add">+	struct path_found_data data = PATH_FOUND_DATA_INIT;
</span> 
 	int path_count = 0;
 	int to_restart = 0;
<span
class="hunk">@@ -502,7 +515,7 @@ static int clear_skip_worktree_from_present_files_sparse(struct index_state *ist
</span> 
 		if (ce_skip_worktree(ce)) {
 			path_count++;
<span
class="del">-			if (path_found(ce-&gt;name, &#38;last_dirname, &#38;dir_len, &#38;dir_found)) {
</span><span
class="add">+			if (path_found(ce-&gt;name, &#38;data)) {
</span> 				if (S_ISSPARSEDIR(ce-&gt;ce_mode)) {
 					to_restart = 1;
 					break;
<span
class="hunk">@@ -516,14 +529,13 @@ static int clear_skip_worktree_from_present_files_sparse(struct index_state *ist
</span> 			   &#34;sparse_path_count&#34;, path_count);
 	trace2_region_leave(&#34;index&#34;, &#34;clear_skip_worktree_from_present_files_sparse&#34;,
 			    istate-&gt;repo);
<span
class="add">+	clear_path_found_data(&#38;data);
</span> 	return to_restart;
 }
 
 static void clear_skip_worktree_from_present_files_full(struct index_state *istate)
 {
<span
class="del">-	const char *last_dirname = NULL;
-	size_t dir_len = 0;
-	int dir_found = 1;
</span><span
class="add">+	struct path_found_data data = PATH_FOUND_DATA_INIT;
</span> 
 	int path_count = 0;
 
<span
class="hunk">@@ -537,7 +549,7 @@ static void clear_skip_worktree_from_present_files_full(struct index_state *ista
</span> 
 		if (ce_skip_worktree(ce)) {
 			path_count++;
<span
class="del">-			if (path_found(ce-&gt;name, &#38;last_dirname, &#38;dir_len, &#38;dir_found))
</span><span
class="add">+			if (path_found(ce-&gt;name, &#38;data))
</span> 				ce-&gt;ce_flags &#38;= ~CE_SKIP_WORKTREE;
 		}
 	}
<span
class="hunk">@@ -546,6 +558,7 @@ static void clear_skip_worktree_from_present_files_full(struct index_state *ista
</span> 			   &#34;full_path_count&#34;, path_count);
 	trace2_region_leave(&#34;index&#34;, &#34;clear_skip_worktree_from_present_files_full&#34;,
 			    istate-&gt;repo);
<span
class="add">+	clear_path_found_data(&#38;data);
</span> }
 
 void clear_skip_worktree_from_present_files(struct index_state *istate)
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Derrick Stolee via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH 0/5] sparse-index: improve clear_skip_worktree_from_present_files()</title><updated>2024-06-20T16:11:21Z</updated><link
href="http://lore.kernel.org/git/pull.1754.git.1718899877.gitgitgadget@gmail.com/"/><id>urn:uuid:0a3e9f9b-e887-e20a-cd21-226c7be2a265</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">While doing some investigation in a private monorepo with sparse-checkout
and a sparse index, I accidentally left a modified file outside of my
sparse-checkout cone. This caused my Git commands to slow to a crawl, so I
reran with GIT_TRACE2_PERF=1.

While I was able to identify clear_skip_worktree_from_present_files() as the
culprit, it took longer than desired to figure out what was going on. This
series intends to both fix the performance issue (as much as possible) and
do some refactoring to make it easier to understand what is happening.

In the end, I was able to reduce the number of lstat() calls in my case from
over 170,000 to about 6,500, improving the time from 2.5s to 71ms on a warm
disk cache. &#160; Thanks, Stolee

Derrick Stolee (5):
  sparse-index: refactor skip worktree retry logic
  sparse-index: refactor path_found()
  sparse-index: use strbuf in path_found()
  sparse-index: count lstat() calls
  sparse-index: improve lstat caching of sparse paths

 sparse-index.c | 220 +++++++++++++++++++++++++++++++++++++------------
 1 file changed, 167 insertions(+), 53 deletions(-)


base-commit: 66ac6e4bcd111be3fa9c2a6b3fafea718d00678d
Published-As: <a
href="https://github.com/gitgitgadget/git/releases/tag/pr-1754%2Fderrickstolee%2Fclear-skip-speed-v1">https://github.com/gitgitgadget/git/releases/tag/pr-1754%2Fderrickstolee%2Fclear-skip-speed-v1</a>
Fetch-It-Via: git fetch <a
href="https://github.com/gitgitgadget/git">https://github.com/gitgitgadget/git</a> pr-1754/derrickstolee/clear-skip-speed-v1
Pull-Request: <a
href="https://github.com/gitgitgadget/git/pull/1754">https://github.com/gitgitgadget/git/pull/1754</a>
-- 
gitgitgadget
</pre></div></content></entry><entry><author><name>Derrick Stolee via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH 1/5] sparse-index: refactor skip worktree retry logic</title><updated>2024-06-20T16:11:21Z</updated><link
href="http://lore.kernel.org/git/ddd8a9a90cea10be47eba4775bb90f01a9b80443.1718899877.git.gitgitgadget@gmail.com/"/><id>urn:uuid:d268264e-979c-3975-33f0-895f558d10ae</id><thr:in-reply-to
ref="urn:uuid:0a3e9f9b-e887-e20a-cd21-226c7be2a265"
href="http://lore.kernel.org/git/pull.1754.git.1718899877.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Derrick Stolee &lt;stolee@gmail.com&gt;

The clear_skip_worktree_from_present_files() method was introduced in
af6a51875a (repo_read_index: clear SKIP_WORKTREE bit from files present
in worktree, 2022-01-14) to help cases where the sparse index is enabled
but some paths outside of the sparse-checkout cone also exist on disk.
This operation can be slow as it needs to check path existence in a way
that is not stored in the collapsed index, so caching was introduced in
d79d299352 (Accelerate clear_skip_worktree_from_present_files() by
caching, 2022-01-14).

If users are having trouble with the performance of this operation and
don&#39;t care about paths outside of the sparse-checkout cone, they can
disable them using the sparse.expectFilesOutsideOfPatterns config option
introduced in ecc7c8841d (repo_read_index: add config to expect files
outside sparse patterns, 2022-02-25).

Even with that caching, it was noticed that this could take a long time
to execute. 89aaab11a3 (index: add trace2 region for clear skip
worktree, 2022-11-03) introduced trace2 regions to measure this time.
Further, the way the loop repeats itself was slightly confusing and
prone to breakage, so a BUG() statement was added in 8c7abdc596 (index:
raise a bug if the index is materialised more than once, 2022-11-03) to
be sure that the second run of the loop does not hit any sparse trees.

One thing that can be confusing about the current setup is that the
trace2 regions nest and it is not clear that a second loop is running
after the index is expanded. Here is an example of what the regions look
like in a typical case:

| region_enter | ... | label:clear_skip_worktree_from_present_files
| region_enter | ... | ..label:update
| region_leave | ... | ..label:update
| region_enter | ... | ..label:ensure_full_index
| region_enter | ... | ....label:update
| region_leave | ... | ....label:update
| region_leave | ... | ..label:ensure_full_index
| data         | ... | ..sparse_path_count:1
| data         | ... | ..sparse_path_count_full:269538
| region_leave | ... | label:clear_skip_worktree_from_present_files

One thing that is particularly difficult to understand about these
regions is that most of the time is spent between the close of the
ensure_full_index region and the reporting of the end data. This is
because of the restart of the loop being within the same region as the
first iteration of the loop.

This change refactors the method into two separate methods that are
traced separately. This will be more important later when we change
other features of the methods, but for now the only functional change is
the difference in the structure of the trace regions.

After this change, the same telemetry section is split into three
distinct chunks:

| region_enter | ... | label:clear_skip_worktree_from_present_files_sparse
| data         | ... | ..sparse_path_count:1
| region_leave | ... | label:clear_skip_worktree_from_present_files_sparse
| region_enter | ... | label:update
| region_leave | ... | label:update
| region_enter | ... | label:ensure_full_index
| region_enter | ... | ..label:update
| region_leave | ... | ..label:update
| region_leave | ... | label:ensure_full_index
| region_enter | ... | label:clear_skip_worktree_from_present_files_full
| data         | ... | ..full_path_count:269538
| region_leave | ... | label:clear_skip_worktree_from_present_files_full

Here, we see the sparse loop terminating early with its first sparse
path being a sparse directory containing a file. Then, that loop&#39;s
region terminates before ensure_full_index begins (in this case, the
cache-tree must also be computed). Then, _after_ the index is expanded,
the full loop begins with its own region.

Signed-off-by: Derrick Stolee &lt;stolee@gmail.com&gt;
---
 sparse-index.c | 77 ++++++++++++++++++++++++++++++++++----------------
 1 file <a href="http://lore.kernel.org/git/ddd8a9a90cea10be47eba4775bb90f01a9b80443.1718899877.git.gitgitgadget@gmail.com/#related">changed</a>, 53 insertions(+), 24 deletions(-)

<span
class="head">diff --git a/sparse-index.c b/sparse-index.c
index e48e40cae71..e0457c87fff 100644
--- a/sparse-index.c
+++ b/sparse-index.c
</span><span
class="hunk">@@ -486,49 +486,78 @@ static int path_found(const char *path, const char **dirname, size_t *dir_len,
</span> 	return 0;
 }
 
<span
class="del">-void clear_skip_worktree_from_present_files(struct index_state *istate)
</span><span
class="add">+static int clear_skip_worktree_from_present_files_sparse(struct index_state *istate)
</span> {
 	const char *last_dirname = NULL;
 	size_t dir_len = 0;
 	int dir_found = 1;
 
<span
class="del">-	int i;
-	int path_count[2] = {0, 0};
-	int restarted = 0;
</span><span
class="add">+	int path_count = 0;
+	int to_restart = 0;
</span> 
<span
class="del">-	if (!core_apply_sparse_checkout ||
-	    sparse_expect_files_outside_of_patterns)
-		return;
-
-	trace2_region_enter(&#34;index&#34;, &#34;clear_skip_worktree_from_present_files&#34;,
</span><span
class="add">+	trace2_region_enter(&#34;index&#34;, &#34;clear_skip_worktree_from_present_files_sparse&#34;,
</span> 			    istate-&gt;repo);
<span
class="del">-restart:
-	for (i = 0; i &lt; istate-&gt;cache_nr; i++) {
</span><span
class="add">+	for (int i = 0; i &lt; istate-&gt;cache_nr; i++) {
</span> 		struct cache_entry *ce = istate-&gt;cache[i];
 
 		if (ce_skip_worktree(ce)) {
<span
class="del">-			path_count[restarted]++;
</span><span
class="add">+			path_count++;
</span> 			if (path_found(ce-&gt;name, &#38;last_dirname, &#38;dir_len, &#38;dir_found)) {
 				if (S_ISSPARSEDIR(ce-&gt;ce_mode)) {
<span
class="del">-					if (restarted)
-						BUG(&#34;ensure-full-index did not fully flatten?&#34;);
-					ensure_full_index(istate);
-					restarted = 1;
-					goto restart;
</span><span
class="add">+					to_restart = 1;
+					break;
</span> 				}
 				ce-&gt;ce_flags &#38;= ~CE_SKIP_WORKTREE;
 			}
 		}
 	}
 
<span
class="del">-	if (path_count[0])
-		trace2_data_intmax(&#34;index&#34;, istate-&gt;repo,
-				   &#34;sparse_path_count&#34;, path_count[0]);
-	if (restarted)
-		trace2_data_intmax(&#34;index&#34;, istate-&gt;repo,
-				   &#34;sparse_path_count_full&#34;, path_count[1]);
-	trace2_region_leave(&#34;index&#34;, &#34;clear_skip_worktree_from_present_files&#34;,
</span><span
class="add">+	trace2_data_intmax(&#34;index&#34;, istate-&gt;repo,
+			   &#34;sparse_path_count&#34;, path_count);
+	trace2_region_leave(&#34;index&#34;, &#34;clear_skip_worktree_from_present_files_sparse&#34;,
+			    istate-&gt;repo);
+	return to_restart;
+}
+
+static void clear_skip_worktree_from_present_files_full(struct index_state *istate)
+{
+	const char *last_dirname = NULL;
+	size_t dir_len = 0;
+	int dir_found = 1;
+
+	int path_count = 0;
+
+	trace2_region_enter(&#34;index&#34;, &#34;clear_skip_worktree_from_present_files_full&#34;,
</span> 			    istate-&gt;repo);
<span
class="add">+	for (int i = 0; i &lt; istate-&gt;cache_nr; i++) {
+		struct cache_entry *ce = istate-&gt;cache[i];
+
+		if (S_ISSPARSEDIR(ce-&gt;ce_mode))
+			BUG(&#34;ensure-full-index did not fully flatten?&#34;);
+
+		if (ce_skip_worktree(ce)) {
+			path_count++;
+			if (path_found(ce-&gt;name, &#38;last_dirname, &#38;dir_len, &#38;dir_found))
+				ce-&gt;ce_flags &#38;= ~CE_SKIP_WORKTREE;
+		}
+	}
+
+	trace2_data_intmax(&#34;index&#34;, istate-&gt;repo,
+			   &#34;full_path_count&#34;, path_count);
+	trace2_region_leave(&#34;index&#34;, &#34;clear_skip_worktree_from_present_files_full&#34;,
+			    istate-&gt;repo);
+}
+
+void clear_skip_worktree_from_present_files(struct index_state *istate)
+{
+	if (!core_apply_sparse_checkout ||
+	    sparse_expect_files_outside_of_patterns)
+		return;
+
+	if (clear_skip_worktree_from_present_files_sparse(istate)) {
+		ensure_full_index(istate);
+		clear_skip_worktree_from_present_files_full(istate);
+	}
</span> }
 
 /*
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Victoria Dye via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 17/17] mktree: remove entries when mode is 0</title><updated>2024-06-19T21:58:31Z</updated><link
href="http://lore.kernel.org/git/d392c440b8a243a9fa3e5b603c42a81f02c26e62.1718834285.git.gitgitgadget@gmail.com/"/><id>urn:uuid:49158d53-0ce6-8266-254e-80e613646c58</id><thr:in-reply-to
ref="urn:uuid:181c79e4-3522-34dd-5a02-fa233eea3ac0"
href="http://lore.kernel.org/git/pull.1746.v2.git.1718834285.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Victoria Dye &lt;vdye@github.com&gt;

If tree entries are specified with a mode with value &#39;0&#39;, remove them from
the tree instead of adding/updating them. If the mode is &#39;0&#39;, both the
provided type string (if specified) and the object ID of the entry are
ignored.

Note that entries with mode &#39;0&#39; are added to the &#39;struct tree_ent_array&#39;
with a trailing slash so that it&#39;s always treated like a directory. This is
a bit of a hack to ensure that the removal supercedes any preceding entries
with matching names, as well as any nested inside a directory matching its
name.

Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
---
 Documentation/git-mktree.txt |  4 ++++
 builtin/mktree.c             | 16 +++++++++++----
 t/t1010-mktree.sh            | 38 ++++++++++++++++++++++++++++++++++++
 3 files <a href="http://lore.kernel.org/git/d392c440b8a243a9fa3e5b603c42a81f02c26e62.1718834285.git.gitgitgadget@gmail.com/#related">changed</a>, 54 insertions(+), 4 deletions(-)

<span
class="head">diff --git a/Documentation/git-mktree.txt b/Documentation/git-mktree.txt
index 43cd9b10cc7..52e6005c1d3 100644
--- a/Documentation/git-mktree.txt
+++ b/Documentation/git-mktree.txt
</span><span
class="hunk">@@ -63,6 +63,10 @@ entries nested within one or more directories. These entries are inserted
</span> into the appropriate tree in the base tree-ish if one exists. Otherwise,
 empty parent trees are created to contain the entries.
 
<span
class="add">+An entry with a mode of &#34;0&#34; will remove an entry of the same name from the
+base tree-ish. If no tree-ish argument is given, or the entry does not exist
+in that tree, the entry is ignored.
+
</span> The order of the tree entries is normalized by `mktree` so pre-sorting the
 input by path is not required. Multiple entries provided with the same path
 are deduplicated, with only the last one specified added to the tree.
<span
class="head">diff --git a/builtin/mktree.c b/builtin/mktree.c
index 74cec92a517..e7adcb384c8 100644
--- a/builtin/mktree.c
+++ b/builtin/mktree.c
</span><span
class="hunk">@@ -32,7 +32,7 @@ struct tree_entry {
</span> 
 static inline size_t df_path_len(size_t pathlen, unsigned int mode)
 {
<span
class="del">-	return S_ISDIR(mode) ? pathlen - 1 : pathlen;
</span><span
class="add">+	return (S_ISDIR(mode) || !mode) ? pathlen - 1 : pathlen;
</span> }
 
 struct tree_entry_array {
<span
class="hunk">@@ -108,7 +108,7 @@ static void append_to_tree(unsigned mode, struct object_id *oid, const char *pat
</span> 		size_t len_to_copy = len;
 
 		/* Normalize and validate entry path */
<span
class="del">-		if (S_ISDIR(mode)) {
</span><span
class="add">+		if (S_ISDIR(mode) || !mode) {
</span> 			while(len_to_copy &gt; 0 &#38;&#38; is_dir_sep(path[len_to_copy - 1]))
 				len_to_copy--;
 			len = len_to_copy + 1; /* add space for trailing slash */
<span
class="hunk">@@ -124,7 +124,7 @@ static void append_to_tree(unsigned mode, struct object_id *oid, const char *pat
</span> 			arr-&gt;has_nested_entries = 1;
 
 		/* Add trailing slash to dir */
<span
class="del">-		if (S_ISDIR(mode))
</span><span
class="add">+		if (S_ISDIR(mode) || !mode)
</span> 			ent-&gt;name[len - 1] = &#39;/&#39;;
 	}
 
<span
class="hunk">@@ -209,7 +209,7 @@ static void sort_and_dedup_tree_entry_array(struct tree_entry_array *arr)
</span> 
 			if (!skip_entry) {
 				arr-&gt;entries[arr-&gt;nr++] = curr;
<span
class="del">-				if (S_ISDIR(curr-&gt;mode))
</span><span
class="add">+				if (S_ISDIR(curr-&gt;mode) || !curr-&gt;mode)
</span> 					tree_entry_array_push(&#38;parent_dir_ents, curr);
 			} else {
 				FREE_AND_NULL(curr);
<span
class="hunk">@@ -270,6 +270,9 @@ static int build_index_from_tree(const struct object_id *oid,
</span> static int add_tree_entry_to_index(struct build_index_data *data,
 				   struct tree_entry *ent)
 {
<span
class="add">+	if (!ent-&gt;mode)
+		return 0;
+
</span> 	if (ent-&gt;expand_dir) {
 		int ret = 0;
 		struct pathspec ps = { 0 };
<span
class="hunk">@@ -450,6 +453,10 @@ static int mktree_line(unsigned int mode, struct object_id *oid,
</span> 	if (stage)
 		die(_(&#34;path &#39;%s&#39; is unmerged&#34;), path);
 
<span
class="add">+	/* OID ignored for zero-mode entries; append unconditionally */
+	if (!mode)
+		goto append_entry;
+
</span> 	if (obj_type != OBJ_ANY &#38;&#38; mode_type != obj_type)
 		die(&#34;object type (%s) doesn&#39;t match mode type (%s)&#34;,
 		    type_name(obj_type), type_name(mode_type));
<span
class="hunk">@@ -484,6 +491,7 @@ static int mktree_line(unsigned int mode, struct object_id *oid,
</span> 		}
 	}
 
<span
class="add">+append_entry:
</span> 	append_to_tree(mode, oid, path, data-&gt;arr, data-&gt;literally);
 	return 0;
 }
<span
class="head">diff --git a/t/t1010-mktree.sh b/t/t1010-mktree.sh
index 9b0e0cf302f..5ed4352054a 100755
--- a/t/t1010-mktree.sh
+++ b/t/t1010-mktree.sh
</span><span
class="hunk">@@ -369,4 +369,42 @@ test_expect_success &#39;mktree fails on directory-file conflict&#39; &#39;
</span> 	test_grep &#34;You have both folder/one and folder/one/deeper/deep&#34; err
 &#39;
 
<span
class="add">+test_expect_success &#39;mktree with remove entries&#39; &#39;
+	tree_oid=&#34;$(cat tree)&#34; &#38;&#38;
+	blob_oid=&#34;$(git rev-parse $tree_oid:folder.txt)&#34; &#38;&#38;
+
+	{
+		printf &#34;100644 blob $blob_oid\ttest/deeper/deep.txt\n&#34; &#38;&#38;
+		printf &#34;100644 blob $blob_oid\ttest.txt\n&#34; &#38;&#38;
+		printf &#34;100644 blob $blob_oid\texample\n&#34; &#38;&#38;
+		printf &#34;100644 blob $blob_oid\texample.a/file\n&#34; &#38;&#38;
+		printf &#34;100644 blob $blob_oid\texample.txt\n&#34; &#38;&#38;
+		printf &#34;040000 tree $tree_oid\tfolder\n&#34; &#38;&#38;
+		printf &#34;0 $ZERO_OID\tfolder\n&#34; &#38;&#38;
+		printf &#34;0 $ZERO_OID\tmissing\n&#34;
+	} | git mktree &gt;tree.base &#38;&#38;
+
+	{
+		printf &#34;0 $ZERO_OID\texample.txt\n&#34; &#38;&#38;
+		printf &#34;0 $ZERO_OID\ttest/deeper\n&#34;
+	} | git mktree $(cat tree.base) &gt;tree.actual &#38;&#38;
+
+	{
+		printf &#34;100644 blob $blob_oid\texample\n&#34; &#38;&#38;
+		printf &#34;100644 blob $blob_oid\texample.a/file\n&#34; &#38;&#38;
+		printf &#34;100644 blob $blob_oid\ttest.txt\n&#34;
+	} &gt;expect &#38;&#38;
+	git ls-tree -r $(cat tree.actual) &gt;actual &#38;&#38;
+
+	test_cmp expect actual
+&#39;
+
+test_expect_success &#39;type and oid not checked if entry mode is 0&#39; &#39;
+	# type and oid do not match
+	printf &#34;0 commit $EMPTY_TREE\tfolder.txt\n&#34; |
+	git mktree &gt;tree.actual &#38;&#38;
+
+	test &#34;$(cat tree.actual)&#34; = $EMPTY_TREE
+&#39;
+
</span> test_done
-- 
gitgitgadget
</pre></div></content></entry><entry><author><name>Victoria Dye via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 16/17] mktree: allow deeper paths in input</title><updated>2024-06-19T21:58:30Z</updated><link
href="http://lore.kernel.org/git/46756c4e3140d34838ad4cd5e7a070d1f9f46b53.1718834285.git.gitgitgadget@gmail.com/"/><id>urn:uuid:9ec836a3-ca87-5daf-24e3-252c561061fe</id><thr:in-reply-to
ref="urn:uuid:181c79e4-3522-34dd-5a02-fa233eea3ac0"
href="http://lore.kernel.org/git/pull.1746.v2.git.1718834285.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Victoria Dye &lt;vdye@github.com&gt;

Update &#39;git mktree&#39; to handle entries nested inside of directories (e.g.
&#39;path/to/a/file.txt&#39;). This functionality requires a series of changes:

* In &#39;sort_and_dedup_tree_entry_array()&#39;, remove entries inside of
  directories that come after them in input order.
* Also in &#39;sort_and_dedup_tree_entry_array()&#39;, mark directories that contain
  entries that come after them in input order (e.g., &#39;folder/&#39; followed by
  &#39;folder/file.txt&#39;) as &#34;need to expand&#34;.
* In &#39;add_tree_entry_to_index()&#39;, if a tree entry is marked as &#34;need to
  expand&#34;, recurse into it with &#39;read_tree_at()&#39; &#38; &#39;build_index_from_tree&#39;.
* In &#39;build_index_from_tree()&#39;, if a user-specified tree entry is contained
  within the current iterated entry, return &#39;READ_TREE_RECURSIVE&#39; to recurse
  into the iterated tree.

Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
---
 Documentation/git-mktree.txt |   5 ++
 builtin/mktree.c             | 101 ++++++++++++++++++++++++++++++---
 t/t1010-mktree.sh            | 107 +++++++++++++++++++++++++++++++++--
 3 files <a href="http://lore.kernel.org/git/46756c4e3140d34838ad4cd5e7a070d1f9f46b53.1718834285.git.gitgitgadget@gmail.com/#related">changed</a>, 200 insertions(+), 13 deletions(-)

<span
class="head">diff --git a/Documentation/git-mktree.txt b/Documentation/git-mktree.txt
index 260d0e0bd7b..43cd9b10cc7 100644
--- a/Documentation/git-mktree.txt
+++ b/Documentation/git-mktree.txt
</span><span
class="hunk">@@ -58,6 +58,11 @@ Higher stages represent conflicted files in an index; this information
</span> cannot be represented in a tree object. The command will fail without
 writing the tree if a higher order stage is specified for any entry.
 
<span
class="add">+Entries may use full pathnames containing directory separators to specify
+entries nested within one or more directories. These entries are inserted
+into the appropriate tree in the base tree-ish if one exists. Otherwise,
+empty parent trees are created to contain the entries.
+
</span> The order of the tree entries is normalized by `mktree` so pre-sorting the
 input by path is not required. Multiple entries provided with the same path
 are deduplicated, with only the last one specified added to the tree.
<span
class="head">diff --git a/builtin/mktree.c b/builtin/mktree.c
index 96f06547a2a..74cec92a517 100644
--- a/builtin/mktree.c
+++ b/builtin/mktree.c
</span><span
class="hunk">@@ -22,6 +22,7 @@ struct tree_entry {
</span> 
 	/* Internal */
 	size_t order;
<span
class="add">+	int expand_dir;
</span> 
 	unsigned mode;
 	struct object_id oid;
<span
class="hunk">@@ -39,6 +40,7 @@ struct tree_entry_array {
</span> 	struct tree_entry **entries;
 
 	struct hashmap df_name_hash;
<span
class="add">+	int has_nested_entries;
</span> };
 
 static int df_name_hash_cmp(const void *cmp_data UNUSED,
<span
class="hunk">@@ -70,6 +72,13 @@ static void tree_entry_array_push(struct tree_entry_array *arr, struct tree_entr
</span> 	arr-&gt;entries[arr-&gt;nr++] = ent;
 }
 
<span
class="add">+static struct tree_entry *tree_entry_array_pop(struct tree_entry_array *arr)
+{
+	if (!arr-&gt;nr)
+		return NULL;
+	return arr-&gt;entries[--arr-&gt;nr];
+}
+
</span> static void tree_entry_array_clear(struct tree_entry_array *arr, int free_entries)
 {
 	if (free_entries) {
<span
class="hunk">@@ -109,8 +118,10 @@ static void append_to_tree(unsigned mode, struct object_id *oid, const char *pat
</span> 
 		if (!verify_path(ent-&gt;name, mode))
 			die(_(&#34;invalid path &#39;%s&#39;&#34;), path);
<span
class="del">-		if (strchr(ent-&gt;name, &#39;/&#39;))
-			die(&#34;path %s contains slash&#34;, path);
</span><span
class="add">+
+		/* mark has_nested_entries if needed */
+		if (!arr-&gt;has_nested_entries &#38;&#38; strchr(ent-&gt;name, &#39;/&#39;))
+			arr-&gt;has_nested_entries = 1;
</span> 
 		/* Add trailing slash to dir */
 		if (S_ISDIR(mode))
<span
class="hunk">@@ -168,6 +179,46 @@ static void sort_and_dedup_tree_entry_array(struct tree_entry_array *arr)
</span> 	ignore_mode = 0;
 	QSORT_S(arr-&gt;entries, arr-&gt;nr, ent_compare, &#38;ignore_mode);
 
<span
class="add">+	if (arr-&gt;has_nested_entries) {
+		struct tree_entry_array parent_dir_ents = { 0 };
+
+		count = arr-&gt;nr;
+		arr-&gt;nr = 0;
+
+		/* Remove any entries where one of its parent dirs has a higher &#39;order&#39; */
+		for (size_t i = 0; i &lt; count; i++) {
+			const char *skipped_prefix;
+			struct tree_entry *parent;
+			struct tree_entry *curr = arr-&gt;entries[i];
+			int skip_entry = 0;
+
+			while ((parent = tree_entry_array_pop(&#38;parent_dir_ents))) {
+				if (!skip_prefix(curr-&gt;name, parent-&gt;name, &#38;skipped_prefix))
+					continue;
+
+				/* entry in dir, so we push the parent back onto the stack */
+				tree_entry_array_push(&#38;parent_dir_ents, parent);
+
+				if (parent-&gt;order &gt; curr-&gt;order)
+					skip_entry = 1;
+				else
+					parent-&gt;expand_dir = 1;
+
+				break;
+			}
+
+			if (!skip_entry) {
+				arr-&gt;entries[arr-&gt;nr++] = curr;
+				if (S_ISDIR(curr-&gt;mode))
+					tree_entry_array_push(&#38;parent_dir_ents, curr);
+			} else {
+				FREE_AND_NULL(curr);
+			}
+		}
+
+		tree_entry_array_release(&#38;parent_dir_ents, 0);
+	}
+
</span> 	/* Finally, initialize the directory-file conflict hash map */
 	for (size_t i = 0; i &lt; count; i++) {
 		struct tree_entry *curr = arr-&gt;entries[i];
<span
class="hunk">@@ -212,15 +263,40 @@ struct build_index_data {
</span> 	struct index_state istate;
 };
 
<span
class="add">+static int build_index_from_tree(const struct object_id *oid,
+				 struct strbuf *base, const char *filename,
+				 unsigned mode, void *context);
+
</span> static int add_tree_entry_to_index(struct build_index_data *data,
 				   struct tree_entry *ent)
 {
<span
class="del">-	struct cache_entry *ce;
-	ce = make_cache_entry(&#38;data-&gt;istate, ent-&gt;mode, &#38;ent-&gt;oid, ent-&gt;name, 0, 0);
-	if (!ce)
-		return error(_(&#34;make_cache_entry failed for path &#39;%s&#39;&#34;), ent-&gt;name);
</span><span
class="add">+	if (ent-&gt;expand_dir) {
+		int ret = 0;
+		struct pathspec ps = { 0 };
+		struct tree *subtree = parse_tree_indirect(&#38;ent-&gt;oid);
+		struct strbuf base_path = STRBUF_INIT;
+		strbuf_add(&#38;base_path, ent-&gt;name, ent-&gt;len);
+
+		if (!subtree)
+			ret = error(_(&#34;not a tree object: %s&#34;), oid_to_hex(&#38;ent-&gt;oid));
+		else if (read_tree_at(the_repository, subtree, &#38;base_path, 0, &#38;ps,
+				 build_index_from_tree, data) &lt; 0)
+			ret = -1;
+
+		strbuf_release(&#38;base_path);
+		if (ret)
+			return ret;
+
+	} else {
+		struct cache_entry *ce = make_cache_entry(&#38;data-&gt;istate,
+							  ent-&gt;mode, &#38;ent-&gt;oid,
+							  ent-&gt;name, 0, 0);
+		if (!ce)
+			return error(_(&#34;make_cache_entry failed for path &#39;%s&#39;&#34;), ent-&gt;name);
+
+		add_index_entry(&#38;data-&gt;istate, ce, ADD_CACHE_JUST_APPEND);
+	}
</span> 
<span
class="del">-	add_index_entry(&#38;data-&gt;istate, ce, ADD_CACHE_JUST_APPEND);
</span> 	return 0;
 }
 
<span
class="hunk">@@ -247,10 +323,12 @@ static int build_index_from_tree(const struct object_id *oid,
</span> 		base_tree_ent-&gt;name[base_tree_ent-&gt;len - 1] = &#39;/&#39;;
 
 	while (cbdata-&gt;iter.current) {
<span
class="add">+		const char *skipped_prefix;
</span> 		struct tree_entry *ent = cbdata-&gt;iter.current;
<span
class="add">+		int cmp;
</span> 
<span
class="del">-		int cmp = name_compare(ent-&gt;name, ent-&gt;len,
-				       base_tree_ent-&gt;name, base_tree_ent-&gt;len);
</span><span
class="add">+		cmp = name_compare(ent-&gt;name, ent-&gt;len,
+				   base_tree_ent-&gt;name, base_tree_ent-&gt;len);
</span> 		if (!cmp || cmp &lt; 0) {
 			tree_entry_iterator_advance(&#38;cbdata-&gt;iter);
 
<span
class="hunk">@@ -264,6 +342,11 @@ static int build_index_from_tree(const struct object_id *oid,
</span> 				goto cleanup_and_return;
 			} else
 				continue;
<span
class="add">+		} else if (skip_prefix(ent-&gt;name, base_tree_ent-&gt;name, &#38;skipped_prefix) &#38;&#38;
+			   S_ISDIR(base_tree_ent-&gt;mode)) {
+			/* The entry is in the current traversed tree entry, so we recurse */
+			result = READ_TREE_RECURSIVE;
+			goto cleanup_and_return;
</span> 		}
 
 		break;
<span
class="head">diff --git a/t/t1010-mktree.sh b/t/t1010-mktree.sh
index 435ac23bd50..9b0e0cf302f 100755
--- a/t/t1010-mktree.sh
+++ b/t/t1010-mktree.sh
</span><span
class="hunk">@@ -85,12 +85,21 @@ test_expect_success &#39;mktree with invalid submodule OIDs&#39; &#39;
</span> 	done
 &#39;
 
<span
class="del">-test_expect_success &#39;mktree refuses to read ls-tree -r output (1)&#39; &#39;
-	test_must_fail git mktree &lt;all
</span><span
class="add">+test_expect_success &#39;mktree reads ls-tree -r output (1)&#39; &#39;
+	git mktree &lt;all &gt;actual &#38;&#38;
+	test_cmp tree actual
</span> &#39;
 
<span
class="del">-test_expect_success &#39;mktree refuses to read ls-tree -r output (2)&#39; &#39;
-	test_must_fail git mktree &lt;all.withsub
</span><span
class="add">+test_expect_success &#39;mktree reads ls-tree -r output (2)&#39; &#39;
+	git mktree &lt;all.withsub &gt;actual &#38;&#38;
+	test_cmp tree.withsub actual
+&#39;
+
+test_expect_success &#39;mktree de-duplicates files inside directories&#39; &#39;
+	git ls-tree $(cat tree) &gt;everything &#38;&#38;
+	cat &lt;all &gt;top_and_all &#38;&#38;
+	git mktree &lt;top_and_all &gt;actual &#38;&#38;
+	test_cmp tree actual
</span> &#39;
 
 test_expect_success &#39;mktree fails on malformed input&#39; &#39;
<span
class="hunk">@@ -234,6 +243,50 @@ test_expect_success &#39;mktree with duplicate entries&#39; &#39;
</span> 	test_cmp expect actual
 &#39;
 
<span
class="add">+test_expect_success &#39;mktree adds entry after nested entry&#39; &#39;
+	tree_oid=$(cat tree) &#38;&#38;
+	folder_oid=$(git rev-parse ${tree_oid}:folder) &#38;&#38;
+	one_oid=$(git rev-parse ${tree_oid}:folder/one) &#38;&#38;
+
+	{
+		printf &#34;040000 tree $folder_oid\tearly\n&#34; &#38;&#38;
+		printf &#34;100644 blob $one_oid\tearly/one\n&#34; &#38;&#38;
+		printf &#34;100644 blob $one_oid\tlater\n&#34; &#38;&#38;
+		printf &#34;040000 tree $EMPTY_TREE\tnew-tree\n&#34; &#38;&#38;
+		printf &#34;100644 blob $one_oid\tnew-tree/one\n&#34; &#38;&#38;
+		printf &#34;100644 blob $one_oid\tzzz\n&#34;
+	} &gt;top.rec &#38;&#38;
+	git mktree &lt;top.rec &gt;tree.actual &#38;&#38;
+
+	{
+		printf &#34;040000 tree $folder_oid\tearly\n&#34; &#38;&#38;
+		printf &#34;100644 blob $one_oid\tlater\n&#34; &#38;&#38;
+		printf &#34;040000 tree $folder_oid\tnew-tree\n&#34; &#38;&#38;
+		printf &#34;100644 blob $one_oid\tzzz\n&#34;
+	} &gt;expect &#38;&#38;
+	git ls-tree $(cat tree.actual) &gt;actual &#38;&#38;
+
+	test_cmp expect actual
+&#39;
+
+test_expect_success &#39;mktree inserts entries into directories&#39; &#39;
+	folder_oid=$(git rev-parse ${tree_oid}:folder) &#38;&#38;
+	one_oid=$(git rev-parse ${tree_oid}:folder/one) &#38;&#38;
+	blob_oid=$(git rev-parse ${tree_oid}:before) &#38;&#38;
+	{
+		printf &#34;040000 tree $folder_oid\tfolder\n&#34; &#38;&#38;
+		printf &#34;100644 blob $blob_oid\tfolder/two\n&#34;
+	} | git mktree &gt;actual &#38;&#38;
+
+	{
+		printf &#34;100644 blob $one_oid\tfolder/one\n&#34; &#38;&#38;
+		printf &#34;100644 blob $blob_oid\tfolder/two\n&#34;
+	} &gt;expect &#38;&#38;
+	git ls-tree -r $(cat actual) &gt;actual &#38;&#38;
+
+	test_cmp expect actual
+&#39;
+
</span> test_expect_success &#39;mktree with base tree&#39; &#39;
 	tree_oid=$(cat tree) &#38;&#38;
 	folder_oid=$(git rev-parse ${tree_oid}:folder) &#38;&#38;
<span
class="hunk">@@ -270,4 +323,50 @@ test_expect_success &#39;mktree with base tree&#39; &#39;
</span> 	test_cmp expect actual
 &#39;
 
<span
class="add">+test_expect_success &#39;mktree with base tree (deep)&#39; &#39;
+	tree_oid=$(cat tree) &#38;&#38;
+	folder_oid=$(git rev-parse ${tree_oid}:folder) &#38;&#38;
+	before_oid=$(git rev-parse ${tree_oid}:before) &#38;&#38;
+	folder_one_oid=$(git rev-parse ${tree_oid}:folder/one) &#38;&#38;
+	head_oid=$(git rev-parse HEAD) &#38;&#38;
+
+	{
+		printf &#34;100755 blob $before_oid\tfolder/before\n&#34; &#38;&#38;
+		printf &#34;100644 blob $before_oid\tfolder/one.txt\n&#34; &#38;&#38;
+		printf &#34;160000 commit $head_oid\tfolder/sub\n&#34; &#38;&#38;
+		printf &#34;040000 tree $folder_oid\tfolder/one\n&#34; &#38;&#38;
+		printf &#34;040000 tree $folder_oid\tfolder/one/deeper\n&#34;
+	} &gt;top.append &#38;&#38;
+	git mktree &lt;top.append $(cat tree) &gt;tree.actual &#38;&#38;
+
+	{
+		printf &#34;100755 blob $before_oid\tfolder/before\n&#34; &#38;&#38;
+		printf &#34;100644 blob $before_oid\tfolder/one.txt\n&#34; &#38;&#38;
+		printf &#34;100644 blob $folder_one_oid\tfolder/one/deeper/one\n&#34; &#38;&#38;
+		printf &#34;100644 blob $folder_one_oid\tfolder/one/one\n&#34; &#38;&#38;
+		printf &#34;160000 commit $head_oid\tfolder/sub\n&#34;
+	} &gt;expect &#38;&#38;
+	git ls-tree -r $(cat tree.actual) -- folder/ &gt;actual &#38;&#38;
+
+	test_cmp expect actual
+&#39;
+
+test_expect_success &#39;mktree fails on directory-file conflict&#39; &#39;
+	tree_oid=&#34;$(cat tree)&#34; &#38;&#38;
+	blob_oid=&#34;$(git rev-parse $tree_oid:folder.txt)&#34; &#38;&#38;
+
+	{
+		printf &#34;100644 blob $blob_oid\ttest\n&#34; &#38;&#38;
+		printf &#34;100644 blob $blob_oid\ttest/deeper\n&#34;
+	} |
+	test_must_fail git mktree 2&gt;err &#38;&#38;
+	test_grep &#34;You have both test and test/deeper&#34; err &#38;&#38;
+
+	{
+		printf &#34;100644 blob $blob_oid\tfolder/one/deeper/deep\n&#34;
+	} |
+	test_must_fail git mktree $tree_oid 2&gt;err &#38;&#38;
+	test_grep &#34;You have both folder/one and folder/one/deeper/deep&#34; err
+&#39;
+
</span> test_done
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Victoria Dye via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 15/17] mktree: optionally add to an existing tree</title><updated>2024-06-19T21:58:29Z</updated><link
href="http://lore.kernel.org/git/4b88f84b933b1598d12e3620f0c9fb85c559e8fb.1718834285.git.gitgitgadget@gmail.com/"/><id>urn:uuid:7d2f96b1-143b-6314-471b-00767cfa17b0</id><thr:in-reply-to
ref="urn:uuid:181c79e4-3522-34dd-5a02-fa233eea3ac0"
href="http://lore.kernel.org/git/pull.1746.v2.git.1718834285.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Victoria Dye &lt;vdye@github.com&gt;

Allow users to specify a single &#34;tree-ish&#34; value as a positional argument.
If provided, the contents of the given tree serve as the basis for the new
tree (or trees, in --batch mode) created by &#39;mktree&#39;, on top of which all of
the stdin-provided tree entries are applied.

At a high level, the entries are &#34;applied&#34; to a base tree by iterating
through the base tree using &#39;read_tree&#39; in parallel with iterating through
the sorted &#38; deduplicated stdin entries via their iterator. That is, for
each call to the &#39;build_index_from_tree callback of &#39;read_tree&#39;:

* If the iterator entry precedes the base tree entry, add it to the in-core
  index, increment the iterator, and repeat.
* If the iterator entry has the same name as the base tree entry, add the
  iterator entry to the index, increment the iterator, and return from the
  callback to continue the &#39;read_tree&#39; iteration.
* If the iterator entry follows the base tree entry, first check
  &#39;df_name_hash&#39; to ensure we won&#39;t be adding an entry with the same name
  later (with a different mode). If there&#39;s no directory/file conflict, add
  the base tree entry to the index. In either case, return from the callback
  to continue the &#39;read_tree&#39; iteration.

Finally, once &#39;read_tree&#39; is complete, add the remaining entries in the
iterator to the index and write out the index as a tree.

Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
---
 Documentation/git-mktree.txt |   7 +-
 builtin/mktree.c             | 138 +++++++++++++++++++++++++++++------
 t/t1010-mktree.sh            |  36 +++++++++
 3 files <a href="http://lore.kernel.org/git/4b88f84b933b1598d12e3620f0c9fb85c559e8fb.1718834285.git.gitgitgadget@gmail.com/#related">changed</a>, 159 insertions(+), 22 deletions(-)

<span
class="head">diff --git a/Documentation/git-mktree.txt b/Documentation/git-mktree.txt
index cf1fd82f754..260d0e0bd7b 100644
--- a/Documentation/git-mktree.txt
+++ b/Documentation/git-mktree.txt
</span><span
class="hunk">@@ -9,7 +9,7 @@ git-mktree - Build a tree-object from formatted tree entries
</span> SYNOPSIS
 --------
 [verse]
<span
class="del">-&#39;git mktree&#39; [-z] [--missing] [--literally] [--batch]
</span><span
class="add">+&#39;git mktree&#39; [-z] [--missing] [--literally] [--batch] [&lt;tree-ish&gt;]
</span> 
 DESCRIPTION
 -----------
<span
class="hunk">@@ -41,6 +41,11 @@ OPTIONS
</span> 	optional.  Note - if the `-z` option is used, lines are terminated
 	with NUL.
 
<span
class="add">+&lt;tree-ish&gt;::
+	If provided, the tree entries provided in stdin are added to this
+	tree rather than a new empty one, replacing existing entries with
+	identical names. Not compatible with `--literally`.
+
</span> INPUT FORMAT
 ------------
 Tree entries may be specified in any of the formats compatible with the
<span
class="head">diff --git a/builtin/mktree.c b/builtin/mktree.c
index b4d71dcdd02..96f06547a2a 100644
--- a/builtin/mktree.c
+++ b/builtin/mktree.c
</span><span
class="hunk">@@ -12,7 +12,9 @@
</span> #include &#34;read-cache-ll.h&#34;
 #include &#34;strbuf.h&#34;
 #include &#34;tree.h&#34;
<span
class="add">+#include &#34;object-name.h&#34;
</span> #include &#34;parse-options.h&#34;
<span
class="add">+#include &#34;pathspec.h&#34;
</span> #include &#34;object-store-ll.h&#34;
 
 struct tree_entry {
<span
class="hunk">@@ -204,47 +206,124 @@ static void tree_entry_iterator_advance(struct tree_entry_iterator *iter)
</span> 			: NULL;
 }
 
<span
class="del">-static int add_tree_entry_to_index(struct index_state *istate,
</span><span
class="add">+struct build_index_data {
+	struct tree_entry_iterator iter;
+	struct hashmap *df_name_hash;
+	struct index_state istate;
+};
+
+static int add_tree_entry_to_index(struct build_index_data *data,
</span> 				   struct tree_entry *ent)
 {
 	struct cache_entry *ce;
<span
class="del">-	struct strbuf ce_name = STRBUF_INIT;
-	strbuf_add(&#38;ce_name, ent-&gt;name, ent-&gt;len);
-
-	ce = make_cache_entry(istate, ent-&gt;mode, &#38;ent-&gt;oid, ent-&gt;name, 0, 0);
</span><span
class="add">+	ce = make_cache_entry(&#38;data-&gt;istate, ent-&gt;mode, &#38;ent-&gt;oid, ent-&gt;name, 0, 0);
</span> 	if (!ce)
 		return error(_(&#34;make_cache_entry failed for path &#39;%s&#39;&#34;), ent-&gt;name);
 
<span
class="del">-	add_index_entry(istate, ce, ADD_CACHE_JUST_APPEND);
-	strbuf_release(&#38;ce_name);
</span><span
class="add">+	add_index_entry(&#38;data-&gt;istate, ce, ADD_CACHE_JUST_APPEND);
</span> 	return 0;
 }
 
<span
class="del">-static void write_tree(struct tree_entry_array *arr, struct object_id *oid)
</span><span
class="add">+static int build_index_from_tree(const struct object_id *oid,
+				 struct strbuf *base, const char *filename,
+				 unsigned mode, void *context)
</span> {
<span
class="del">-	struct tree_entry_iterator iter = { NULL };
-	struct index_state istate = INDEX_STATE_INIT(the_repository);
-	istate.sparse_index = 1;
</span><span
class="add">+	int result;
+	struct tree_entry *base_tree_ent;
+	struct build_index_data *cbdata = context;
+	size_t filename_len = strlen(filename);
+	size_t path_len = S_ISDIR(mode) ? st_add3(filename_len, base-&gt;len, 1)
+					: st_add(filename_len, base-&gt;len);
+
+	/* Create a tree entry from the current entry in read_tree iteration */
+	base_tree_ent = xcalloc(1, st_add3(sizeof(struct tree_entry), path_len, 1));
+	base_tree_ent-&gt;len = path_len;
+	base_tree_ent-&gt;mode = mode;
+	oidcpy(&#38;base_tree_ent-&gt;oid, oid);
+
+	memcpy(base_tree_ent-&gt;name, base-&gt;buf, base-&gt;len);
+	memcpy(base_tree_ent-&gt;name + base-&gt;len, filename, filename_len);
+	if (S_ISDIR(mode))
+		base_tree_ent-&gt;name[base_tree_ent-&gt;len - 1] = &#39;/&#39;;
+
+	while (cbdata-&gt;iter.current) {
+		struct tree_entry *ent = cbdata-&gt;iter.current;
+
+		int cmp = name_compare(ent-&gt;name, ent-&gt;len,
+				       base_tree_ent-&gt;name, base_tree_ent-&gt;len);
+		if (!cmp || cmp &lt; 0) {
+			tree_entry_iterator_advance(&#38;cbdata-&gt;iter);
+
+			if (add_tree_entry_to_index(cbdata, ent) &lt; 0) {
+				result = error(_(&#34;failed to add tree entry &#39;%s&#39;&#34;), ent-&gt;name);
+				goto cleanup_and_return;
+			}
+
+			if (!cmp) {
+				result = 0;
+				goto cleanup_and_return;
+			} else
+				continue;
+		}
+
+		break;
+	}
+
+	/*
+	 * If the tree entry should be replaced with an entry with the same name
+	 * (but different mode), skip it.
+	 */
+	hashmap_entry_init(&#38;base_tree_ent-&gt;ent,
+			   memhash(base_tree_ent-&gt;name, df_path_len(base_tree_ent-&gt;len, base_tree_ent-&gt;mode)));
+	if (hashmap_get_entry(cbdata-&gt;df_name_hash, base_tree_ent, ent, NULL)) {
+		result = 0;
+		goto cleanup_and_return;
+	}
+
+	if (add_tree_entry_to_index(cbdata, base_tree_ent)) {
+		result = -1;
+		goto cleanup_and_return;
+	}
+
+	result = 0;
+
+cleanup_and_return:
+	FREE_AND_NULL(base_tree_ent);
+	return result;
+}
+
+static void write_tree(struct tree_entry_array *arr, struct tree *base_tree,
+		       struct object_id *oid)
+{
+	struct build_index_data cbdata = { 0 };
+	struct pathspec ps = { 0 };
</span> 
 	sort_and_dedup_tree_entry_array(arr);
 
<span
class="del">-	tree_entry_iterator_init(&#38;iter, arr);
</span><span
class="add">+	index_state_init(&#38;cbdata.istate, the_repository);
+	cbdata.istate.sparse_index = 1;
+	tree_entry_iterator_init(&#38;cbdata.iter, arr);
+	cbdata.df_name_hash = &#38;arr-&gt;df_name_hash;
</span> 
 	/* Construct an in-memory index from the provided entries &#38; base tree */
<span
class="del">-	while (iter.current) {
-		struct tree_entry *ent = iter.current;
-		tree_entry_iterator_advance(&#38;iter);
</span><span
class="add">+	if (base_tree &#38;&#38;
+	    read_tree(the_repository, base_tree, &#38;ps, build_index_from_tree, &#38;cbdata) &lt; 0)
+		die(_(&#34;failed to create tree&#34;));
+
+	while (cbdata.iter.current) {
+		struct tree_entry *ent = cbdata.iter.current;
+		tree_entry_iterator_advance(&#38;cbdata.iter);
</span> 
<span
class="del">-		if (add_tree_entry_to_index(&#38;istate, ent))
</span><span
class="add">+		if (add_tree_entry_to_index(&#38;cbdata, ent))
</span> 			die(_(&#34;failed to add tree entry &#39;%s&#39;&#34;), ent-&gt;name);
 	}
 
 	/* Write out new tree */
<span
class="del">-	if (cache_tree_update(&#38;istate, WRITE_TREE_SILENT | WRITE_TREE_MISSING_OK))
</span><span
class="add">+	if (cache_tree_update(&#38;cbdata.istate, WRITE_TREE_SILENT | WRITE_TREE_MISSING_OK))
</span> 		die(_(&#34;failed to write tree&#34;));
<span
class="del">-	oidcpy(oid, &#38;istate.cache_tree-&gt;oid);
</span><span
class="add">+	oidcpy(oid, &#38;cbdata.istate.cache_tree-&gt;oid);
</span> 
<span
class="del">-	release_index(&#38;istate);
</span><span
class="add">+	release_index(&#38;cbdata.istate);
</span> }
 
 static void write_tree_literally(struct tree_entry_array *arr,
<span
class="hunk">@@ -268,7 +347,7 @@ static void write_tree_literally(struct tree_entry_array *arr,
</span> }
 
 static const char *mktree_usage[] = {
<span
class="del">-	&#34;git mktree [-z] [--missing] [--literally] [--batch]&#34;,
</span><span
class="add">+	&#34;git mktree [-z] [--missing] [--literally] [--batch] [&lt;tree-ish&gt;]&#34;,
</span> 	NULL
 };
 
<span
class="hunk">@@ -334,6 +413,7 @@ int cmd_mktree(int ac, const char **av, const char *prefix)
</span> 	struct tree_entry_array arr = { 0 };
 	struct mktree_line_data mktree_line_data = { .arr = &#38;arr };
 	struct strbuf line = STRBUF_INIT;
<span
class="add">+	struct tree *base_tree = NULL;
</span> 	int ret;
 
 	const struct option option[] = {
<span
class="hunk">@@ -346,6 +426,22 @@ int cmd_mktree(int ac, const char **av, const char *prefix)
</span> 	};
 
 	ac = parse_options(ac, av, prefix, option, mktree_usage, 0);
<span
class="add">+	if (ac &gt; 1)
+		usage_with_options(mktree_usage, option);
+
+	if (ac) {
+		struct object_id base_tree_oid;
+
+		if (mktree_line_data.literally)
+			die(_(&#34;option &#39;%s&#39; and tree-ish cannot be used together&#34;), &#34;--literally&#34;);
+
+		if (repo_get_oid(the_repository, av[0], &#38;base_tree_oid))
+			die(_(&#34;not a valid object name %s&#34;), av[0]);
+
+		base_tree = parse_tree_indirect(&#38;base_tree_oid);
+		if (!base_tree)
+			die(_(&#34;not a tree object: %s&#34;), oid_to_hex(&#38;base_tree_oid));
+	}
</span> 
 	tree_entry_array_init(&#38;arr);
 
<span
class="hunk">@@ -373,7 +469,7 @@ int cmd_mktree(int ac, const char **av, const char *prefix)
</span> 			if (mktree_line_data.literally)
 				write_tree_literally(&#38;arr, &#38;oid);
 			else
<span
class="del">-				write_tree(&#38;arr, &#38;oid);
</span><span
class="add">+				write_tree(&#38;arr, base_tree, &#38;oid);
</span> 			puts(oid_to_hex(&#38;oid));
 			fflush(stdout);
 		}
<span
class="head">diff --git a/t/t1010-mktree.sh b/t/t1010-mktree.sh
index 08760141d6f..435ac23bd50 100755
--- a/t/t1010-mktree.sh
+++ b/t/t1010-mktree.sh
</span><span
class="hunk">@@ -234,4 +234,40 @@ test_expect_success &#39;mktree with duplicate entries&#39; &#39;
</span> 	test_cmp expect actual
 &#39;
 
<span
class="add">+test_expect_success &#39;mktree with base tree&#39; &#39;
+	tree_oid=$(cat tree) &#38;&#38;
+	folder_oid=$(git rev-parse ${tree_oid}:folder) &#38;&#38;
+	before_oid=$(git rev-parse ${tree_oid}:before) &#38;&#38;
+	head_oid=$(git rev-parse HEAD) &#38;&#38;
+
+	{
+		printf &#34;040000 tree $folder_oid\ttest\n&#34; &#38;&#38;
+		printf &#34;100644 blob $before_oid\ttest.txt\n&#34; &#38;&#38;
+		printf &#34;040000 tree $folder_oid\ttest-\n&#34; &#38;&#38;
+		printf &#34;160000 commit $head_oid\ttest0\n&#34;
+	} &gt;top.base &#38;&#38;
+	git mktree &lt;top.base &gt;tree.base &#38;&#38;
+
+	{
+		printf &#34;100755 blob $before_oid\tz\n&#34; &#38;&#38;
+		printf &#34;160000 commit $head_oid\ttest.xyz\n&#34; &#38;&#38;
+		printf &#34;040000 tree $folder_oid\ta\n&#34; &#38;&#38;
+		printf &#34;100644 blob $before_oid\ttest\n&#34;
+	} &gt;top.append &#38;&#38;
+	git mktree $(cat tree.base) &lt;top.append &gt;tree.actual &#38;&#38;
+
+	{
+		printf &#34;040000 tree $folder_oid\ta\n&#34; &#38;&#38;
+		printf &#34;100644 blob $before_oid\ttest\n&#34; &#38;&#38;
+		printf &#34;040000 tree $folder_oid\ttest-\n&#34; &#38;&#38;
+		printf &#34;100644 blob $before_oid\ttest.txt\n&#34; &#38;&#38;
+		printf &#34;160000 commit $head_oid\ttest.xyz\n&#34; &#38;&#38;
+		printf &#34;160000 commit $head_oid\ttest0\n&#34; &#38;&#38;
+		printf &#34;100755 blob $before_oid\tz\n&#34;
+	} &gt;expect &#38;&#38;
+	git ls-tree $(cat tree.actual) &gt;actual &#38;&#38;
+
+	test_cmp expect actual
+&#39;
+
</span> test_done
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Victoria Dye via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 14/17] mktree: add directory-file conflict hashmap</title><updated>2024-06-19T21:58:27Z</updated><link
href="http://lore.kernel.org/git/6f6d78ae7acb35991afbeaef9b61af892af93ca1.1718834285.git.gitgitgadget@gmail.com/"/><id>urn:uuid:a2ca91b7-49e6-d4eb-92c7-68def6ba6e7b</id><thr:in-reply-to
ref="urn:uuid:181c79e4-3522-34dd-5a02-fa233eea3ac0"
href="http://lore.kernel.org/git/pull.1746.v2.git.1718834285.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Victoria Dye &lt;vdye@github.com&gt;

Create a hashmap member of a &#39;struct tree_entry_array&#39; that contains all of
the (de-duplicated) provided tree entries, indexed by the hash of their path
with *no* trailing slash. This hashmap will be used in a later commit to
avoid adding a file to an existing tree that has the same path as a
directory, or vice versa.

Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
---
 builtin/mktree.c | 38 ++++++++++++++++++++++++++++++++++++++
 1 file <a href="http://lore.kernel.org/git/6f6d78ae7acb35991afbeaef9b61af892af93ca1.1718834285.git.gitgitgadget@gmail.com/#related">changed</a>, 38 insertions(+)

<span
class="head">diff --git a/builtin/mktree.c b/builtin/mktree.c
index 344c9b9b6fe..b4d71dcdd02 100644
--- a/builtin/mktree.c
+++ b/builtin/mktree.c
</span><span
class="hunk">@@ -16,6 +16,8 @@
</span> #include &#34;object-store-ll.h&#34;
 
 struct tree_entry {
<span
class="add">+	struct hashmap_entry ent;
+
</span> 	/* Internal */
 	size_t order;
 
<span
class="hunk">@@ -33,8 +35,33 @@ static inline size_t df_path_len(size_t pathlen, unsigned int mode)
</span> struct tree_entry_array {
 	size_t nr, alloc;
 	struct tree_entry **entries;
<span
class="add">+
+	struct hashmap df_name_hash;
</span> };
 
<span
class="add">+static int df_name_hash_cmp(const void *cmp_data UNUSED,
+			    const struct hashmap_entry *eptr,
+			    const struct hashmap_entry *entry_or_key,
+			    const void *keydata UNUSED)
+{
+	const struct tree_entry *e1, *e2;
+	size_t e1_len, e2_len;
+
+	e1 = container_of(eptr, const struct tree_entry, ent);
+	e2 = container_of(entry_or_key, const struct tree_entry, ent);
+
+	e1_len = df_path_len(e1-&gt;len, e1-&gt;mode);
+	e2_len = df_path_len(e2-&gt;len, e2-&gt;mode);
+
+	return e1_len != e2_len ||
+	       name_compare(e1-&gt;name, e1_len, e2-&gt;name, e2_len);
+}
+
+static void tree_entry_array_init(struct tree_entry_array *arr)
+{
+	hashmap_init(&#38;arr-&gt;df_name_hash, df_name_hash_cmp, NULL, 0);
+}
+
</span> static void tree_entry_array_push(struct tree_entry_array *arr, struct tree_entry *ent)
 {
 	ALLOC_GROW(arr-&gt;entries, arr-&gt;nr + 1, arr-&gt;alloc);
<span
class="hunk">@@ -48,6 +75,7 @@ static void tree_entry_array_clear(struct tree_entry_array *arr, int free_entrie
</span> 			FREE_AND_NULL(arr-&gt;entries[i]);
 	}
 	arr-&gt;nr = 0;
<span
class="add">+	hashmap_clear(&#38;arr-&gt;df_name_hash);
</span> }
 
 static void tree_entry_array_release(struct tree_entry_array *arr, int free_entries)
<span
class="hunk">@@ -137,6 +165,14 @@ static void sort_and_dedup_tree_entry_array(struct tree_entry_array *arr)
</span> 	/* Sort again to order the entries for tree insertion */
 	ignore_mode = 0;
 	QSORT_S(arr-&gt;entries, arr-&gt;nr, ent_compare, &#38;ignore_mode);
<span
class="add">+
+	/* Finally, initialize the directory-file conflict hash map */
+	for (size_t i = 0; i &lt; count; i++) {
+		struct tree_entry *curr = arr-&gt;entries[i];
+		hashmap_entry_init(&#38;curr-&gt;ent,
+				   memhash(curr-&gt;name, df_path_len(curr-&gt;len, curr-&gt;mode)));
+		hashmap_put(&#38;arr-&gt;df_name_hash, &#38;curr-&gt;ent);
+	}
</span> }
 
 struct tree_entry_iterator {
<span
class="hunk">@@ -311,6 +347,8 @@ int cmd_mktree(int ac, const char **av, const char *prefix)
</span> 
 	ac = parse_options(ac, av, prefix, option, mktree_usage, 0);
 
<span
class="add">+	tree_entry_array_init(&#38;arr);
+
</span> 	do {
 		ret = read_index_info(nul_term_line, mktree_line, &#38;mktree_line_data, &#38;line);
 		if (ret &lt; 0)
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Victoria Dye via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 13/17] mktree: use iterator struct to add tree entries to index</title><updated>2024-06-19T21:58:26Z</updated><link
href="http://lore.kernel.org/git/56f28efff5404a3fa22bd544d6de8ce2d919b78a.1718834285.git.gitgitgadget@gmail.com/"/><id>urn:uuid:4f513379-c3cd-c9ad-d1ae-3536a501d1d7</id><thr:in-reply-to
ref="urn:uuid:181c79e4-3522-34dd-5a02-fa233eea3ac0"
href="http://lore.kernel.org/git/pull.1746.v2.git.1718834285.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Victoria Dye &lt;vdye@github.com&gt;

Create &#39;struct tree_entry_iterator&#39; to manage iteration through a &#39;struct
tree_entry_array&#39;. Using an iterator allows for conditional iteration; this
functionality will be necessary in later commits when performing parallel
iteration through multiple sets of tree entries.

Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
---
 builtin/mktree.c | 39 ++++++++++++++++++++++++++++++++++++---
 1 file <a href="http://lore.kernel.org/git/56f28efff5404a3fa22bd544d6de8ce2d919b78a.1718834285.git.gitgitgadget@gmail.com/#related">changed</a>, 36 insertions(+), 3 deletions(-)

<span
class="head">diff --git a/builtin/mktree.c b/builtin/mktree.c
index 3ce8d3dc524..344c9b9b6fe 100644
--- a/builtin/mktree.c
+++ b/builtin/mktree.c
</span><span
class="hunk">@@ -139,6 +139,35 @@ static void sort_and_dedup_tree_entry_array(struct tree_entry_array *arr)
</span> 	QSORT_S(arr-&gt;entries, arr-&gt;nr, ent_compare, &#38;ignore_mode);
 }
 
<span
class="add">+struct tree_entry_iterator {
+	struct tree_entry *current;
+
+	/* private */
+	struct {
+		struct tree_entry_array *arr;
+		size_t idx;
+	} priv;
+};
+
+static void tree_entry_iterator_init(struct tree_entry_iterator *iter,
+				     struct tree_entry_array *arr)
+{
+	iter-&gt;priv.arr = arr;
+	iter-&gt;priv.idx = 0;
+	iter-&gt;current = 0 &lt; arr-&gt;nr ? arr-&gt;entries[0] : NULL;
+}
+
+/*
+ * Advance the tree entry iterator to the next entry in the array. If no
+ * entries remain, &#39;current&#39; is set to NULL.
+ */
+static void tree_entry_iterator_advance(struct tree_entry_iterator *iter)
+{
+	iter-&gt;current = (iter-&gt;priv.idx + 1) &lt; iter-&gt;priv.arr-&gt;nr
+			? iter-&gt;priv.arr-&gt;entries[++iter-&gt;priv.idx]
+			: NULL;
+}
+
</span> static int add_tree_entry_to_index(struct index_state *istate,
 				   struct tree_entry *ent)
 {
<span
class="hunk">@@ -157,14 +186,18 @@ static int add_tree_entry_to_index(struct index_state *istate,
</span> 
 static void write_tree(struct tree_entry_array *arr, struct object_id *oid)
 {
<span
class="add">+	struct tree_entry_iterator iter = { NULL };
</span> 	struct index_state istate = INDEX_STATE_INIT(the_repository);
 	istate.sparse_index = 1;
 
 	sort_and_dedup_tree_entry_array(arr);
 
<span
class="del">-	/* Construct an in-memory index from the provided entries */
-	for (size_t i = 0; i &lt; arr-&gt;nr; i++) {
-		struct tree_entry *ent = arr-&gt;entries[i];
</span><span
class="add">+	tree_entry_iterator_init(&#38;iter, arr);
+
+	/* Construct an in-memory index from the provided entries &#38; base tree */
+	while (iter.current) {
+		struct tree_entry *ent = iter.current;
+		tree_entry_iterator_advance(&#38;iter);
</span> 
 		if (add_tree_entry_to_index(&#38;istate, ent))
 			die(_(&#34;failed to add tree entry &#39;%s&#39;&#34;), ent-&gt;name);
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Victoria Dye via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 12/17] mktree: create tree using an in-core index</title><updated>2024-06-19T21:58:25Z</updated><link
href="http://lore.kernel.org/git/2333775ba5bd71766a6aece87e39a6d189aeaead.1718834285.git.gitgitgadget@gmail.com/"/><id>urn:uuid:e96b31af-c168-9ebf-886e-4547e15d06f0</id><thr:in-reply-to
ref="urn:uuid:181c79e4-3522-34dd-5a02-fa233eea3ac0"
href="http://lore.kernel.org/git/pull.1746.v2.git.1718834285.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Victoria Dye &lt;vdye@github.com&gt;

Rather than manually write out the contents of a tree object file, construct
an in-memory sparse index from the provided tree entries and create the tree
by writing out its corresponding cache tree.

This patch does not change the behavior of the &#39;mktree&#39; command. However,
constructing the tree this way will substantially simplify future extensions
to the command&#39;s functionality, including handling deeper-than-toplevel tree
entries and applying the provided entries to an existing tree.

Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
---
 builtin/mktree.c | 74 +++++++++++++++++++++++++++++++++++-------------
 1 file <a href="http://lore.kernel.org/git/2333775ba5bd71766a6aece87e39a6d189aeaead.1718834285.git.gitgitgadget@gmail.com/#related">changed</a>, 55 insertions(+), 19 deletions(-)

<span
class="head">diff --git a/builtin/mktree.c b/builtin/mktree.c
index a91d3a7b028..3ce8d3dc524 100644
--- a/builtin/mktree.c
+++ b/builtin/mktree.c
</span><span
class="hunk">@@ -4,6 +4,7 @@
</span>  * Copyright (c) Junio C Hamano, 2006, 2009
  */
 #include &#34;builtin.h&#34;
<span
class="add">+#include &#34;cache-tree.h&#34;
</span> #include &#34;gettext.h&#34;
 #include &#34;hex.h&#34;
 #include &#34;index-info.h&#34;
<span
class="hunk">@@ -24,6 +25,11 @@ struct tree_entry {
</span> 	char name[FLEX_ARRAY];
 };
 
<span
class="add">+static inline size_t df_path_len(size_t pathlen, unsigned int mode)
+{
+	return S_ISDIR(mode) ? pathlen - 1 : pathlen;
+}
+
</span> struct tree_entry_array {
 	size_t nr, alloc;
 	struct tree_entry **entries;
<span
class="hunk">@@ -60,17 +66,25 @@ static void append_to_tree(unsigned mode, struct object_id *oid, const char *pat
</span> 	if (literally) {
 		FLEX_ALLOC_MEM(ent, name, path, len);
 	} else {
<span
class="add">+		size_t len_to_copy = len;
+
</span> 		/* Normalize and validate entry path */
 		if (S_ISDIR(mode)) {
<span
class="del">-			while(len &gt; 0 &#38;&#38; is_dir_sep(path[len - 1]))
-				len--;
</span><span
class="add">+			while(len_to_copy &gt; 0 &#38;&#38; is_dir_sep(path[len_to_copy - 1]))
+				len_to_copy--;
+			len = len_to_copy + 1; /* add space for trailing slash */
</span> 		}
<span
class="del">-		FLEX_ALLOC_MEM(ent, name, path, len);
</span><span
class="add">+		ent = xcalloc(1, st_add3(sizeof(struct tree_entry), len, 1));
+		memcpy(ent-&gt;name, path, len_to_copy);
</span> 
 		if (!verify_path(ent-&gt;name, mode))
 			die(_(&#34;invalid path &#39;%s&#39;&#34;), path);
 		if (strchr(ent-&gt;name, &#39;/&#39;))
 			die(&#34;path %s contains slash&#34;, path);
<span
class="add">+
+		/* Add trailing slash to dir */
+		if (S_ISDIR(mode))
+			ent-&gt;name[len - 1] = &#39;/&#39;;
</span> 	}
 
 	ent-&gt;mode = mode;
<span
class="hunk">@@ -88,11 +102,14 @@ static int ent_compare(const void *a_, const void *b_, void *ctx)
</span> 	struct tree_entry *b = *(struct tree_entry **)b_;
 	int ignore_mode = *((int *)ctx);
 
<span
class="del">-	if (ignore_mode)
-		cmp = name_compare(a-&gt;name, a-&gt;len, b-&gt;name, b-&gt;len);
-	else
-		cmp = base_name_compare(a-&gt;name, a-&gt;len, a-&gt;mode,
-					b-&gt;name, b-&gt;len, b-&gt;mode);
</span><span
class="add">+	size_t a_len = a-&gt;len, b_len = b-&gt;len;
+
+	if (ignore_mode) {
+		a_len = df_path_len(a_len, a-&gt;mode);
+		b_len = df_path_len(b_len, b-&gt;mode);
+	}
+
+	cmp = name_compare(a-&gt;name, a_len, b-&gt;name, b_len);
</span> 	return cmp ? cmp : b-&gt;order - a-&gt;order;
 }
 
<span
class="hunk">@@ -108,8 +125,8 @@ static void sort_and_dedup_tree_entry_array(struct tree_entry_array *arr)
</span> 	for (size_t i = 0; i &lt; count; i++) {
 		struct tree_entry *curr = arr-&gt;entries[i];
 		if (prev &#38;&#38;
<span
class="del">-		    !name_compare(prev-&gt;name, prev-&gt;len,
-				  curr-&gt;name, curr-&gt;len)) {
</span><span
class="add">+		    !name_compare(prev-&gt;name, df_path_len(prev-&gt;len, prev-&gt;mode),
+				  curr-&gt;name, df_path_len(curr-&gt;len, curr-&gt;mode))) {
</span> 			FREE_AND_NULL(curr);
 		} else {
 			arr-&gt;entries[arr-&gt;nr++] = curr;
<span
class="hunk">@@ -122,24 +139,43 @@ static void sort_and_dedup_tree_entry_array(struct tree_entry_array *arr)
</span> 	QSORT_S(arr-&gt;entries, arr-&gt;nr, ent_compare, &#38;ignore_mode);
 }
 
<span
class="add">+static int add_tree_entry_to_index(struct index_state *istate,
+				   struct tree_entry *ent)
+{
+	struct cache_entry *ce;
+	struct strbuf ce_name = STRBUF_INIT;
+	strbuf_add(&#38;ce_name, ent-&gt;name, ent-&gt;len);
+
+	ce = make_cache_entry(istate, ent-&gt;mode, &#38;ent-&gt;oid, ent-&gt;name, 0, 0);
+	if (!ce)
+		return error(_(&#34;make_cache_entry failed for path &#39;%s&#39;&#34;), ent-&gt;name);
+
+	add_index_entry(istate, ce, ADD_CACHE_JUST_APPEND);
+	strbuf_release(&#38;ce_name);
+	return 0;
+}
+
</span> static void write_tree(struct tree_entry_array *arr, struct object_id *oid)
 {
<span
class="del">-	struct strbuf buf;
-	size_t size = 0;
</span><span
class="add">+	struct index_state istate = INDEX_STATE_INIT(the_repository);
+	istate.sparse_index = 1;
</span> 
 	sort_and_dedup_tree_entry_array(arr);
<span
class="del">-	for (size_t i = 0; i &lt; arr-&gt;nr; i++)
-		size += 32 + arr-&gt;entries[i]-&gt;len;
</span> 
<span
class="del">-	strbuf_init(&#38;buf, size);
</span><span
class="add">+	/* Construct an in-memory index from the provided entries */
</span> 	for (size_t i = 0; i &lt; arr-&gt;nr; i++) {
 		struct tree_entry *ent = arr-&gt;entries[i];
<span
class="del">-		strbuf_addf(&#38;buf, &#34;%o %s%c&#34;, ent-&gt;mode, ent-&gt;name, &#39;\0&#39;);
-		strbuf_add(&#38;buf, ent-&gt;oid.hash, the_hash_algo-&gt;rawsz);
</span><span
class="add">+
+		if (add_tree_entry_to_index(&#38;istate, ent))
+			die(_(&#34;failed to add tree entry &#39;%s&#39;&#34;), ent-&gt;name);
</span> 	}
 
<span
class="del">-	write_object_file(buf.buf, buf.len, OBJ_TREE, oid);
-	strbuf_release(&#38;buf);
</span><span
class="add">+	/* Write out new tree */
+	if (cache_tree_update(&#38;istate, WRITE_TREE_SILENT | WRITE_TREE_MISSING_OK))
+		die(_(&#34;failed to write tree&#34;));
+	oidcpy(oid, &#38;istate.cache_tree-&gt;oid);
+
+	release_index(&#38;istate);
</span> }
 
 static void write_tree_literally(struct tree_entry_array *arr,
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Victoria Dye via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 11/17] mktree: overwrite duplicate entries</title><updated>2024-06-19T21:58:23Z</updated><link
href="http://lore.kernel.org/git/fb555658057f834d94f232f1d8b380a6304a3671.1718834285.git.gitgitgadget@gmail.com/"/><id>urn:uuid:31174b45-1ae8-28b5-1a21-079fa7216f46</id><thr:in-reply-to
ref="urn:uuid:181c79e4-3522-34dd-5a02-fa233eea3ac0"
href="http://lore.kernel.org/git/pull.1746.v2.git.1718834285.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Victoria Dye &lt;vdye@github.com&gt;

If multiple tree entries with the same name are provided as input to
&#39;mktree&#39;, only write the last one to the tree. Entries are considered
duplicates if they have identical names (*not* considering mode); if a blob
and a tree with the same name are provided, only the last one will be
written to the tree. A tree with duplicate entries is invalid (per &#39;git
fsck&#39;), so that condition should be avoided wherever possible.

Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
---
 Documentation/git-mktree.txt |  3 ++-
 builtin/mktree.c             | 45 ++++++++++++++++++++++++++++++++----
 t/t1010-mktree.sh            | 36 +++++++++++++++++++++++++++--
 3 files <a href="http://lore.kernel.org/git/fb555658057f834d94f232f1d8b380a6304a3671.1718834285.git.gitgitgadget@gmail.com/#related">changed</a>, 77 insertions(+), 7 deletions(-)

<span
class="head">diff --git a/Documentation/git-mktree.txt b/Documentation/git-mktree.txt
index 5f3a6dfe38e..cf1fd82f754 100644
--- a/Documentation/git-mktree.txt
+++ b/Documentation/git-mktree.txt
</span><span
class="hunk">@@ -54,7 +54,8 @@ cannot be represented in a tree object. The command will fail without
</span> writing the tree if a higher order stage is specified for any entry.
 
 The order of the tree entries is normalized by `mktree` so pre-sorting the
<span
class="del">-input by path is not required.
</span><span
class="add">+input by path is not required. Multiple entries provided with the same path
+are deduplicated, with only the last one specified added to the tree.
</span> 
 GIT
 ---
<span
class="head">diff --git a/builtin/mktree.c b/builtin/mktree.c
index 8f0af24b6b1..a91d3a7b028 100644
--- a/builtin/mktree.c
+++ b/builtin/mktree.c
</span><span
class="hunk">@@ -15,6 +15,9 @@
</span> #include &#34;object-store-ll.h&#34;
 
 struct tree_entry {
<span
class="add">+	/* Internal */
+	size_t order;
+
</span> 	unsigned mode;
 	struct object_id oid;
 	int len;
<span
class="hunk">@@ -74,15 +77,49 @@ static void append_to_tree(unsigned mode, struct object_id *oid, const char *pat
</span> 	ent-&gt;len = len;
 	oidcpy(&#38;ent-&gt;oid, oid);
 
<span
class="add">+	ent-&gt;order = arr-&gt;nr;
</span> 	tree_entry_array_push(arr, ent);
 }
 
<span
class="del">-static int ent_compare(const void *a_, const void *b_)
</span><span
class="add">+static int ent_compare(const void *a_, const void *b_, void *ctx)
</span> {
<span
class="add">+	int cmp;
</span> 	struct tree_entry *a = *(struct tree_entry **)a_;
 	struct tree_entry *b = *(struct tree_entry **)b_;
<span
class="del">-	return base_name_compare(a-&gt;name, a-&gt;len, a-&gt;mode,
-				 b-&gt;name, b-&gt;len, b-&gt;mode);
</span><span
class="add">+	int ignore_mode = *((int *)ctx);
+
+	if (ignore_mode)
+		cmp = name_compare(a-&gt;name, a-&gt;len, b-&gt;name, b-&gt;len);
+	else
+		cmp = base_name_compare(a-&gt;name, a-&gt;len, a-&gt;mode,
+					b-&gt;name, b-&gt;len, b-&gt;mode);
+	return cmp ? cmp : b-&gt;order - a-&gt;order;
+}
+
+static void sort_and_dedup_tree_entry_array(struct tree_entry_array *arr)
+{
+	size_t count = arr-&gt;nr;
+	struct tree_entry *prev = NULL;
+
+	int ignore_mode = 1;
+	QSORT_S(arr-&gt;entries, arr-&gt;nr, ent_compare, &#38;ignore_mode);
+
+	arr-&gt;nr = 0;
+	for (size_t i = 0; i &lt; count; i++) {
+		struct tree_entry *curr = arr-&gt;entries[i];
+		if (prev &#38;&#38;
+		    !name_compare(prev-&gt;name, prev-&gt;len,
+				  curr-&gt;name, curr-&gt;len)) {
+			FREE_AND_NULL(curr);
+		} else {
+			arr-&gt;entries[arr-&gt;nr++] = curr;
+			prev = curr;
+		}
+	}
+
+	/* Sort again to order the entries for tree insertion */
+	ignore_mode = 0;
+	QSORT_S(arr-&gt;entries, arr-&gt;nr, ent_compare, &#38;ignore_mode);
</span> }
 
 static void write_tree(struct tree_entry_array *arr, struct object_id *oid)
<span
class="hunk">@@ -90,7 +127,7 @@ static void write_tree(struct tree_entry_array *arr, struct object_id *oid)
</span> 	struct strbuf buf;
 	size_t size = 0;
 
<span
class="del">-	QSORT(arr-&gt;entries, arr-&gt;nr, ent_compare);
</span><span
class="add">+	sort_and_dedup_tree_entry_array(arr);
</span> 	for (size_t i = 0; i &lt; arr-&gt;nr; i++)
 		size += 32 + arr-&gt;entries[i]-&gt;len;
 
<span
class="head">diff --git a/t/t1010-mktree.sh b/t/t1010-mktree.sh
index 7e750530455..08760141d6f 100755
--- a/t/t1010-mktree.sh
+++ b/t/t1010-mktree.sh
</span><span
class="hunk">@@ -6,11 +6,16 @@ TEST_PASSES_SANITIZE_LEAK=true
</span> . ./test-lib.sh
 
 test_expect_success setup &#39;
<span
class="del">-	for d in a a- a0
</span><span
class="add">+	for d in folder folder- folder0
</span> 	do
 		mkdir &#34;$d&#34; &#38;&#38; echo &#34;$d/one&#34; &gt;&#34;$d/one&#34; &#38;&#38;
 		git add &#34;$d&#34; || return 1
 	done &#38;&#38;
<span
class="add">+	for f in before folder.txt later
+	do
+		echo &#34;$f&#34; &gt;&#34;$f&#34; &#38;&#38;
+		git add &#34;$f&#34; || return 1
+	done &#38;&#38;
</span> 	echo zero &gt;one &#38;&#38;
 	git update-index --add --info-only one &#38;&#38;
 	git write-tree --missing-ok &gt;tree.missing &#38;&#38;
<span
class="hunk">@@ -171,7 +176,7 @@ test_expect_success &#39;--literally can create invalid trees&#39; &#39;
</span> 
 test_expect_success &#39;mktree validates path&#39; &#39;
 	tree_oid=&#34;$(cat tree)&#34; &#38;&#38;
<span
class="del">-	blob_oid=&#34;$(git rev-parse $tree_oid:a/one)&#34; &#38;&#38;
</span><span
class="add">+	blob_oid=&#34;$(git rev-parse $tree_oid:folder.txt)&#34; &#38;&#38;
</span> 	head_oid=&#34;$(git rev-parse HEAD)&#34; &#38;&#38;
 
 	# Valid: tree with or without trailing slash, blob without trailing slash
<span
class="hunk">@@ -202,4 +207,31 @@ test_expect_success &#39;mktree validates path&#39; &#39;
</span> 	test_grep &#34;invalid path ${SQ}.git/${SQ}&#34; err
 &#39;
 
<span
class="add">+test_expect_success &#39;mktree with duplicate entries&#39; &#39;
+	tree_oid=$(cat tree) &#38;&#38;
+	folder_oid=$(git rev-parse ${tree_oid}:folder) &#38;&#38;
+	before_oid=$(git rev-parse ${tree_oid}:before) &#38;&#38;
+	head_oid=$(git rev-parse HEAD) &#38;&#38;
+
+	{
+		printf &#34;100755 blob $before_oid\ttest\n&#34; &#38;&#38;
+		printf &#34;040000 tree $folder_oid\ttest-\n&#34; &#38;&#38;
+		printf &#34;160000 commit $head_oid\ttest.txt\n&#34; &#38;&#38;
+		printf &#34;040000 tree $folder_oid\ttest\n&#34; &#38;&#38;
+		printf &#34;100644 blob $before_oid\ttest0\n&#34; &#38;&#38;
+		printf &#34;160000 commit $head_oid\ttest-\n&#34;
+	} &gt;top.dup &#38;&#38;
+	git mktree &lt;top.dup &gt;tree.actual &#38;&#38;
+
+	{
+		printf &#34;160000 commit $head_oid\ttest-\n&#34; &#38;&#38;
+		printf &#34;160000 commit $head_oid\ttest.txt\n&#34; &#38;&#38;
+		printf &#34;040000 tree $folder_oid\ttest\n&#34; &#38;&#38;
+		printf &#34;100644 blob $before_oid\ttest0\n&#34;
+	} &gt;expect &#38;&#38;
+	git ls-tree $(cat tree.actual) &gt;actual &#38;&#38;
+
+	test_cmp expect actual
+&#39;
+
</span> test_done
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Victoria Dye via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 10/17] mktree: validate paths more carefully</title><updated>2024-06-19T21:58:22Z</updated><link
href="http://lore.kernel.org/git/2eb207064f80d48a7db5617feea417a015bb6082.1718834285.git.gitgitgadget@gmail.com/"/><id>urn:uuid:1159d95a-291a-f291-2950-8d2fcaedc44e</id><thr:in-reply-to
ref="urn:uuid:181c79e4-3522-34dd-5a02-fa233eea3ac0"
href="http://lore.kernel.org/git/pull.1746.v2.git.1718834285.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Victoria Dye &lt;vdye@github.com&gt;

Use &#39;verify_path&#39; to validate the paths provided as tree entries, ensuring
we do not create entries with paths not allowed in trees (e.g., .git). Also,
remove trailing slashes on directories before validating, allowing users to
provide &#39;folder-name/&#39; as the path for a tree object entry.

Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
---
 builtin/mktree.c  | 20 +++++++++++++++++---
 t/t1010-mktree.sh | 33 +++++++++++++++++++++++++++++++++
 2 files <a href="http://lore.kernel.org/git/2eb207064f80d48a7db5617feea417a015bb6082.1718834285.git.gitgitgadget@gmail.com/#related">changed</a>, 50 insertions(+), 3 deletions(-)

<span
class="head">diff --git a/builtin/mktree.c b/builtin/mktree.c
index 4ff99d44d79..8f0af24b6b1 100644
--- a/builtin/mktree.c
+++ b/builtin/mktree.c
</span><span
class="hunk">@@ -8,6 +8,7 @@
</span> #include &#34;hex.h&#34;
 #include &#34;index-info.h&#34;
 #include &#34;quote.h&#34;
<span
class="add">+#include &#34;read-cache-ll.h&#34;
</span> #include &#34;strbuf.h&#34;
 #include &#34;tree.h&#34;
 #include &#34;parse-options.h&#34;
<span
class="hunk">@@ -52,10 +53,23 @@ static void append_to_tree(unsigned mode, struct object_id *oid, const char *pat
</span> {
 	struct tree_entry *ent;
 	size_t len = strlen(path);
<span
class="del">-	if (!literally &#38;&#38; strchr(path, &#39;/&#39;))
-		die(&#34;path %s contains slash&#34;, path);
</span> 
<span
class="del">-	FLEX_ALLOC_MEM(ent, name, path, len);
</span><span
class="add">+	if (literally) {
+		FLEX_ALLOC_MEM(ent, name, path, len);
+	} else {
+		/* Normalize and validate entry path */
+		if (S_ISDIR(mode)) {
+			while(len &gt; 0 &#38;&#38; is_dir_sep(path[len - 1]))
+				len--;
+		}
+		FLEX_ALLOC_MEM(ent, name, path, len);
+
+		if (!verify_path(ent-&gt;name, mode))
+			die(_(&#34;invalid path &#39;%s&#39;&#34;), path);
+		if (strchr(ent-&gt;name, &#39;/&#39;))
+			die(&#34;path %s contains slash&#34;, path);
+	}
+
</span> 	ent-&gt;mode = mode;
 	ent-&gt;len = len;
 	oidcpy(&#38;ent-&gt;oid, oid);
<span
class="head">diff --git a/t/t1010-mktree.sh b/t/t1010-mktree.sh
index 961c0c3e55e..7e750530455 100755
--- a/t/t1010-mktree.sh
+++ b/t/t1010-mktree.sh
</span><span
class="hunk">@@ -169,4 +169,37 @@ test_expect_success &#39;--literally can create invalid trees&#39; &#39;
</span> 	test_grep &#34;not properly sorted&#34; err
 &#39;
 
<span
class="add">+test_expect_success &#39;mktree validates path&#39; &#39;
+	tree_oid=&#34;$(cat tree)&#34; &#38;&#38;
+	blob_oid=&#34;$(git rev-parse $tree_oid:a/one)&#34; &#38;&#38;
+	head_oid=&#34;$(git rev-parse HEAD)&#34; &#38;&#38;
+
+	# Valid: tree with or without trailing slash, blob without trailing slash
+	{
+		printf &#34;040000 tree $tree_oid\tfolder1/\n&#34; &#38;&#38;
+		printf &#34;040000 tree $tree_oid\tfolder2\n&#34; &#38;&#38;
+		printf &#34;100644 blob $blob_oid\tfile.txt\n&#34;
+	} | git mktree &gt;actual &#38;&#38;
+
+	# Invalid: blob with trailing slash
+	printf &#34;100644 blob $blob_oid\ttest/&#34; |
+	test_must_fail git mktree 2&gt;err &#38;&#38;
+	test_grep &#34;invalid path ${SQ}test/${SQ}&#34; err &#38;&#38;
+
+	# Invalid: dotdot
+	printf &#34;040000 tree $tree_oid\t../&#34; |
+	test_must_fail git mktree 2&gt;err &#38;&#38;
+	test_grep &#34;invalid path ${SQ}../${SQ}&#34; err &#38;&#38;
+
+	# Invalid: dot
+	printf &#34;040000 tree $tree_oid\t.&#34; |
+	test_must_fail git mktree 2&gt;err &#38;&#38;
+	test_grep &#34;invalid path ${SQ}.${SQ}&#34; err &#38;&#38;
+
+	# Invalid: .git
+	printf &#34;040000 tree $tree_oid\t.git/&#34; |
+	test_must_fail git mktree 2&gt;err &#38;&#38;
+	test_grep &#34;invalid path ${SQ}.git/${SQ}&#34; err
+&#39;
+
</span> test_done
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Victoria Dye via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 09/17] mktree: add a --literally option</title><updated>2024-06-19T21:58:20Z</updated><link
href="http://lore.kernel.org/git/e640a385b3d15a8c07d9ebd4c0872029cdc0d54f.1718834285.git.gitgitgadget@gmail.com/"/><id>urn:uuid:cae0cc65-2596-c008-0b56-9aa4d0000332</id><thr:in-reply-to
ref="urn:uuid:181c79e4-3522-34dd-5a02-fa233eea3ac0"
href="http://lore.kernel.org/git/pull.1746.v2.git.1718834285.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Victoria Dye &lt;vdye@github.com&gt;

Add the &#39;--literally&#39; option to &#39;git mktree&#39; to allow constructing a tree
with invalid contents. For now, the only change this represents compared to
the normal &#39;git mktree&#39; behavior is no longer sorting the inputs; in later
commits, deduplicaton and path validation will be added to the command and
&#39;--literally&#39; will skip those as well.

Certain tests use &#39;git mktree&#39; to intentionally generate corrupt trees.
Update these tests to use &#39;--literally&#39; so that they continue functioning
properly when additional input cleanup &#38; validation is added to the base
command. Note that, because &#39;mktree --literally&#39; does not sort entries, some
of the tests are updated to provide their inputs in tree order; otherwise,
the test would fail with an &#34;incorrect order&#34; error instead of the error the
test expects.

Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
---
 Documentation/git-mktree.txt       |  9 ++++++-
 builtin/mktree.c                   | 36 +++++++++++++++++++++++----
 t/t1010-mktree.sh                  | 40 ++++++++++++++++++++++++++++++
 t/t1014-read-tree-confusing.sh     |  6 ++---
 t/t1450-fsck.sh                    |  4 +--
 t/t1601-index-bogus.sh             |  2 +-
 t/t1700-split-index.sh             |  6 ++---
 t/t7008-filter-branch-null-sha1.sh |  6 ++---
 t/t7417-submodule-path-url.sh      |  2 +-
 t/t7450-bad-git-dotfiles.sh        |  8 +++---
 10 files <a href="http://lore.kernel.org/git/e640a385b3d15a8c07d9ebd4c0872029cdc0d54f.1718834285.git.gitgitgadget@gmail.com/#related">changed</a>, 96 insertions(+), 23 deletions(-)

<span
class="head">diff --git a/Documentation/git-mktree.txt b/Documentation/git-mktree.txt
index c187403c6bd..5f3a6dfe38e 100644
--- a/Documentation/git-mktree.txt
+++ b/Documentation/git-mktree.txt
</span><span
class="hunk">@@ -9,7 +9,7 @@ git-mktree - Build a tree-object from formatted tree entries
</span> SYNOPSIS
 --------
 [verse]
<span
class="del">-&#39;git mktree&#39; [-z] [--missing] [--batch]
</span><span
class="add">+&#39;git mktree&#39; [-z] [--missing] [--literally] [--batch]
</span> 
 DESCRIPTION
 -----------
<span
class="hunk">@@ -28,6 +28,13 @@ OPTIONS
</span> 	object.  This option has no effect on the treatment of gitlink entries
 	(aka &#34;submodules&#34;) which are always allowed to be missing.
 
<span
class="add">+--literally::
+	Create the tree from the tree entries provided to stdin in the order
+	they are provided without performing additional sorting,
+	deduplication, or path validation on them. This option is primarily
+	useful for creating invalid tree objects to use in tests of how Git
+	deals with various forms of tree corruption.
+
</span> --batch::
 	Allow building of more than one tree object before exiting.  Each
 	tree is separated by a single blank line. The final newline is
<span
class="head">diff --git a/builtin/mktree.c b/builtin/mktree.c
index f509ed1a81f..4ff99d44d79 100644
--- a/builtin/mktree.c
+++ b/builtin/mktree.c
</span><span
class="hunk">@@ -48,11 +48,11 @@ static void tree_entry_array_release(struct tree_entry_array *arr, int free_entr
</span> }
 
 static void append_to_tree(unsigned mode, struct object_id *oid, const char *path,
<span
class="del">-			   struct tree_entry_array *arr)
</span><span
class="add">+			   struct tree_entry_array *arr, int literally)
</span> {
 	struct tree_entry *ent;
 	size_t len = strlen(path);
<span
class="del">-	if (strchr(path, &#39;/&#39;))
</span><span
class="add">+	if (!literally &#38;&#38; strchr(path, &#39;/&#39;))
</span> 		die(&#34;path %s contains slash&#34;, path);
 
 	FLEX_ALLOC_MEM(ent, name, path, len);
<span
class="hunk">@@ -91,14 +91,35 @@ static void write_tree(struct tree_entry_array *arr, struct object_id *oid)
</span> 	strbuf_release(&#38;buf);
 }
 
<span
class="add">+static void write_tree_literally(struct tree_entry_array *arr,
+				 struct object_id *oid)
+{
+	struct strbuf buf;
+	size_t size = 0;
+
+	for (size_t i = 0; i &lt; arr-&gt;nr; i++)
+		size += 32 + arr-&gt;entries[i]-&gt;len;
+
+	strbuf_init(&#38;buf, size);
+	for (size_t i = 0; i &lt; arr-&gt;nr; i++) {
+		struct tree_entry *ent = arr-&gt;entries[i];
+		strbuf_addf(&#38;buf, &#34;%o %s%c&#34;, ent-&gt;mode, ent-&gt;name, &#39;\0&#39;);
+		strbuf_add(&#38;buf, ent-&gt;oid.hash, the_hash_algo-&gt;rawsz);
+	}
+
+	write_object_file(buf.buf, buf.len, OBJ_TREE, oid);
+	strbuf_release(&#38;buf);
+}
+
</span> static const char *mktree_usage[] = {
<span
class="del">-	&#34;git mktree [-z] [--missing] [--batch]&#34;,
</span><span
class="add">+	&#34;git mktree [-z] [--missing] [--literally] [--batch]&#34;,
</span> 	NULL
 };
 
 struct mktree_line_data {
 	struct tree_entry_array *arr;
 	int allow_missing;
<span
class="add">+	int literally;
</span> };
 
 static int mktree_line(unsigned int mode, struct object_id *oid,
<span
class="hunk">@@ -145,7 +166,7 @@ static int mktree_line(unsigned int mode, struct object_id *oid,
</span> 		}
 	}
 
<span
class="del">-	append_to_tree(mode, oid, path, data-&gt;arr);
</span><span
class="add">+	append_to_tree(mode, oid, path, data-&gt;arr, data-&gt;literally);
</span> 	return 0;
 }
 
<span
class="hunk">@@ -162,6 +183,8 @@ int cmd_mktree(int ac, const char **av, const char *prefix)
</span> 	const struct option option[] = {
 		OPT_BOOL(&#39;z&#39;, NULL, &#38;nul_term_line, N_(&#34;input is NUL terminated&#34;)),
 		OPT_BOOL(0, &#34;missing&#34;, &#38;mktree_line_data.allow_missing, N_(&#34;allow missing objects&#34;)),
<span
class="add">+		OPT_BOOL(0, &#34;literally&#34;, &#38;mktree_line_data.literally,
+			 N_(&#34;do not sort, deduplicate, or validate paths of tree entries&#34;)),
</span> 		OPT_BOOL(0, &#34;batch&#34;, &#38;is_batch_mode, N_(&#34;allow creation of more than one tree&#34;)),
 		OPT_END()
 	};
<span
class="hunk">@@ -189,7 +212,10 @@ int cmd_mktree(int ac, const char **av, const char *prefix)
</span> 			 */
 			; /* skip creating an empty tree */
 		} else {
<span
class="del">-			write_tree(&#38;arr, &#38;oid);
</span><span
class="add">+			if (mktree_line_data.literally)
+				write_tree_literally(&#38;arr, &#38;oid);
+			else
+				write_tree(&#38;arr, &#38;oid);
</span> 			puts(oid_to_hex(&#38;oid));
 			fflush(stdout);
 		}
<span
class="head">diff --git a/t/t1010-mktree.sh b/t/t1010-mktree.sh
index 48fc532e7af..961c0c3e55e 100755
--- a/t/t1010-mktree.sh
+++ b/t/t1010-mktree.sh
</span><span
class="hunk">@@ -129,4 +129,44 @@ test_expect_success &#39;mktree fails on mode mismatch&#39; &#39;
</span> 	test_grep &#34;object $tree_oid is a tree but specified type was (blob)&#34; err
 &#39;
 
<span
class="add">+test_expect_success &#39;--literally can create invalid trees&#39; &#39;
+	tree_oid=&#34;$(cat tree)&#34; &#38;&#38;
+	blob_oid=&#34;$(git rev-parse ${tree_oid}:one)&#34; &#38;&#38;
+
+	# duplicate entries
+	{
+		printf &#34;040000 tree $tree_oid\tmy-tree\n&#34; &#38;&#38;
+		printf &#34;100644 blob $blob_oid\ttest-file\n&#34; &#38;&#38;
+		printf &#34;100755 blob $blob_oid\ttest-file\n&#34;
+	} | git mktree --literally &gt;tree.bad &#38;&#38;
+	git cat-file tree $(cat tree.bad) &gt;top.bad &#38;&#38;
+	test_must_fail git hash-object --stdin -t tree &lt;top.bad 2&gt;err &#38;&#38;
+	test_grep &#34;contains duplicate file entries&#34; err &#38;&#38;
+
+	# disallowed path
+	{
+		printf &#34;100644 blob $blob_oid\t.git\n&#34;
+	} | git mktree --literally &gt;tree.bad &#38;&#38;
+	git cat-file tree $(cat tree.bad) &gt;top.bad &#38;&#38;
+	test_must_fail git hash-object --stdin -t tree &lt;top.bad 2&gt;err &#38;&#38;
+	test_grep &#34;contains ${SQ}.git${SQ}&#34; err &#38;&#38;
+
+	# nested entry
+	{
+		printf &#34;100644 blob $blob_oid\tdeeper/my-file\n&#34;
+	} | git mktree --literally &gt;tree.bad &#38;&#38;
+	git cat-file tree $(cat tree.bad) &gt;top.bad &#38;&#38;
+	test_must_fail git hash-object --stdin -t tree &lt;top.bad 2&gt;err &#38;&#38;
+	test_grep &#34;contains full pathnames&#34; err &#38;&#38;
+
+	# bad entry ordering
+	{
+		printf &#34;100644 blob $blob_oid\tB\n&#34; &#38;&#38;
+		printf &#34;040000 tree $tree_oid\tA\n&#34;
+	} | git mktree --literally &gt;tree.bad &#38;&#38;
+	git cat-file tree $(cat tree.bad) &gt;top.bad &#38;&#38;
+	test_must_fail git hash-object --stdin -t tree &lt;top.bad 2&gt;err &#38;&#38;
+	test_grep &#34;not properly sorted&#34; err
+&#39;
+
</span> test_done
<span
class="head">diff --git a/t/t1014-read-tree-confusing.sh b/t/t1014-read-tree-confusing.sh
index 8ea8d36818b..762eb789704 100755
--- a/t/t1014-read-tree-confusing.sh
+++ b/t/t1014-read-tree-confusing.sh
</span><span
class="hunk">@@ -30,13 +30,13 @@ while read path pretty; do
</span> 	esac
 	test_expect_success &#34;reject $pretty at end of path&#34; &#39;
 		printf &#34;100644 blob %s\t%s&#34; &#34;$blob&#34; &#34;$path&#34; &gt;tree &#38;&#38;
<span
class="del">-		bogus=$(git mktree &lt;tree) &#38;&#38;
</span><span
class="add">+		bogus=$(git mktree --literally &lt;tree) &#38;&#38;
</span> 		test_must_fail git read-tree $bogus
 	&#39;
 
 	test_expect_success &#34;reject $pretty as subtree&#34; &#39;
 		printf &#34;040000 tree %s\t%s&#34; &#34;$tree&#34; &#34;$path&#34; &gt;tree &#38;&#38;
<span
class="del">-		bogus=$(git mktree &lt;tree) &#38;&#38;
</span><span
class="add">+		bogus=$(git mktree --literally &lt;tree) &#38;&#38;
</span> 		test_must_fail git read-tree $bogus
 	&#39;
 done &lt;&lt;-EOF
<span
class="hunk">@@ -58,7 +58,7 @@ test_expect_success &#39;utf-8 paths allowed with core.protectHFS off&#39; &#39;
</span> 	test_when_finished &#34;git read-tree HEAD&#34; &#38;&#38;
 	test_config core.protectHFS false &#38;&#38;
 	printf &#34;100644 blob %s\t%s&#34; &#34;$blob&#34; &#34;.gi${u200c}t&#34; &gt;tree &#38;&#38;
<span
class="del">-	ok=$(git mktree &lt;tree) &#38;&#38;
</span><span
class="add">+	ok=$(git mktree --literally &lt;tree) &#38;&#38;
</span> 	git read-tree $ok
 &#39;
 
<span
class="head">diff --git a/t/t1450-fsck.sh b/t/t1450-fsck.sh
index 8a456b1142d..532d2770e88 100755
--- a/t/t1450-fsck.sh
+++ b/t/t1450-fsck.sh
</span><span
class="hunk">@@ -316,7 +316,7 @@ check_duplicate_names () {
</span> 			*)  printf &#34;100644 blob %s\t%s\n&#34; $blob &#34;$name&#34; ;;
 			esac
 		done &gt;badtree &#38;&#38;
<span
class="del">-		badtree=$(git mktree &lt;badtree) &#38;&#38;
</span><span
class="add">+		badtree=$(git mktree --literally &lt;badtree) &#38;&#38;
</span> 		test_must_fail git fsck 2&gt;out &#38;&#38;
 		test_grep &#34;$badtree&#34; out &#38;&#38;
 		test_grep &#34;error in tree .*contains duplicate file entries&#34; out
<span
class="hunk">@@ -614,7 +614,7 @@ while read name path pretty; do
</span> 			tree=$(git rev-parse HEAD^{tree}) &#38;&#38;
 			value=$(eval &#34;echo \$$type&#34;) &#38;&#38;
 			printf &#34;$mode $type %s\t%s&#34; &#34;$value&#34; &#34;$path&#34; &gt;bad &#38;&#38;
<span
class="del">-			bad_tree=$(git mktree &lt;bad) &#38;&#38;
</span><span
class="add">+			bad_tree=$(git mktree --literally &lt;bad) &#38;&#38;
</span> 			git fsck 2&gt;out &#38;&#38;
 			test_grep &#34;warning.*tree $bad_tree&#34; out
 		)&#39;
<span
class="head">diff --git a/t/t1601-index-bogus.sh b/t/t1601-index-bogus.sh
index 4171f1e1410..54e8ae038b7 100755
--- a/t/t1601-index-bogus.sh
+++ b/t/t1601-index-bogus.sh
</span><span
class="hunk">@@ -4,7 +4,7 @@ test_description=&#39;test handling of bogus index entries&#39;
</span> . ./test-lib.sh
 
 test_expect_success &#39;create tree with null sha1&#39; &#39;
<span
class="del">-	tree=$(printf &#34;160000 commit $ZERO_OID\\tbroken\\n&#34; | git mktree)
</span><span
class="add">+	tree=$(printf &#34;160000 commit $ZERO_OID\\tbroken\\n&#34; | git mktree --literally)
</span> &#39;
 
 test_expect_success &#39;read-tree refuses to read null sha1&#39; &#39;
<span
class="head">diff --git a/t/t1700-split-index.sh b/t/t1700-split-index.sh
index ac4a5b2734c..97b58aa3cca 100755
--- a/t/t1700-split-index.sh
+++ b/t/t1700-split-index.sh
</span><span
class="hunk">@@ -478,12 +478,12 @@ test_expect_success &#39;writing split index with null sha1 does not write cache tre
</span> 	git config splitIndex.maxPercentChange 0 &#38;&#38;
 	git commit -m &#34;commit&#34; &#38;&#38;
 	{
<span
class="del">-		git ls-tree HEAD &#38;&#38;
-		printf &#34;160000 commit $ZERO_OID\\tbroken\\n&#34;
</span><span
class="add">+		printf &#34;160000 commit $ZERO_OID\\tbroken\\n&#34; &#38;&#38;
+		git ls-tree HEAD
</span> 	} &gt;broken-tree &#38;&#38;
 	echo &#34;add broken entry&#34; &gt;msg &#38;&#38;
 
<span
class="del">-	tree=$(git mktree &lt;broken-tree) &#38;&#38;
</span><span
class="add">+	tree=$(git mktree --literally &lt;broken-tree) &#38;&#38;
</span> 	test_tick &#38;&#38;
 	commit=$(git commit-tree $tree -p HEAD &lt;msg) &#38;&#38;
 	git update-ref HEAD &#34;$commit&#34; &#38;&#38;
<span
class="head">diff --git a/t/t7008-filter-branch-null-sha1.sh b/t/t7008-filter-branch-null-sha1.sh
index 93fbc92b8db..a1b4c295c01 100755
--- a/t/t7008-filter-branch-null-sha1.sh
+++ b/t/t7008-filter-branch-null-sha1.sh
</span><span
class="hunk">@@ -12,12 +12,12 @@ test_expect_success &#39;setup: base commits&#39; &#39;
</span> 
 test_expect_success &#39;setup: a commit with a bogus null sha1 in the tree&#39; &#39;
 	{
<span
class="del">-		git ls-tree HEAD &#38;&#38;
-		printf &#34;160000 commit $ZERO_OID\\tbroken\\n&#34;
</span><span
class="add">+		printf &#34;160000 commit $ZERO_OID\\tbroken\\n&#34; &#38;&#38;
+		git ls-tree HEAD
</span> 	} &gt;broken-tree &#38;&#38;
 	echo &#34;add broken entry&#34; &gt;msg &#38;&#38;
 
<span
class="del">-	tree=$(git mktree &lt;broken-tree) &#38;&#38;
</span><span
class="add">+	tree=$(git mktree --literally &lt;broken-tree) &#38;&#38;
</span> 	test_tick &#38;&#38;
 	commit=$(git commit-tree $tree -p HEAD &lt;msg) &#38;&#38;
 	git update-ref HEAD &#34;$commit&#34;
<span
class="head">diff --git a/t/t7417-submodule-path-url.sh b/t/t7417-submodule-path-url.sh
index dbbb3853dc0..5d3c98e99a7 100755
--- a/t/t7417-submodule-path-url.sh
+++ b/t/t7417-submodule-path-url.sh
</span><span
class="hunk">@@ -42,7 +42,7 @@ test_expect_success MINGW &#39;submodule paths disallows trailing spaces&#39; &#39;
</span> 	tree=$(git -C super write-tree) &#38;&#38;
 	git -C super ls-tree $tree &gt;tree &#38;&#38;
 	sed &#34;s/sub/sub /&#34; &lt;tree &gt;tree.new &#38;&#38;
<span
class="del">-	tree=$(git -C super mktree &lt;tree.new) &#38;&#38;
</span><span
class="add">+	tree=$(git -C super mktree --literally &lt;tree.new) &#38;&#38;
</span> 	commit=$(echo with space | git -C super commit-tree $tree) &#38;&#38;
 	git -C super update-ref refs/heads/main $commit &#38;&#38;
 
<span
class="head">diff --git a/t/t7450-bad-git-dotfiles.sh b/t/t7450-bad-git-dotfiles.sh
index 4a9c22c9e2b..de2d45d2244 100755
--- a/t/t7450-bad-git-dotfiles.sh
+++ b/t/t7450-bad-git-dotfiles.sh
</span><span
class="hunk">@@ -203,11 +203,11 @@ check_dotx_symlink () {
</span> 			content=$(git hash-object -w ../.gitmodules) &#38;&#38;
 			target=$(printf &#34;$tricky&#34; | git hash-object -w --stdin) &#38;&#38;
 			{
<span
class="del">-				printf &#34;100644 blob $content\t$tricky\n&#34; &#38;&#38;
-				printf &#34;120000 blob $target\t$path\n&#34;
</span><span
class="add">+				printf &#34;120000 blob $target\t$path\n&#34; &#38;&#38;
+				printf &#34;100644 blob $content\t$tricky\n&#34;
</span> 			} &gt;bad-tree
 		) &#38;&#38;
<span
class="del">-		tree=$(git -C $dir mktree &lt;$dir/bad-tree)
</span><span
class="add">+		tree=$(git -C $dir mktree --literally &lt;$dir/bad-tree)
</span> 	&#39;
 
 	test_expect_success &#34;fsck detects symlinked $name ($type)&#34; &#39;
<span
class="hunk">@@ -261,7 +261,7 @@ test_expect_success &#39;fsck detects non-blob .gitmodules&#39; &#39;
</span> 		cp ../.gitmodules subdir/file &#38;&#38;
 		git add subdir/file &#38;&#38;
 		git commit -m ok &#38;&#38;
<span
class="del">-		git ls-tree HEAD | sed s/subdir/.gitmodules/ | git mktree &#38;&#38;
</span><span
class="add">+		git ls-tree HEAD | sed s/subdir/.gitmodules/ | git mktree --literally &#38;&#38;
</span> 
 		test_must_fail git fsck 2&gt;output &#38;&#38;
 		test_grep gitmodulesBlob output
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Victoria Dye via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 08/17] mktree.c: do not fail on mismatched submodule type</title><updated>2024-06-19T21:58:19Z</updated><link
href="http://lore.kernel.org/git/8a3264afd0c072d10ec0571e2038f009733c4de5.1718834285.git.gitgitgadget@gmail.com/"/><id>urn:uuid:f8f06f9a-5b8a-7bc4-e8a5-5e18b420831e</id><thr:in-reply-to
ref="urn:uuid:181c79e4-3522-34dd-5a02-fa233eea3ac0"
href="http://lore.kernel.org/git/pull.1746.v2.git.1718834285.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Victoria Dye &lt;vdye@github.com&gt;

Adjust the &#39;git mktree&#39; tree entry intake logic to no longer fail if an OID
specified with a S_IFGITLINK mode exists in the current repository&#39;s object
database with a different type.

While this scenario likely represents a mistake by the user, submodule OIDs
are not validated as part of object writes or in &#39;git fsck&#39;. In other
commands, any object info would be ignored if such an OID was found in the
current repository with a different type.

Since this check is not needed to avoid creation of a corrupt tree, let&#39;s
remove it and make &#39;git mktree&#39; less opinionated as a result.

Helped-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
---
 builtin/mktree.c  | 58 ++++++++++++++++++++++-------------------------
 t/t1010-mktree.sh | 18 ++++++---------
 2 files <a href="http://lore.kernel.org/git/8a3264afd0c072d10ec0571e2038f009733c4de5.1718834285.git.gitgitgadget@gmail.com/#related">changed</a>, 34 insertions(+), 42 deletions(-)

<span
class="head">diff --git a/builtin/mktree.c b/builtin/mktree.c
index 03a9899bc11..f509ed1a81f 100644
--- a/builtin/mktree.c
+++ b/builtin/mktree.c
</span><span
class="hunk">@@ -107,8 +107,6 @@ static int mktree_line(unsigned int mode, struct object_id *oid,
</span> {
 	struct mktree_line_data *data = cbdata;
 	enum object_type mode_type = object_type(mode);
<span
class="del">-	struct object_info oi = OBJECT_INFO_INIT;
-	enum object_type parsed_obj_type;
</span> 
 	if (stage)
 		die(_(&#34;path &#39;%s&#39; is unmerged&#34;), path);
<span
class="hunk">@@ -117,36 +115,34 @@ static int mktree_line(unsigned int mode, struct object_id *oid,
</span> 		die(&#34;object type (%s) doesn&#39;t match mode type (%s)&#34;,
 		    type_name(obj_type), type_name(mode_type));
 
<span
class="del">-	oi.typep = &#38;parsed_obj_type;
-
-	if (oid_object_info_extended(the_repository, oid, &#38;oi,
-				     OBJECT_INFO_LOOKUP_REPLACE |
</span><span
class="add">+	if (!S_ISGITLINK(mode)) {
+		struct object_info oi = OBJECT_INFO_INIT;
+		enum object_type parsed_obj_type;
+		unsigned int flags = OBJECT_INFO_LOOKUP_REPLACE |
</span> 				     OBJECT_INFO_QUICK |
<span
class="del">-				     OBJECT_INFO_SKIP_FETCH_OBJECT) &lt; 0)
-		parsed_obj_type = -1;
-
-	if (parsed_obj_type &lt; 0) {
-		/*
-		 * There are two conditions where the object being missing
-		 * is acceptable:
-		 *
-		 * - We&#39;re explicitly allowing it with --missing.
-		 * - The object is a submodule, which we wouldn&#39;t expect to
-		 *   be in this repo anyway.
-		 *
-		 * If neither condition is met, die().
-		 */
-		if (!data-&gt;allow_missing &#38;&#38; !S_ISGITLINK(mode))
-			die(&#34;entry &#39;%s&#39; object %s is unavailable&#34;, path, oid_to_hex(oid));
-
-	} else if (parsed_obj_type != mode_type) {
-		/*
-		 * The object exists but is of the wrong type.
-		 * This is a problem regardless of allow_missing
-		 * because the new tree entry will never be correct.
-		 */
-		die(&#34;entry &#39;%s&#39; object %s is a %s but specified type was (%s)&#34;,
-		    path, oid_to_hex(oid), type_name(parsed_obj_type), type_name(mode_type));
</span><span
class="add">+				     OBJECT_INFO_SKIP_FETCH_OBJECT;
+
+		oi.typep = &#38;parsed_obj_type;
+
+		if (oid_object_info_extended(the_repository, oid, &#38;oi, flags) &lt; 0) {
+			/*
+			 * If the object is missing and we aren&#39;t explicitly
+			 * allowing missing objects, die(). Otherwise, continue
+			 * without error.
+			 */
+			if (!data-&gt;allow_missing)
+				die(&#34;entry &#39;%s&#39; object %s is unavailable&#34;, path,
+				    oid_to_hex(oid));
+		} else if (parsed_obj_type != mode_type) {
+			/*
+			 * The object exists but is of the wrong type.
+			 * This is a problem regardless of allow_missing
+			 * because the new tree entry will never be correct.
+			 */
+			die(&#34;entry &#39;%s&#39; object %s is a %s but specified type was (%s)&#34;,
+			    path, oid_to_hex(oid), type_name(parsed_obj_type),
+			    type_name(mode_type));
+		}
</span> 	}
 
 	append_to_tree(mode, oid, path, data-&gt;arr);
<span
class="head">diff --git a/t/t1010-mktree.sh b/t/t1010-mktree.sh
index 649842fa27c..48fc532e7af 100755
--- a/t/t1010-mktree.sh
+++ b/t/t1010-mktree.sh
</span><span
class="hunk">@@ -71,17 +71,13 @@ test_expect_success &#39;allow missing object with --missing&#39; &#39;
</span> &#39;
 
 test_expect_success &#39;mktree with invalid submodule OIDs&#39; &#39;
<span
class="del">-	# non-existent OID - ok
-	printf &#34;160000 commit $(test_oid numeric)\tA\n&#34; &gt;in &#38;&#38;
-	git mktree &lt;in &gt;tree.actual &#38;&#38;
-	git ls-tree $(cat tree.actual) &gt;actual &#38;&#38;
-	test_cmp in actual &#38;&#38;
-
-	# existing OID, wrong type - error
-	tree_oid=&#34;$(cat tree)&#34; &#38;&#38;
-	printf &#34;160000 commit $tree_oid\tA&#34; |
-	test_must_fail git mktree 2&gt;err &#38;&#38;
-	test_grep &#34;object $tree_oid is a tree but specified type was (commit)&#34; err
</span><span
class="add">+	for oid in &#34;$(test_oid numeric)&#34; &#34;$(cat tree)&#34;
+	do
+		printf &#34;160000 commit $oid\tA\n&#34; &gt;in &#38;&#38;
+		git mktree &lt;in &gt;tree.actual &#38;&#38;
+		git ls-tree $(cat tree.actual) &gt;actual &#38;&#38;
+		test_cmp in actual || return 1
+	done
</span> &#39;
 
 test_expect_success &#39;mktree refuses to read ls-tree -r output (1)&#39; &#39;
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Victoria Dye via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 07/17] mktree: use read_index_info to read stdin lines</title><updated>2024-06-19T21:58:19Z</updated><link
href="http://lore.kernel.org/git/9dc8e16a7fca886ec378d74a8e2ac61921a7f6ea.1718834285.git.gitgitgadget@gmail.com/"/><id>urn:uuid:9c15035e-6dcf-3ece-b1ce-5ae058ab6c80</id><thr:in-reply-to
ref="urn:uuid:181c79e4-3522-34dd-5a02-fa233eea3ac0"
href="http://lore.kernel.org/git/pull.1746.v2.git.1718834285.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Victoria Dye &lt;vdye@github.com&gt;

Replace the custom input parsing of &#39;mktree&#39; with &#39;read_index_info()&#39;, which
handles not only the &#39;ls-tree&#39; output format it already handles but also the
other formats compatible with &#39;update-index&#39;. This lends some consistency
across the commands (avoiding the need for two similar implementations for
input parsing) and adds flexibility to mktree.

It should be noted that, while the error messages are largely preserved in
the refactor, one does change: &#34;fatal: invalid quoting&#34; is now &#34;error: bad
quoting of path name&#34;.

Update &#39;Documentation/git-mktree.txt&#39; to reflect the more permissive input
format, as well as make a note about rejecting stage values higher than 0.

Helped-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
---
 Documentation/git-mktree.txt |  26 ++++--
 builtin/mktree.c             | 156 +++++++++++++++--------------------
 t/t1010-mktree.sh            |  66 +++++++++++++++
 3 files <a href="http://lore.kernel.org/git/9dc8e16a7fca886ec378d74a8e2ac61921a7f6ea.1718834285.git.gitgitgadget@gmail.com/#related">changed</a>, 151 insertions(+), 97 deletions(-)

<span
class="head">diff --git a/Documentation/git-mktree.txt b/Documentation/git-mktree.txt
index 383f09dd333..c187403c6bd 100644
--- a/Documentation/git-mktree.txt
+++ b/Documentation/git-mktree.txt
</span><span
class="hunk">@@ -3,7 +3,7 @@ git-mktree(1)
</span> 
 NAME
 ----
<span
class="del">-git-mktree - Build a tree-object from ls-tree formatted text
</span><span
class="add">+git-mktree - Build a tree-object from formatted tree entries
</span> 
 
 SYNOPSIS
<span
class="hunk">@@ -13,15 +13,14 @@ SYNOPSIS
</span> 
 DESCRIPTION
 -----------
<span
class="del">-Reads standard input in non-recursive `ls-tree` output format, and creates
-a tree object.  The order of the tree entries is normalized by mktree so
-pre-sorting the input is not required.  The object name of the tree object
-built is written to the standard output.
</span><span
class="add">+Reads entry information from stdin and creates a tree object from those
+entries. The object name of the tree object built is written to the standard
+output.
</span> 
 OPTIONS
 -------
 -z::
<span
class="del">-	Read the NUL-terminated `ls-tree -z` output instead.
</span><span
class="add">+	Input lines are separated with NUL rather than LF.
</span> 
 --missing::
 	Allow missing objects.  The default behaviour (without this option)
<span
class="hunk">@@ -35,6 +34,21 @@ OPTIONS
</span> 	optional.  Note - if the `-z` option is used, lines are terminated
 	with NUL.
 
<span
class="add">+INPUT FORMAT
+------------
+Tree entries may be specified in any of the formats compatible with the
+`--index-info` option to linkgit:git-update-index[1]:
+
+include::index-info-formats.txt[]
+
+Note that if the `stage` of a tree entry is given, the value must be 0.
+Higher stages represent conflicted files in an index; this information
+cannot be represented in a tree object. The command will fail without
+writing the tree if a higher order stage is specified for any entry.
+
+The order of the tree entries is normalized by `mktree` so pre-sorting the
+input by path is not required.
+
</span> GIT
 ---
 Part of the linkgit:git[1] suite
<span
class="head">diff --git a/builtin/mktree.c b/builtin/mktree.c
index a96ea10bf95..03a9899bc11 100644
--- a/builtin/mktree.c
+++ b/builtin/mktree.c
</span><span
class="hunk">@@ -6,6 +6,7 @@
</span> #include &#34;builtin.h&#34;
 #include &#34;gettext.h&#34;
 #include &#34;hex.h&#34;
<span
class="add">+#include &#34;index-info.h&#34;
</span> #include &#34;quote.h&#34;
 #include &#34;strbuf.h&#34;
 #include &#34;tree.h&#34;
<span
class="hunk">@@ -95,123 +96,96 @@ static const char *mktree_usage[] = {
</span> 	NULL
 };
 
<span
class="del">-static void mktree_line(char *buf, int nul_term_line, int allow_missing,
-			struct tree_entry_array *arr)
</span><span
class="add">+struct mktree_line_data {
+	struct tree_entry_array *arr;
+	int allow_missing;
+};
+
+static int mktree_line(unsigned int mode, struct object_id *oid,
+		       enum object_type obj_type, int stage,
+		       const char *path, void *cbdata)
</span> {
<span
class="del">-	char *ptr, *ntr;
-	const char *p;
-	unsigned mode;
-	enum object_type mode_type; /* object type derived from mode */
-	enum object_type obj_type; /* object type derived from sha */
</span><span
class="add">+	struct mktree_line_data *data = cbdata;
+	enum object_type mode_type = object_type(mode);
</span> 	struct object_info oi = OBJECT_INFO_INIT;
<span
class="del">-	char *path, *to_free = NULL;
-	struct object_id oid;
</span><span
class="add">+	enum object_type parsed_obj_type;
</span> 
<span
class="del">-	ptr = buf;
-	/*
-	 * Read non-recursive ls-tree output format:
-	 *     mode SP type SP sha1 TAB name
-	 */
-	mode = strtoul(ptr, &#38;ntr, 8);
-	if (ptr == ntr || !ntr || *ntr != &#39; &#39;)
-		die(&#34;input format error: %s&#34;, buf);
-	ptr = ntr + 1; /* type */
-	ntr = strchr(ptr, &#39; &#39;);
-	if (!ntr || parse_oid_hex(ntr + 1, &#38;oid, &#38;p) ||
-	    *p != &#39;\t&#39;)
-		die(&#34;input format error: %s&#34;, buf);
-
-	/* It is perfectly normal if we do not have a commit from a submodule */
-	if (S_ISGITLINK(mode))
-		allow_missing = 1;
-
-
-	*ntr++ = 0; /* now at the beginning of SHA1 */
-
-	path = (char *)p + 1;  /* at the beginning of name */
-	if (!nul_term_line &#38;&#38; path[0] == &#39;&#34;&#39;) {
-		struct strbuf p_uq = STRBUF_INIT;
-		if (unquote_c_style(&#38;p_uq, path, NULL))
-			die(&#34;invalid quoting&#34;);
-		path = to_free = strbuf_detach(&#38;p_uq, NULL);
-	}
</span><span
class="add">+	if (stage)
+		die(_(&#34;path &#39;%s&#39; is unmerged&#34;), path);
</span> 
<span
class="del">-	/*
-	 * Object type is redundantly derivable three ways.
-	 * These should all agree.
-	 */
-	mode_type = object_type(mode);
-	if (mode_type != type_from_string(ptr)) {
-		die(&#34;entry &#39;%s&#39; object type (%s) doesn&#39;t match mode type (%s)&#34;,
-			path, ptr, type_name(mode_type));
-	}
</span><span
class="add">+	if (obj_type != OBJ_ANY &#38;&#38; mode_type != obj_type)
+		die(&#34;object type (%s) doesn&#39;t match mode type (%s)&#34;,
+		    type_name(obj_type), type_name(mode_type));
+
+	oi.typep = &#38;parsed_obj_type;
</span> 
<span
class="del">-	/* Check the type of object identified by oid without fetching objects */
-	oi.typep = &#38;obj_type;
-	if (oid_object_info_extended(the_repository, &#38;oid, &#38;oi,
</span><span
class="add">+	if (oid_object_info_extended(the_repository, oid, &#38;oi,
</span> 				     OBJECT_INFO_LOOKUP_REPLACE |
 				     OBJECT_INFO_QUICK |
 				     OBJECT_INFO_SKIP_FETCH_OBJECT) &lt; 0)
<span
class="del">-		obj_type = -1;
-
-	if (obj_type &lt; 0) {
-		if (allow_missing) {
-			; /* no problem - missing objects are presumed to be of the right type */
-		} else {
-			die(&#34;entry &#39;%s&#39; object %s is unavailable&#34;, path, oid_to_hex(&#38;oid));
-		}
-	} else {
-		if (obj_type != mode_type) {
-			/*
-			 * The object exists but is of the wrong type.
-			 * This is a problem regardless of allow_missing
-			 * because the new tree entry will never be correct.
-			 */
-			die(&#34;entry &#39;%s&#39; object %s is a %s but specified type was (%s)&#34;,
-				path, oid_to_hex(&#38;oid), type_name(obj_type), type_name(mode_type));
-		}
</span><span
class="add">+		parsed_obj_type = -1;
+
+	if (parsed_obj_type &lt; 0) {
+		/*
+		 * There are two conditions where the object being missing
+		 * is acceptable:
+		 *
+		 * - We&#39;re explicitly allowing it with --missing.
+		 * - The object is a submodule, which we wouldn&#39;t expect to
+		 *   be in this repo anyway.
+		 *
+		 * If neither condition is met, die().
+		 */
+		if (!data-&gt;allow_missing &#38;&#38; !S_ISGITLINK(mode))
+			die(&#34;entry &#39;%s&#39; object %s is unavailable&#34;, path, oid_to_hex(oid));
+
+	} else if (parsed_obj_type != mode_type) {
+		/*
+		 * The object exists but is of the wrong type.
+		 * This is a problem regardless of allow_missing
+		 * because the new tree entry will never be correct.
+		 */
+		die(&#34;entry &#39;%s&#39; object %s is a %s but specified type was (%s)&#34;,
+		    path, oid_to_hex(oid), type_name(parsed_obj_type), type_name(mode_type));
</span> 	}
 
<span
class="del">-	append_to_tree(mode, &#38;oid, path, arr);
-	free(to_free);
</span><span
class="add">+	append_to_tree(mode, oid, path, data-&gt;arr);
+	return 0;
</span> }
 
 int cmd_mktree(int ac, const char **av, const char *prefix)
 {
<span
class="del">-	struct strbuf sb = STRBUF_INIT;
</span> 	struct object_id oid;
 	int nul_term_line = 0;
<span
class="del">-	int allow_missing = 0;
</span> 	int is_batch_mode = 0;
<span
class="del">-	int got_eof = 0;
</span> 	struct tree_entry_array arr = { 0 };
<span
class="del">-	strbuf_getline_fn getline_fn;
</span><span
class="add">+	struct mktree_line_data mktree_line_data = { .arr = &#38;arr };
+	struct strbuf line = STRBUF_INIT;
+	int ret;
</span> 
 	const struct option option[] = {
 		OPT_BOOL(&#39;z&#39;, NULL, &#38;nul_term_line, N_(&#34;input is NUL terminated&#34;)),
<span
class="del">-		OPT_BOOL(0, &#34;missing&#34;, &#38;allow_missing, N_(&#34;allow missing objects&#34;)),
</span><span
class="add">+		OPT_BOOL(0, &#34;missing&#34;, &#38;mktree_line_data.allow_missing, N_(&#34;allow missing objects&#34;)),
</span> 		OPT_BOOL(0, &#34;batch&#34;, &#38;is_batch_mode, N_(&#34;allow creation of more than one tree&#34;)),
 		OPT_END()
 	};
 
 	ac = parse_options(ac, av, prefix, option, mktree_usage, 0);
<span
class="del">-	getline_fn = nul_term_line ? strbuf_getline_nul : strbuf_getline_lf;
-
-	while (!got_eof) {
-		while (1) {
-			if (getline_fn(&#38;sb, stdin) == EOF) {
-				got_eof = 1;
-				break;
-			}
-			if (sb.buf[0] == &#39;\0&#39;) {
</span><span
class="add">+
+	do {
+		ret = read_index_info(nul_term_line, mktree_line, &#38;mktree_line_data, &#38;line);
+		if (ret &lt; 0)
+			break;
+
+		if (ret == INDEX_INFO_UNRECOGNIZED_LINE) {
+			if (line.len)
+				die(&#34;input format error: %s&#34;, line.buf);
+			else if (!is_batch_mode)
</span> 				/* empty lines denote tree boundaries in batch mode */
<span
class="del">-				if (is_batch_mode)
-					break;
</span> 				die(&#34;input format error: (blank line only valid in batch mode)&#34;);
<span
class="del">-			}
-			mktree_line(sb.buf, nul_term_line, allow_missing, &#38;arr);
</span> 		}
<span
class="del">-		if (is_batch_mode &#38;&#38; got_eof &#38;&#38; arr.nr &lt; 1) {
</span><span
class="add">+
+		if (is_batch_mode &#38;&#38; !ret &#38;&#38; arr.nr &lt; 1) {
</span> 			/*
 			 * Execution gets here if the last tree entry is terminated with a
 			 * new-line.  The final new-line has been made optional to be
<span
class="hunk">@@ -224,9 +198,9 @@ int cmd_mktree(int ac, const char **av, const char *prefix)
</span> 			fflush(stdout);
 		}
 		tree_entry_array_clear(&#38;arr, 1); /* reset tree entry buffer for re-use in batch mode */
<span
class="del">-	}
</span><span
class="add">+	} while (ret &gt; 0);
</span> 
<span
class="add">+	strbuf_release(&#38;line);
</span> 	tree_entry_array_release(&#38;arr, 1);
<span
class="del">-	strbuf_release(&#38;sb);
-	return 0;
</span><span
class="add">+	return !!ret;
</span> }
<span
class="head">diff --git a/t/t1010-mktree.sh b/t/t1010-mktree.sh
index 22875ba598c..649842fa27c 100755
--- a/t/t1010-mktree.sh
+++ b/t/t1010-mktree.sh
</span><span
class="hunk">@@ -54,11 +54,36 @@ test_expect_success &#39;ls-tree output in wrong order given to mktree (2)&#39; &#39;
</span> 	test_cmp tree.withsub actual
 &#39;
 
<span
class="add">+test_expect_success &#39;--batch creates multiple trees&#39; &#39;
+	cat top &gt;multi-tree &#38;&#38;
+	echo &#34;&#34; &gt;&gt;multi-tree &#38;&#38;
+	cat top.withsub &gt;&gt;multi-tree &#38;&#38;
+
+	cat tree &gt;expect &#38;&#38;
+	cat tree.withsub &gt;&gt;expect &#38;&#38;
+	git mktree --batch &lt;multi-tree &gt;actual &#38;&#38;
+	test_cmp expect actual
+&#39;
+
</span> test_expect_success &#39;allow missing object with --missing&#39; &#39;
 	git mktree --missing &lt;top.missing &gt;actual &#38;&#38;
 	test_cmp tree.missing actual
 &#39;
 
<span
class="add">+test_expect_success &#39;mktree with invalid submodule OIDs&#39; &#39;
+	# non-existent OID - ok
+	printf &#34;160000 commit $(test_oid numeric)\tA\n&#34; &gt;in &#38;&#38;
+	git mktree &lt;in &gt;tree.actual &#38;&#38;
+	git ls-tree $(cat tree.actual) &gt;actual &#38;&#38;
+	test_cmp in actual &#38;&#38;
+
+	# existing OID, wrong type - error
+	tree_oid=&#34;$(cat tree)&#34; &#38;&#38;
+	printf &#34;160000 commit $tree_oid\tA&#34; |
+	test_must_fail git mktree 2&gt;err &#38;&#38;
+	test_grep &#34;object $tree_oid is a tree but specified type was (commit)&#34; err
+&#39;
+
</span> test_expect_success &#39;mktree refuses to read ls-tree -r output (1)&#39; &#39;
 	test_must_fail git mktree &lt;all
 &#39;
<span
class="hunk">@@ -67,4 +92,45 @@ test_expect_success &#39;mktree refuses to read ls-tree -r output (2)&#39; &#39;
</span> 	test_must_fail git mktree &lt;all.withsub
 &#39;
 
<span
class="add">+test_expect_success &#39;mktree fails on malformed input&#39; &#39;
+	# empty line without --batch
+	echo &#34;&#34; |
+	test_must_fail git mktree 2&gt;err &#38;&#38;
+	test_grep &#34;blank line only valid in batch mode&#34; err &#38;&#38;
+
+	# bad whitespace
+	printf &#34;100644 blob $EMPTY_BLOB A&#34; |
+	test_must_fail git mktree 2&gt;err &#38;&#38;
+	test_grep &#34;input format error&#34; err &#38;&#38;
+
+	# invalid type
+	printf &#34;100644 bad $EMPTY_BLOB\tA&#34; |
+	test_must_fail git mktree 2&gt;err &#38;&#38;
+	test_grep &#34;invalid object type&#34; err &#38;&#38;
+
+	# invalid OID length
+	printf &#34;100755 blob abc123\tA&#34; |
+	test_must_fail git mktree 2&gt;err &#38;&#38;
+	test_grep &#34;input format error&#34; err &#38;&#38;
+
+	# bad quoting
+	printf &#34;100644 blob $EMPTY_BLOB\t\&#34;A&#34; |
+	test_must_fail git mktree 2&gt;err &#38;&#38;
+	test_grep &#34;bad quoting of path name&#34; err
+&#39;
+
+test_expect_success &#39;mktree fails on mode mismatch&#39; &#39;
+	tree_oid=&#34;$(cat tree)&#34; &#38;&#38;
+
+	# mode-type mismatch
+	printf &#34;100644 tree $tree_oid\tA&#34; |
+	test_must_fail git mktree 2&gt;err &#38;&#38;
+	test_grep &#34;object type (tree) doesn${SQ}t match mode type (blob)&#34; err &#38;&#38;
+
+	# mode-object mismatch (no --missing)
+	printf &#34;100644 $tree_oid\tA&#34; |
+	test_must_fail git mktree 2&gt;err &#38;&#38;
+	test_grep &#34;object $tree_oid is a tree but specified type was (blob)&#34; err
+&#39;
+
</span> test_done
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Victoria Dye via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 05/17] index-info.c: return unrecognized lines to caller</title><updated>2024-06-19T21:58:17Z</updated><link
href="http://lore.kernel.org/git/4f4d54c8d075a43960af36ccb025b2ddb34266f8.1718834285.git.gitgitgadget@gmail.com/"/><id>urn:uuid:0136632e-a650-155a-5385-104a89cbb84a</id><thr:in-reply-to
ref="urn:uuid:181c79e4-3522-34dd-5a02-fa233eea3ac0"
href="http://lore.kernel.org/git/pull.1746.v2.git.1718834285.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Victoria Dye &lt;vdye@github.com&gt;

Update &#39;read_index_info()&#39; to return INDEX_INFO_UNRECOGNIZED_LINE (value 1),
rather than die()-ing when the function encounters a line that cannot be
parsed according to one of the accepted formats. This grants the caller the
flexibility to fall back on custom handling for such lines rather than a
returning a catch-all error. In the case of &#39;update-index&#39;, we&#39;ll still exit
with a &#34;malformed input line&#34; error. However, when &#39;read_index_info()&#39; is
used to process the input to &#39;mktree&#39; in a later patch, an empty line return
value will signal a new tree in --batch mode.

Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
---
 builtin/update-index.c |  9 +++++++--
 index-info.c           | 16 +++++++++-------
 index-info.h           |  5 ++++-
 3 files <a href="http://lore.kernel.org/git/4f4d54c8d075a43960af36ccb025b2ddb34266f8.1718834285.git.gitgitgadget@gmail.com/#related">changed</a>, 20 insertions(+), 10 deletions(-)

<span
class="head">diff --git a/builtin/update-index.c b/builtin/update-index.c
index fddf59b54c1..8d0b40a6fd6 100644
--- a/builtin/update-index.c
+++ b/builtin/update-index.c
</span><span
class="hunk">@@ -787,11 +787,16 @@ static enum parse_opt_result stdin_cacheinfo_callback(
</span> 		ret = error(&#34;option &#39;%s&#39; must be the last argument&#34;, opt-&gt;long_name);
 	} else {
 		int *nul_term_line = opt-&gt;value;
<span
class="add">+		struct strbuf line = STRBUF_INIT;
</span> 
 		allow_add = allow_replace = allow_remove = 1;
<span
class="del">-		ret = read_index_info(*nul_term_line, apply_index_info, NULL);
-		if (ret)
</span><span
class="add">+		ret = read_index_info(*nul_term_line, apply_index_info, NULL, &#38;line);
+
+		if (ret == INDEX_INFO_UNRECOGNIZED_LINE)
+			ret = error(&#34;malformed input line &#39;%s&#39;&#34;, line.buf);
+		else if (ret)
</span> 			ret = -1;
<span
class="add">+		strbuf_release(&#38;line);
</span> 	}
 
 	return ret;
<span
class="head">diff --git a/index-info.c b/index-info.c
index 8ccaac5487b..7a02f66426a 100644
--- a/index-info.c
+++ b/index-info.c
</span><span
class="hunk">@@ -5,16 +5,16 @@
</span> #include &#34;strbuf.h&#34;
 #include &#34;quote.h&#34;
 
<span
class="del">-int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata)
</span><span
class="add">+int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata,
+		    struct strbuf *line)
</span> {
 	const int hexsz = the_hash_algo-&gt;hexsz;
<span
class="del">-	struct strbuf buf = STRBUF_INIT;
</span> 	struct strbuf uq = STRBUF_INIT;
 	strbuf_getline_fn getline_fn;
 	int ret = 0;
 
 	getline_fn = nul_term_line ? strbuf_getline_nul : strbuf_getline_lf;
<span
class="del">-	while (getline_fn(&#38;buf, stdin) != EOF) {
</span><span
class="add">+	while (getline_fn(line, stdin) != EOF) {
</span> 		char *ptr, *tab;
 		char *path_name;
 		struct object_id oid;
<span
class="hunk">@@ -39,8 +39,8 @@ int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata)
</span> 		 * index file and matches &#34;git ls-files --stage&#34; output.
 		 */
 		errno = 0;
<span
class="del">-		ul = strtoul(buf.buf, &#38;ptr, 8);
-		if (ptr == buf.buf || *ptr != &#39; &#39;
</span><span
class="add">+		ul = strtoul(line-&gt;buf, &#38;ptr, 8);
+		if (ptr == line-&gt;buf || *ptr != &#39; &#39;
</span> 		    || errno || (unsigned int) ul != ul)
 			goto bad_line;
 		mode = ul;
<span
class="hunk">@@ -81,10 +81,12 @@ int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata)
</span> 		continue;
 
 	bad_line:
<span
class="del">-		die(&#34;malformed input line &#39;%s&#39;&#34;, buf.buf);
</span><span
class="add">+		ret = INDEX_INFO_UNRECOGNIZED_LINE;
+		break;
</span> 	}
<span
class="del">-	strbuf_release(&#38;buf);
</span> 	strbuf_release(&#38;uq);
<span
class="add">+	if (!ret)
+		strbuf_reset(line);
</span> 
 	return ret;
 }
<span
class="head">diff --git a/index-info.h b/index-info.h
index d650498325a..9258011462d 100644
--- a/index-info.h
+++ b/index-info.h
</span><span
class="hunk">@@ -5,7 +5,10 @@
</span> 
 typedef int (*each_index_info_fn)(unsigned int, struct object_id *, int, const char *, void *);
 
<span
class="add">+#define INDEX_INFO_UNRECOGNIZED_LINE 1
+
</span> /* Iterate over parsed index info from stdin */
<span
class="del">-int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata);
</span><span
class="add">+int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata,
+		    struct strbuf *line);
</span> 
 #endif /* INDEX_INFO_H */
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Victoria Dye via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 06/17] index-info.c: parse object type in provided in read_index_info</title><updated>2024-06-19T21:58:17Z</updated><link
href="http://lore.kernel.org/git/472efcaf1dde3dd590f34bde63c5ce6dcf72a531.1718834285.git.gitgitgadget@gmail.com/"/><id>urn:uuid:e1d7d988-c2de-d032-ef87-9876e2d44b28</id><thr:in-reply-to
ref="urn:uuid:181c79e4-3522-34dd-5a02-fa233eea3ac0"
href="http://lore.kernel.org/git/pull.1746.v2.git.1718834285.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Victoria Dye &lt;vdye@github.com&gt;

If the object type (e.g. &#34;blob&#34;, &#34;tree&#34;) is identified on a stdin line read
by &#39;read_index_info()&#39; (i.e. on lines formatted like the output of &#39;git
ls-tree&#39;), parse it into an &#39;enum object_type&#39; and provide it to the
&#39;read_index_info()&#39; callback as an argument. If the type is not provided,
pass &#39;OBJ_ANY&#39; instead. If the object type is invalid, return an error.

The goal of this change is to allow for more thorough validation of the
provided object type (e.g. against the provided mode) in &#39;mktree&#39; once
&#39;mktree_line&#39; is replaced with &#39;read_index_info()&#39;. Note, though, that this
change also strengthens the validation done by &#39;update-index&#39;, since invalid
type names now trigger an error.

Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
---
 builtin/update-index.c        |  3 ++-
 index-info.c                  | 16 ++++++++++++----
 index-info.h                  |  3 ++-
 t/t2107-update-index-basic.sh |  5 +++++
 4 files <a href="http://lore.kernel.org/git/472efcaf1dde3dd590f34bde63c5ce6dcf72a531.1718834285.git.gitgitgadget@gmail.com/#related">changed</a>, 21 insertions(+), 6 deletions(-)

<span
class="head">diff --git a/builtin/update-index.c b/builtin/update-index.c
index 8d0b40a6fd6..42a274f9ce4 100644
--- a/builtin/update-index.c
+++ b/builtin/update-index.c
</span><span
class="hunk">@@ -510,7 +510,8 @@ static void update_one(const char *path)
</span> 	report(&#34;add &#39;%s&#39;&#34;, path);
 }
 
<span
class="del">-static int apply_index_info(unsigned int mode, struct object_id *oid, int stage,
</span><span
class="add">+static int apply_index_info(unsigned int mode, struct object_id *oid,
+			    enum object_type obj_type UNUSED, int stage,
</span> 			    const char *path_name, void *cbdata UNUSED)
 {
 	if (!verify_path(path_name, mode)) {
<span
class="head">diff --git a/index-info.c b/index-info.c
index 7a02f66426a..9c986cd9093 100644
--- a/index-info.c
+++ b/index-info.c
</span><span
class="hunk">@@ -18,6 +18,7 @@ int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata,
</span> 		char *ptr, *tab;
 		char *path_name;
 		struct object_id oid;
<span
class="add">+		enum object_type obj_type = OBJ_ANY;
</span> 		unsigned int mode;
 		unsigned long ul;
 		int stage;
<span
class="hunk">@@ -51,18 +52,17 @@ int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata,
</span> 
 		if (tab[-2] == &#39; &#39; &#38;&#38; &#39;0&#39; &lt;= tab[-1] &#38;&#38; tab[-1] &lt;= &#39;3&#39;) {
 			stage = tab[-1] - &#39;0&#39;;
<span
class="del">-			ptr = tab + 1; /* point at the head of path */
</span><span
class="add">+			path_name = tab + 1; /* point at the head of path */
</span> 			tab = tab - 2; /* point at tail of sha1 */
 		} else {
 			stage = 0;
<span
class="del">-			ptr = tab + 1; /* point at the head of path */
</span><span
class="add">+			path_name = tab + 1; /* point at the head of path */
</span> 		}
 
 		if (get_oid_hex(tab - hexsz, &#38;oid) ||
 			tab[-(hexsz + 1)] != &#39; &#39;)
 			goto bad_line;
 
<span
class="del">-		path_name = ptr;
</span> 		if (!nul_term_line &#38;&#38; path_name[0] == &#39;&#34;&#39;) {
 			strbuf_reset(&#38;uq);
 			if (unquote_c_style(&#38;uq, path_name, NULL)) {
<span
class="hunk">@@ -72,7 +72,15 @@ int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata,
</span> 			path_name = uq.buf;
 		}
 
<span
class="del">-		ret = fn(mode, &#38;oid, stage, path_name, cbdata);
</span><span
class="add">+		/* Get the type, if provided */
+		if (tab - hexsz - 1 &gt; ptr + 1) {
+			if (*(tab - hexsz - 1) != &#39; &#39;)
+				goto bad_line;
+			*(tab - hexsz - 1) = &#39;\0&#39;;
+			obj_type = type_from_string(ptr + 1);
+		}
+
+		ret = fn(mode, &#38;oid, obj_type, stage, path_name, cbdata);
</span> 		if (ret) {
 			ret = -1;
 			break;
<span
class="head">diff --git a/index-info.h b/index-info.h
index 9258011462d..adea453b197 100644
--- a/index-info.h
+++ b/index-info.h
</span><span
class="hunk">@@ -2,8 +2,9 @@
</span> #define INDEX_INFO_H
 
 #include &#34;hash.h&#34;
<span
class="add">+#include &#34;object.h&#34;
</span> 
<span
class="del">-typedef int (*each_index_info_fn)(unsigned int, struct object_id *, int, const char *, void *);
</span><span
class="add">+typedef int (*each_index_info_fn)(unsigned int, struct object_id *, enum object_type, int, const char *, void *);
</span> 
 #define INDEX_INFO_UNRECOGNIZED_LINE 1
 
<span
class="head">diff --git a/t/t2107-update-index-basic.sh b/t/t2107-update-index-basic.sh
index 794a5b1a184..9e0e77bbf9e 100755
--- a/t/t2107-update-index-basic.sh
+++ b/t/t2107-update-index-basic.sh
</span><span
class="hunk">@@ -153,6 +153,11 @@ test_expect_success &#39;--index-info fails on malformed input&#39; &#39;
</span> 	test_must_fail git update-index --index-info 2&gt;err &#38;&#38;
 	test_grep &#34;malformed input line&#34; err &#38;&#38;
 
<span
class="add">+	# invalid type
+	printf &#34;100644 bad $EMPTY_BLOB\tA&#34; |
+	test_must_fail git update-index --index-info 2&gt;err &#38;&#38;
+	test_grep &#34;invalid object type&#34; err &#38;&#38;
+
</span> 	# invalid stage value
 	printf &#34;100644 $EMPTY_BLOB 5\tA&#34; |
 	test_must_fail git update-index --index-info 2&gt;err &#38;&#38;
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Victoria Dye via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title
type="html">[PATCH v2 04/17] update-index: generalize &#39;read_index_info&#39;</title><updated>2024-06-19T21:58:15Z</updated><link
href="http://lore.kernel.org/git/f5473764236be36c6e23714ce99c533ba83ac18e.1718834285.git.gitgitgadget@gmail.com/"/><id>urn:uuid:5473f2f5-3710-a17e-d296-5c412ce9270c</id><thr:in-reply-to
ref="urn:uuid:181c79e4-3522-34dd-5a02-fa233eea3ac0"
href="http://lore.kernel.org/git/pull.1746.v2.git.1718834285.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Victoria Dye &lt;vdye@github.com&gt;

Move &#39;read_index_info()&#39; into a new header &#39;index-info.h&#39; and generalize the
function to call a provided callback for each parsed line. Update
&#39;update-index.c&#39; to use this generalized &#39;read_index_info()&#39;, adding the
callback &#39;apply_index_info()&#39; to verify the parsed line and update the index
according to its contents.

Switching to using a callback to validate the parsed entry in &#39;update-index&#39;
results in a slight change to the error message indicating a file could not
be removed from the index. The original implementation uses the raw, quoted
pathname in the error message, whereas the callback (without access to the
raw pathname) uses the unquoted value. However, this change makes the failed
removal message consistent with all other error messages in the function,
and that consistency is likely more beneficial than not to a user.

The motivation for this change is to consolidate the already-similar input
parsing logic in &#39;git update-index&#39; and &#39;git mktree&#39;, avoiding code
duplication and the associated maintenance burden. The input formats
accepted by &#39;update-index&#39; are a superset of those accepted by &#39;mktree&#39;, so
in a later commit we can replace the input parsing of the latter with
&#39;read_index_info()&#39; without breaking existing usage.

Co-authored-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
---
 Documentation/git-update-index.txt   |  16 +---
 Documentation/index-info-formats.txt |  13 +++
 Makefile                             |   1 +
 builtin/update-index.c               | 129 +++++++--------------------
 index-info.c                         |  90 +++++++++++++++++++
 index-info.h                         |  11 +++
 t/t2107-update-index-basic.sh        |  27 ++++++
 7 files <a href="http://lore.kernel.org/git/f5473764236be36c6e23714ce99c533ba83ac18e.1718834285.git.gitgitgadget@gmail.com/#related">changed</a>, 177 insertions(+), 110 deletions(-)
 create mode 100644 Documentation/index-info-formats.txt
 create mode 100644 index-info.c
 create mode 100644 index-info.h

<span
class="head">diff --git a/Documentation/git-update-index.txt b/Documentation/git-update-index.txt
index 7128aed5405..e52aecb845d 100644
--- a/Documentation/git-update-index.txt
+++ b/Documentation/git-update-index.txt
</span><span
class="hunk">@@ -278,21 +278,9 @@ USING --INDEX-INFO
</span> 
 `--index-info` is a more powerful mechanism that lets you feed
 multiple entry definitions from the standard input, and designed
<span
class="del">-specifically for scripts.  It can take inputs of three formats:
</span><span
class="add">+specifically for scripts.  It can take inputs in the following formats:
</span> 
<span
class="del">-    . mode SP type SP sha1          TAB path
-+
-This format is to stuff `git ls-tree` output into the index.
-
-    . mode         SP sha1 SP stage TAB path
-+
-This format is to put higher order stages into the
-index file and matches &#39;git ls-files --stage&#39; output.
-
-    . mode         SP sha1          TAB path
-+
-This format is no longer produced by any Git command, but is
-and will continue to be supported by `update-index --index-info`.
</span><span
class="add">+include::index-info-formats.txt[]
</span> 
 To place a higher stage entry to the index, the path should
 first be removed by feeding a mode=0 entry for the path, and
<span
class="head">diff --git a/Documentation/index-info-formats.txt b/Documentation/index-info-formats.txt
new file mode 100644
index 00000000000..037ebd24321
--- /dev/null
+++ b/Documentation/index-info-formats.txt
</span><span
class="hunk">@@ -0,0 +1,13 @@
</span><span
class="add">+    . mode SP type SP sha1          TAB path
++
+This format is to use `git ls-tree` output.
+
+    . mode         SP sha1 SP stage TAB path
++
+This format allows higher order stages to appear and
+matches &#39;git ls-files --stage&#39; output.
+
+    . mode         SP sha1          TAB path
++
+This format is no longer produced by any Git command, but is
+and will continue to be supported.
</span><span
class="head">diff --git a/Makefile b/Makefile
index 2f5f16847ae..db9604e59c3 100644
--- a/Makefile
+++ b/Makefile
</span><span
class="hunk">@@ -1037,6 +1037,7 @@ LIB_OBJS += hex.o
</span> LIB_OBJS += hex-ll.o
 LIB_OBJS += hook.o
 LIB_OBJS += ident.o
<span
class="add">+LIB_OBJS += index-info.o
</span> LIB_OBJS += json-writer.o
 LIB_OBJS += kwset.o
 LIB_OBJS += levenshtein.o
<span
class="head">diff --git a/builtin/update-index.c b/builtin/update-index.c
index d343416ae26..fddf59b54c1 100644
--- a/builtin/update-index.c
+++ b/builtin/update-index.c
</span><span
class="hunk">@@ -11,6 +11,7 @@
</span> #include &#34;gettext.h&#34;
 #include &#34;hash.h&#34;
 #include &#34;hex.h&#34;
<span
class="add">+#include &#34;index-info.h&#34;
</span> #include &#34;lockfile.h&#34;
 #include &#34;quote.h&#34;
 #include &#34;cache-tree.h&#34;
<span
class="hunk">@@ -509,100 +510,29 @@ static void update_one(const char *path)
</span> 	report(&#34;add &#39;%s&#39;&#34;, path);
 }
 
<span
class="del">-static void read_index_info(int nul_term_line)
</span><span
class="add">+static int apply_index_info(unsigned int mode, struct object_id *oid, int stage,
+			    const char *path_name, void *cbdata UNUSED)
</span> {
<span
class="del">-	const int hexsz = the_hash_algo-&gt;hexsz;
-	struct strbuf buf = STRBUF_INIT;
-	struct strbuf uq = STRBUF_INIT;
-	strbuf_getline_fn getline_fn;
</span><span
class="add">+	if (!verify_path(path_name, mode)) {
+		fprintf(stderr, &#34;Ignoring path %s\n&#34;, path_name);
+		return 0;
+	}
</span> 
<span
class="del">-	getline_fn = nul_term_line ? strbuf_getline_nul : strbuf_getline_lf;
-	while (getline_fn(&#38;buf, stdin) != EOF) {
-		char *ptr, *tab;
-		char *path_name;
-		struct object_id oid;
-		unsigned int mode;
-		unsigned long ul;
-		int stage;
-
-		/* This reads lines formatted in one of three formats:
-		 *
-		 * (1) mode         SP sha1          TAB path
-		 * The first format is what &#34;git apply --index-info&#34;
-		 * reports, and used to reconstruct a partial tree
-		 * that is used for phony merge base tree when falling
-		 * back on 3-way merge.
-		 *
-		 * (2) mode SP type SP sha1          TAB path
-		 * The second format is to stuff &#34;git ls-tree&#34; output
-		 * into the index file.
-		 *
-		 * (3) mode         SP sha1 SP stage TAB path
-		 * This format is to put higher order stages into the
-		 * index file and matches &#34;git ls-files --stage&#34; output.
</span><span
class="add">+	if (!mode) {
+		/* mode == 0 means there is no such path -- remove */
+		if (remove_file_from_index(the_repository-&gt;index, path_name))
+			die(&#34;git update-index: unable to remove %s&#34;, path_name);
+	}
+	else {
+		/* mode &#39; &#39; sha1 &#39;\t&#39; name
+		 * ptr[-1] points at tab,
+		 * ptr[-41] is at the beginning of sha1
</span> 		 */
<span
class="del">-		errno = 0;
-		ul = strtoul(buf.buf, &#38;ptr, 8);
-		if (ptr == buf.buf || *ptr != &#39; &#39;
-		    || errno || (unsigned int) ul != ul)
-			goto bad_line;
-		mode = ul;
-
-		tab = strchr(ptr, &#39;\t&#39;);
-		if (!tab || tab - ptr &lt; hexsz + 1)
-			goto bad_line;
-
-		if (tab[-2] == &#39; &#39; &#38;&#38; &#39;0&#39; &lt;= tab[-1] &#38;&#38; tab[-1] &lt;= &#39;3&#39;) {
-			stage = tab[-1] - &#39;0&#39;;
-			ptr = tab + 1; /* point at the head of path */
-			tab = tab - 2; /* point at tail of sha1 */
-		}
-		else {
-			stage = 0;
-			ptr = tab + 1; /* point at the head of path */
-		}
-
-		if (get_oid_hex(tab - hexsz, &#38;oid) ||
-			tab[-(hexsz + 1)] != &#39; &#39;)
-			goto bad_line;
-
-		path_name = ptr;
-		if (!nul_term_line &#38;&#38; path_name[0] == &#39;&#34;&#39;) {
-			strbuf_reset(&#38;uq);
-			if (unquote_c_style(&#38;uq, path_name, NULL)) {
-				die(&#34;git update-index: bad quoting of path name&#34;);
-			}
-			path_name = uq.buf;
-		}
-
-		if (!verify_path(path_name, mode)) {
-			fprintf(stderr, &#34;Ignoring path %s\n&#34;, path_name);
-			continue;
-		}
-
-		if (!mode) {
-			/* mode == 0 means there is no such path -- remove */
-			if (remove_file_from_index(the_repository-&gt;index, path_name))
-				die(&#34;git update-index: unable to remove %s&#34;,
-				    ptr);
-		}
-		else {
-			/* mode &#39; &#39; sha1 &#39;\t&#39; name
-			 * ptr[-1] points at tab,
-			 * ptr[-41] is at the beginning of sha1
-			 */
-			ptr[-(hexsz + 2)] = ptr[-1] = 0;
-			if (add_cacheinfo(mode, &#38;oid, path_name, stage))
-				die(&#34;git update-index: unable to update %s&#34;,
-				    path_name);
-		}
-		continue;
-
-	bad_line:
-		die(&#34;malformed index info %s&#34;, buf.buf);
</span><span
class="add">+		if (add_cacheinfo(mode, oid, path_name, stage))
+			die(&#34;git update-index: unable to update %s&#34;, path_name);
</span> 	}
<span
class="del">-	strbuf_release(&#38;buf);
-	strbuf_release(&#38;uq);
</span><span
class="add">+
+	return 0;
</span> }
 
 static const char * const update_index_usage[] = {
<span
class="hunk">@@ -848,16 +778,23 @@ static enum parse_opt_result stdin_cacheinfo_callback(
</span> 	struct parse_opt_ctx_t *ctx, const struct option *opt,
 	const char *arg, int unset)
 {
<span
class="del">-	int *nul_term_line = opt-&gt;value;
</span><span
class="add">+	int ret = 0;
</span> 
 	BUG_ON_OPT_NEG(unset);
 	BUG_ON_OPT_ARG(arg);
 
<span
class="del">-	if (ctx-&gt;argc != 1)
-		return error(&#34;option &#39;%s&#39; must be the last argument&#34;, opt-&gt;long_name);
-	allow_add = allow_replace = allow_remove = 1;
-	read_index_info(*nul_term_line);
-	return 0;
</span><span
class="add">+	if (ctx-&gt;argc != 1) {
+		ret = error(&#34;option &#39;%s&#39; must be the last argument&#34;, opt-&gt;long_name);
+	} else {
+		int *nul_term_line = opt-&gt;value;
+
+		allow_add = allow_replace = allow_remove = 1;
+		ret = read_index_info(*nul_term_line, apply_index_info, NULL);
+		if (ret)
+			ret = -1;
+	}
+
+	return ret;
</span> }
 
 static enum parse_opt_result stdin_callback(
<span
class="head">diff --git a/index-info.c b/index-info.c
new file mode 100644
index 00000000000..8ccaac5487b
--- /dev/null
+++ b/index-info.c
</span><span
class="hunk">@@ -0,0 +1,90 @@
</span><span
class="add">+#include &#34;git-compat-util.h&#34;
+#include &#34;index-info.h&#34;
+#include &#34;hash.h&#34;
+#include &#34;hex.h&#34;
+#include &#34;strbuf.h&#34;
+#include &#34;quote.h&#34;
+
+int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata)
+{
+	const int hexsz = the_hash_algo-&gt;hexsz;
+	struct strbuf buf = STRBUF_INIT;
+	struct strbuf uq = STRBUF_INIT;
+	strbuf_getline_fn getline_fn;
+	int ret = 0;
+
+	getline_fn = nul_term_line ? strbuf_getline_nul : strbuf_getline_lf;
+	while (getline_fn(&#38;buf, stdin) != EOF) {
+		char *ptr, *tab;
+		char *path_name;
+		struct object_id oid;
+		unsigned int mode;
+		unsigned long ul;
+		int stage;
+
+		/* This reads lines formatted in one of three formats:
+		 *
+		 * (1) mode         SP sha1          TAB path
+		 * The first format is what &#34;git apply --index-info&#34;
+		 * reports, and used to reconstruct a partial tree
+		 * that is used for phony merge base tree when falling
+		 * back on 3-way merge.
+		 *
+		 * (2) mode SP type SP sha1          TAB path
+		 * The second format is to stuff &#34;git ls-tree&#34; output
+		 * into the index file.
+		 *
+		 * (3) mode         SP sha1 SP stage TAB path
+		 * This format is to put higher order stages into the
+		 * index file and matches &#34;git ls-files --stage&#34; output.
+		 */
+		errno = 0;
+		ul = strtoul(buf.buf, &#38;ptr, 8);
+		if (ptr == buf.buf || *ptr != &#39; &#39;
+		    || errno || (unsigned int) ul != ul)
+			goto bad_line;
+		mode = ul;
+
+		tab = strchr(ptr, &#39;\t&#39;);
+		if (!tab || tab - ptr &lt; hexsz + 1)
+			goto bad_line;
+
+		if (tab[-2] == &#39; &#39; &#38;&#38; &#39;0&#39; &lt;= tab[-1] &#38;&#38; tab[-1] &lt;= &#39;3&#39;) {
+			stage = tab[-1] - &#39;0&#39;;
+			ptr = tab + 1; /* point at the head of path */
+			tab = tab - 2; /* point at tail of sha1 */
+		} else {
+			stage = 0;
+			ptr = tab + 1; /* point at the head of path */
+		}
+
+		if (get_oid_hex(tab - hexsz, &#38;oid) ||
+			tab[-(hexsz + 1)] != &#39; &#39;)
+			goto bad_line;
+
+		path_name = ptr;
+		if (!nul_term_line &#38;&#38; path_name[0] == &#39;&#34;&#39;) {
+			strbuf_reset(&#38;uq);
+			if (unquote_c_style(&#38;uq, path_name, NULL)) {
+				ret = error(&#34;bad quoting of path name&#34;);
+				break;
+			}
+			path_name = uq.buf;
+		}
+
+		ret = fn(mode, &#38;oid, stage, path_name, cbdata);
+		if (ret) {
+			ret = -1;
+			break;
+		}
+
+		continue;
+
+	bad_line:
+		die(&#34;malformed input line &#39;%s&#39;&#34;, buf.buf);
+	}
+	strbuf_release(&#38;buf);
+	strbuf_release(&#38;uq);
+
+	return ret;
+}
</span><span
class="head">diff --git a/index-info.h b/index-info.h
new file mode 100644
index 00000000000..d650498325a
--- /dev/null
+++ b/index-info.h
</span><span
class="hunk">@@ -0,0 +1,11 @@
</span><span
class="add">+#ifndef INDEX_INFO_H
+#define INDEX_INFO_H
+
+#include &#34;hash.h&#34;
+
+typedef int (*each_index_info_fn)(unsigned int, struct object_id *, int, const char *, void *);
+
+/* Iterate over parsed index info from stdin */
+int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata);
+
+#endif /* INDEX_INFO_H */
</span><span
class="head">diff --git a/t/t2107-update-index-basic.sh b/t/t2107-update-index-basic.sh
index cc72ead79f3..794a5b1a184 100755
--- a/t/t2107-update-index-basic.sh
+++ b/t/t2107-update-index-basic.sh
</span><span
class="hunk">@@ -142,4 +142,31 @@ test_expect_success &#39;--index-version&#39; &#39;
</span> 	test_must_be_empty actual
 &#39;
 
<span
class="add">+test_expect_success &#39;--index-info fails on malformed input&#39; &#39;
+	# empty line
+	echo &#34;&#34; |
+	test_must_fail git update-index --index-info 2&gt;err &#38;&#38;
+	test_grep &#34;malformed input line&#34; err &#38;&#38;
+
+	# bad whitespace
+	printf &#34;100644 $EMPTY_BLOB A&#34; |
+	test_must_fail git update-index --index-info 2&gt;err &#38;&#38;
+	test_grep &#34;malformed input line&#34; err &#38;&#38;
+
+	# invalid stage value
+	printf &#34;100644 $EMPTY_BLOB 5\tA&#34; |
+	test_must_fail git update-index --index-info 2&gt;err &#38;&#38;
+	test_grep &#34;malformed input line&#34; err &#38;&#38;
+
+	# invalid OID length
+	printf &#34;100755 abc123\tA&#34; |
+	test_must_fail git update-index --index-info 2&gt;err &#38;&#38;
+	test_grep &#34;malformed input line&#34; err &#38;&#38;
+
+	# bad quoting
+	printf &#34;100644 $EMPTY_BLOB\t\&#34;A&#34; |
+	test_must_fail git update-index --index-info 2&gt;err &#38;&#38;
+	test_grep &#34;bad quoting of path name&#34; err
+&#39;
+
</span> test_done
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Victoria Dye via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 03/17] mktree: use non-static tree_entry array</title><updated>2024-06-19T21:58:14Z</updated><link
href="http://lore.kernel.org/git/d0d5523a32b2f56f48772367651eba3d52d16c35.1718834285.git.gitgitgadget@gmail.com/"/><id>urn:uuid:1f673a88-3db8-356e-7f22-e780c9cec8bc</id><thr:in-reply-to
ref="urn:uuid:181c79e4-3522-34dd-5a02-fa233eea3ac0"
href="http://lore.kernel.org/git/pull.1746.v2.git.1718834285.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Victoria Dye &lt;vdye@github.com&gt;

Replace the static &#39;struct tree_entry **entries&#39; with a non-static &#39;struct
tree_entry_array&#39; instance. In later commits, we&#39;ll want to be able to
create additional &#39;struct tree_entry_array&#39; instances utilizing common
functionality (create, push, clear, free). To avoid code duplication, create
the &#39;struct tree_entry_array&#39; type and add functions that perform those
basic operations.

Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
---
 builtin/mktree.c | 69 ++++++++++++++++++++++++++++++++++--------------
 1 file <a href="http://lore.kernel.org/git/d0d5523a32b2f56f48772367651eba3d52d16c35.1718834285.git.gitgitgadget@gmail.com/#related">changed</a>, 49 insertions(+), 20 deletions(-)

<span
class="head">diff --git a/builtin/mktree.c b/builtin/mktree.c
index c02feb06aff..a96ea10bf95 100644
--- a/builtin/mktree.c
+++ b/builtin/mktree.c
</span><span
class="hunk">@@ -12,15 +12,42 @@
</span> #include &#34;parse-options.h&#34;
 #include &#34;object-store-ll.h&#34;
 
<span
class="del">-static struct tree_entry {
</span><span
class="add">+struct tree_entry {
</span> 	unsigned mode;
 	struct object_id oid;
 	int len;
 	char name[FLEX_ARRAY];
<span
class="del">-} **entries;
-static int alloc, used;
</span><span
class="add">+};
+
+struct tree_entry_array {
+	size_t nr, alloc;
+	struct tree_entry **entries;
+};
+
+static void tree_entry_array_push(struct tree_entry_array *arr, struct tree_entry *ent)
+{
+	ALLOC_GROW(arr-&gt;entries, arr-&gt;nr + 1, arr-&gt;alloc);
+	arr-&gt;entries[arr-&gt;nr++] = ent;
+}
+
+static void tree_entry_array_clear(struct tree_entry_array *arr, int free_entries)
+{
+	if (free_entries) {
+		for (size_t i = 0; i &lt; arr-&gt;nr; i++)
+			FREE_AND_NULL(arr-&gt;entries[i]);
+	}
+	arr-&gt;nr = 0;
+}
</span> 
<span
class="del">-static void append_to_tree(unsigned mode, struct object_id *oid, char *path)
</span><span
class="add">+static void tree_entry_array_release(struct tree_entry_array *arr, int free_entries)
+{
+	tree_entry_array_clear(arr, free_entries);
+	FREE_AND_NULL(arr-&gt;entries);
+	arr-&gt;alloc = 0;
+}
+
+static void append_to_tree(unsigned mode, struct object_id *oid, const char *path,
+			   struct tree_entry_array *arr)
</span> {
 	struct tree_entry *ent;
 	size_t len = strlen(path);
<span
class="hunk">@@ -32,8 +59,7 @@ static void append_to_tree(unsigned mode, struct object_id *oid, char *path)
</span> 	ent-&gt;len = len;
 	oidcpy(&#38;ent-&gt;oid, oid);
 
<span
class="del">-	ALLOC_GROW(entries, used + 1, alloc);
-	entries[used++] = ent;
</span><span
class="add">+	tree_entry_array_push(arr, ent);
</span> }
 
 static int ent_compare(const void *a_, const void *b_)
<span
class="hunk">@@ -44,19 +70,18 @@ static int ent_compare(const void *a_, const void *b_)
</span> 				 b-&gt;name, b-&gt;len, b-&gt;mode);
 }
 
<span
class="del">-static void write_tree(struct object_id *oid)
</span><span
class="add">+static void write_tree(struct tree_entry_array *arr, struct object_id *oid)
</span> {
 	struct strbuf buf;
<span
class="del">-	size_t size;
-	int i;
</span><span
class="add">+	size_t size = 0;
</span> 
<span
class="del">-	QSORT(entries, used, ent_compare);
-	for (size = i = 0; i &lt; used; i++)
-		size += 32 + entries[i]-&gt;len;
</span><span
class="add">+	QSORT(arr-&gt;entries, arr-&gt;nr, ent_compare);
+	for (size_t i = 0; i &lt; arr-&gt;nr; i++)
+		size += 32 + arr-&gt;entries[i]-&gt;len;
</span> 
 	strbuf_init(&#38;buf, size);
<span
class="del">-	for (i = 0; i &lt; used; i++) {
-		struct tree_entry *ent = entries[i];
</span><span
class="add">+	for (size_t i = 0; i &lt; arr-&gt;nr; i++) {
+		struct tree_entry *ent = arr-&gt;entries[i];
</span> 		strbuf_addf(&#38;buf, &#34;%o %s%c&#34;, ent-&gt;mode, ent-&gt;name, &#39;\0&#39;);
 		strbuf_add(&#38;buf, ent-&gt;oid.hash, the_hash_algo-&gt;rawsz);
 	}
<span
class="hunk">@@ -70,7 +95,8 @@ static const char *mktree_usage[] = {
</span> 	NULL
 };
 
<span
class="del">-static void mktree_line(char *buf, int nul_term_line, int allow_missing)
</span><span
class="add">+static void mktree_line(char *buf, int nul_term_line, int allow_missing,
+			struct tree_entry_array *arr)
</span> {
 	char *ptr, *ntr;
 	const char *p;
<span
class="hunk">@@ -146,7 +172,7 @@ static void mktree_line(char *buf, int nul_term_line, int allow_missing)
</span> 		}
 	}
 
<span
class="del">-	append_to_tree(mode, &#38;oid, path);
</span><span
class="add">+	append_to_tree(mode, &#38;oid, path, arr);
</span> 	free(to_free);
 }
 
<span
class="hunk">@@ -158,6 +184,7 @@ int cmd_mktree(int ac, const char **av, const char *prefix)
</span> 	int allow_missing = 0;
 	int is_batch_mode = 0;
 	int got_eof = 0;
<span
class="add">+	struct tree_entry_array arr = { 0 };
</span> 	strbuf_getline_fn getline_fn;
 
 	const struct option option[] = {
<span
class="hunk">@@ -182,9 +209,9 @@ int cmd_mktree(int ac, const char **av, const char *prefix)
</span> 					break;
 				die(&#34;input format error: (blank line only valid in batch mode)&#34;);
 			}
<span
class="del">-			mktree_line(sb.buf, nul_term_line, allow_missing);
</span><span
class="add">+			mktree_line(sb.buf, nul_term_line, allow_missing, &#38;arr);
</span> 		}
<span
class="del">-		if (is_batch_mode &#38;&#38; got_eof &#38;&#38; used &lt; 1) {
</span><span
class="add">+		if (is_batch_mode &#38;&#38; got_eof &#38;&#38; arr.nr &lt; 1) {
</span> 			/*
 			 * Execution gets here if the last tree entry is terminated with a
 			 * new-line.  The final new-line has been made optional to be
<span
class="hunk">@@ -192,12 +219,14 @@ int cmd_mktree(int ac, const char **av, const char *prefix)
</span> 			 */
 			; /* skip creating an empty tree */
 		} else {
<span
class="del">-			write_tree(&#38;oid);
</span><span
class="add">+			write_tree(&#38;arr, &#38;oid);
</span> 			puts(oid_to_hex(&#38;oid));
 			fflush(stdout);
 		}
<span
class="del">-		used=0; /* reset tree entry buffer for re-use in batch mode */
</span><span
class="add">+		tree_entry_array_clear(&#38;arr, 1); /* reset tree entry buffer for re-use in batch mode */
</span> 	}
<span
class="add">+
+	tree_entry_array_release(&#38;arr, 1);
</span> 	strbuf_release(&#38;sb);
 	return 0;
 }
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Victoria Dye via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 02/17] mktree: rename treeent to tree_entry</title><updated>2024-06-19T21:58:12Z</updated><link
href="http://lore.kernel.org/git/4558f35e7bf9a1594510951ee54252069bdcfc5b.1718834285.git.gitgitgadget@gmail.com/"/><id>urn:uuid:b4c270f4-e50c-3ac6-cb27-b0db29636587</id><thr:in-reply-to
ref="urn:uuid:181c79e4-3522-34dd-5a02-fa233eea3ac0"
href="http://lore.kernel.org/git/pull.1746.v2.git.1718834285.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Victoria Dye &lt;vdye@github.com&gt;

Rename the type for better readability, clearly specifying &#34;entry&#34; (instead
of the &#34;ent&#34; abbreviation) and separating &#34;tree&#34; from &#34;entry&#34;.

Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
---
 builtin/mktree.c | 10 +++++-----
 1 file <a href="http://lore.kernel.org/git/4558f35e7bf9a1594510951ee54252069bdcfc5b.1718834285.git.gitgitgadget@gmail.com/#related">changed</a>, 5 insertions(+), 5 deletions(-)

<span
class="head">diff --git a/builtin/mktree.c b/builtin/mktree.c
index 8b19d440747..c02feb06aff 100644
--- a/builtin/mktree.c
+++ b/builtin/mktree.c
</span><span
class="hunk">@@ -12,7 +12,7 @@
</span> #include &#34;parse-options.h&#34;
 #include &#34;object-store-ll.h&#34;
 
<span
class="del">-static struct treeent {
</span><span
class="add">+static struct tree_entry {
</span> 	unsigned mode;
 	struct object_id oid;
 	int len;
<span
class="hunk">@@ -22,7 +22,7 @@ static int alloc, used;
</span> 
 static void append_to_tree(unsigned mode, struct object_id *oid, char *path)
 {
<span
class="del">-	struct treeent *ent;
</span><span
class="add">+	struct tree_entry *ent;
</span> 	size_t len = strlen(path);
 	if (strchr(path, &#39;/&#39;))
 		die(&#34;path %s contains slash&#34;, path);
<span
class="hunk">@@ -38,8 +38,8 @@ static void append_to_tree(unsigned mode, struct object_id *oid, char *path)
</span> 
 static int ent_compare(const void *a_, const void *b_)
 {
<span
class="del">-	struct treeent *a = *(struct treeent **)a_;
-	struct treeent *b = *(struct treeent **)b_;
</span><span
class="add">+	struct tree_entry *a = *(struct tree_entry **)a_;
+	struct tree_entry *b = *(struct tree_entry **)b_;
</span> 	return base_name_compare(a-&gt;name, a-&gt;len, a-&gt;mode,
 				 b-&gt;name, b-&gt;len, b-&gt;mode);
 }
<span
class="hunk">@@ -56,7 +56,7 @@ static void write_tree(struct object_id *oid)
</span> 
 	strbuf_init(&#38;buf, size);
 	for (i = 0; i &lt; used; i++) {
<span
class="del">-		struct treeent *ent = entries[i];
</span><span
class="add">+		struct tree_entry *ent = entries[i];
</span> 		strbuf_addf(&#38;buf, &#34;%o %s%c&#34;, ent-&gt;mode, ent-&gt;name, &#39;\0&#39;);
 		strbuf_add(&#38;buf, ent-&gt;oid.hash, the_hash_algo-&gt;rawsz);
 	}
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Victoria Dye via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 01/17] mktree: use OPT_BOOL</title><updated>2024-06-19T21:58:10Z</updated><link
href="http://lore.kernel.org/git/074dc98acc79e08d07cf4f5c8105b872ec57980c.1718834285.git.gitgitgadget@gmail.com/"/><id>urn:uuid:899b7aaf-27c1-4344-f37c-ddeaecda10e3</id><thr:in-reply-to
ref="urn:uuid:181c79e4-3522-34dd-5a02-fa233eea3ac0"
href="http://lore.kernel.org/git/pull.1746.v2.git.1718834285.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Victoria Dye &lt;vdye@github.com&gt;

Replace &#39;OPT_SET_INT&#39; with &#39;OPT_BOOL&#39; for the options &#39;--missing&#39; and
&#39;--batch&#39;. The use of &#39;OPT_SET_INT&#39; in these options is identical to
&#39;OPT_BOOL&#39;, but &#39;OPT_BOOL&#39; provides slightly simpler syntax.

Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
---
 builtin/mktree.c | 4 ++--
 1 file <a href="http://lore.kernel.org/git/074dc98acc79e08d07cf4f5c8105b872ec57980c.1718834285.git.gitgitgadget@gmail.com/#related">changed</a>, 2 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/builtin/mktree.c b/builtin/mktree.c
index 9a22d4e2773..8b19d440747 100644
--- a/builtin/mktree.c
+++ b/builtin/mktree.c
</span><span
class="hunk">@@ -162,8 +162,8 @@ int cmd_mktree(int ac, const char **av, const char *prefix)
</span> 
 	const struct option option[] = {
 		OPT_BOOL(&#39;z&#39;, NULL, &#38;nul_term_line, N_(&#34;input is NUL terminated&#34;)),
<span
class="del">-		OPT_SET_INT( 0 , &#34;missing&#34;, &#38;allow_missing, N_(&#34;allow missing objects&#34;), 1),
-		OPT_SET_INT( 0 , &#34;batch&#34;, &#38;is_batch_mode, N_(&#34;allow creation of more than one tree&#34;), 1),
</span><span
class="add">+		OPT_BOOL(0, &#34;missing&#34;, &#38;allow_missing, N_(&#34;allow missing objects&#34;)),
+		OPT_BOOL(0, &#34;batch&#34;, &#38;is_batch_mode, N_(&#34;allow creation of more than one tree&#34;)),
</span> 		OPT_END()
 	};
 
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Victoria Dye via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 00/17] mktree: support more flexible usage</title><updated>2024-06-19T21:58:10Z</updated><link
href="http://lore.kernel.org/git/pull.1746.v2.git.1718834285.gitgitgadget@gmail.com/"/><id>urn:uuid:181c79e4-3522-34dd-5a02-fa233eea3ac0</id><thr:in-reply-to
ref="urn:uuid:757ea386-1716-4209-4df9-06317772f1ec"
href="http://lore.kernel.org/git/pull.1746.git.1718130288.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The goal of this series is to make &#39;git mktree&#39; a much more flexible and
powerful tool for constructing arbitrary trees in memory without the use of
an index or worktree. The main additions are:

 * Using an optional &#34;base tree&#34; to add or replace entries in an existing
   tree rather than creating a new one from scratch.
   * Building off of this, having entries with mode &#34;0&#34; indicate &#34;remove
     this entry, if it exists, from the tree&#34;
 * Handling tree entries inside of subtrees (e.g., folder1/my-file.txt)

It also introduces some quality-of-life updates:

 * Using the same input parsing as &#39;update-index&#39; to allow a wider variety
   of tree entry formats.
 * Adding deduplication of input entries &#38; more thorough validation of
   inputs (with an option to disable both - plus input sorting - if desired
   with &#39;--literally&#39;).

The implementation change underpinning the new features is completely
revamping how the tree is constructed in memory. Instead of writing a single
tree object into a strbuf and hashing it into the object database, we
construct an in-core sparse index and write out the root tree, as well as
any new subtrees, using the cache tree infrastructure.

The series is organized as follows:

 * Commits 1-3 contain miscellaneous small renames/refactors to make the
   code more readable &#38; prepare for larger refactoring later.
 * Commits 4-7 generalize the input parsing performed by &#39;read_index_info()&#39;
   in &#39;update-index&#39; and update &#39;mktree&#39; to use it.
 * Commit 8 removes the check on object existence &#38; type from submodule
   entries.
 * Commit 9 adds the &#39;--literally&#39; option to &#39;mktree&#39;. Practically, this
   option allows tests that currently use &#39;mktree&#39; to generate corrupt trees
   to continue functioning after we strengthen input validations.
 * Commits 10 &#38; 11 add input path validation &#38; entry deduplication,
   respectively.
 * Commit 12 replaces the strbuf-to-object tree creation with construction
   of an in-core index &#38; writing out the cache tree.
 * Commits 13-15 add the ability to add tree entries to an existing &#34;base&#34;
   tree. Takes 3 commits to do it because it requires a bit of finesse
   around directory/file deduplication and iterating over a tree with
   &#39;read_tree()&#39; with a parallel iteration over the input tree entries.
 * Commit 16 allows for deeper paths in the input.
 * Commit 17 adds handling for mode &#39;0&#39; as &#34;removal&#34; entries.

I also plan to add a &#39;--strict&#39; option that runs &#39;fsck&#39; checks on the new
tree(s) before writing to the object database (similar to &#39;mkttag
--strict&#39;), but this series is pretty long as it is and that part can easily
be separated out into its own series.


Changes since V1
================

 * Renamed &#39;tree_entry_array&#39; &#38; &#39;tree_entry_iterator&#39; functions to
   &#39;tree_entry_array&#39; &#38; &#39;tree_entry_iterator&#39;, respectively.
 * Removed the return value from &#39;tree_entry_iterator_advance&#39;.
 * Added call to &#39;tree_entry_array_clear&#39; in &#39;tree_entry_array_release&#39;,
   updated both methods to optionally free tree entries based on a
   &#39;free_entries&#39; arg.
 * Updated &#39;read_index_info()&#39;:
   * Replaced INDEX_INFO_EMPTY_LINE with INDEX_INFO_UNRECOGNIZED_LINE which
     is returned when any &#34;malformed&#34; line is found, setting an input strbuf
     to the line contents for the caller to deal with.
   * Updated default object type value (when no type info is specified) to
     &#39;OBJ_ANY&#39; from &#39;OBJ_NONE&#39;.
 * Updated &#39;mktree&#39; to &#39;die()&#39; on malformed line with &#34;input format error&#34;,
   rather than &#39;error()&#39; with &#34;malformed input line&#34;, to avoid unnecessarily
   changing the error message.
 * Removed check for object existence &#38; type when the entry type is a
   submodule, rearranged checks for readability.
 * Replaced use of &#39;grep&#39; with &#39;test_grep&#39; in new/updated tests.
 * Wrapped lines in documentation updates to 76 characters.
 * Applied documentation refactor patch in [1].
 * Dropped &#39;[--]&#39; from the &#39;mktree&#39; usage string.

[1] <a
href="https://lore.kernel.org/git/xmqqle3aovpq.fsf@gitster.g/">https://lore.kernel.org/git/xmqqle3aovpq.fsf@gitster.g/</a>

Thanks!

 * Victoria

Victoria Dye (17):
  mktree: use OPT_BOOL
  mktree: rename treeent to tree_entry
  mktree: use non-static tree_entry array
  update-index: generalize &#39;read_index_info&#39;
  index-info.c: return unrecognized lines to caller
  index-info.c: parse object type in provided in read_index_info
  mktree: use read_index_info to read stdin lines
  mktree.c: do not fail on mismatched submodule type
  mktree: add a --literally option
  mktree: validate paths more carefully
  mktree: overwrite duplicate entries
  mktree: create tree using an in-core index
  mktree: use iterator struct to add tree entries to index
  mktree: add directory-file conflict hashmap
  mktree: optionally add to an existing tree
  mktree: allow deeper paths in input
  mktree: remove entries when mode is 0

 Documentation/git-mktree.txt         |  50 ++-
 Documentation/git-update-index.txt   |  16 +-
 Documentation/index-info-formats.txt |  13 +
 Makefile                             |   1 +
 builtin/mktree.c                     | 592 ++++++++++++++++++++++-----
 builtin/update-index.c               | 135 ++----
 index-info.c                         | 100 +++++
 index-info.h                         |  15 +
 t/t1010-mktree.sh                    | 350 +++++++++++++++-
 t/t1014-read-tree-confusing.sh       |   6 +-
 t/t1450-fsck.sh                      |   4 +-
 t/t1601-index-bogus.sh               |   2 +-
 t/t1700-split-index.sh               |   6 +-
 t/t2107-update-index-basic.sh        |  32 ++
 t/t7008-filter-branch-null-sha1.sh   |   6 +-
 t/t7417-submodule-path-url.sh        |   2 +-
 t/t7450-bad-git-dotfiles.sh          |   8 +-
 17 files changed, 1088 insertions(+), 250 deletions(-)
 create mode 100644 Documentation/index-info-formats.txt
 create mode 100644 index-info.c
 create mode 100644 index-info.h


base-commit: 8d94cfb54504f2ec9edc7ca3eb5c29a3dd3675ae
Published-As: <a
href="https://github.com/gitgitgadget/git/releases/tag/pr-1746%2Fvdye%2Fvdye%2Fmktree-recursive-v2">https://github.com/gitgitgadget/git/releases/tag/pr-1746%2Fvdye%2Fvdye%2Fmktree-recursive-v2</a>
Fetch-It-Via: git fetch <a
href="https://github.com/gitgitgadget/git">https://github.com/gitgitgadget/git</a> pr-1746/vdye/vdye/mktree-recursive-v2
Pull-Request: <a
href="https://github.com/gitgitgadget/git/pull/1746">https://github.com/gitgitgadget/git/pull/1746</a>

Range-diff vs v1:

  1:  074dc98acc7 =  1:  074dc98acc7 mktree: use OPT_BOOL
  2:  4558f35e7bf =  2:  4558f35e7bf mktree: rename treeent to tree_entry
  3:  5ade145352f !  3:  d0d5523a32b mktree: use non-static tree_entry array
     @@ builtin/mktree.c
      +	size_t nr, alloc;
      +	struct tree_entry **entries;
      +};
     - 
     --static void append_to_tree(unsigned mode, struct object_id *oid, char *path)
     ++
      +static void tree_entry_array_push(struct tree_entry_array *arr, struct tree_entry *ent)
      +{
      +	ALLOC_GROW(arr-&gt;entries, arr-&gt;nr + 1, arr-&gt;alloc);
      +	arr-&gt;entries[arr-&gt;nr++] = ent;
      +}
      +
     -+static void clear_tree_entry_array(struct tree_entry_array *arr)
     ++static void tree_entry_array_clear(struct tree_entry_array *arr, int free_entries)
      +{
     -+	for (size_t i = 0; i &lt; arr-&gt;nr; i++)
     -+		FREE_AND_NULL(arr-&gt;entries[i]);
     ++	if (free_entries) {
     ++		for (size_t i = 0; i &lt; arr-&gt;nr; i++)
     ++			FREE_AND_NULL(arr-&gt;entries[i]);
     ++	}
      +	arr-&gt;nr = 0;
      +}
     -+
     -+static void release_tree_entry_array(struct tree_entry_array *arr)
     + 
     +-static void append_to_tree(unsigned mode, struct object_id *oid, char *path)
     ++static void tree_entry_array_release(struct tree_entry_array *arr, int free_entries)
      +{
     ++	tree_entry_array_clear(arr, free_entries);
      +	FREE_AND_NULL(arr-&gt;entries);
     -+	arr-&gt;nr = arr-&gt;alloc = 0;
     ++	arr-&gt;alloc = 0;
      +}
      +
      +static void append_to_tree(unsigned mode, struct object_id *oid, const char *path,
     @@ builtin/mktree.c: static void append_to_tree(unsigned mode, struct object_id *oi
       
      -	ALLOC_GROW(entries, used + 1, alloc);
      -	entries[used++] = ent;
     -+	/* Append the update */
      +	tree_entry_array_push(arr, ent);
       }
       
     @@ builtin/mktree.c: int cmd_mktree(int ac, const char **av, const char *prefix)
       			fflush(stdout);
       		}
      -		used=0; /* reset tree entry buffer for re-use in batch mode */
     -+		clear_tree_entry_array(&#38;arr); /* reset tree entry buffer for re-use in batch mode */
     ++		tree_entry_array_clear(&#38;arr, 1); /* reset tree entry buffer for re-use in batch mode */
       	}
      +
     -+	release_tree_entry_array(&#38;arr);
     ++	tree_entry_array_release(&#38;arr, 1);
       	strbuf_release(&#38;sb);
       	return 0;
       }
  4:  9d0689e9c28 !  4:  f5473764236 update-index: generalize &#39;read_index_info&#39;
     @@ Commit message
          callback &#39;apply_index_info()&#39; to verify the parsed line and update the index
          according to its contents.
      
     -    The input parsing done by &#39;read_index_info()&#39; is similar to, but more
     -    flexible than, the parsing done in &#39;mktree&#39; by &#39;mktree_line()&#39; (handling not
     -    only &#39;git ls-tree&#39; output but also the outputs of &#39;git apply --index-info&#39;
     -    and &#39;git ls-files --stage&#39; outputs). To make &#39;mktree&#39; more flexible, a later
     -    patch will replace mktree&#39;s custom parsing with &#39;read_index_info()&#39;.
     +    Switching to using a callback to validate the parsed entry in &#39;update-index&#39;
     +    results in a slight change to the error message indicating a file could not
     +    be removed from the index. The original implementation uses the raw, quoted
     +    pathname in the error message, whereas the callback (without access to the
     +    raw pathname) uses the unquoted value. However, this change makes the failed
     +    removal message consistent with all other error messages in the function,
     +    and that consistency is likely more beneficial than not to a user.
      
     +    The motivation for this change is to consolidate the already-similar input
     +    parsing logic in &#39;git update-index&#39; and &#39;git mktree&#39;, avoiding code
     +    duplication and the associated maintenance burden. The input formats
     +    accepted by &#39;update-index&#39; are a superset of those accepted by &#39;mktree&#39;, so
     +    in a later commit we can replace the input parsing of the latter with
     +    &#39;read_index_info()&#39; without breaking existing usage.
     +
     +    Co-authored-by: Junio C Hamano &lt;gitster@pobox.com&gt;
          Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
      
     + ## Documentation/git-update-index.txt ##
     +@@ Documentation/git-update-index.txt: USING --INDEX-INFO
     + 
     + `--index-info` is a more powerful mechanism that lets you feed
     + multiple entry definitions from the standard input, and designed
     +-specifically for scripts.  It can take inputs of three formats:
     ++specifically for scripts.  It can take inputs in the following formats:
     + 
     +-    . mode SP type SP sha1          TAB path
     +-+
     +-This format is to stuff `git ls-tree` output into the index.
     +-
     +-    . mode         SP sha1 SP stage TAB path
     +-+
     +-This format is to put higher order stages into the
     +-index file and matches &#39;git ls-files --stage&#39; output.
     +-
     +-    . mode         SP sha1          TAB path
     +-+
     +-This format is no longer produced by any Git command, but is
     +-and will continue to be supported by `update-index --index-info`.
     ++include::index-info-formats.txt[]
     + 
     + To place a higher stage entry to the index, the path should
     + first be removed by feeding a mode=0 entry for the path, and
     +
     + ## Documentation/index-info-formats.txt (new) ##
     +@@
     ++    . mode SP type SP sha1          TAB path
     +++
     ++This format is to use `git ls-tree` output.
     ++
     ++    . mode         SP sha1 SP stage TAB path
     +++
     ++This format allows higher order stages to appear and
     ++matches &#39;git ls-files --stage&#39; output.
     ++
     ++    . mode         SP sha1          TAB path
     +++
     ++This format is no longer produced by any Git command, but is
     ++and will continue to be supported.
     +
       ## Makefile ##
      @@ Makefile: LIB_OBJS += hex.o
       LIB_OBJS += hex-ll.o
     @@ builtin/update-index.c: static void update_one(const char *path)
       
       static const char * const update_index_usage[] = {
      @@ builtin/update-index.c: static enum parse_opt_result stdin_cacheinfo_callback(
     + 	struct parse_opt_ctx_t *ctx, const struct option *opt,
       	const char *arg, int unset)
       {
     - 	int *nul_term_line = opt-&gt;value;
     -+	int ret;
     +-	int *nul_term_line = opt-&gt;value;
     ++	int ret = 0;
       
       	BUG_ON_OPT_NEG(unset);
       	BUG_ON_OPT_ARG(arg);
     -@@ builtin/update-index.c: static enum parse_opt_result stdin_cacheinfo_callback(
     - 	if (ctx-&gt;argc != 1)
     - 		return error(&#34;option &#39;%s&#39; must be the last argument&#34;, opt-&gt;long_name);
     - 	allow_add = allow_replace = allow_remove = 1;
     + 
     +-	if (ctx-&gt;argc != 1)
     +-		return error(&#34;option &#39;%s&#39; must be the last argument&#34;, opt-&gt;long_name);
     +-	allow_add = allow_replace = allow_remove = 1;
      -	read_index_info(*nul_term_line);
     -+	ret = read_index_info(*nul_term_line, apply_index_info, NULL);
     -+	if (ret)
     -+		return -1;
     +-	return 0;
     ++	if (ctx-&gt;argc != 1) {
     ++		ret = error(&#34;option &#39;%s&#39; must be the last argument&#34;, opt-&gt;long_name);
     ++	} else {
     ++		int *nul_term_line = opt-&gt;value;
      +
     - 	return 0;
     ++		allow_add = allow_replace = allow_remove = 1;
     ++		ret = read_index_info(*nul_term_line, apply_index_info, NULL);
     ++		if (ret)
     ++			ret = -1;
     ++	}
     ++
     ++	return ret;
       }
       
     + static enum parse_opt_result stdin_callback(
      
       ## index-info.c (new) ##
      @@
     @@ index-info.c (new)
      +		continue;
      +
      +	bad_line:
     -+		ret = error(&#34;malformed input line &#39;%s&#39;&#34;, buf.buf);
     -+		break;
     ++		die(&#34;malformed input line &#39;%s&#39;&#34;, buf.buf);
      +	}
      +	strbuf_release(&#38;buf);
      +	strbuf_release(&#38;uq);
     @@ t/t2107-update-index-basic.sh: test_expect_success &#39;--index-version&#39; &#39;
      +	# empty line
      +	echo &#34;&#34; |
      +	test_must_fail git update-index --index-info 2&gt;err &#38;&#38;
     -+	grep &#34;malformed input line&#34; err &#38;&#38;
     ++	test_grep &#34;malformed input line&#34; err &#38;&#38;
      +
      +	# bad whitespace
      +	printf &#34;100644 $EMPTY_BLOB A&#34; |
      +	test_must_fail git update-index --index-info 2&gt;err &#38;&#38;
     -+	grep &#34;malformed input line&#34; err &#38;&#38;
     ++	test_grep &#34;malformed input line&#34; err &#38;&#38;
      +
      +	# invalid stage value
      +	printf &#34;100644 $EMPTY_BLOB 5\tA&#34; |
      +	test_must_fail git update-index --index-info 2&gt;err &#38;&#38;
     -+	grep &#34;malformed input line&#34; err &#38;&#38;
     ++	test_grep &#34;malformed input line&#34; err &#38;&#38;
      +
      +	# invalid OID length
      +	printf &#34;100755 abc123\tA&#34; |
      +	test_must_fail git update-index --index-info 2&gt;err &#38;&#38;
     -+	grep &#34;malformed input line&#34; err &#38;&#38;
     ++	test_grep &#34;malformed input line&#34; err &#38;&#38;
      +
      +	# bad quoting
      +	printf &#34;100644 $EMPTY_BLOB\t\&#34;A&#34; |
      +	test_must_fail git update-index --index-info 2&gt;err &#38;&#38;
     -+	grep &#34;bad quoting of path name&#34; err
     ++	test_grep &#34;bad quoting of path name&#34; err
      +&#39;
      +
       test_done
  5:  7e3bcc16e23 !  5:  4f4d54c8d07 index-info.c: identify empty input lines in read_index_info
     @@ Metadata
      Author: Victoria Dye &lt;vdye@github.com&gt;
      
       ## Commit message ##
     -    index-info.c: identify empty input lines in read_index_info
     +    index-info.c: return unrecognized lines to caller
      
     -    Update &#39;read_index_info()&#39; to return INDEX_INFO_EMPTY_LINE (value 1), rather
     -    than the default error code (value -1) when the function encounters an empty
     -    line in stdin. This grants the caller the flexibility to handle such
     -    scenarios differently than a typical error. In the case of &#39;update-index&#39;,
     -    we&#39;ll still exit with a &#34;malformed input line&#34; error. However, when
     -    &#39;read_index_info()&#39; is used to process the input to &#39;mktree&#39; in a later
     -    patch, the empty line return value will signal a new tree in --batch mode.
     +    Update &#39;read_index_info()&#39; to return INDEX_INFO_UNRECOGNIZED_LINE (value 1),
     +    rather than die()-ing when the function encounters a line that cannot be
     +    parsed according to one of the accepted formats. This grants the caller the
     +    flexibility to fall back on custom handling for such lines rather than a
     +    returning a catch-all error. In the case of &#39;update-index&#39;, we&#39;ll still exit
     +    with a &#34;malformed input line&#34; error. However, when &#39;read_index_info()&#39; is
     +    used to process the input to &#39;mktree&#39; in a later patch, an empty line return
     +    value will signal a new tree in --batch mode.
      
          Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
      
       ## builtin/update-index.c ##
      @@ builtin/update-index.c: static enum parse_opt_result stdin_cacheinfo_callback(
     - 		return error(&#34;option &#39;%s&#39; must be the last argument&#34;, opt-&gt;long_name);
     - 	allow_add = allow_replace = allow_remove = 1;
     - 	ret = read_index_info(*nul_term_line, apply_index_info, NULL);
     --	if (ret)
     -+	if (ret == INDEX_INFO_EMPTY_LINE)
     -+		return error(&#34;malformed input line &#39;&#39;&#34;);
     -+	else if (ret &lt; 0)
     - 		return -1;
     - 
     - 	return 0;
     + 		ret = error(&#34;option &#39;%s&#39; must be the last argument&#34;, opt-&gt;long_name);
     + 	} else {
     + 		int *nul_term_line = opt-&gt;value;
     ++		struct strbuf line = STRBUF_INIT;
     + 
     + 		allow_add = allow_replace = allow_remove = 1;
     +-		ret = read_index_info(*nul_term_line, apply_index_info, NULL);
     +-		if (ret)
     ++		ret = read_index_info(*nul_term_line, apply_index_info, NULL, &#38;line);
     ++
     ++		if (ret == INDEX_INFO_UNRECOGNIZED_LINE)
     ++			ret = error(&#34;malformed input line &#39;%s&#39;&#34;, line.buf);
     ++		else if (ret)
     + 			ret = -1;
     ++		strbuf_release(&#38;line);
     + 	}
     + 
     + 	return ret;
      
       ## index-info.c ##
     +@@
     + #include &#34;strbuf.h&#34;
     + #include &#34;quote.h&#34;
     + 
     +-int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata)
     ++int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata,
     ++		    struct strbuf *line)
     + {
     + 	const int hexsz = the_hash_algo-&gt;hexsz;
     +-	struct strbuf buf = STRBUF_INIT;
     + 	struct strbuf uq = STRBUF_INIT;
     + 	strbuf_getline_fn getline_fn;
     + 	int ret = 0;
     + 
     + 	getline_fn = nul_term_line ? strbuf_getline_nul : strbuf_getline_lf;
     +-	while (getline_fn(&#38;buf, stdin) != EOF) {
     ++	while (getline_fn(line, stdin) != EOF) {
     + 		char *ptr, *tab;
     + 		char *path_name;
     + 		struct object_id oid;
     +@@ index-info.c: int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata)
     + 		 * index file and matches &#34;git ls-files --stage&#34; output.
     + 		 */
     + 		errno = 0;
     +-		ul = strtoul(buf.buf, &#38;ptr, 8);
     +-		if (ptr == buf.buf || *ptr != &#39; &#39;
     ++		ul = strtoul(line-&gt;buf, &#38;ptr, 8);
     ++		if (ptr == line-&gt;buf || *ptr != &#39; &#39;
     + 		    || errno || (unsigned int) ul != ul)
     + 			goto bad_line;
     + 		mode = ul;
      @@ index-info.c: int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata)
     - 		unsigned long ul;
     - 		int stage;
     + 		continue;
       
     -+		if (!buf.len) {
     -+			ret = INDEX_INFO_EMPTY_LINE;
     -+			break;
     -+		}
     -+
     - 		/* This reads lines formatted in one of three formats:
     - 		 *
     - 		 * (1) mode         SP sha1          TAB path
     + 	bad_line:
     +-		die(&#34;malformed input line &#39;%s&#39;&#34;, buf.buf);
     ++		ret = INDEX_INFO_UNRECOGNIZED_LINE;
     ++		break;
     + 	}
     +-	strbuf_release(&#38;buf);
     + 	strbuf_release(&#38;uq);
     ++	if (!ret)
     ++		strbuf_reset(line);
     + 
     + 	return ret;
     + }
      
       ## index-info.h ##
      @@
       
       typedef int (*each_index_info_fn)(unsigned int, struct object_id *, int, const char *, void *);
       
     -+#define INDEX_INFO_EMPTY_LINE 1
     ++#define INDEX_INFO_UNRECOGNIZED_LINE 1
      +
       /* Iterate over parsed index info from stdin */
     - int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata);
     +-int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata);
     ++int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata,
     ++		    struct strbuf *line);
       
     + #endif /* INDEX_INFO_H */
  6:  f56eee0b48d !  6:  472efcaf1dd index-info.c: parse object type in provided in read_index_info
     @@ Commit message
          by &#39;read_index_info()&#39; (i.e. on lines formatted like the output of &#39;git
          ls-tree&#39;), parse it into an &#39;enum object_type&#39; and provide it to the
          &#39;read_index_info()&#39; callback as an argument. If the type is not provided,
     -    pass &#39;OBJ_NONE&#39; instead. If the object type is invalid, return an error.
     +    pass &#39;OBJ_ANY&#39; instead. If the object type is invalid, return an error.
      
          The goal of this change is to allow for more thorough validation of the
          provided object type (e.g. against the provided mode) in &#39;mktree&#39; once
     @@ builtin/update-index.c: static void update_one(const char *path)
       	if (!verify_path(path_name, mode)) {
      
       ## index-info.c ##
     -@@ index-info.c: int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata)
     +@@ index-info.c: int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata,
       		char *ptr, *tab;
       		char *path_name;
       		struct object_id oid;
     -+		enum object_type obj_type = OBJ_NONE;
     ++		enum object_type obj_type = OBJ_ANY;
       		unsigned int mode;
       		unsigned long ul;
       		int stage;
     -@@ index-info.c: int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata)
     +@@ index-info.c: int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata,
       
       		if (tab[-2] == &#39; &#39; &#38;&#38; &#39;0&#39; &lt;= tab[-1] &#38;&#38; tab[-1] &lt;= &#39;3&#39;) {
       			stage = tab[-1] - &#39;0&#39;;
     @@ index-info.c: int read_index_info(int nul_term_line, each_index_info_fn fn, void
       		if (!nul_term_line &#38;&#38; path_name[0] == &#39;&#34;&#39;) {
       			strbuf_reset(&#38;uq);
       			if (unquote_c_style(&#38;uq, path_name, NULL)) {
     -@@ index-info.c: int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata)
     +@@ index-info.c: int read_index_info(int nul_term_line, each_index_info_fn fn, void *cbdata,
       			path_name = uq.buf;
       		}
       
     @@ index-info.h
      -typedef int (*each_index_info_fn)(unsigned int, struct object_id *, int, const char *, void *);
      +typedef int (*each_index_info_fn)(unsigned int, struct object_id *, enum object_type, int, const char *, void *);
       
     - #define INDEX_INFO_EMPTY_LINE 1
     + #define INDEX_INFO_UNRECOGNIZED_LINE 1
       
      
       ## t/t2107-update-index-basic.sh ##
      @@ t/t2107-update-index-basic.sh: test_expect_success &#39;--index-info fails on malformed input&#39; &#39;
       	test_must_fail git update-index --index-info 2&gt;err &#38;&#38;
     - 	grep &#34;malformed input line&#34; err &#38;&#38;
     + 	test_grep &#34;malformed input line&#34; err &#38;&#38;
       
      +	# invalid type
      +	printf &#34;100644 bad $EMPTY_BLOB\tA&#34; |
      +	test_must_fail git update-index --index-info 2&gt;err &#38;&#38;
     -+	grep &#34;invalid object type&#34; err &#38;&#38;
     ++	test_grep &#34;invalid object type&#34; err &#38;&#38;
      +
       	# invalid stage value
       	printf &#34;100644 $EMPTY_BLOB 5\tA&#34; |
  7:  8d1e1eaa70b !  7:  9dc8e16a7fc mktree: use read_index_info to read stdin lines
     @@ Commit message
          across the commands (avoiding the need for two similar implementations for
          input parsing) and adds flexibility to mktree.
      
     +    It should be noted that, while the error messages are largely preserved in
     +    the refactor, one does change: &#34;fatal: invalid quoting&#34; is now &#34;error: bad
     +    quoting of path name&#34;.
     +
          Update &#39;Documentation/git-mktree.txt&#39; to reflect the more permissive input
     -    format.
     +    format, as well as make a note about rejecting stage values higher than 0.
      
     +    Helped-by: Junio C Hamano &lt;gitster@pobox.com&gt;
          Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
      
       ## Documentation/git-mktree.txt ##
     @@ Documentation/git-mktree.txt: SYNOPSIS
      -a tree object.  The order of the tree entries is normalized by mktree so
      -pre-sorting the input is not required.  The object name of the tree object
      -built is written to the standard output.
     -+Reads entry information from stdin and creates a tree object from those entries.
     -+The object name of the tree object built is written to the standard output.
     ++Reads entry information from stdin and creates a tree object from those
     ++entries. The object name of the tree object built is written to the standard
     ++output.
       
       OPTIONS
       -------
     @@ Documentation/git-mktree.txt: OPTIONS
      +INPUT FORMAT
      +------------
      +Tree entries may be specified in any of the formats compatible with the
     -+`--index-info` option to linkgit:git-update-index[1]. The order of the tree
     -+entries is normalized by `mktree` so pre-sorting the input by path is not
     -+required.
     ++`--index-info` option to linkgit:git-update-index[1]:
     ++
     ++include::index-info-formats.txt[]
     ++
     ++Note that if the `stage` of a tree entry is given, the value must be 0.
     ++Higher stages represent conflicted files in an index; this information
     ++cannot be represented in a tree object. The command will fail without
     ++writing the tree if a higher order stage is specified for any entry.
     ++
     ++The order of the tree entries is normalized by `mktree` so pre-sorting the
     ++input by path is not required.
      +
       GIT
       ---
     @@ builtin/mktree.c: static const char *mktree_usage[] = {
      +};
      +
      +static int mktree_line(unsigned int mode, struct object_id *oid,
     -+		       enum object_type obj_type, int stage UNUSED,
     ++		       enum object_type obj_type, int stage,
      +		       const char *path, void *cbdata)
       {
      -	char *ptr, *ntr;
     @@ builtin/mktree.c: static const char *mktree_usage[] = {
      -			die(&#34;invalid quoting&#34;);
      -		path = to_free = strbuf_detach(&#38;p_uq, NULL);
      -	}
     -+	if (obj_type &#38;&#38; mode_type != obj_type)
     -+		die(&#34;object type (%s) doesn&#39;t match mode type (%s)&#34;,
     -+		    type_name(obj_type), type_name(mode_type));
     ++	if (stage)
     ++		die(_(&#34;path &#39;%s&#39; is unmerged&#34;), path);
       
      -	/*
      -	 * Object type is redundantly derivable three ways.
     @@ builtin/mktree.c: static const char *mktree_usage[] = {
      -		die(&#34;entry &#39;%s&#39; object type (%s) doesn&#39;t match mode type (%s)&#34;,
      -			path, ptr, type_name(mode_type));
      -	}
     ++	if (obj_type != OBJ_ANY &#38;&#38; mode_type != obj_type)
     ++		die(&#34;object type (%s) doesn&#39;t match mode type (%s)&#34;,
     ++		    type_name(obj_type), type_name(mode_type));
     ++
      +	oi.typep = &#38;parsed_obj_type;
       
      -	/* Check the type of object identified by oid without fetching objects */
     @@ builtin/mktree.c: static const char *mktree_usage[] = {
       				     OBJECT_INFO_QUICK |
       				     OBJECT_INFO_SKIP_FETCH_OBJECT) &lt; 0)
      -		obj_type = -1;
     -+		parsed_obj_type = -1;
     - 
     +-
      -	if (obj_type &lt; 0) {
      -		if (allow_missing) {
      -			; /* no problem - missing objects are presumed to be of the right type */
     -+	if (parsed_obj_type &lt; 0) {
     -+		if (data-&gt;allow_missing || S_ISGITLINK(mode)) {
     -+			; /* no problem - missing objects &#38; submodules are presumed to be of the right type */
     - 		} else {
     +-		} else {
      -			die(&#34;entry &#39;%s&#39; object %s is unavailable&#34;, path, oid_to_hex(&#38;oid));
      -		}
      -	} else {
     @@ builtin/mktree.c: static const char *mktree_usage[] = {
      -			 */
      -			die(&#34;entry &#39;%s&#39; object %s is a %s but specified type was (%s)&#34;,
      -				path, oid_to_hex(&#38;oid), type_name(obj_type), type_name(mode_type));
     +-		}
     ++		parsed_obj_type = -1;
     ++
     ++	if (parsed_obj_type &lt; 0) {
     ++		/*
     ++		 * There are two conditions where the object being missing
     ++		 * is acceptable:
     ++		 *
     ++		 * - We&#39;re explicitly allowing it with --missing.
     ++		 * - The object is a submodule, which we wouldn&#39;t expect to
     ++		 *   be in this repo anyway.
     ++		 *
     ++		 * If neither condition is met, die().
     ++		 */
     ++		if (!data-&gt;allow_missing &#38;&#38; !S_ISGITLINK(mode))
      +			die(&#34;entry &#39;%s&#39; object %s is unavailable&#34;, path, oid_to_hex(oid));
     - 		}
     ++
      +	} else if (parsed_obj_type != mode_type) {
      +		/*
      +		 * The object exists but is of the wrong type.
     @@ builtin/mktree.c: static const char *mktree_usage[] = {
       	struct tree_entry_array arr = { 0 };
      -	strbuf_getline_fn getline_fn;
      +	struct mktree_line_data mktree_line_data = { .arr = &#38;arr };
     ++	struct strbuf line = STRBUF_INIT;
      +	int ret;
       
       	const struct option option[] = {
     @@ builtin/mktree.c: static const char *mktree_usage[] = {
      -				break;
      -			}
      -			if (sb.buf[0] == &#39;\0&#39;) {
     --				/* empty lines denote tree boundaries in batch mode */
     --				if (is_batch_mode)
     --					break;
     --				die(&#34;input format error: (blank line only valid in batch mode)&#34;);
     --			}
     --			mktree_line(sb.buf, nul_term_line, allow_missing, &#38;arr);
     --		}
     --		if (is_batch_mode &#38;&#38; got_eof &#38;&#38; arr.nr &lt; 1) {
      +
      +	do {
     -+		ret = read_index_info(nul_term_line, mktree_line, &#38;mktree_line_data);
     ++		ret = read_index_info(nul_term_line, mktree_line, &#38;mktree_line_data, &#38;line);
      +		if (ret &lt; 0)
      +			break;
      +
     -+		/* empty lines denote tree boundaries in batch mode */
     -+		if (ret &gt; 0 &#38;&#38; !is_batch_mode)
     -+			die(&#34;input format error: (blank line only valid in batch mode)&#34;);
     ++		if (ret == INDEX_INFO_UNRECOGNIZED_LINE) {
     ++			if (line.len)
     ++				die(&#34;input format error: %s&#34;, line.buf);
     ++			else if (!is_batch_mode)
     + 				/* empty lines denote tree boundaries in batch mode */
     +-				if (is_batch_mode)
     +-					break;
     + 				die(&#34;input format error: (blank line only valid in batch mode)&#34;);
     +-			}
     +-			mktree_line(sb.buf, nul_term_line, allow_missing, &#38;arr);
     + 		}
     +-		if (is_batch_mode &#38;&#38; got_eof &#38;&#38; arr.nr &lt; 1) {
      +
      +		if (is_batch_mode &#38;&#38; !ret &#38;&#38; arr.nr &lt; 1) {
       			/*
     @@ builtin/mktree.c: static const char *mktree_usage[] = {
      @@ builtin/mktree.c: int cmd_mktree(int ac, const char **av, const char *prefix)
       			fflush(stdout);
       		}
     - 		clear_tree_entry_array(&#38;arr); /* reset tree entry buffer for re-use in batch mode */
     + 		tree_entry_array_clear(&#38;arr, 1); /* reset tree entry buffer for re-use in batch mode */
      -	}
      +	} while (ret &gt; 0);
       
     - 	release_tree_entry_array(&#38;arr);
     ++	strbuf_release(&#38;line);
     + 	tree_entry_array_release(&#38;arr, 1);
      -	strbuf_release(&#38;sb);
      -	return 0;
      +	return !!ret;
     @@ t/t1010-mktree.sh: test_expect_success &#39;ls-tree output in wrong order given to m
      +	tree_oid=&#34;$(cat tree)&#34; &#38;&#38;
      +	printf &#34;160000 commit $tree_oid\tA&#34; |
      +	test_must_fail git mktree 2&gt;err &#38;&#38;
     -+	grep &#34;object $tree_oid is a tree but specified type was (commit)&#34; err
     ++	test_grep &#34;object $tree_oid is a tree but specified type was (commit)&#34; err
      +&#39;
      +
       test_expect_success &#39;mktree refuses to read ls-tree -r output (1)&#39; &#39;
     @@ t/t1010-mktree.sh: test_expect_success &#39;mktree refuses to read ls-tree -r output
      +	# empty line without --batch
      +	echo &#34;&#34; |
      +	test_must_fail git mktree 2&gt;err &#38;&#38;
     -+	grep &#34;blank line only valid in batch mode&#34; err &#38;&#38;
     ++	test_grep &#34;blank line only valid in batch mode&#34; err &#38;&#38;
      +
      +	# bad whitespace
      +	printf &#34;100644 blob $EMPTY_BLOB A&#34; |
      +	test_must_fail git mktree 2&gt;err &#38;&#38;
     -+	grep &#34;malformed input line&#34; err &#38;&#38;
     ++	test_grep &#34;input format error&#34; err &#38;&#38;
      +
      +	# invalid type
      +	printf &#34;100644 bad $EMPTY_BLOB\tA&#34; |
      +	test_must_fail git mktree 2&gt;err &#38;&#38;
     -+	grep &#34;invalid object type&#34; err &#38;&#38;
     ++	test_grep &#34;invalid object type&#34; err &#38;&#38;
      +
      +	# invalid OID length
      +	printf &#34;100755 blob abc123\tA&#34; |
      +	test_must_fail git mktree 2&gt;err &#38;&#38;
     -+	grep &#34;malformed input line&#34; err &#38;&#38;
     ++	test_grep &#34;input format error&#34; err &#38;&#38;
      +
      +	# bad quoting
      +	printf &#34;100644 blob $EMPTY_BLOB\t\&#34;A&#34; |
      +	test_must_fail git mktree 2&gt;err &#38;&#38;
     -+	grep &#34;bad quoting of path name&#34; err
     ++	test_grep &#34;bad quoting of path name&#34; err
      +&#39;
      +
      +test_expect_success &#39;mktree fails on mode mismatch&#39; &#39;
     @@ t/t1010-mktree.sh: test_expect_success &#39;mktree refuses to read ls-tree -r output
      +	# mode-type mismatch
      +	printf &#34;100644 tree $tree_oid\tA&#34; |
      +	test_must_fail git mktree 2&gt;err &#38;&#38;
     -+	grep &#34;object type (tree) doesn${SQ}t match mode type (blob)&#34; err &#38;&#38;
     ++	test_grep &#34;object type (tree) doesn${SQ}t match mode type (blob)&#34; err &#38;&#38;
      +
      +	# mode-object mismatch (no --missing)
      +	printf &#34;100644 $tree_oid\tA&#34; |
      +	test_must_fail git mktree 2&gt;err &#38;&#38;
     -+	grep &#34;object $tree_oid is a tree but specified type was (blob)&#34; err
     ++	test_grep &#34;object $tree_oid is a tree but specified type was (blob)&#34; err
      +&#39;
      +
       test_done
  -:  ----------- &gt;  8:  8a3264afd0c mktree.c: do not fail on mismatched submodule type
  8:  b497dc90687 !  9:  e640a385b3d mktree: add a --literally option
     @@ Documentation/git-mktree.txt: OPTIONS
       
      +--literally::
      +	Create the tree from the tree entries provided to stdin in the order
     -+	they are provided without performing additional sorting, deduplication,
     -+	or path validation on them. This option is primarily useful for creating
     -+	invalid tree objects to use in tests of how Git deals with various forms
     -+	of tree corruption.
     ++	they are provided without performing additional sorting,
     ++	deduplication, or path validation on them. This option is primarily
     ++	useful for creating invalid tree objects to use in tests of how Git
     ++	deals with various forms of tree corruption.
      +
       --batch::
       	Allow building of more than one tree object before exiting.  Each
       	tree is separated by a single blank line. The final newline is
      
       ## builtin/mktree.c ##
     -@@ builtin/mktree.c: static void release_tree_entry_array(struct tree_entry_array *arr)
     +@@ builtin/mktree.c: static void tree_entry_array_release(struct tree_entry_array *arr, int free_entr
       }
       
       static void append_to_tree(unsigned mode, struct object_id *oid, const char *path,
     @@ builtin/mktree.c: static void write_tree(struct tree_entry_array *arr, struct ob
       
       static int mktree_line(unsigned int mode, struct object_id *oid,
      @@ builtin/mktree.c: static int mktree_line(unsigned int mode, struct object_id *oid,
     - 		    path, oid_to_hex(oid), type_name(parsed_obj_type), type_name(mode_type));
     + 		}
       	}
       
      -	append_to_tree(mode, oid, path, data-&gt;arr);
     @@ builtin/mktree.c: int cmd_mktree(int ac, const char **av, const char *prefix)
      
       ## t/t1010-mktree.sh ##
      @@ t/t1010-mktree.sh: test_expect_success &#39;mktree fails on mode mismatch&#39; &#39;
     - 	grep &#34;object $tree_oid is a tree but specified type was (blob)&#34; err
     + 	test_grep &#34;object $tree_oid is a tree but specified type was (blob)&#34; err
       &#39;
       
      +test_expect_success &#39;--literally can create invalid trees&#39; &#39;
     @@ t/t1010-mktree.sh: test_expect_success &#39;mktree fails on mode mismatch&#39; &#39;
      +	} | git mktree --literally &gt;tree.bad &#38;&#38;
      +	git cat-file tree $(cat tree.bad) &gt;top.bad &#38;&#38;
      +	test_must_fail git hash-object --stdin -t tree &lt;top.bad 2&gt;err &#38;&#38;
     -+	grep &#34;contains duplicate file entries&#34; err &#38;&#38;
     ++	test_grep &#34;contains duplicate file entries&#34; err &#38;&#38;
      +
      +	# disallowed path
      +	{
     @@ t/t1010-mktree.sh: test_expect_success &#39;mktree fails on mode mismatch&#39; &#39;
      +	} | git mktree --literally &gt;tree.bad &#38;&#38;
      +	git cat-file tree $(cat tree.bad) &gt;top.bad &#38;&#38;
      +	test_must_fail git hash-object --stdin -t tree &lt;top.bad 2&gt;err &#38;&#38;
     -+	grep &#34;contains ${SQ}.git${SQ}&#34; err &#38;&#38;
     ++	test_grep &#34;contains ${SQ}.git${SQ}&#34; err &#38;&#38;
      +
      +	# nested entry
      +	{
     @@ t/t1010-mktree.sh: test_expect_success &#39;mktree fails on mode mismatch&#39; &#39;
      +	} | git mktree --literally &gt;tree.bad &#38;&#38;
      +	git cat-file tree $(cat tree.bad) &gt;top.bad &#38;&#38;
      +	test_must_fail git hash-object --stdin -t tree &lt;top.bad 2&gt;err &#38;&#38;
     -+	grep &#34;contains full pathnames&#34; err &#38;&#38;
     ++	test_grep &#34;contains full pathnames&#34; err &#38;&#38;
      +
      +	# bad entry ordering
      +	{
     @@ t/t1010-mktree.sh: test_expect_success &#39;mktree fails on mode mismatch&#39; &#39;
      +	} | git mktree --literally &gt;tree.bad &#38;&#38;
      +	git cat-file tree $(cat tree.bad) &gt;top.bad &#38;&#38;
      +	test_must_fail git hash-object --stdin -t tree &lt;top.bad 2&gt;err &#38;&#38;
     -+	grep &#34;not properly sorted&#34; err
     ++	test_grep &#34;not properly sorted&#34; err
      +&#39;
      +
       test_done
  9:  4f9f77e693c ! 10:  2eb207064f8 mktree: validate paths more carefully
     @@ builtin/mktree.c: static void append_to_tree(unsigned mode, struct object_id *oi
      
       ## t/t1010-mktree.sh ##
      @@ t/t1010-mktree.sh: test_expect_success &#39;--literally can create invalid trees&#39; &#39;
     - 	grep &#34;not properly sorted&#34; err
     + 	test_grep &#34;not properly sorted&#34; err
       &#39;
       
      +test_expect_success &#39;mktree validates path&#39; &#39;
     @@ t/t1010-mktree.sh: test_expect_success &#39;--literally can create invalid trees&#39; &#39;
      +	# Invalid: blob with trailing slash
      +	printf &#34;100644 blob $blob_oid\ttest/&#34; |
      +	test_must_fail git mktree 2&gt;err &#38;&#38;
     -+	grep &#34;invalid path ${SQ}test/${SQ}&#34; err &#38;&#38;
     ++	test_grep &#34;invalid path ${SQ}test/${SQ}&#34; err &#38;&#38;
      +
      +	# Invalid: dotdot
      +	printf &#34;040000 tree $tree_oid\t../&#34; |
      +	test_must_fail git mktree 2&gt;err &#38;&#38;
     -+	grep &#34;invalid path ${SQ}../${SQ}&#34; err &#38;&#38;
     ++	test_grep &#34;invalid path ${SQ}../${SQ}&#34; err &#38;&#38;
      +
      +	# Invalid: dot
      +	printf &#34;040000 tree $tree_oid\t.&#34; |
      +	test_must_fail git mktree 2&gt;err &#38;&#38;
     -+	grep &#34;invalid path ${SQ}.${SQ}&#34; err &#38;&#38;
     ++	test_grep &#34;invalid path ${SQ}.${SQ}&#34; err &#38;&#38;
      +
      +	# Invalid: .git
      +	printf &#34;040000 tree $tree_oid\t.git/&#34; |
      +	test_must_fail git mktree 2&gt;err &#38;&#38;
     -+	grep &#34;invalid path ${SQ}.git/${SQ}&#34; err
     ++	test_grep &#34;invalid path ${SQ}.git/${SQ}&#34; err
      +&#39;
      +
       test_done
 10:  b59a4ad8ab4 ! 11:  fb555658057 mktree: overwrite duplicate entries
     @@ Commit message
          Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
      
       ## Documentation/git-mktree.txt ##
     -@@ Documentation/git-mktree.txt: OPTIONS
     - INPUT FORMAT
     - ------------
     - Tree entries may be specified in any of the formats compatible with the
     --`--index-info` option to linkgit:git-update-index[1]. The order of the tree
     --entries is normalized by `mktree` so pre-sorting the input by path is not
     --required.
     -+`--index-info` option to linkgit:git-update-index[1].
     -+
     -+The order of the tree entries is normalized by `mktree` so pre-sorting the input
     -+by path is not required. Multiple entries provided with the same path are
     -+deduplicated, with only the last one specified added to the tree.
     +@@ Documentation/git-mktree.txt: cannot be represented in a tree object. The command will fail without
     + writing the tree if a higher order stage is specified for any entry.
     + 
     + The order of the tree entries is normalized by `mktree` so pre-sorting the
     +-input by path is not required.
     ++input by path is not required. Multiple entries provided with the same path
     ++are deduplicated, with only the last one specified added to the tree.
       
       GIT
       ---
     @@ builtin/mktree.c
       	struct object_id oid;
       	int len;
      @@ builtin/mktree.c: static void append_to_tree(unsigned mode, struct object_id *oid, const char *pat
     + 	ent-&gt;len = len;
       	oidcpy(&#38;ent-&gt;oid, oid);
       
     - 	/* Append the update */
      +	ent-&gt;order = arr-&gt;nr;
       	tree_entry_array_push(arr, ent);
       }
     @@ t/t1010-mktree.sh: test_expect_success &#39;--literally can create invalid trees&#39; &#39;
       
       	# Valid: tree with or without trailing slash, blob without trailing slash
      @@ t/t1010-mktree.sh: test_expect_success &#39;mktree validates path&#39; &#39;
     - 	grep &#34;invalid path ${SQ}.git/${SQ}&#34; err
     + 	test_grep &#34;invalid path ${SQ}.git/${SQ}&#34; err
       &#39;
       
      +test_expect_success &#39;mktree with duplicate entries&#39; &#39;
 11:  130413f2404 = 12:  2333775ba5b mktree: create tree using an in-core index
 12:  94d6615d634 ! 13:  56f28efff54 mktree: use iterator struct to add tree entries to index
     @@ builtin/mktree.c: static void sort_and_dedup_tree_entry_array(struct tree_entry_
      +	} priv;
      +};
      +
     -+static void init_tree_entry_iterator(struct tree_entry_iterator *iter,
     ++static void tree_entry_iterator_init(struct tree_entry_iterator *iter,
      +				     struct tree_entry_array *arr)
      +{
      +	iter-&gt;priv.arr = arr;
     @@ builtin/mktree.c: static void sort_and_dedup_tree_entry_array(struct tree_entry_
      +}
      +
      +/*
     -+ * Advance the tree entry iterator to the next entry in the array. If no entries
     -+ * remain, &#39;current&#39; is set to NULL. Returns the previous &#39;current&#39; value of the
     -+ * iterator.
     ++ * Advance the tree entry iterator to the next entry in the array. If no
     ++ * entries remain, &#39;current&#39; is set to NULL.
      + */
     -+static struct tree_entry *advance_tree_entry_iterator(struct tree_entry_iterator *iter)
     ++static void tree_entry_iterator_advance(struct tree_entry_iterator *iter)
      +{
     -+	struct tree_entry *prev = iter-&gt;current;
      +	iter-&gt;current = (iter-&gt;priv.idx + 1) &lt; iter-&gt;priv.arr-&gt;nr
      +			? iter-&gt;priv.arr-&gt;entries[++iter-&gt;priv.idx]
      +			: NULL;
     -+	return prev;
      +}
      +
       static int add_tree_entry_to_index(struct index_state *istate,
     @@ builtin/mktree.c: static int add_tree_entry_to_index(struct index_state *istate,
       static void write_tree(struct tree_entry_array *arr, struct object_id *oid)
       {
      +	struct tree_entry_iterator iter = { NULL };
     -+	struct tree_entry *ent;
       	struct index_state istate = INDEX_STATE_INIT(the_repository);
       	istate.sparse_index = 1;
       
     @@ builtin/mktree.c: static int add_tree_entry_to_index(struct index_state *istate,
      -	/* Construct an in-memory index from the provided entries */
      -	for (size_t i = 0; i &lt; arr-&gt;nr; i++) {
      -		struct tree_entry *ent = arr-&gt;entries[i];
     -+	init_tree_entry_iterator(&#38;iter, arr);
     - 
     ++	tree_entry_iterator_init(&#38;iter, arr);
     ++
      +	/* Construct an in-memory index from the provided entries &#38; base tree */
     -+	while ((ent = advance_tree_entry_iterator(&#38;iter))) {
     ++	while (iter.current) {
     ++		struct tree_entry *ent = iter.current;
     ++		tree_entry_iterator_advance(&#38;iter);
     + 
       		if (add_tree_entry_to_index(&#38;istate, ent))
       			die(_(&#34;failed to add tree entry &#39;%s&#39;&#34;), ent-&gt;name);
     - 	}
 13:  68acdd3c5ee ! 14:  6f6d78ae7ac mktree: add directory-file conflict hashmap
     @@ builtin/mktree.c: static inline size_t df_path_len(size_t pathlen, unsigned int
      +	       name_compare(e1-&gt;name, e1_len, e2-&gt;name, e2_len);
      +}
      +
     -+static void init_tree_entry_array(struct tree_entry_array *arr)
     ++static void tree_entry_array_init(struct tree_entry_array *arr)
      +{
      +	hashmap_init(&#38;arr-&gt;df_name_hash, df_name_hash_cmp, NULL, 0);
      +}
     @@ builtin/mktree.c: static inline size_t df_path_len(size_t pathlen, unsigned int
       static void tree_entry_array_push(struct tree_entry_array *arr, struct tree_entry *ent)
       {
       	ALLOC_GROW(arr-&gt;entries, arr-&gt;nr + 1, arr-&gt;alloc);
     -@@ builtin/mktree.c: static void tree_entry_array_push(struct tree_entry_array *arr, struct tree_entr
     - 
     - static void clear_tree_entry_array(struct tree_entry_array *arr)
     - {
     -+	hashmap_clear(&#38;arr-&gt;df_name_hash);
     - 	for (size_t i = 0; i &lt; arr-&gt;nr; i++)
     - 		FREE_AND_NULL(arr-&gt;entries[i]);
     +@@ builtin/mktree.c: static void tree_entry_array_clear(struct tree_entry_array *arr, int free_entrie
     + 			FREE_AND_NULL(arr-&gt;entries[i]);
     + 	}
       	arr-&gt;nr = 0;
     -@@ builtin/mktree.c: static void clear_tree_entry_array(struct tree_entry_array *arr)
     - 
     - static void release_tree_entry_array(struct tree_entry_array *arr)
     - {
      +	hashmap_clear(&#38;arr-&gt;df_name_hash);
     - 	FREE_AND_NULL(arr-&gt;entries);
     - 	arr-&gt;nr = arr-&gt;alloc = 0;
       }
     + 
     + static void tree_entry_array_release(struct tree_entry_array *arr, int free_entries)
      @@ builtin/mktree.c: static void sort_and_dedup_tree_entry_array(struct tree_entry_array *arr)
       	/* Sort again to order the entries for tree insertion */
       	ignore_mode = 0;
     @@ builtin/mktree.c: int cmd_mktree(int ac, const char **av, const char *prefix)
       
       	ac = parse_options(ac, av, prefix, option, mktree_usage, 0);
       
     -+	init_tree_entry_array(&#38;arr);
     ++	tree_entry_array_init(&#38;arr);
      +
       	do {
     - 		ret = read_index_info(nul_term_line, mktree_line, &#38;mktree_line_data);
     + 		ret = read_index_info(nul_term_line, mktree_line, &#38;mktree_line_data, &#38;line);
       		if (ret &lt; 0)
 14:  df0c50dfea3 ! 15:  4b88f84b933 mktree: optionally add to an existing tree
     @@ Documentation/git-mktree.txt: git-mktree - Build a tree-object from formatted tr
       --------
       [verse]
      -&#39;git mktree&#39; [-z] [--missing] [--literally] [--batch]
     -+&#39;git mktree&#39; [-z] [--missing] [--literally] [--batch] [--] [&lt;tree-ish&gt;]
     ++&#39;git mktree&#39; [-z] [--missing] [--literally] [--batch] [&lt;tree-ish&gt;]
       
       DESCRIPTION
       -----------
     @@ Documentation/git-mktree.txt: OPTIONS
       	with NUL.
       
      +&lt;tree-ish&gt;::
     -+	If provided, the tree entries provided in stdin are added to this tree
     -+	rather than a new empty one, replacing existing entries with identical
     -+	names. Not compatible with `--literally`.
     ++	If provided, the tree entries provided in stdin are added to this
     ++	tree rather than a new empty one, replacing existing entries with
     ++	identical names. Not compatible with `--literally`.
      +
       INPUT FORMAT
       ------------
     @@ builtin/mktree.c
       #include &#34;object-store-ll.h&#34;
       
       struct tree_entry {
     -@@ builtin/mktree.c: static struct tree_entry *advance_tree_entry_iterator(struct tree_entry_iterator
     - 	return prev;
     +@@ builtin/mktree.c: static void tree_entry_iterator_advance(struct tree_entry_iterator *iter)
     + 			: NULL;
       }
       
      -static int add_tree_entry_to_index(struct index_state *istate,
     @@ builtin/mktree.c: static struct tree_entry *advance_tree_entry_iterator(struct t
      +				 unsigned mode, void *context)
       {
      -	struct tree_entry_iterator iter = { NULL };
     +-	struct index_state istate = INDEX_STATE_INIT(the_repository);
     +-	istate.sparse_index = 1;
      +	int result;
      +	struct tree_entry *base_tree_ent;
      +	struct build_index_data *cbdata = context;
     @@ builtin/mktree.c: static struct tree_entry *advance_tree_entry_iterator(struct t
      +		int cmp = name_compare(ent-&gt;name, ent-&gt;len,
      +				       base_tree_ent-&gt;name, base_tree_ent-&gt;len);
      +		if (!cmp || cmp &lt; 0) {
     -+			advance_tree_entry_iterator(&#38;cbdata-&gt;iter);
     ++			tree_entry_iterator_advance(&#38;cbdata-&gt;iter);
      +
      +			if (add_tree_entry_to_index(cbdata, ent) &lt; 0) {
      +				result = error(_(&#34;failed to add tree entry &#39;%s&#39;&#34;), ent-&gt;name);
     @@ builtin/mktree.c: static struct tree_entry *advance_tree_entry_iterator(struct t
      +		       struct object_id *oid)
      +{
      +	struct build_index_data cbdata = { 0 };
     - 	struct tree_entry *ent;
     --	struct index_state istate = INDEX_STATE_INIT(the_repository);
     --	istate.sparse_index = 1;
      +	struct pathspec ps = { 0 };
       
       	sort_and_dedup_tree_entry_array(arr);
       
     --	init_tree_entry_iterator(&#38;iter, arr);
     +-	tree_entry_iterator_init(&#38;iter, arr);
      +	index_state_init(&#38;cbdata.istate, the_repository);
      +	cbdata.istate.sparse_index = 1;
     -+	init_tree_entry_iterator(&#38;cbdata.iter, arr);
     ++	tree_entry_iterator_init(&#38;cbdata.iter, arr);
      +	cbdata.df_name_hash = &#38;arr-&gt;df_name_hash;
       
       	/* Construct an in-memory index from the provided entries &#38; base tree */
     --	while ((ent = advance_tree_entry_iterator(&#38;iter))) {
     --		if (add_tree_entry_to_index(&#38;istate, ent))
     +-	while (iter.current) {
     +-		struct tree_entry *ent = iter.current;
     +-		tree_entry_iterator_advance(&#38;iter);
      +	if (base_tree &#38;&#38;
      +	    read_tree(the_repository, base_tree, &#38;ps, build_index_from_tree, &#38;cbdata) &lt; 0)
      +		die(_(&#34;failed to create tree&#34;));
      +
     -+	while ((ent = advance_tree_entry_iterator(&#38;cbdata.iter))) {
     ++	while (cbdata.iter.current) {
     ++		struct tree_entry *ent = cbdata.iter.current;
     ++		tree_entry_iterator_advance(&#38;cbdata.iter);
     + 
     +-		if (add_tree_entry_to_index(&#38;istate, ent))
      +		if (add_tree_entry_to_index(&#38;cbdata, ent))
       			die(_(&#34;failed to add tree entry &#39;%s&#39;&#34;), ent-&gt;name);
       	}
     @@ builtin/mktree.c: static void write_tree_literally(struct tree_entry_array *arr,
       
       static const char *mktree_usage[] = {
      -	&#34;git mktree [-z] [--missing] [--literally] [--batch]&#34;,
     -+	&#34;git mktree [-z] [--missing] [--literally] [--batch] [--] [&lt;tree-ish&gt;]&#34;,
     ++	&#34;git mktree [-z] [--missing] [--literally] [--batch] [&lt;tree-ish&gt;]&#34;,
       	NULL
       };
       
      @@ builtin/mktree.c: int cmd_mktree(int ac, const char **av, const char *prefix)
     - 	int is_batch_mode = 0;
       	struct tree_entry_array arr = { 0 };
       	struct mktree_line_data mktree_line_data = { .arr = &#38;arr };
     + 	struct strbuf line = STRBUF_INIT;
      +	struct tree *base_tree = NULL;
       	int ret;
       
     @@ builtin/mktree.c: int cmd_mktree(int ac, const char **av, const char *prefix)
      +			die(_(&#34;not a tree object: %s&#34;), oid_to_hex(&#38;base_tree_oid));
      +	}
       
     - 	init_tree_entry_array(&#38;arr);
     + 	tree_entry_array_init(&#38;arr);
       
      @@ builtin/mktree.c: int cmd_mktree(int ac, const char **av, const char *prefix)
       			if (mktree_line_data.literally)
 15:  058354f45f7 ! 16:  46756c4e314 mktree: allow deeper paths in input
     @@ Commit message
          Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
      
       ## Documentation/git-mktree.txt ##
     -@@ Documentation/git-mktree.txt: INPUT FORMAT
     - Tree entries may be specified in any of the formats compatible with the
     - `--index-info` option to linkgit:git-update-index[1].
     +@@ Documentation/git-mktree.txt: Higher stages represent conflicted files in an index; this information
     + cannot be represented in a tree object. The command will fail without
     + writing the tree if a higher order stage is specified for any entry.
       
      +Entries may use full pathnames containing directory separators to specify
     -+entries nested within one or more directories. These entries are inserted into
     -+the appropriate tree in the base tree-ish if one exists. Otherwise, empty parent
     -+trees are created to contain the entries.
     ++entries nested within one or more directories. These entries are inserted
     ++into the appropriate tree in the base tree-ish if one exists. Otherwise,
     ++empty parent trees are created to contain the entries.
      +
     - The order of the tree entries is normalized by `mktree` so pre-sorting the input
     - by path is not required. Multiple entries provided with the same path are
     - deduplicated, with only the last one specified added to the tree.
     + The order of the tree entries is normalized by `mktree` so pre-sorting the
     + input by path is not required. Multiple entries provided with the same path
     + are deduplicated, with only the last one specified added to the tree.
      
       ## builtin/mktree.c ##
      @@ builtin/mktree.c: struct tree_entry {
     @@ builtin/mktree.c: static void tree_entry_array_push(struct tree_entry_array *arr
      +	return arr-&gt;entries[--arr-&gt;nr];
      +}
      +
     - static void clear_tree_entry_array(struct tree_entry_array *arr)
     + static void tree_entry_array_clear(struct tree_entry_array *arr, int free_entries)
       {
     - 	hashmap_clear(&#38;arr-&gt;df_name_hash);
     + 	if (free_entries) {
      @@ builtin/mktree.c: static void append_to_tree(unsigned mode, struct object_id *oid, const char *pat
       
       		if (!verify_path(ent-&gt;name, mode))
     @@ builtin/mktree.c: static void sort_and_dedup_tree_entry_array(struct tree_entry_
      +			}
      +		}
      +
     -+		release_tree_entry_array(&#38;parent_dir_ents);
     ++		tree_entry_array_release(&#38;parent_dir_ents, 0);
      +	}
      +
       	/* Finally, initialize the directory-file conflict hash map */
     @@ builtin/mktree.c: static int build_index_from_tree(const struct object_id *oid,
      +		cmp = name_compare(ent-&gt;name, ent-&gt;len,
      +				   base_tree_ent-&gt;name, base_tree_ent-&gt;len);
       		if (!cmp || cmp &lt; 0) {
     - 			advance_tree_entry_iterator(&#38;cbdata-&gt;iter);
     + 			tree_entry_iterator_advance(&#38;cbdata-&gt;iter);
       
      @@ builtin/mktree.c: static int build_index_from_tree(const struct object_id *oid,
       				goto cleanup_and_return;
     @@ builtin/mktree.c: static int build_index_from_tree(const struct object_id *oid,
      
       ## t/t1010-mktree.sh ##
      @@ t/t1010-mktree.sh: test_expect_success &#39;mktree with invalid submodule OIDs&#39; &#39;
     - 	grep &#34;object $tree_oid is a tree but specified type was (commit)&#34; err
     + 	done
       &#39;
       
      -test_expect_success &#39;mktree refuses to read ls-tree -r output (1)&#39; &#39;
     @@ t/t1010-mktree.sh: test_expect_success &#39;mktree with base tree&#39; &#39;
      +		printf &#34;100644 blob $blob_oid\ttest/deeper\n&#34;
      +	} |
      +	test_must_fail git mktree 2&gt;err &#38;&#38;
     -+	grep &#34;You have both test and test/deeper&#34; err &#38;&#38;
     ++	test_grep &#34;You have both test and test/deeper&#34; err &#38;&#38;
      +
      +	{
      +		printf &#34;100644 blob $blob_oid\tfolder/one/deeper/deep\n&#34;
      +	} |
      +	test_must_fail git mktree $tree_oid 2&gt;err &#38;&#38;
     -+	grep &#34;You have both folder/one and folder/one/deeper/deep&#34; err
     ++	test_grep &#34;You have both folder/one and folder/one/deeper/deep&#34; err
      +&#39;
      +
       test_done
 16:  a90d6d0c943 ! 17:  d392c440b8a mktree: remove entries when mode is 0
     @@ Commit message
          Signed-off-by: Victoria Dye &lt;vdye@github.com&gt;
      
       ## Documentation/git-mktree.txt ##
     -@@ Documentation/git-mktree.txt: entries nested within one or more directories. These entries are inserted into
     - the appropriate tree in the base tree-ish if one exists. Otherwise, empty parent
     - trees are created to contain the entries.
     +@@ Documentation/git-mktree.txt: entries nested within one or more directories. These entries are inserted
     + into the appropriate tree in the base tree-ish if one exists. Otherwise,
     + empty parent trees are created to contain the entries.
       
     -+An entry with a mode of &#34;0&#34; will remove an entry of the same name from the base
     -+tree-ish. If no tree-ish argument is given, or the entry does not exist in that
     -+tree, the entry is ignored.
     ++An entry with a mode of &#34;0&#34; will remove an entry of the same name from the
     ++base tree-ish. If no tree-ish argument is given, or the entry does not exist
     ++in that tree, the entry is ignored.
      +
     - The order of the tree entries is normalized by `mktree` so pre-sorting the input
     - by path is not required. Multiple entries provided with the same path are
     - deduplicated, with only the last one specified added to the tree.
     + The order of the tree entries is normalized by `mktree` so pre-sorting the
     + input by path is not required. Multiple entries provided with the same path
     + are deduplicated, with only the last one specified added to the tree.
      
       ## builtin/mktree.c ##
      @@ builtin/mktree.c: struct tree_entry {
     @@ builtin/mktree.c: static int build_index_from_tree(const struct object_id *oid,
       		int ret = 0;
       		struct pathspec ps = { 0 };
      @@ builtin/mktree.c: static int mktree_line(unsigned int mode, struct object_id *oid,
     - 		       const char *path, void *cbdata)
     - {
     - 	struct mktree_line_data *data = cbdata;
     --	enum object_type mode_type = object_type(mode);
     --	struct object_info oi = OBJECT_INFO_INIT;
     --	enum object_type parsed_obj_type;
     - 
     --	if (obj_type &#38;&#38; mode_type != obj_type)
     --		die(&#34;object type (%s) doesn&#39;t match mode type (%s)&#34;,
     --		    type_name(obj_type), type_name(mode_type));
     -+	if (mode) {
     -+		struct object_info oi = OBJECT_INFO_INIT;
     -+		enum object_type parsed_obj_type;
     -+		enum object_type mode_type = object_type(mode);
     - 
     --	oi.typep = &#38;parsed_obj_type;
     -+		if (obj_type &#38;&#38; mode_type != obj_type)
     -+			die(&#34;object type (%s) doesn&#39;t match mode type (%s)&#34;,
     -+			    type_name(obj_type), type_name(mode_type));
     + 	if (stage)
     + 		die(_(&#34;path &#39;%s&#39; is unmerged&#34;), path);
       
     --	if (oid_object_info_extended(the_repository, oid, &#38;oi,
     --				     OBJECT_INFO_LOOKUP_REPLACE |
     --				     OBJECT_INFO_QUICK |
     --				     OBJECT_INFO_SKIP_FETCH_OBJECT) &lt; 0)
     --		parsed_obj_type = -1;
     -+		oi.typep = &#38;parsed_obj_type;
     - 
     --	if (parsed_obj_type &lt; 0) {
     --		if (data-&gt;allow_missing || S_ISGITLINK(mode)) {
     --			; /* no problem - missing objects &#38; submodules are presumed to be of the right type */
     --		} else {
     --			die(&#34;entry &#39;%s&#39; object %s is unavailable&#34;, path, oid_to_hex(oid));
     -+		if (oid_object_info_extended(the_repository, oid, &#38;oi,
     -+					     OBJECT_INFO_LOOKUP_REPLACE |
     -+					     OBJECT_INFO_QUICK |
     -+					     OBJECT_INFO_SKIP_FETCH_OBJECT) &lt; 0)
     -+			parsed_obj_type = -1;
     ++	/* OID ignored for zero-mode entries; append unconditionally */
     ++	if (!mode)
     ++		goto append_entry;
      +
     -+		if (parsed_obj_type &lt; 0) {
     -+			if (data-&gt;allow_missing || S_ISGITLINK(mode)) {
     -+				; /* no problem - missing objects &#38; submodules are presumed to be of the right type */
     -+			} else {
     -+				die(&#34;entry &#39;%s&#39; object %s is unavailable&#34;, path, oid_to_hex(oid));
     -+			}
     -+		} else if (parsed_obj_type != mode_type) {
     -+			/*
     -+			* The object exists but is of the wrong type.
     -+			* This is a problem regardless of allow_missing
     -+			* because the new tree entry will never be correct.
     -+			*/
     -+			die(&#34;entry &#39;%s&#39; object %s is a %s but specified type was (%s)&#34;,
     -+			path, oid_to_hex(oid), type_name(parsed_obj_type), type_name(mode_type));
     + 	if (obj_type != OBJ_ANY &#38;&#38; mode_type != obj_type)
     + 		die(&#34;object type (%s) doesn&#39;t match mode type (%s)&#34;,
     + 		    type_name(obj_type), type_name(mode_type));
     +@@ builtin/mktree.c: static int mktree_line(unsigned int mode, struct object_id *oid,
       		}
     --	} else if (parsed_obj_type != mode_type) {
     --		/*
     --		 * The object exists but is of the wrong type.
     --		 * This is a problem regardless of allow_missing
     --		 * because the new tree entry will never be correct.
     --		 */
     --		die(&#34;entry &#39;%s&#39; object %s is a %s but specified type was (%s)&#34;,
     --		    path, oid_to_hex(oid), type_name(parsed_obj_type), type_name(mode_type));
       	}
       
     ++append_entry:
       	append_to_tree(mode, oid, path, data-&gt;arr, data-&gt;literally);
     + 	return 0;
     + }
      
       ## t/t1010-mktree.sh ##
      @@ t/t1010-mktree.sh: test_expect_success &#39;mktree fails on directory-file conflict&#39; &#39;
     - 	grep &#34;You have both folder/one and folder/one/deeper/deep&#34; err
     + 	test_grep &#34;You have both folder/one and folder/one/deeper/deep&#34; err
       &#39;
       
      +test_expect_success &#39;mktree with remove entries&#39; &#39;

-- 
gitgitgadget
</pre></div></content></entry><entry><author><name>Ghanshyam Thakkar</name><email>shyamthakkar001@gmail.com</email></author><title>[GSoC][PATCH] t: migrate helper/test-oidmap.c to unit-tests/t-oidmap.c</title><updated>2024-06-19T17:50:51Z</updated><link
href="http://lore.kernel.org/git/20240619175036.64291-1-shyamthakkar001@gmail.com/"/><id>urn:uuid:cfac487a-68d2-8476-3830-8aa4eb4d2814</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">helper/test-oidmap.c along with t0016-oidmap.sh test the oidmap.h
library which is built on top of hashmap.h to store arbitrary
datastructure (which must contain oidmap_entry, which is a wrapper
around object_id). These entries can be accessed by querying their
associated object_id.

Migrate them to the unit testing framework for better performance,
concise code and better debugging. Along with the migration also plug
memory leaks and make the test logic independent for all the tests.
The migration removes &#39;put&#39; tests from t0016, because it is used as
setup to all the other tests, so testing it separately does not yield
any benefit.

Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Mentored-by: Kaartic Sivaraam &lt;kaartic.sivaraam@gmail.com&gt;
Signed-off-by: Ghanshyam Thakkar &lt;shyamthakkar001@gmail.com&gt;
---
This patch is depenedent on &#39;gt/unit-test-oidtree&#39; for lib-oid.

 Makefile                |   2 +-
 t/helper/test-oidmap.c  | 123 ------------------------------
 t/helper/test-tool.c    |   1 -
 t/helper/test-tool.h    |   1 -
 t/t0016-oidmap.sh       | 112 ---------------------------
 t/unit-tests/t-oidmap.c | 165 ++++++++++++++++++++++++++++++++++++++++
 6 files <a href="http://lore.kernel.org/git/20240619175036.64291-1-shyamthakkar001@gmail.com/#related">changed</a>, 166 insertions(+), 238 deletions(-)
 delete mode 100644 t/helper/test-oidmap.c
 delete mode 100755 t/t0016-oidmap.sh
 create mode 100644 t/unit-tests/t-oidmap.c

<span
class="head">diff --git a/Makefile b/Makefile
index 03751e0fc0..f7ed50f3a9 100644
--- a/Makefile
+++ b/Makefile
</span><span
class="hunk">@@ -810,7 +810,6 @@ TEST_BUILTINS_OBJS += test-match-trees.o
</span> TEST_BUILTINS_OBJS += test-mergesort.o
 TEST_BUILTINS_OBJS += test-mktemp.o
 TEST_BUILTINS_OBJS += test-oid-array.o
<span
class="del">-TEST_BUILTINS_OBJS += test-oidmap.o
</span> TEST_BUILTINS_OBJS += test-online-cpus.o
 TEST_BUILTINS_OBJS += test-pack-mtimes.o
 TEST_BUILTINS_OBJS += test-parse-options.o
<span
class="hunk">@@ -1334,6 +1333,7 @@ THIRD_PARTY_SOURCES += sha1dc/%
</span> 
 UNIT_TEST_PROGRAMS += t-ctype
 UNIT_TEST_PROGRAMS += t-mem-pool
<span
class="add">+UNIT_TEST_PROGRAMS += t-oidmap
</span> UNIT_TEST_PROGRAMS += t-oidtree
 UNIT_TEST_PROGRAMS += t-prio-queue
 UNIT_TEST_PROGRAMS += t-strbuf
<span
class="head">diff --git a/t/helper/test-oidmap.c b/t/helper/test-oidmap.c
deleted file mode 100644
index bd30244a54..0000000000
--- a/t/helper/test-oidmap.c
+++ /dev/null
</span><span
class="hunk">@@ -1,123 +0,0 @@
</span><span
class="del">-#include &#34;test-tool.h&#34;
-#include &#34;hex.h&#34;
-#include &#34;object-name.h&#34;
-#include &#34;oidmap.h&#34;
-#include &#34;repository.h&#34;
-#include &#34;setup.h&#34;
-#include &#34;strbuf.h&#34;
-#include &#34;string-list.h&#34;
-
-/* key is an oid and value is a name (could be a refname for example) */
-struct test_entry {
-	struct oidmap_entry entry;
-	char name[FLEX_ARRAY];
-};
-
-#define DELIM &#34; \t\r\n&#34;
-
-/*
- * Read stdin line by line and print result of commands to stdout:
- *
- * hash oidkey -&gt; sha1hash(oidkey)
- * put oidkey namevalue -&gt; NULL / old namevalue
- * get oidkey -&gt; NULL / namevalue
- * remove oidkey -&gt; NULL / old namevalue
- * iterate -&gt; oidkey1 namevalue1\noidkey2 namevalue2\n...
- *
- */
-int cmd__oidmap(int argc UNUSED, const char **argv UNUSED)
-{
-	struct string_list parts = STRING_LIST_INIT_NODUP;
-	struct strbuf line = STRBUF_INIT;
-	struct oidmap map = OIDMAP_INIT;
-
-	setup_git_directory();
-
-	/* init oidmap */
-	oidmap_init(&#38;map, 0);
-
-	/* process commands from stdin */
-	while (strbuf_getline(&#38;line, stdin) != EOF) {
-		char *cmd, *p1, *p2;
-		struct test_entry *entry;
-		struct object_id oid;
-
-		/* break line into command and up to two parameters */
-		string_list_setlen(&#38;parts, 0);
-		string_list_split_in_place(&#38;parts, line.buf, DELIM, 2);
-		string_list_remove_empty_items(&#38;parts, 0);
-
-		/* ignore empty lines */
-		if (!parts.nr)
-			continue;
-		if (!*parts.items[0].string || *parts.items[0].string == &#39;#&#39;)
-			continue;
-
-		cmd = parts.items[0].string;
-		p1 = parts.nr &gt;= 1 ? parts.items[1].string : NULL;
-		p2 = parts.nr &gt;= 2 ? parts.items[2].string : NULL;
-
-		if (!strcmp(&#34;put&#34;, cmd) &#38;&#38; p1 &#38;&#38; p2) {
-
-			if (repo_get_oid(the_repository, p1, &#38;oid)) {
-				printf(&#34;Unknown oid: %s\n&#34;, p1);
-				continue;
-			}
-
-			/* create entry with oid_key = p1, name_value = p2 */
-			FLEX_ALLOC_STR(entry, name, p2);
-			oidcpy(&#38;entry-&gt;entry.oid, &#38;oid);
-
-			/* add / replace entry */
-			entry = oidmap_put(&#38;map, entry);
-
-			/* print and free replaced entry, if any */
-			puts(entry ? entry-&gt;name : &#34;NULL&#34;);
-			free(entry);
-
-		} else if (!strcmp(&#34;get&#34;, cmd) &#38;&#38; p1) {
-
-			if (repo_get_oid(the_repository, p1, &#38;oid)) {
-				printf(&#34;Unknown oid: %s\n&#34;, p1);
-				continue;
-			}
-
-			/* lookup entry in oidmap */
-			entry = oidmap_get(&#38;map, &#38;oid);
-
-			/* print result */
-			puts(entry ? entry-&gt;name : &#34;NULL&#34;);
-
-		} else if (!strcmp(&#34;remove&#34;, cmd) &#38;&#38; p1) {
-
-			if (repo_get_oid(the_repository, p1, &#38;oid)) {
-				printf(&#34;Unknown oid: %s\n&#34;, p1);
-				continue;
-			}
-
-			/* remove entry from oidmap */
-			entry = oidmap_remove(&#38;map, &#38;oid);
-
-			/* print result and free entry*/
-			puts(entry ? entry-&gt;name : &#34;NULL&#34;);
-			free(entry);
-
-		} else if (!strcmp(&#34;iterate&#34;, cmd)) {
-
-			struct oidmap_iter iter;
-			oidmap_iter_init(&#38;map, &#38;iter);
-			while ((entry = oidmap_iter_next(&#38;iter)))
-				printf(&#34;%s %s\n&#34;, oid_to_hex(&#38;entry-&gt;entry.oid), entry-&gt;name);
-
-		} else {
-
-			printf(&#34;Unknown command %s\n&#34;, cmd);
-
-		}
-	}
-
-	string_list_clear(&#38;parts, 0);
-	strbuf_release(&#38;line);
-	oidmap_free(&#38;map, 1);
-	return 0;
-}
</span><span
class="head">diff --git a/t/helper/test-tool.c b/t/helper/test-tool.c
index 253324a06b..5f013d8b2b 100644
--- a/t/helper/test-tool.c
+++ b/t/helper/test-tool.c
</span><span
class="hunk">@@ -45,7 +45,6 @@ static struct test_cmd cmds[] = {
</span> 	{ &#34;mergesort&#34;, cmd__mergesort },
 	{ &#34;mktemp&#34;, cmd__mktemp },
 	{ &#34;oid-array&#34;, cmd__oid_array },
<span
class="del">-	{ &#34;oidmap&#34;, cmd__oidmap },
</span> 	{ &#34;online-cpus&#34;, cmd__online_cpus },
 	{ &#34;pack-mtimes&#34;, cmd__pack_mtimes },
 	{ &#34;parse-options&#34;, cmd__parse_options },
<span
class="head">diff --git a/t/helper/test-tool.h b/t/helper/test-tool.h
index 460dd7d260..c7d3e43694 100644
--- a/t/helper/test-tool.h
+++ b/t/helper/test-tool.h
</span><span
class="hunk">@@ -38,7 +38,6 @@ int cmd__lazy_init_name_hash(int argc, const char **argv);
</span> int cmd__match_trees(int argc, const char **argv);
 int cmd__mergesort(int argc, const char **argv);
 int cmd__mktemp(int argc, const char **argv);
<span
class="del">-int cmd__oidmap(int argc, const char **argv);
</span> int cmd__online_cpus(int argc, const char **argv);
 int cmd__pack_mtimes(int argc, const char **argv);
 int cmd__parse_options(int argc, const char **argv);
<span
class="head">diff --git a/t/t0016-oidmap.sh b/t/t0016-oidmap.sh
deleted file mode 100755
index 0faef1f4f1..0000000000
--- a/t/t0016-oidmap.sh
+++ /dev/null
</span><span
class="hunk">@@ -1,112 +0,0 @@
</span><span
class="del">-#!/bin/sh
-
-test_description=&#39;test oidmap&#39;
-
-TEST_PASSES_SANITIZE_LEAK=true
-. ./test-lib.sh
-
-# This purposefully is very similar to t0011-hashmap.sh
-
-test_oidmap () {
-	echo &#34;$1&#34; | test-tool oidmap $3 &gt;actual &#38;&#38;
-	echo &#34;$2&#34; &gt;expect &#38;&#38;
-	test_cmp expect actual
-}
-
-
-test_expect_success &#39;setup&#39; &#39;
-
-	test_commit one &#38;&#38;
-	test_commit two &#38;&#38;
-	test_commit three &#38;&#38;
-	test_commit four
-
-&#39;
-
-test_expect_success &#39;put&#39; &#39;
-
-test_oidmap &#34;put one 1
-put two 2
-put invalidOid 4
-put three 3&#34; &#34;NULL
-NULL
-Unknown oid: invalidOid
-NULL&#34;
-
-&#39;
-
-test_expect_success &#39;replace&#39; &#39;
-
-test_oidmap &#34;put one 1
-put two 2
-put three 3
-put invalidOid 4
-put two deux
-put one un&#34; &#34;NULL
-NULL
-NULL
-Unknown oid: invalidOid
-2
-1&#34;
-
-&#39;
-
-test_expect_success &#39;get&#39; &#39;
-
-test_oidmap &#34;put one 1
-put two 2
-put three 3
-get two
-get four
-get invalidOid
-get one&#34; &#34;NULL
-NULL
-NULL
-2
-NULL
-Unknown oid: invalidOid
-1&#34;
-
-&#39;
-
-test_expect_success &#39;remove&#39; &#39;
-
-test_oidmap &#34;put one 1
-put two 2
-put three 3
-remove one
-remove two
-remove invalidOid
-remove four&#34; &#34;NULL
-NULL
-NULL
-1
-2
-Unknown oid: invalidOid
-NULL&#34;
-
-&#39;
-
-test_expect_success &#39;iterate&#39; &#39;
-	test-tool oidmap &gt;actual.raw &lt;&lt;-\EOF &#38;&#38;
-	put one 1
-	put two 2
-	put three 3
-	iterate
-	EOF
-
-	# sort &#34;expect&#34; too so we do not rely on the order of particular oids
-	sort &gt;expect &lt;&lt;-EOF &#38;&#38;
-	NULL
-	NULL
-	NULL
-	$(git rev-parse one) 1
-	$(git rev-parse two) 2
-	$(git rev-parse three) 3
-	EOF
-
-	sort &lt;actual.raw &gt;actual &#38;&#38;
-	test_cmp expect actual
-&#39;
-
-test_done
</span><span
class="head">diff --git a/t/unit-tests/t-oidmap.c b/t/unit-tests/t-oidmap.c
new file mode 100644
index 0000000000..9b98a3ed09
--- /dev/null
+++ b/t/unit-tests/t-oidmap.c
</span><span
class="hunk">@@ -0,0 +1,165 @@
</span><span
class="add">+#include &#34;test-lib.h&#34;
+#include &#34;lib-oid.h&#34;
+#include &#34;oidmap.h&#34;
+#include &#34;hash.h&#34;
+#include &#34;hex.h&#34;
+
+/*
+ * elements we will put in oidmap structs are made of a key: the entry.oid
+ * field, which is of type struct object_id, and a value: the name field (could
+ * be a refname for example)
+ */
+struct test_entry {
+	struct oidmap_entry entry;
+	char name[FLEX_ARRAY];
+};
+
+static const char *key_val[][2] = { { &#34;11&#34;, &#34;one&#34; },
+				    { &#34;22&#34;, &#34;two&#34; },
+				    { &#34;33&#34;, &#34;three&#34; } };
+
+static int put_and_check_null(struct oidmap *map, const char *hex,
+			      const char *entry_name)
+{
+	struct test_entry *entry;
+
+	FLEX_ALLOC_STR(entry, name, entry_name);
+	if (get_oid_arbitrary_hex(hex, &#38;entry-&gt;entry.oid))
+		return -1;
+	if (!check(oidmap_put(map, entry) == NULL))
+		return -1;
+	return 0;
+}
+
+static void setup(void (*f)(struct oidmap *map))
+{
+	struct oidmap map = OIDMAP_INIT;
+	int ret = 0;
+
+	for (size_t i = 0; i &lt; ARRAY_SIZE(key_val); i++)
+		if ((ret = put_and_check_null(&#38;map, key_val[i][0],
+					      key_val[i][1])))
+			break;
+
+	if (!ret)
+		f(&#38;map);
+	oidmap_free(&#38;map, 1);
+}
+
+static void t_replace(struct oidmap *map)
+{
+	struct test_entry *entry, *prev;
+
+	FLEX_ALLOC_STR(entry, name, &#34;un&#34;);
+	if (get_oid_arbitrary_hex(&#34;11&#34;, &#38;entry-&gt;entry.oid))
+		return;
+	prev = oidmap_put(map, entry);
+	if (!check(prev != NULL))
+		return;
+	check_str(prev-&gt;name, &#34;one&#34;);
+	free(prev);
+
+	FLEX_ALLOC_STR(entry, name, &#34;deux&#34;);
+	if (get_oid_arbitrary_hex(&#34;22&#34;, &#38;entry-&gt;entry.oid))
+		return;
+	prev = oidmap_put(map, entry);
+	if (!check(prev != NULL))
+		return;
+	check_str(prev-&gt;name, &#34;two&#34;);
+	free(prev);
+}
+
+static void t_get(struct oidmap *map)
+{
+	struct test_entry *entry;
+	struct object_id oid;
+
+	if (get_oid_arbitrary_hex(&#34;22&#34;, &#38;oid))
+		return;
+	entry = oidmap_get(map, &#38;oid);
+	if (!check(entry != NULL))
+		return;
+	check_str(entry-&gt;name, &#34;two&#34;);
+
+	if (get_oid_arbitrary_hex(&#34;44&#34;, &#38;oid))
+		return;
+	check(oidmap_get(map, &#38;oid) == NULL);
+
+	if (get_oid_arbitrary_hex(&#34;11&#34;, &#38;oid))
+		return;
+	entry = oidmap_get(map, &#38;oid);
+	if (!check(entry != NULL))
+		return;
+	check_str(entry-&gt;name, &#34;one&#34;);
+}
+
+static void t_remove(struct oidmap *map)
+{
+	struct test_entry *entry;
+	struct object_id oid;
+
+	if (get_oid_arbitrary_hex(&#34;11&#34;, &#38;oid))
+		return;
+	entry = oidmap_remove(map, &#38;oid);
+	if (!check(entry != NULL))
+		return;
+	check_str(entry-&gt;name, &#34;one&#34;);
+	check(oidmap_get(map, &#38;oid) == NULL);
+	free(entry);
+
+	if (get_oid_arbitrary_hex(&#34;22&#34;, &#38;oid))
+		return;
+	entry = oidmap_remove(map, &#38;oid);
+	if (!check(entry != NULL))
+		return;
+	check_str(entry-&gt;name, &#34;two&#34;);
+	check(oidmap_get(map, &#38;oid) == NULL);
+	free(entry);
+
+	if (get_oid_arbitrary_hex(&#34;44&#34;, &#38;oid))
+		return;
+	check(oidmap_remove(map, &#38;oid) == NULL);
+}
+
+static int key_val_contains(struct test_entry *entry)
+{
+	/* the test is small enough to be able to bear O(n) */
+	for (size_t i = 0; i &lt; ARRAY_SIZE(key_val); i++) {
+		if (!strcmp(key_val[i][1], entry-&gt;name)) {
+			struct object_id oid;
+			if (get_oid_arbitrary_hex(key_val[i][0], &#38;oid))
+				return -1;
+			if (oideq(&#38;entry-&gt;entry.oid, &#38;oid))
+				return 0;
+		}
+	}
+	return 1;
+}
+
+static void t_iterate(struct oidmap *map)
+{
+	struct oidmap_iter iter;
+	struct test_entry *entry;
+	int ret;
+
+	oidmap_iter_init(map, &#38;iter);
+	while ((entry = oidmap_iter_next(&#38;iter))) {
+		if (!check_int((ret = key_val_contains(entry)), ==, 0)) {
+			if (ret == -1)
+				return;
+			test_msg(&#34;obtained entry was not given in the input\n&#34;
+				 &#34;  name: %s\n   oid: %s\n&#34;,
+				 entry-&gt;name, oid_to_hex(&#38;entry-&gt;entry.oid));
+		}
+	}
+	check_int(hashmap_get_size(&#38;map-&gt;map), ==, ARRAY_SIZE(key_val));
+}
+
+int cmd_main(int argc UNUSED, const char **argv UNUSED)
+{
+	TEST(setup(t_replace), &#34;replace works&#34;);
+	TEST(setup(t_get), &#34;get works&#34;);
+	TEST(setup(t_remove), &#34;remove works&#34;);
+	TEST(setup(t_iterate), &#34;iterate works&#34;);
+	return test_done();
+}
</span>-- 
2.45.2

</pre></div></content></entry><entry><author><name>Randall S. Becker</name><email>the.n.e.key@gmail.com</email></author><title>[PATCH v0 1/1] Teach git version --build-options about OpenSSL</title><updated>2024-06-19T17:24:57Z</updated><link
href="http://lore.kernel.org/git/20240619172421.33548-2-randall.becker@nexbridge.ca/"/><id>urn:uuid:4815f088-2d15-ec2a-66b8-221ad8d55469</id><thr:in-reply-to
ref="urn:uuid:33d647fe-65b6-d287-9b5c-67e195ebccce"
href="http://lore.kernel.org/git/20240619172421.33548-1-randall.becker@nexbridge.ca/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This change uses the OpenSSL supplied OPENSSL_VERSION_TEXT #define supplied
for this purpose by that project. If the #define is not present, the version
is not reported.

Signed-off-by: Randall S. Becker &lt;rsbecker@nexbridge.com&gt;
---
 help.c | 3 +++
 1 file <a href="http://lore.kernel.org/git/20240619172421.33548-2-randall.becker@nexbridge.ca/#related">changed</a>, 3 insertions(+)

<span
class="head">diff --git a/help.c b/help.c
index 1d057aa607..ce55aaa2c0 100644
--- a/help.c
+++ b/help.c
</span><span
class="hunk">@@ -757,6 +757,9 @@ void get_version_info(struct strbuf *buf, int show_build_options)
</span> 
 		if (fsmonitor_ipc__is_supported())
 			strbuf_addstr(buf, &#34;feature: fsmonitor--daemon\n&#34;);
<span
class="add">+#if defined OPENSSL_VERSION_TEXT
+		strbuf_addf(buf, &#34;OpenSSL: %s\n&#34;, OPENSSL_VERSION_TEXT);
+#endif
</span> 	}
 }
 
-- 
2.43.0

</pre></div></content></entry><entry><author><name>Randall S. Becker</name><email>the.n.e.key@gmail.com</email></author><title>[PATCH v0 0/1] Teach git version --build-options about OpenSSL</title><updated>2024-06-19T17:24:56Z</updated><link
href="http://lore.kernel.org/git/20240619172421.33548-1-randall.becker@nexbridge.ca/"/><id>urn:uuid:33d647fe-65b6-d287-9b5c-67e195ebccce</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This simple series adds the OpenSSL version, if any, used during a git
build.

As an example, if built with OpenSSL 3.0, the following is appended to
the git version --build-options report:

	OpenSSL: OpenSSL 3.0.13 30 Jan 2024

Randall S. Becker (1):
  Teach git version --build-options to know about the OpenSSL version
    used.

 help.c | 3 +++
 1 file changed, 3 insertions(+)

-- 
2.43.0

</pre></div></content></entry><entry><author><name>Ren&#233; Scharfe</name><email>l.s.r@web.de</email></author><title>[PATCH 3/2] commit: remove find_header_mem()</title><updated>2024-06-19T17:13:33Z</updated><link
href="http://lore.kernel.org/git/0d85712c-5beb-4a64-a7f4-797782c26694@web.de/"/><id>urn:uuid:5f1c5f62-4838-0c10-f87e-3c1fcfa22ee3</id><thr:in-reply-to
ref="urn:uuid:54077b19-9580-560b-8187-be4acdad451f"
href="http://lore.kernel.org/git/8b350cae-2180-4ac7-a911-d40043576445@web.de/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">cfc5cf428b (receive-pack.c: consolidate find header logic, 2022-01-06)
introduced find_header_mem() and turned find_commit_header() into a thin
wrapper.  Since then, the latter has become the last remaining caller of
the former.  Remove it to restore find_commit_header() to the state
before cfc5cf428b, get rid of a strlen(3) call and resolve a NEEDSWORK
note in the process.

Signed-off-by: Ren&#233; Scharfe &lt;l.s.r@web.de&gt;
---
 commit.c | 16 ++--------------
 commit.h |  5 -----
 2 files <a href="http://lore.kernel.org/git/0d85712c-5beb-4a64-a7f4-797782c26694@web.de/#related">changed</a>, 2 insertions(+), 19 deletions(-)

<span
class="head">diff --git a/commit.c b/commit.c
index 1d08951007..aacc401e72 100644
--- a/commit.c
+++ b/commit.c
</span><span
class="hunk">@@ -1870,20 +1870,12 @@ struct commit_list **commit_list_append(struct commit *commit,
</span> 	return &#38;new_commit-&gt;next;
 }

<span
class="del">-const char *find_header_mem(const char *msg, size_t len,
-			const char *key, size_t *out_len)
</span><span
class="add">+const char *find_commit_header(const char *msg, const char *key, size_t *out_len)
</span> {
 	int key_len = strlen(key);
 	const char *line = msg;

<span
class="del">-	/*
-	 * NEEDSWORK: It&#39;s possible for strchrnul() to scan beyond the range
-	 * given by len. However, current callers are safe because they compute
-	 * len by scanning a NUL-terminated block of memory starting at msg.
-	 * Nonetheless, it would be better to ensure the function does not look
-	 * at msg beyond the len provided by the caller.
-	 */
-	while (line &#38;&#38; line &lt; msg + len) {
</span><span
class="add">+	while (line) {
</span> 		const char *eol = strchrnul(line, &#39;\n&#39;);

 		if (line == eol)
<span
class="hunk">@@ -1900,10 +1892,6 @@ const char *find_header_mem(const char *msg, size_t len,
</span> 	return NULL;
 }

<span
class="del">-const char *find_commit_header(const char *msg, const char *key, size_t *out_len)
-{
-	return find_header_mem(msg, strlen(msg), key, out_len);
-}
</span> /*
  * Inspect the given string and determine the true &#34;end&#34; of the log message, in
  * order to find where to put a new Signed-off-by trailer.  Ignored are
<span
class="head">diff --git a/commit.h b/commit.h
index 62fe0d77a7..3084f591fd 100644
--- a/commit.h
+++ b/commit.h
</span><span
class="hunk">@@ -280,17 +280,12 @@ void free_commit_extra_headers(struct commit_extra_header *extra);
</span>
 /*
  * Search the commit object contents given by &#34;msg&#34; for the header &#34;key&#34;.
<span
class="del">- * Reads up to &#34;len&#34; bytes of &#34;msg&#34;.
</span>  * Returns a pointer to the start of the header contents, or NULL. The length
  * of the header, up to the first newline, is returned via out_len.
  *
  * Note that some headers (like mergetag) may be multi-line. It is the caller&#39;s
  * responsibility to parse further in this case!
  */
<span
class="del">-const char *find_header_mem(const char *msg, size_t len,
-			const char *key,
-			size_t *out_len);
-
</span> const char *find_commit_header(const char *msg, const char *key,
 			       size_t *out_len);

<span
class="del">--
</span>2.45.2
</pre></div></content></entry><entry><author><name>Jeff King</name><email>peff@peff.net</email></author><title>[PATCH] fetch-pack: fix segfault when fscking without --lock-pack</title><updated>2024-06-19T13:02:57Z</updated><link
href="http://lore.kernel.org/git/20240619130256.GA228005@coredump.intra.peff.net/"/><id>urn:uuid:60231219-8407-0915-cda6-0b49579ae96c</id><thr:in-reply-to
ref="urn:uuid:f1bd3bad-8320-73ff-ba65-35502b67eb91"
href="http://lore.kernel.org/git/ZnJpJyLPAKlu82s8@deca.navytux.spb.ru/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">On Wed, Jun 19, 2024 at 05:14:21AM +0000, Kirill Smelkov wrote:

<span
class="q">&gt; + newren, peff, calvinwan, ps, avarab
</span>
It&#39;s fine (and even encouraged) to re-post a topic which didn&#39;t get any
attention the first time around. But please don&#39;t mass-cc unrelated
people like this. We can all read the list and see your re-post, and if
we don&#39;t respond it may be because we have other priorities.

<span
class="q">&gt; +test_expect_failure &#39;fetch with fsckObjects but without --lock-pack does not segfault&#39; &#39;
&gt; +	rm -rf server client &#38;&#38;
&gt; +	git init server &#38;&#38;
&gt; +	test_commit -C server 1 &#38;&#38;
&gt; +
&gt; +	git init client &#38;&#38;
&gt; +	# unpackLimit=1 forces to keep received pack as pack instead of
&gt; +	# unpacking it to loose objects. The code is currently segfaulting when
&gt; +	# trying to index that kept pack.
&gt; +	git -c fetch.fsckObjects=true -c fetch.unpackLimit=1 \
&gt; +	    -C client fetch-pack ../server \
&gt; +		$(git -C server rev-parse refs/heads/main)
&gt; +&#39;
</span>
Thanks for providing a reproduction of the problem.

I think we don&#39;t want to stick the test right here, as it is breaking up
two related tests (though it is confusing because one uses http and the
other doesn&#39;t, so there&#39;s some http setup in between them). Though
curiously, putting the &#34;rm -rf server&#34; here revealed a minor bug in
those other tests. Fixed here:

  <a
href="https://lore.kernel.org/git/20240619125255.GA346466@coredump.intra.peff.net">https://lore.kernel.org/git/20240619125255.GA346466@coredump.intra.peff.net</a>

I think it&#39;s a bug that fetch.unpackLimit causes index-pack to create a
lockfile at all, but there&#39;s a more direct way to trigger the issue,
which I&#39;ve used in the patch below. I&#39;ll follow up with more details in
a reply to the patch.

-- &gt;8 --
Subject: fetch-pack: fix segfault when fscking without --lock-pack

The fetch-pack internals have multiple options related to creating
&#34;.keep&#34; lock-files for the received pack:

  - if args.lock_pack is set, then we tell index-pack to create a .keep
    file. In the fetch-pack plumbing command, this is triggered by
    passing &#34;-k&#34; twice.

  - if the caller passes in a pack_lockfiles string list, then we use it
    to record the path of the keep-file created by index-pack. We get
    that name by reading the stdout of index-pack. In the fetch-pack
    command, this is triggered by passing the (undocumented) --lock-pack
    option; without it, we pass in a NULL string list.

So it&#39;s possible to ask index-pack to create the lock-file (using &#34;-k
-k&#34;) but not ask to record it (by avoiding &#34;--lock-pack&#34;). This worked
fine until 5476e1efde (fetch-pack: print and use dangling .gitmodules,
2021-02-22), but now it causes a segfault.

Before that commit, if pack_lockfiles was NULL, we wouldn&#39;t bother
reading the output from index-pack at all. But since that commit,
index-pack may produce extra output if we asked it to fsck. So even if
nobody cares about the lockfile path, we still need to read it to skip
to the output we do care about.

We correctly check that we didn&#39;t get a NULL lockfile path (which can
happen if we did not ask it to create a .keep file at all), but we
missed the case where the lockfile path is not NULL (due to &#34;-k -k&#34;) but
the pack_lockfiles string_list is NULL (because nobody passed
&#34;--lock-pack&#34;), and segfault trying to add to the NULL string-list.

We can fix this by skipping the append to the string list when either
the value or the list is NULL. In that case we must also free the
lockfile path to avoid leaking it when it&#39;s non-NULL.

Nobody noticed the bug for so long because the transport code used by
&#34;git fetch&#34; always passes in a pack_lockfiles pointer, and remote-curl
(the main user of the fetch-pack plumbing command) always passes
--lock-pack.

Reported-by: Kirill Smelkov &lt;kirr@nexedi.com&gt;
Signed-off-by: Jeff King &lt;peff@peff.net&gt;
---
 fetch-pack.c          |  4 +++-
 t/t5500-fetch-pack.sh | 10 ++++++++++
 2 files <a href="http://lore.kernel.org/git/20240619130256.GA228005@coredump.intra.peff.net/#related">changed</a>, 13 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/fetch-pack.c b/fetch-pack.c
index eba9e420ea..42f48fbc31 100644
--- a/fetch-pack.c
+++ b/fetch-pack.c
</span><span
class="hunk">@@ -1038,8 +1038,10 @@ static int get_pack(struct fetch_pack_args *args,
</span> 
 		if (!is_well_formed)
 			die(_(&#34;fetch-pack: invalid index-pack output&#34;));
<span
class="del">-		if (pack_lockfile)
</span><span
class="add">+		if (pack_lockfiles &#38;&#38; pack_lockfile)
</span> 			string_list_append_nodup(pack_lockfiles, pack_lockfile);
<span
class="add">+		else
+			free(pack_lockfile);
</span> 		parse_gitmodules_oids(cmd.out, gitmodules_oids);
 		close(cmd.out);
 	}
<span
class="head">diff --git a/t/t5500-fetch-pack.sh b/t/t5500-fetch-pack.sh
index b26f367620..585ea0ee16 100755
--- a/t/t5500-fetch-pack.sh
+++ b/t/t5500-fetch-pack.sh
</span><span
class="hunk">@@ -993,6 +993,16 @@ test_expect_success &#39;ensure bogus fetch.negotiationAlgorithm yields error&#39; &#39;
</span> 		       fetch origin server_has both_have_2
 &#39;
 
<span
class="add">+test_expect_success &#39;fetch-pack with fsckObjects and keep-file does not segfault&#39; &#39;
+	rm -rf server client &#38;&#38;
+	test_create_repo server &#38;&#38;
+	test_commit -C server one &#38;&#38;
+
+	test_create_repo client &#38;&#38;
+	git -c fetch.fsckObjects=true \
+	    -C client fetch-pack -k -k ../server HEAD
+&#39;
+
</span> test_expect_success &#39;filtering by size&#39; &#39;
 	rm -rf server client &#38;&#38;
 	test_create_repo server &#38;&#38;
-- 
2.45.2.949.g1c649f6aed

</pre></div></content></entry><entry><author><name>Christian Couder</name><email>christian.couder@gmail.com</email></author><title>[PATCH 2/3] version: refactor get_uname_info()</title><updated>2024-06-19T12:57:41Z</updated><link
href="http://lore.kernel.org/git/20240619125708.3719150-3-christian.couder@gmail.com/"/><id>urn:uuid:f2bb63fe-5838-0363-22ae-0d08ea191698</id><thr:in-reply-to
ref="urn:uuid:a7e875bf-92e5-fc90-85a0-18ee4a461bc6"
href="http://lore.kernel.org/git/20240619125708.3719150-1-christian.couder@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Some code from &#34;builtin/bugreport.c&#34; uses uname(2) to get system
information.

Let&#39;s refactor this code into a new get_uname_info() function, so
that we can reuse it in a following commit.

Signed-off-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
---
 builtin/bugreport.c | 13 ++-----------
 version.c           | 20 ++++++++++++++++++++
 version.h           |  7 +++++++
 3 files <a href="http://lore.kernel.org/git/20240619125708.3719150-3-christian.couder@gmail.com/#related">changed</a>, 29 insertions(+), 11 deletions(-)

<span
class="head">diff --git a/builtin/bugreport.c b/builtin/bugreport.c
index b3cc77af53..b24f876c41 100644
--- a/builtin/bugreport.c
+++ b/builtin/bugreport.c
</span><span
class="hunk">@@ -11,10 +11,10 @@
</span> #include &#34;diagnose.h&#34;
 #include &#34;object-file.h&#34;
 #include &#34;setup.h&#34;
<span
class="add">+#include &#34;version.h&#34;
</span> 
 static void get_system_info(struct strbuf *sys_info)
 {
<span
class="del">-	struct utsname uname_info;
</span> 	char *shell = NULL;
 
 	/* get git version from native cmd */
<span
class="hunk">@@ -23,16 +23,7 @@ static void get_system_info(struct strbuf *sys_info)
</span> 
 	/* system call for other version info */
 	strbuf_addstr(sys_info, &#34;uname: &#34;);
<span
class="del">-	if (uname(&#38;uname_info))
-		strbuf_addf(sys_info, _(&#34;uname() failed with error &#39;%s&#39; (%d)\n&#34;),
-			    strerror(errno),
-			    errno);
-	else
-		strbuf_addf(sys_info, &#34;%s %s %s %s\n&#34;,
-			    uname_info.sysname,
-			    uname_info.release,
-			    uname_info.version,
-			    uname_info.machine);
</span><span
class="add">+	get_uname_info(sys_info);
</span> 
 	strbuf_addstr(sys_info, _(&#34;compiler info: &#34;));
 	get_compiler_info(sys_info);
<span
class="head">diff --git a/version.c b/version.c
index 331ee6c372..10b9fa77d1 100644
--- a/version.c
+++ b/version.c
</span><span
class="hunk">@@ -1,6 +1,7 @@
</span> #include &#34;git-compat-util.h&#34;
 #include &#34;version.h&#34;
 #include &#34;strbuf.h&#34;
<span
class="add">+#include &#34;gettext.h&#34;
</span> 
 const char git_version_string[] = GIT_VERSION;
 const char git_built_from_commit_string[] = GIT_BUILT_FROM_COMMIT;
<span
class="hunk">@@ -41,3 +42,22 @@ const char *git_user_agent_sanitized(void)
</span> 
 	return agent;
 }
<span
class="add">+
+int get_uname_info(struct strbuf *buf)
+{
+	struct utsname uname_info;
+
+	if (uname(&#38;uname_info)) {
+		strbuf_addf(buf, _(&#34;uname() failed with error &#39;%s&#39; (%d)\n&#34;),
+			    strerror(errno),
+			    errno);
+		return -1;
+	}
+
+	strbuf_addf(buf, &#34;%s %s %s %s\n&#34;,
+		    uname_info.sysname,
+		    uname_info.release,
+		    uname_info.version,
+		    uname_info.machine);
+	return 0;
+}
</span><span
class="head">diff --git a/version.h b/version.h
index 7c62e80577..afe3dbbab7 100644
--- a/version.h
+++ b/version.h
</span><span
class="hunk">@@ -7,4 +7,11 @@ extern const char git_built_from_commit_string[];
</span> const char *git_user_agent(void);
 const char *git_user_agent_sanitized(void);
 
<span
class="add">+/*
+  Try to get information about the system using uname(2).
+  Return -1 and put an error message into &#39;buf&#39; in case of uname()
+  error. Return 0 and put uname info into &#39;buf&#39; otherwise.
+*/
+int get_uname_info(struct strbuf *buf);
+
</span> #endif /* VERSION_H */
-- 
2.45.2.563.g6aa460b3cb

</pre></div></content></entry><entry><author><name>Christian Couder</name><email>christian.couder@gmail.com</email></author><title>[PATCH 3/3] connect: advertise OS version</title><updated>2024-06-19T12:57:41Z</updated><link
href="http://lore.kernel.org/git/20240619125708.3719150-4-christian.couder@gmail.com/"/><id>urn:uuid:30ecbd71-6c07-b9d1-9b74-2deeaf2bb3b5</id><thr:in-reply-to
ref="urn:uuid:a7e875bf-92e5-fc90-85a0-18ee4a461bc6"
href="http://lore.kernel.org/git/20240619125708.3719150-1-christian.couder@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">As some issues that can happen with a Git client can be operating system
specific, it can be useful for a server to know which OS a client is
using. In the same way it can be useful for a client to know which OS
a server is using.

Let&#39;s add OS information exchange to the protocol in the same way some
git version exchange is performed.

Signed-off-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
---
 Documentation/gitprotocol-v2.txt | 18 ++++++++++++++++++
 connect.c                        |  3 +++
 serve.c                          | 12 ++++++++++++
 t/t5555-http-smart-common.sh     |  3 +++
 t/t5701-git-serve.sh             |  3 +++
 version.c                        | 29 +++++++++++++++++++++++++++++
 version.h                        |  3 +++
 7 files <a href="http://lore.kernel.org/git/20240619125708.3719150-4-christian.couder@gmail.com/#related">changed</a>, 71 insertions(+)

<span
class="head">diff --git a/Documentation/gitprotocol-v2.txt b/Documentation/gitprotocol-v2.txt
index 414bc625d5..f676b2dc7a 100644
--- a/Documentation/gitprotocol-v2.txt
+++ b/Documentation/gitprotocol-v2.txt
</span><span
class="hunk">@@ -190,6 +190,24 @@ printable ASCII characters except space (i.e., the byte range 32 &lt; x &lt;
</span> and debugging purposes, and MUST NOT be used to programmatically assume
 the presence or absence of particular features.
 
<span
class="add">+os-version
+~~~~~~~~~~
+
+In the same way as the `agent` capability above, the server can
+advertise the `os-version` capability with a value `X` (in the form
+`os-version=X`) to notify the client that the server is running an
+operating system that can be identified by `X`. The client may
+optionally send its own `os-version` string by including the
+`os-version` capability with a value `Y` (in the form `os-version=Y`)
+in its request to the server (but it MUST NOT do so if the server did
+not advertise the os-version capability). The `X` and `Y` strings may
+contain any printable ASCII characters except space (i.e., the byte
+range 32 &lt; x &lt; 127), and are typically made from the result of
+`uname -srvm`. The os-version strings are purely informative for
+statistics and debugging purposes, and MUST NOT be used to
+programmatically assume the presence or absence of particular
+features.
+
</span> ls-refs
 ~~~~~~~
 
<span
class="head">diff --git a/connect.c b/connect.c
index 0d77737a53..3a48806ddc 100644
--- a/connect.c
+++ b/connect.c
</span><span
class="hunk">@@ -489,6 +489,9 @@ static void send_capabilities(int fd_out, struct packet_reader *reader)
</span> 	if (server_supports_v2(&#34;agent&#34;))
 		packet_write_fmt(fd_out, &#34;agent=%s&#34;, git_user_agent_sanitized());
 
<span
class="add">+	if (server_supports_v2(&#34;os-version&#34;))
+		packet_write_fmt(fd_out, &#34;os-version=%s&#34;, os_version_sanitized());
+
</span> 	if (server_feature_v2(&#34;object-format&#34;, &#38;hash_name)) {
 		int hash_algo = hash_algo_by_name(hash_name);
 		if (hash_algo == GIT_HASH_UNKNOWN)
<span
class="head">diff --git a/serve.c b/serve.c
index aa651b73e9..77eb5ebdaa 100644
--- a/serve.c
+++ b/serve.c
</span><span
class="hunk">@@ -29,6 +29,14 @@ static int agent_advertise(struct repository *r UNUSED,
</span> 	return 1;
 }
 
<span
class="add">+static int os_version_advertise(struct repository *r UNUSED,
+			   struct strbuf *value)
+{
+	if (value)
+		strbuf_addstr(value, os_version_sanitized());
+	return 1;
+}
+
</span> static int object_format_advertise(struct repository *r,
 				   struct strbuf *value)
 {
<span
class="hunk">@@ -121,6 +129,10 @@ static struct protocol_capability capabilities[] = {
</span> 		.name = &#34;agent&#34;,
 		.advertise = agent_advertise,
 	},
<span
class="add">+	{
+		.name = &#34;os-version&#34;,
+		.advertise = os_version_advertise,
+	},
</span> 	{
 		.name = &#34;ls-refs&#34;,
 		.advertise = ls_refs_advertise,
<span
class="head">diff --git a/t/t5555-http-smart-common.sh b/t/t5555-http-smart-common.sh
index 3dcb3340a3..c67739236f 100755
--- a/t/t5555-http-smart-common.sh
+++ b/t/t5555-http-smart-common.sh
</span><span
class="hunk">@@ -124,9 +124,12 @@ test_expect_success &#39;git receive-pack --advertise-refs: v1&#39; &#39;
</span> &#39;
 
 test_expect_success &#39;git upload-pack --advertise-refs: v2&#39; &#39;
<span
class="add">+	# Octal intervals \001-\040 and \177-\377
+	# corresponds to decimal intervals 1-32 and 127-255
</span> 	cat &gt;expect &lt;&lt;-EOF &#38;&#38;
 	version 2
 	agent=FAKE
<span
class="add">+	os-version=$(uname -srvm | tr -d &#34;\n&#34; | tr &#34;[\001-\040][\177-\377]&#34; &#34;.&#34;)
</span> 	ls-refs=unborn
 	fetch=shallow wait-for-done
 	server-option
<span
class="head">diff --git a/t/t5701-git-serve.sh b/t/t5701-git-serve.sh
index c48830de8f..9c9a707e6a 100755
--- a/t/t5701-git-serve.sh
+++ b/t/t5701-git-serve.sh
</span><span
class="hunk">@@ -13,9 +13,12 @@ test_expect_success &#39;test capability advertisement&#39; &#39;
</span> 	wrong_algo sha1:sha256
 	wrong_algo sha256:sha1
 	EOF
<span
class="add">+	# Octal intervals \001-\040 and \177-\377
+	# corresponds to decimal intervals 1-32 and 127-255
</span> 	cat &gt;expect.base &lt;&lt;-EOF &#38;&#38;
 	version 2
 	agent=git/$(git version | cut -d&#34; &#34; -f3)
<span
class="add">+	os-version=$(uname -srvm | tr -d &#34;\n&#34; | tr &#34;[\001-\040][\177-\377]&#34; &#34;.&#34;)
</span> 	ls-refs=unborn
 	fetch=shallow wait-for-done
 	server-option
<span
class="head">diff --git a/version.c b/version.c
index 10b9fa77d1..5b20ea0d7c 100644
--- a/version.c
+++ b/version.c
</span><span
class="hunk">@@ -61,3 +61,32 @@ int get_uname_info(struct strbuf *buf)
</span> 		    uname_info.machine);
 	return 0;
 }
<span
class="add">+
+const char *os_version(void)
+{
+	static const char *os = NULL;
+
+	if (!os) {
+		struct strbuf buf = STRBUF_INIT;
+
+		get_uname_info(&#38;buf);
+		os = strbuf_detach(&#38;buf, NULL);
+	}
+
+	return os;
+}
+
+const char *os_version_sanitized(void)
+{
+	static const char *os_sanitized = NULL;
+
+	if (!os_sanitized) {
+		struct strbuf buf = STRBUF_INIT;
+
+		strbuf_addstr(&#38;buf, os_version());
+		strbuf_sanitize(&#38;buf);
+		os_sanitized = strbuf_detach(&#38;buf, NULL);
+	}
+
+	return os_sanitized;
+}
</span><span
class="head">diff --git a/version.h b/version.h
index afe3dbbab7..349952c8f2 100644
--- a/version.h
+++ b/version.h
</span><span
class="hunk">@@ -14,4 +14,7 @@ const char *git_user_agent_sanitized(void);
</span> */
 int get_uname_info(struct strbuf *buf);
 
<span
class="add">+const char *os_version(void);
+const char *os_version_sanitized(void);
+
</span> #endif /* VERSION_H */
-- 
2.45.2.563.g6aa460b3cb

</pre></div></content></entry><entry><author><name>Christian Couder</name><email>christian.couder@gmail.com</email></author><title>[PATCH 1/3] version: refactor strbuf_sanitize()</title><updated>2024-06-19T12:57:38Z</updated><link
href="http://lore.kernel.org/git/20240619125708.3719150-2-christian.couder@gmail.com/"/><id>urn:uuid:d134ee81-6502-b557-a6d2-69ec9a442cf4</id><thr:in-reply-to
ref="urn:uuid:a7e875bf-92e5-fc90-85a0-18ee4a461bc6"
href="http://lore.kernel.org/git/20240619125708.3719150-1-christian.couder@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The git_user_agent_sanitized() function performs some sanitizing to
avoid special characters being sent over the line and possibly messing
up with the protocol or with the parsing on the other side.

Let&#39;s extract this sanitizing into a new strbuf_sanitize() function, as
we will want to reuse it in a following patch.

For now the new strbuf_sanitize() function is still static as it&#39;s only
needed locally.

While at it, let&#39;s also make a few small improvements:
  - use &#39;size_t&#39; for &#39;i&#39; instead of &#39;int&#39;,
  - move the declaration of &#39;i&#39; inside the &#39;for ( ... )&#39;,
  - use strbuf_detach() to explicitely detach the string contained by
    the &#39;buf&#39; strbuf.

Signed-off-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
---
 version.c | 18 +++++++++++-------
 1 file <a href="http://lore.kernel.org/git/20240619125708.3719150-2-christian.couder@gmail.com/#related">changed</a>, 11 insertions(+), 7 deletions(-)

<span
class="head">diff --git a/version.c b/version.c
index 41b718c29e..331ee6c372 100644
--- a/version.c
+++ b/version.c
</span><span
class="hunk">@@ -5,6 +5,15 @@
</span> const char git_version_string[] = GIT_VERSION;
 const char git_built_from_commit_string[] = GIT_BUILT_FROM_COMMIT;
 
<span
class="add">+static void strbuf_sanitize(struct strbuf *buf)
+{
+	strbuf_trim(buf);
+	for (size_t i = 0; i &lt; buf-&gt;len; i++) {
+		if (buf-&gt;buf[i] &lt;= 32 || buf-&gt;buf[i] &gt;= 127)
+			buf-&gt;buf[i] = &#39;.&#39;;
+	}
+}
+
</span> const char *git_user_agent(void)
 {
 	static const char *agent = NULL;
<span
class="hunk">@@ -24,15 +33,10 @@ const char *git_user_agent_sanitized(void)
</span> 
 	if (!agent) {
 		struct strbuf buf = STRBUF_INIT;
<span
class="del">-		int i;
</span> 
 		strbuf_addstr(&#38;buf, git_user_agent());
<span
class="del">-		strbuf_trim(&#38;buf);
-		for (i = 0; i &lt; buf.len; i++) {
-			if (buf.buf[i] &lt;= 32 || buf.buf[i] &gt;= 127)
-				buf.buf[i] = &#39;.&#39;;
-		}
-		agent = buf.buf;
</span><span
class="add">+		strbuf_sanitize(&#38;buf);
+		agent = strbuf_detach(&#38;buf, NULL);
</span> 	}
 
 	return agent;
-- 
2.45.2.563.g6aa460b3cb

</pre></div></content></entry><entry><author><name>Christian Couder</name><email>christian.couder@gmail.com</email></author><title>[PATCH 0/3] Advertise OS version</title><updated>2024-06-19T12:57:37Z</updated><link
href="http://lore.kernel.org/git/20240619125708.3719150-1-christian.couder@gmail.com/"/><id>urn:uuid:a7e875bf-92e5-fc90-85a0-18ee4a461bc6</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">For debugging and statistical purposes, it can be useful for Git
servers to know the OS the client are using.

So let&#39;s add a new &#39;os-version&#39; capability to the v2 protocol, in the
same way as the existing &#39;agent&#39; capability that lets clients and
servers exchange the Git version they are running.

This sends the same info as `git bugreport` is already sending, which
uses uname(2). It should be the same as what `uname -srvm` returns,
except that it is sanitized in the same way as the Git version sent by
the &#39;agent&#39; capability is sanitized (by replacing character having an
ascii code less than 32 or more than 127 with &#39;.&#39;).

CI tests are currently failing on Windows as it looks like uname(1)
and uname(2) don&#39;t report the same thing:

  -os-version=MINGW64_NT-10.0-20348.3.4.10-87d57229.x86_64.2024-02-14.20:17.UTC.x86_64
  +os-version=Windows.10.0.20348

(See: <a
href="https://github.com/chriscool/git/actions/runs/9581822699">https://github.com/chriscool/git/actions/runs/9581822699</a>)

Thoughts?

Christian Couder (3):
  version: refactor strbuf_sanitize()
  version: refactor get_uname_info()
  connect: advertise OS version

 Documentation/gitprotocol-v2.txt | 18 +++++++++
 builtin/bugreport.c              | 13 +------
 connect.c                        |  3 ++
 serve.c                          | 12 ++++++
 t/t5555-http-smart-common.sh     |  3 ++
 t/t5701-git-serve.sh             |  3 ++
 version.c                        | 67 ++++++++++++++++++++++++++++----
 version.h                        | 10 +++++
 8 files changed, 111 insertions(+), 18 deletions(-)

-- 
2.45.2.563.g6aa460b3cb

</pre></div></content></entry><entry><author><name>Jeff King</name><email>peff@peff.net</email></author><title>[PATCH] t5500: fix mistaken $SERVER reference in helper function</title><updated>2024-06-19T12:52:58Z</updated><link
href="http://lore.kernel.org/git/20240619125255.GA346466@coredump.intra.peff.net/"/><id>urn:uuid:115d97e1-53d6-eb09-5e26-dd82980910e5</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The end of t5500 contains two tests which use a single helper function,
fetch_filter_blob_limit_zero(). It takes a parameter to point to the
path of the server repository, which we store locally as $SERVER. The
first caller uses the relative path &#34;server&#34;, while the second points
into the httpd document root.

Commit 07ef3c6604 (fetch test: use more robust test for filtered
objects, 2019-12-23) refactored some lines, but accidentally switched
&#34;$SERVER&#34; to &#34;server&#34; in one spot. That means the second caller is
looking at the server directory from the previous test rather than its
own.

This happens to work out because the &#34;server&#34; directory from the first
test is still hanging around, and the contents of the two are identical.
But it was clearly not the intended behavior, and is fragile to cleaning
up the leftovers from the first test.

Signed-off-by: Jeff King &lt;peff@peff.net&gt;
---
 t/t5500-fetch-pack.sh | 2 +-
 1 file <a href="http://lore.kernel.org/git/20240619125255.GA346466@coredump.intra.peff.net/#related">changed</a>, 1 insertion(+), 1 deletion(-)

<span
class="head">diff --git a/t/t5500-fetch-pack.sh b/t/t5500-fetch-pack.sh
index 1bc15a3f08..b26f367620 100755
--- a/t/t5500-fetch-pack.sh
+++ b/t/t5500-fetch-pack.sh
</span><span
class="hunk">@@ -1046,7 +1046,7 @@ fetch_filter_blob_limit_zero () {
</span> 
 	# Ensure that commit is fetched, but blob is not
 	commit=$(git -C &#34;$SERVER&#34; rev-parse two) &#38;&#38;
<span
class="del">-	blob=$(git hash-object server/two.t) &#38;&#38;
</span><span
class="add">+	blob=$(git hash-object &#34;$SERVER/two.t&#34;) &#38;&#38;
</span> 	git -C client rev-list --objects --missing=allow-any &#34;$commit&#34; &gt;oids &#38;&#38;
 	grep &#34;$commit&#34; oids &#38;&#38;
 	! grep &#34;$blob&#34; oids
-- 
2.45.2.949.g1c649f6aed
</pre></div></content></entry><entry><author><name>shejialuo</name><email>shejialuo@gmail.com</email></author><title>[GSoC][PATCH v4 7/7] fsck: add ref content check for files backend</title><updated>2024-06-19T07:44:38Z</updated><link
href="http://lore.kernel.org/git/ZnKMY4VdHKHAMNY6@ArchLinux/"/><id>urn:uuid:4dbf58bc-dd6e-7512-3d7c-51622095abfc</id><thr:in-reply-to
ref="urn:uuid:67cc5cb7-690b-6bd7-e8b6-8d2a3608a3b6"
href="http://lore.kernel.org/git/ZnKKy52QFO2UhqM6@ArchLinux/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Enhance the git-fsck(1) command by adding a check for reference content
in the files backend. The new functionality ensures that symrefs, real
symbolic link and regular refs are validated correctly.

In order to check the trailing content of the regular refs, add a new
parameter `trailing` to `parse_loose_ref_contents`.

For symrefs, `parse_loose_ref_contents` will set the &#34;referent&#34;.
However, symbolic link could be either absolute or relative. Use
&#34;strbuf_add_real_path&#34; to read the symbolic link and convert the
relative path to absolute path. Then use &#34;skip_prefix&#34; to make it align
with symref &#34;referent&#34;.

Thus, the symrefs and symbolic links could share the same interface. Add
a new function &#34;files_fsck_symref_target&#34; which aims at checking the
following things:

1. whether the pointee is under the `refs/` directory.
2. whether the pointee name is correct.
3. whether the pointee path is a wrong type in filesystem.

Last, add the following FSCK MESSAGEs:

1. &#34;badRefContent(ERROR)&#34;: A ref has a bad content
2. &#34;badSymrefPointee(ERROR)&#34;: The pointee of a symref is bad.
3. &#34;trailingRefContent(WARN)&#34;: A ref content has trailing contents.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Karthik Nayak &lt;karthik.188@gmail.com&gt;
Signed-off-by: shejialuo &lt;shejialuo@gmail.com&gt;
---
 Documentation/fsck-msgids.txt |   9 +++
 fsck.h                        |   3 +
 refs.c                        |   2 +-
 refs/files-backend.c          | 145 +++++++++++++++++++++++++++++++++-
 refs/refs-internal.h          |   5 +-
 t/t0602-reffiles-fsck.sh      | 110 ++++++++++++++++++++++++++
 6 files <a href="http://lore.kernel.org/git/ZnKMY4VdHKHAMNY6@ArchLinux/#related">changed</a>, 269 insertions(+), 5 deletions(-)

<span
class="head">diff --git a/Documentation/fsck-msgids.txt b/Documentation/fsck-msgids.txt
index dab4012246..b1630a478b 100644
--- a/Documentation/fsck-msgids.txt
+++ b/Documentation/fsck-msgids.txt
</span><span
class="hunk">@@ -19,9 +19,15 @@
</span> `badParentSha1`::
 	(ERROR) A commit object has a bad parent sha1.
 
<span
class="add">+`badRefContent`::
+	(ERROR) A ref has a bad content.
+
</span> `badRefName`::
 	(ERROR) A ref has a bad name.
 
<span
class="add">+`badSymrefPointee`::
+	(ERROR) The pointee of a symref is bad.
+
</span> `badTagName`::
 	(INFO) A tag has an invalid format.
 
<span
class="hunk">@@ -167,6 +173,9 @@
</span> `nullSha1`::
 	(WARN) Tree contains entries pointing to a null sha1.
 
<span
class="add">+`trailingRefContent`::
+	(WARN) A ref content has trailing contents.
+
</span> `treeNotSorted`::
 	(ERROR) A tree is not properly sorted.
 
<span
class="head">diff --git a/fsck.h b/fsck.h
index f26dec2ea4..8afee05f20 100644
--- a/fsck.h
+++ b/fsck.h
</span><span
class="hunk">@@ -32,6 +32,8 @@ enum fsck_msg_type {
</span> 	FUNC(BAD_OBJECT_SHA1, ERROR) \
 	FUNC(BAD_PARENT_SHA1, ERROR) \
 	FUNC(BAD_REF_NAME, ERROR) \
<span
class="add">+	FUNC(BAD_REF_CONTENT, ERROR) \
+	FUNC(BAD_SYMREF_POINTEE, ERROR) \
</span> 	FUNC(BAD_TIMEZONE, ERROR) \
 	FUNC(BAD_TREE, ERROR) \
 	FUNC(BAD_TREE_SHA1, ERROR) \
<span
class="hunk">@@ -72,6 +74,7 @@ enum fsck_msg_type {
</span> 	FUNC(HAS_DOTDOT, WARN) \
 	FUNC(HAS_DOTGIT, WARN) \
 	FUNC(NULL_SHA1, WARN) \
<span
class="add">+	FUNC(TRAILING_REF_CONTENT, WARN) \
</span> 	FUNC(ZERO_PADDED_FILEMODE, WARN) \
 	FUNC(NUL_IN_COMMIT, WARN) \
 	FUNC(LARGE_PATHNAME, WARN) \
<span
class="head">diff --git a/refs.c b/refs.c
index cb3b8ec36a..5fc34d39b1 100644
--- a/refs.c
+++ b/refs.c
</span><span
class="hunk">@@ -1744,7 +1744,7 @@ static int refs_read_special_head(struct ref_store *ref_store,
</span> 	}
 
 	result = parse_loose_ref_contents(content.buf, oid, referent, type,
<span
class="del">-					  failure_errno);
</span><span
class="add">+					  failure_errno, NULL);
</span> 
 done:
 	strbuf_release(&#38;full_path);
<span
class="head">diff --git a/refs/files-backend.c b/refs/files-backend.c
index 5bc233b524..3b8e76dab5 100644
--- a/refs/files-backend.c
+++ b/refs/files-backend.c
</span><span
class="hunk">@@ -1,4 +1,5 @@
</span> #include &#34;../git-compat-util.h&#34;
<span
class="add">+#include &#34;../abspath.h&#34;
</span> #include &#34;../copy.h&#34;
 #include &#34;../environment.h&#34;
 #include &#34;../gettext.h&#34;
<span
class="hunk">@@ -551,7 +552,7 @@ static int read_ref_internal(struct ref_store *ref_store, const char *refname,
</span> 	strbuf_rtrim(&#38;sb_contents);
 	buf = sb_contents.buf;
 
<span
class="del">-	ret = parse_loose_ref_contents(buf, oid, referent, type, &#38;myerr);
</span><span
class="add">+	ret = parse_loose_ref_contents(buf, oid, referent, type, &#38;myerr, NULL);
</span> 
 out:
 	if (ret &#38;&#38; !myerr)
<span
class="hunk">@@ -587,7 +588,7 @@ static int files_read_symbolic_ref(struct ref_store *ref_store, const char *refn
</span> 
 int parse_loose_ref_contents(const char *buf, struct object_id *oid,
 			     struct strbuf *referent, unsigned int *type,
<span
class="del">-			     int *failure_errno)
</span><span
class="add">+			     int *failure_errno, const char **trailing)
</span> {
 	const char *p;
 	if (skip_prefix(buf, &#34;ref:&#34;, &#38;buf)) {
<span
class="hunk">@@ -609,6 +610,10 @@ int parse_loose_ref_contents(const char *buf, struct object_id *oid,
</span> 		*failure_errno = EINVAL;
 		return -1;
 	}
<span
class="add">+
+	if (trailing)
+		*trailing = p;
+
</span> 	return 0;
 }
 
<span
class="hunk">@@ -3435,6 +3440,141 @@ static int files_fsck_refs_name(struct fsck_options *o,
</span> 	return ret;
 }
 
<span
class="add">+/*
+ * Check the symref &#34;pointee_name&#34; and &#34;pointee_path&#34;. The caller should
+ * make sure that &#34;pointee_path&#34; is absolute. For symbolic ref, &#34;pointee_name&#34;
+ * would be the content after &#34;refs:&#34;. For symblic link, &#34;pointee_name&#34; would
+ * be the relative path agaignst &#34;gitdir&#34;.
+ */
+static int files_fsck_symref_target(struct fsck_options *o,
+				    const char *refname,
+				    const char *pointee_name,
+				    const char *pointee_path)
+{
+	const char *p = NULL;
+	struct stat st;
+	int ret = 0;
+
+	if (!skip_prefix(pointee_name, &#34;refs/&#34;, &#38;p)) {
+
+		ret = fsck_refs_report(o, refname,
+				       FSCK_MSG_BAD_SYMREF_POINTEE,
+				       &#34;point to target out of refs hierarchy&#34;);
+		goto out;
+	}
+
+	if (check_refname_format(pointee_name, 0)) {
+		ret = fsck_refs_report(o, refname,
+				       FSCK_MSG_BAD_SYMREF_POINTEE,
+				       &#34;point to invalid refname&#34;);
+	}
+
+	if (lstat(pointee_path, &#38;st) &lt; 0)
+		goto out;
+
+	if (!S_ISREG(st.st_mode) &#38;&#38; !S_ISLNK(st.st_mode)) {
+		ret = fsck_refs_report(o, refname,
+				       FSCK_MSG_BAD_SYMREF_POINTEE,
+				       &#34;point to invalid target&#34;);
+		goto out;
+	}
+out:
+	return ret;
+}
+
+static int files_fsck_refs_content(struct fsck_options *o,
+				   const char *gitdir,
+				   const char *refs_check_dir,
+				   struct dir_iterator *iter)
+{
+	struct strbuf pointee_path = STRBUF_INIT,
+		      ref_content = STRBUF_INIT,
+		      abs_gitdir = STRBUF_INIT,
+		      referent = STRBUF_INIT,
+		      refname = STRBUF_INIT;
+	const char *trailing = NULL;
+	int failure_errno = 0;
+	unsigned int type = 0;
+	struct object_id oid;
+	int ret = 0;
+
+	strbuf_addf(&#38;refname, &#34;%s/%s&#34;, refs_check_dir, iter-&gt;relative_path);
+
+	/*
+	 * If the file is a symlink, we need to only check the connectivity
+	 * of the destination object.
+	 */
+	if (S_ISLNK(iter-&gt;st.st_mode)) {
+		const char *pointee_name = NULL;
+
+		strbuf_add_real_path(&#38;pointee_path, iter-&gt;path.buf);
+
+		strbuf_add_absolute_path(&#38;abs_gitdir, gitdir);
+		strbuf_normalize_path(&#38;abs_gitdir);
+		if (!is_dir_sep(abs_gitdir.buf[abs_gitdir.len - 1]))
+			strbuf_addch(&#38;abs_gitdir, &#39;/&#39;);
+
+		if (!skip_prefix(pointee_path.buf,
+				 abs_gitdir.buf, &#38;pointee_name)) {
+			ret = fsck_refs_report(o, refname.buf,
+					       FSCK_MSG_BAD_SYMREF_POINTEE,
+					       &#34;point to target outside gitdir&#34;);
+			goto clean;
+		}
+
+		ret = files_fsck_symref_target(o, refname.buf, pointee_name,
+					       pointee_path.buf);
+		goto clean;
+	}
+
+	if (strbuf_read_file(&#38;ref_content, iter-&gt;path.buf, 0) &lt; 0) {
+		ret = error_errno(_(&#34;%s/%s: unable to read the ref&#34;),
+				  refs_check_dir, iter-&gt;relative_path);
+		goto clean;
+	}
+
+	if (parse_loose_ref_contents(ref_content.buf, &#38;oid,
+				     &#38;referent, &#38;type,
+				     &#38;failure_errno, &#38;trailing)) {
+		ret = fsck_refs_report(o, refname.buf,
+				       FSCK_MSG_BAD_REF_CONTENT,
+				       &#34;invalid ref content&#34;);
+		goto clean;
+	}
+
+	/*
+	 * If the ref is a symref, we need to check the destination name and
+	 * connectivity.
+	 */
+	if (referent.len &#38;&#38; (type &#38; REF_ISSYMREF)) {
+		strbuf_addf(&#38;pointee_path, &#34;%s/%s&#34;, gitdir, referent.buf);
+		strbuf_rtrim(&#38;referent);
+
+		ret = files_fsck_symref_target(o, refname.buf, referent.buf,
+					       pointee_path.buf);
+		goto clean;
+	} else {
+		/*
+		 * Only regular refs could have a trailing garbage. Should
+		 * be reported as a warning.
+		 */
+		if (trailing &#38;&#38; (*trailing != &#39;\0&#39; &#38;&#38; *trailing != &#39;\n&#39;)) {
+			ret = fsck_refs_report(o, refname.buf,
+					       FSCK_MSG_TRAILING_REF_CONTENT,
+					       &#34;trailing garbage in ref&#34;);
+			goto clean;
+		}
+	}
+
+clean:
+	strbuf_release(&#38;abs_gitdir);
+	strbuf_release(&#38;pointee_path);
+	strbuf_release(&#38;refname);
+	strbuf_release(&#38;ref_content);
+	strbuf_release(&#38;referent);
+	return ret;
+}
+
</span> static int files_fsck_refs_dir(struct ref_store *ref_store,
 			       struct fsck_options *o,
 			       const char *refs_check_dir,
<span
class="hunk">@@ -3487,6 +3627,7 @@ static int files_fsck_refs(struct ref_store *ref_store,
</span> 	int ret;
 	files_fsck_refs_fn fsck_refs_fns[]= {
 		files_fsck_refs_name,
<span
class="add">+		files_fsck_refs_content,
</span> 		NULL
 	};
 
<span
class="head">diff --git a/refs/refs-internal.h b/refs/refs-internal.h
index 280acb7f9e..1126c6102a 100644
--- a/refs/refs-internal.h
+++ b/refs/refs-internal.h
</span><span
class="hunk">@@ -709,11 +709,12 @@ struct ref_store {
</span> 
 /*
  * Parse contents of a loose ref file. *failure_errno maybe be set to EINVAL for
<span
class="del">- * invalid contents.
</span><span
class="add">+ * invalid contents. Also *trailing is set to the first character after the
+ * refname or NULL if the referent is not empty.
</span>  */
 int parse_loose_ref_contents(const char *buf, struct object_id *oid,
 			     struct strbuf *referent, unsigned int *type,
<span
class="del">-			     int *failure_errno);
</span><span
class="add">+			     int *failure_errno, const char **trailing);
</span> 
 /*
  * Fill in the generic part of refs and add it to our collection of
<span
class="head">diff --git a/t/t0602-reffiles-fsck.sh b/t/t0602-reffiles-fsck.sh
index b2db58d2c6..35bf40ee64 100755
--- a/t/t0602-reffiles-fsck.sh
+++ b/t/t0602-reffiles-fsck.sh
</span><span
class="hunk">@@ -98,4 +98,114 @@ test_expect_success &#39;ref name check should be adapted into fsck messages&#39; &#39;
</span> 	)
 &#39;
 
<span
class="add">+test_expect_success &#39;regular ref content should be checked&#39; &#39;
+	test_when_finished &#34;rm -rf repo&#34; &#38;&#38;
+	git init repo &#38;&#38;
+	branch_dir_prefix=.git/refs/heads &#38;&#38;
+	tag_dir_prefix=.git/refs/tags &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		git commit --allow-empty -m initial &#38;&#38;
+		git checkout -b branch-1 &#38;&#38;
+		git tag tag-1 &#38;&#38;
+		git commit --allow-empty -m second &#38;&#38;
+		git checkout -b branch-2 &#38;&#38;
+		git tag tag-2 &#38;&#38;
+		git checkout -b a/b/tag-2
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		printf &#34;%s garbage&#34; &#34;$(git rev-parse branch-1)&#34; &gt; $branch_dir_prefix/branch-1-garbage &#38;&#38;
+		git fsck 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		warning: refs/heads/branch-1-garbage: trailingRefContent: trailing garbage in ref
+		EOF
+		rm $branch_dir_prefix/branch-1-garbage &#38;&#38;
+		test_cmp expect err
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		printf &#34;%s garbage&#34; &#34;$(git rev-parse tag-1)&#34; &gt; $tag_dir_prefix/tag-1-garbage &#38;&#38;
+		test_must_fail git -c fsck.trailingRefContent=error fsck 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		error: refs/tags/tag-1-garbage: trailingRefContent: trailing garbage in ref
+		EOF
+		rm $tag_dir_prefix/tag-1-garbage &#38;&#38;
+		test_cmp expect err
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		printf &#34;%s    &#34; &#34;$(git rev-parse tag-2)&#34; &gt; $tag_dir_prefix/tag-2-garbage &#38;&#38;
+		git fsck 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		warning: refs/tags/tag-2-garbage: trailingRefContent: trailing garbage in ref
+		EOF
+		rm $tag_dir_prefix/tag-2-garbage &#38;&#38;
+		test_cmp expect err
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		printf &#34;xfsazqfxcadas&#34; &gt; $tag_dir_prefix/tag-2-bad &#38;&#38;
+		test_must_fail git refs verify 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		error: refs/tags/tag-2-bad: badRefContent: invalid ref content
+		EOF
+		rm $tag_dir_prefix/tag-2-bad &#38;&#38;
+		test_cmp expect err
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		printf &#34;xfsazqfxcadas&#34; &gt; $branch_dir_prefix/a/b/branch-2-bad &#38;&#38;
+		test_must_fail git refs verify 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		error: refs/heads/a/b/branch-2-bad: badRefContent: invalid ref content
+		EOF
+		rm $branch_dir_prefix/a/b/branch-2-bad &#38;&#38;
+		test_cmp expect err
+	)
+&#39;
+
+test_expect_success &#39;symbolic ref content should be checked&#39; &#39;
+	test_when_finished &#34;rm -rf repo&#34; &#38;&#38;
+	git init repo &#38;&#38;
+	branch_dir_prefix=.git/refs/heads &#38;&#38;
+	tag_dir_prefix=.git/refs/tags &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		git commit --allow-empty -m initial &#38;&#38;
+		git checkout -b branch-1 &#38;&#38;
+		git tag tag-1
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		printf &#34;ref: refs/heads/.branch&#34; &gt; $branch_dir_prefix/branch-2-bad &#38;&#38;
+		test_must_fail git refs verify 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		error: refs/heads/branch-2-bad: badSymrefPointee: point to invalid refname
+		EOF
+		rm $branch_dir_prefix/branch-2-bad &#38;&#38;
+		test_cmp expect err
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		printf &#34;ref: refs/heads&#34; &gt; $branch_dir_prefix/branch-2-bad &#38;&#38;
+		test_must_fail git refs verify 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		error: refs/heads/branch-2-bad: badSymrefPointee: point to invalid target
+		EOF
+		rm $branch_dir_prefix/branch-2-bad &#38;&#38;
+		test_cmp expect err
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		printf &#34;ref: logs/maint-v2.45&#34; &gt; $branch_dir_prefix/branch-2-bad &#38;&#38;
+		test_must_fail git refs verify 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		error: refs/heads/branch-2-bad: badSymrefPointee: point to target out of refs hierarchy
+		EOF
+		rm $branch_dir_prefix/branch-2-bad &#38;&#38;
+		test_cmp expect err
+	)
+&#39;
+
</span> test_done
-- 
2.45.2

</pre></div></content></entry><entry><author><name>shejialuo</name><email>shejialuo@gmail.com</email></author><title>[GSoC][PATCH v4 6/7] fsck: add ref name check for files backend</title><updated>2024-06-19T07:44:20Z</updated><link
href="http://lore.kernel.org/git/ZnKMUV_ozbcg7NG6@ArchLinux/"/><id>urn:uuid:67c055e4-f618-5540-4895-cd45422f79e8</id><thr:in-reply-to
ref="urn:uuid:67cc5cb7-690b-6bd7-e8b6-8d2a3608a3b6"
href="http://lore.kernel.org/git/ZnKKy52QFO2UhqM6@ArchLinux/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The git-fsck(1) only implicitly checks the reference, it does not fully
check refs with bad format name such as standalone &#34;@&#34; and name ending
with &#34;.lock&#34;.

In order to provide such checks, add a new fsck message id &#34;badRefName&#34;
with default ERROR type. Use existing &#34;check_refname_format&#34; to explicit
check the ref name. And add a new unit test to verify the functionality.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Karthik Nayak &lt;karthik.188@gmail.com&gt;
Signed-off-by: shejialuo &lt;shejialuo@gmail.com&gt;
---
 Documentation/fsck-msgids.txt |   3 +
 fsck.h                        |   1 +
 refs/files-backend.c          |  20 +++++++
 t/t0602-reffiles-fsck.sh      | 101 ++++++++++++++++++++++++++++++++++
 4 files <a href="http://lore.kernel.org/git/ZnKMUV_ozbcg7NG6@ArchLinux/#related">changed</a>, 125 insertions(+)
 create mode 100755 t/t0602-reffiles-fsck.sh

<span
class="head">diff --git a/Documentation/fsck-msgids.txt b/Documentation/fsck-msgids.txt
index f643585a34..dab4012246 100644
--- a/Documentation/fsck-msgids.txt
+++ b/Documentation/fsck-msgids.txt
</span><span
class="hunk">@@ -19,6 +19,9 @@
</span> `badParentSha1`::
 	(ERROR) A commit object has a bad parent sha1.
 
<span
class="add">+`badRefName`::
+	(ERROR) A ref has a bad name.
+
</span> `badTagName`::
 	(INFO) A tag has an invalid format.
 
<span
class="head">diff --git a/fsck.h b/fsck.h
index 0391dffbb0..f26dec2ea4 100644
--- a/fsck.h
+++ b/fsck.h
</span><span
class="hunk">@@ -31,6 +31,7 @@ enum fsck_msg_type {
</span> 	FUNC(BAD_NAME, ERROR) \
 	FUNC(BAD_OBJECT_SHA1, ERROR) \
 	FUNC(BAD_PARENT_SHA1, ERROR) \
<span
class="add">+	FUNC(BAD_REF_NAME, ERROR) \
</span> 	FUNC(BAD_TIMEZONE, ERROR) \
 	FUNC(BAD_TREE, ERROR) \
 	FUNC(BAD_TREE_SHA1, ERROR) \
<span
class="head">diff --git a/refs/files-backend.c b/refs/files-backend.c
index 5156530774..5bc233b524 100644
--- a/refs/files-backend.c
+++ b/refs/files-backend.c
</span><span
class="hunk">@@ -3416,6 +3416,25 @@ typedef int (*files_fsck_refs_fn)(struct fsck_options *o,
</span> 				  const char *refs_check_dir,
 				  struct dir_iterator *iter);
 
<span
class="add">+static int files_fsck_refs_name(struct fsck_options *o,
+				const char *gitdir UNUSED,
+				const char *refs_check_dir,
+				struct dir_iterator *iter)
+{
+	struct strbuf sb = STRBUF_INIT;
+	int ret = 0;
+
+	if (check_refname_format(iter-&gt;basename, REFNAME_ALLOW_ONELEVEL)) {
+		strbuf_addf(&#38;sb, &#34;%s/%s&#34;, refs_check_dir, iter-&gt;relative_path);
+		ret = fsck_refs_report(o, sb.buf,
+				       FSCK_MSG_BAD_REF_NAME,
+				       &#34;invalid refname format&#34;);
+	}
+
+	strbuf_release(&#38;sb);
+	return ret;
+}
+
</span> static int files_fsck_refs_dir(struct ref_store *ref_store,
 			       struct fsck_options *o,
 			       const char *refs_check_dir,
<span
class="hunk">@@ -3467,6 +3486,7 @@ static int files_fsck_refs(struct ref_store *ref_store,
</span> {
 	int ret;
 	files_fsck_refs_fn fsck_refs_fns[]= {
<span
class="add">+		files_fsck_refs_name,
</span> 		NULL
 	};
 
<span
class="head">diff --git a/t/t0602-reffiles-fsck.sh b/t/t0602-reffiles-fsck.sh
new file mode 100755
index 0000000000..b2db58d2c6
--- /dev/null
+++ b/t/t0602-reffiles-fsck.sh
</span><span
class="hunk">@@ -0,0 +1,101 @@
</span><span
class="add">+#!/bin/sh
+
+test_description=&#39;Test reffiles backend consistency check&#39;
+
+GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME=main
+export GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME
+GIT_TEST_DEFAULT_REF_FORMAT=files
+export GIT_TEST_DEFAULT_REF_FORMAT
+
+. ./test-lib.sh
+
+test_expect_success &#39;ref name should be checked&#39; &#39;
+	test_when_finished &#34;rm -rf repo&#34; &#38;&#38;
+	git init repo &#38;&#38;
+	branch_dir_prefix=.git/refs/heads &#38;&#38;
+	tag_dir_prefix=.git/refs/tags &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		git commit --allow-empty -m initial &#38;&#38;
+		git checkout -b branch-1 &#38;&#38;
+		git tag tag-1 &#38;&#38;
+		git commit --allow-empty -m second &#38;&#38;
+		git checkout -b branch-2 &#38;&#38;
+		git tag tag-2 &#38;&#38;
+		git tag multi_hierarchy/tag-2
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		cp $branch_dir_prefix/branch-1 $branch_dir_prefix/.branch-1 &#38;&#38;
+		test_must_fail git fsck 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		error: refs/heads/.branch-1: badRefName: invalid refname format
+		EOF
+		rm $branch_dir_prefix/.branch-1 &#38;&#38;
+		test_cmp expect err
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		cp $tag_dir_prefix/tag-1 $tag_dir_prefix/tag-1.lock &#38;&#38;
+		test_must_fail git fsck 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		error: refs/tags/tag-1.lock: badRefName: invalid refname format
+		EOF
+		rm $tag_dir_prefix/tag-1.lock &#38;&#38;
+		test_cmp expect err
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		cp $branch_dir_prefix/branch-1 $branch_dir_prefix/@ &#38;&#38;
+		test_must_fail git fsck 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		error: refs/heads/@: badRefName: invalid refname format
+		EOF
+		rm $branch_dir_prefix/@ &#38;&#38;
+		test_cmp expect err
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		cp $tag_dir_prefix/multi_hierarchy/tag-2 $tag_dir_prefix/multi_hierarchy/@ &#38;&#38;
+		test_must_fail git fsck 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		error: refs/tags/multi_hierarchy/@: badRefName: invalid refname format
+		EOF
+		rm $tag_dir_prefix/multi_hierarchy/@ &#38;&#38;
+		test_cmp expect err
+	)
+&#39;
+
+test_expect_success &#39;ref name check should be adapted into fsck messages&#39; &#39;
+	test_when_finished &#34;rm -rf repo&#34; &#38;&#38;
+	git init repo &#38;&#38;
+	branch_dir_prefix=.git/refs/heads &#38;&#38;
+	tag_dir_prefix=.git/refs/tags &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		git commit --allow-empty -m initial &#38;&#38;
+		git checkout -b branch-1 &#38;&#38;
+		git tag tag-1 &#38;&#38;
+		git commit --allow-empty -m second &#38;&#38;
+		git checkout -b branch-2 &#38;&#38;
+		git tag tag-2
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		cp $branch_dir_prefix/branch-1 $branch_dir_prefix/.branch-1 &#38;&#38;
+		git -c fsck.badRefName=warn fsck 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		warning: refs/heads/.branch-1: badRefName: invalid refname format
+		EOF
+		rm $branch_dir_prefix/.branch-1 &#38;&#38;
+		test_cmp expect err
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		cp $branch_dir_prefix/branch-1 $branch_dir_prefix/@ &#38;&#38;
+		git -c fsck.badRefName=ignore fsck 2&gt;err &#38;&#38;
+		test_must_be_empty err
+	)
+&#39;
+
+test_done
</span>-- 
2.45.2

</pre></div></content></entry><entry><author><name>shejialuo</name><email>shejialuo@gmail.com</email></author><title>[GSoC][PATCH v4 5/7] files-backend: add unified interface for refs scanning</title><updated>2024-06-19T07:43:56Z</updated><link
href="http://lore.kernel.org/git/ZnKMOVsHs-RlheS_@ArchLinux/"/><id>urn:uuid:8aec1c9b-84ac-2f9e-9bb7-2652c8047a83</id><thr:in-reply-to
ref="urn:uuid:67cc5cb7-690b-6bd7-e8b6-8d2a3608a3b6"
href="http://lore.kernel.org/git/ZnKKy52QFO2UhqM6@ArchLinux/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">For refs and reflogs, we need to scan its corresponding directories to
check every regular file or symbolic link which shares the same pattern.
Introduce a unified interface for scanning directories for
files-backend.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Karthik Nayak &lt;karthik.188@gmail.com&gt;
Signed-off-by: shejialuo &lt;shejialuo@gmail.com&gt;
---
 refs/files-backend.c | 77 +++++++++++++++++++++++++++++++++++++++++++-
 1 file <a href="http://lore.kernel.org/git/ZnKMOVsHs-RlheS_@ArchLinux/#related">changed</a>, 76 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/refs/files-backend.c b/refs/files-backend.c
index ba9e57d1e9..5156530774 100644
--- a/refs/files-backend.c
+++ b/refs/files-backend.c
</span><span
class="hunk">@@ -4,6 +4,7 @@
</span> #include &#34;../gettext.h&#34;
 #include &#34;../hash.h&#34;
 #include &#34;../hex.h&#34;
<span
class="add">+#include &#34;../fsck.h&#34;
</span> #include &#34;../refs.h&#34;
 #include &#34;refs-internal.h&#34;
 #include &#34;ref-cache.h&#34;
<span
class="hunk">@@ -3405,6 +3406,78 @@ static int files_ref_store_remove_on_disk(struct ref_store *ref_store,
</span> 	return ret;
 }
 
<span
class="add">+/*
+ * For refs and reflogs, they share a unified interface when scanning
+ * the whole directory. This function is used as the callback for each
+ * regular file or symlink in the directory.
+ */
+typedef int (*files_fsck_refs_fn)(struct fsck_options *o,
+				  const char *gitdir,
+				  const char *refs_check_dir,
+				  struct dir_iterator *iter);
+
+static int files_fsck_refs_dir(struct ref_store *ref_store,
+			       struct fsck_options *o,
+			       const char *refs_check_dir,
+			       files_fsck_refs_fn *fsck_refs_fns)
+{
+	const char *gitdir = ref_store-&gt;gitdir;
+	struct strbuf sb = STRBUF_INIT;
+	struct dir_iterator *iter;
+	int iter_status;
+	int ret = 0;
+
+	strbuf_addf(&#38;sb, &#34;%s/%s&#34;, gitdir, refs_check_dir);
+
+	iter = dir_iterator_begin(sb.buf, 0);
+
+	if (!iter) {
+		ret = error_errno(&#34;cannot open directory %s&#34;, sb.buf);
+		goto out;
+	}
+
+	while ((iter_status = dir_iterator_advance(iter)) == ITER_OK) {
+		if (S_ISDIR(iter-&gt;st.st_mode)) {
+			continue;
+		} else if (S_ISREG(iter-&gt;st.st_mode) ||
+			   S_ISLNK(iter-&gt;st.st_mode)) {
+			if (o-&gt;verbose)
+				fprintf_ln(stderr, &#34;Checking %s/%s&#34;,
+					   refs_check_dir, iter-&gt;relative_path);
+			for (size_t i = 0; fsck_refs_fns[i]; i++) {
+				if (fsck_refs_fns[i](o, gitdir, refs_check_dir, iter))
+					ret = -1;
+			}
+		} else {
+			ret = error(_(&#34;unexpected file type for &#39;%s&#39;&#34;),
+				    iter-&gt;basename);
+		}
+	}
+
+	if (iter_status != ITER_DONE)
+		ret = error(_(&#34;failed to iterate over &#39;%s&#39;&#34;), sb.buf);
+
+out:
+	strbuf_release(&#38;sb);
+	return ret;
+}
+
+static int files_fsck_refs(struct ref_store *ref_store,
+			   struct fsck_options *o)
+{
+	int ret;
+	files_fsck_refs_fn fsck_refs_fns[]= {
+		NULL
+	};
+
+	if (o-&gt;verbose)
+		fprintf_ln(stderr, &#34;Checking references consistency&#34;);
+
+	ret = files_fsck_refs_dir(ref_store, o, &#34;refs&#34;, fsck_refs_fns);
+
+	return ret;
+}
+
</span> static int files_fsck(struct ref_store *ref_store,
 		      struct fsck_options *o)
 {
<span
class="hunk">@@ -3412,7 +3485,9 @@ static int files_fsck(struct ref_store *ref_store,
</span> 	struct files_ref_store *refs =
 		files_downcast(ref_store, REF_STORE_READ, &#34;fsck&#34;);
 
<span
class="del">-	ret = refs-&gt;packed_ref_store-&gt;be-&gt;fsck(refs-&gt;packed_ref_store, o);
</span><span
class="add">+	ret = refs-&gt;packed_ref_store-&gt;be-&gt;fsck(refs-&gt;packed_ref_store, o)
+	    | files_fsck_refs(ref_store, o);
+
</span> 	return ret;
 }
 
-- 
2.45.2

</pre></div></content></entry><entry><author><name>shejialuo</name><email>shejialuo@gmail.com</email></author><title>[GSoC][PATCH v4 4/7] builtin/fsck: add `git-refs verify` child process</title><updated>2024-06-19T07:42:39Z</updated><link
href="http://lore.kernel.org/git/ZnKL7Evg-lLIzW4e@ArchLinux/"/><id>urn:uuid:370edb7d-a96b-f1b5-601f-784a8de59ec0</id><thr:in-reply-to
ref="urn:uuid:67cc5cb7-690b-6bd7-e8b6-8d2a3608a3b6"
href="http://lore.kernel.org/git/ZnKKy52QFO2UhqM6@ArchLinux/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Introduce a new function &#34;fsck_refs&#34; that initializes and runs a child
process to execute the &#34;git-refs verify&#34; command.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Karthik Nayak &lt;karthik.188@gmail.com&gt;
Signed-off-by: shejialuo &lt;shejialuo@gmail.com&gt;
---
 builtin/fsck.c | 17 +++++++++++++++++
 1 file <a href="http://lore.kernel.org/git/ZnKL7Evg-lLIzW4e@ArchLinux/#related">changed</a>, 17 insertions(+)

<span
class="head">diff --git a/builtin/fsck.c b/builtin/fsck.c
index a5b82e228c..cd988ff167 100644
--- a/builtin/fsck.c
+++ b/builtin/fsck.c
</span><span
class="hunk">@@ -896,6 +896,21 @@ static int check_pack_rev_indexes(struct repository *r, int show_progress)
</span> 	return res;
 }
 
<span
class="add">+static void fsck_refs(void)
+{
+	struct child_process refs_verify = CHILD_PROCESS_INIT;
+	child_process_init(&#38;refs_verify);
+	refs_verify.git_cmd = 1;
+	strvec_pushl(&#38;refs_verify.args, &#34;refs&#34;, &#34;verify&#34;, NULL);
+	if (verbose)
+		strvec_push(&#38;refs_verify.args, &#34;--verbose&#34;);
+	if (check_strict)
+		strvec_push(&#38;refs_verify.args, &#34;--strict&#34;);
+
+	if (run_command(&#38;refs_verify))
+		errors_found |= ERROR_REFS;
+}
+
</span> static char const * const fsck_usage[] = {
 	N_(&#34;git fsck [--tags] [--root] [--unreachable] [--cache] [--no-reflogs]\n&#34;
 	   &#34;         [--[no-]full] [--strict] [--verbose] [--lost-found]\n&#34;
<span
class="hunk">@@ -1065,6 +1080,8 @@ int cmd_fsck(int argc, const char **argv, const char *prefix)
</span> 
 	check_connectivity();
 
<span
class="add">+	fsck_refs();
+
</span> 	if (the_repository-&gt;settings.core_commit_graph) {
 		struct child_process commit_graph_verify = CHILD_PROCESS_INIT;
 
-- 
2.45.2

</pre></div></content></entry><entry><author><name>shejialuo</name><email>shejialuo@gmail.com</email></author><title>[GSoC][PATCH v4 3/7] builtin/refs: add verify subcommand</title><updated>2024-06-19T07:42:14Z</updated><link
href="http://lore.kernel.org/git/ZnKL0-u_s19-Fdmt@ArchLinux/"/><id>urn:uuid:2b10daa7-f369-85ad-26a4-bc0c42535e10</id><thr:in-reply-to
ref="urn:uuid:67cc5cb7-690b-6bd7-e8b6-8d2a3608a3b6"
href="http://lore.kernel.org/git/ZnKKy52QFO2UhqM6@ArchLinux/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Introduce a new subcommand &#34;verify&#34; in git-refs(1) to allow the user to
check the reference database consistency.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Karthik Nayak &lt;karthik.188@gmail.com&gt;
Signed-off-by: shejialuo &lt;shejialuo@gmail.com&gt;
---
 Documentation/git-refs.txt | 13 +++++++++++
 builtin/refs.c             | 45 ++++++++++++++++++++++++++++++++++++++
 2 files <a href="http://lore.kernel.org/git/ZnKL0-u_s19-Fdmt@ArchLinux/#related">changed</a>, 58 insertions(+)

<span
class="head">diff --git a/Documentation/git-refs.txt b/Documentation/git-refs.txt
index 5b99e04385..1244a85b64 100644
--- a/Documentation/git-refs.txt
+++ b/Documentation/git-refs.txt
</span><span
class="hunk">@@ -10,6 +10,7 @@ SYNOPSIS
</span> --------
 [verse]
 &#39;git refs migrate&#39; --ref-format=&lt;format&gt; [--dry-run]
<span
class="add">+&#39;git refs verify&#39; [--strict] [--verbose]
</span> 
 DESCRIPTION
 -----------
<span
class="hunk">@@ -22,6 +23,9 @@ COMMANDS
</span> migrate::
 	Migrate ref store between different formats.
 
<span
class="add">+verify::
+	Verify reference database consistency.
+
</span> OPTIONS
 -------
 
<span
class="hunk">@@ -39,6 +43,15 @@ include::ref-storage-format.txt[]
</span> 	can be used to double check that the migration works as expected before
 	performing the actual migration.
 
<span
class="add">+The following options are specific to &#39;git refs verify&#39;:
+
+--strict::
+	Enable more strict checking, every WARN severity for the `Fsck Messages`
+	be seen as ERROR. See linkgit:git-fsck[1].
+
+--verbose::
+	When verifying the reference database consistency, be chatty.
+
</span> KNOWN LIMITATIONS
 -----------------
 
<span
class="head">diff --git a/builtin/refs.c b/builtin/refs.c
index 46dcd150d4..231a051f6b 100644
--- a/builtin/refs.c
+++ b/builtin/refs.c
</span><span
class="hunk">@@ -1,4 +1,6 @@
</span> #include &#34;builtin.h&#34;
<span
class="add">+#include &#34;config.h&#34;
+#include &#34;fsck.h&#34;
</span> #include &#34;parse-options.h&#34;
 #include &#34;refs.h&#34;
 #include &#34;repository.h&#34;
<span
class="hunk">@@ -7,6 +9,9 @@
</span> #define REFS_MIGRATE_USAGE \
 	N_(&#34;git refs migrate --ref-format=&lt;format&gt; [--dry-run]&#34;)
 
<span
class="add">+#define REFS_VERIFY_USAGE \
+	N_(&#34;git refs verify [--strict] [--verbose]&#34;)
+
</span> static int cmd_refs_migrate(int argc, const char **argv, const char *prefix)
 {
 	const char * const migrate_usage[] = {
<span
class="hunk">@@ -58,15 +63,55 @@ static int cmd_refs_migrate(int argc, const char **argv, const char *prefix)
</span> 	return err;
 }
 
<span
class="add">+static int cmd_refs_verify(int argc, const char **argv, const char *prefix)
+{
+	const char * const verify_usage[] = {
+		REFS_VERIFY_USAGE,
+		NULL,
+	};
+	int ret = 0;
+	unsigned int verbose = 0, strict = 0;
+	struct fsck_options fsck_options = FSCK_OPTIONS_DEFAULT;
+	struct option options[] = {
+		OPT__VERBOSE(&#38;verbose, N_(&#34;be verbose&#34;)),
+		OPT_BOOL(0, &#34;strict&#34;, &#38;strict, N_(&#34;enable strict checking&#34;)),
+		OPT_END(),
+	};
+
+	argc = parse_options(argc, argv, prefix, options, verify_usage, 0);
+	if (argc)
+		usage(_(&#34;too many arguments&#34;));
+
+	if (verbose)
+		fsck_options.verbose = 1;
+	if (strict)
+		fsck_options.strict = 1;
+
+	git_config(git_fsck_config, &#38;fsck_options);
+	prepare_repo_settings(the_repository);
+
+	ret = refs_fsck(get_main_ref_store(the_repository), &#38;fsck_options);
+
+	/*
+	 * Explicitly free the allocated array and object skiplist set. Because
+	 * we reuse `git_fsck_config` here. It will still set the skiplist.
+	 */
+	free(fsck_options.msg_type);
+	oidset_clear(&#38;fsck_options.objs_options.skiplist);
+	return ret;
+}
+
</span> int cmd_refs(int argc, const char **argv, const char *prefix)
 {
 	const char * const refs_usage[] = {
 		REFS_MIGRATE_USAGE,
<span
class="add">+		REFS_VERIFY_USAGE,
</span> 		NULL,
 	};
 	parse_opt_subcommand_fn *fn = NULL;
 	struct option opts[] = {
 		OPT_SUBCOMMAND(&#34;migrate&#34;, &#38;fn, cmd_refs_migrate),
<span
class="add">+		OPT_SUBCOMMAND(&#34;verify&#34;, &#38;fn, cmd_refs_verify),
</span> 		OPT_END(),
 	};
 
-- 
2.45.2

</pre></div></content></entry><entry><author><name>shejialuo</name><email>shejialuo@gmail.com</email></author><title>[GSoC][PATCH v4 2/7] refs: set up ref consistency check infrastructure</title><updated>2024-06-19T07:41:38Z</updated><link
href="http://lore.kernel.org/git/ZnKLr-H_HI-I-7xo@ArchLinux/"/><id>urn:uuid:93107620-78d7-bb4b-c55f-3c5541d714fd</id><thr:in-reply-to
ref="urn:uuid:67cc5cb7-690b-6bd7-e8b6-8d2a3608a3b6"
href="http://lore.kernel.org/git/ZnKKy52QFO2UhqM6@ArchLinux/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The interfaces defined in the `ref_storage_be` are carefully structured
in semantic. It&#39;s organized as the five parts:

1. The name and the initialization interfaces.
2. The ref transaction interfaces.
3. The ref internal interfaces (pack, rename and copy).
4. The ref filesystem interfaces.
5. The reflog related interfaces.

To keep consistent with the git-fsck(1), add a new interface named
&#34;fsck_refs_fn&#34; to the end of &#34;ref_storage_be&#34;. This semantic cannot be
grouped into any above five categories. Explicitly add blank line to
make it different from others.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Karthik Nayak &lt;karthik.188@gmail.com&gt;
Signed-off-by: shejialuo &lt;shejialuo@gmail.com&gt;
---
 refs.c                  |  5 +++++
 refs.h                  |  8 ++++++++
 refs/debug.c            | 11 +++++++++++
 refs/files-backend.c    | 15 ++++++++++++++-
 refs/packed-backend.c   |  8 ++++++++
 refs/refs-internal.h    |  6 ++++++
 refs/reftable-backend.c |  8 ++++++++
 7 files <a href="http://lore.kernel.org/git/ZnKLr-H_HI-I-7xo@ArchLinux/#related">changed</a>, 60 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/refs.c b/refs.c
index 0c1e45f5a9..cb3b8ec36a 100644
--- a/refs.c
+++ b/refs.c
</span><span
class="hunk">@@ -316,6 +316,11 @@ int check_refname_format(const char *refname, int flags)
</span> 	return check_or_sanitize_refname(refname, flags, NULL);
 }
 
<span
class="add">+int refs_fsck(struct ref_store *refs, struct fsck_options *o)
+{
+	return refs-&gt;be-&gt;fsck(refs, o);
+}
+
</span> void sanitize_refname_component(const char *refname, struct strbuf *out)
 {
 	if (check_or_sanitize_refname(refname, REFNAME_ALLOW_ONELEVEL, out))
<span
class="head">diff --git a/refs.h b/refs.h
index 756039a051..93fa23c7ee 100644
--- a/refs.h
+++ b/refs.h
</span><span
class="hunk">@@ -3,6 +3,7 @@
</span> 
 #include &#34;commit.h&#34;
 
<span
class="add">+struct fsck_options;
</span> struct object_id;
 struct ref_store;
 struct repository;
<span
class="hunk">@@ -547,6 +548,13 @@ int refs_for_each_reflog(struct ref_store *refs, each_reflog_fn fn, void *cb_dat
</span>  */
 int check_refname_format(const char *refname, int flags);
 
<span
class="add">+/*
+ * Check the reference database for consistency. Return 0 if refs and
+ * reflogs are consistent, and non-zero otherwise. The errors will be
+ * written to stderr.
+ */
+int refs_fsck(struct ref_store *refs, struct fsck_options *o);
+
</span> /*
  * Apply the rules from check_refname_format, but mutate the result until it
  * is acceptable, and place the result in &#34;out&#34;.
<span
class="head">diff --git a/refs/debug.c b/refs/debug.c
index 547d9245b9..45e2e784a0 100644
--- a/refs/debug.c
+++ b/refs/debug.c
</span><span
class="hunk">@@ -419,6 +419,15 @@ static int debug_reflog_expire(struct ref_store *ref_store, const char *refname,
</span> 	return res;
 }
 
<span
class="add">+static int debug_fsck(struct ref_store *ref_store,
+		      struct fsck_options *o)
+{
+	struct debug_ref_store *drefs = (struct debug_ref_store *)ref_store;
+	int res = drefs-&gt;refs-&gt;be-&gt;fsck(drefs-&gt;refs, o);
+	trace_printf_key(&#38;trace_refs, &#34;fsck: %d\n&#34;, res);
+	return res;
+}
+
</span> struct ref_storage_be refs_be_debug = {
 	.name = &#34;debug&#34;,
 	.init = NULL,
<span
class="hunk">@@ -451,4 +460,6 @@ struct ref_storage_be refs_be_debug = {
</span> 	.create_reflog = debug_create_reflog,
 	.delete_reflog = debug_delete_reflog,
 	.reflog_expire = debug_reflog_expire,
<span
class="add">+
+	.fsck = debug_fsck,
</span> };
<span
class="head">diff --git a/refs/files-backend.c b/refs/files-backend.c
index 4519b46171..ba9e57d1e9 100644
--- a/refs/files-backend.c
+++ b/refs/files-backend.c
</span><span
class="hunk">@@ -3405,6 +3405,17 @@ static int files_ref_store_remove_on_disk(struct ref_store *ref_store,
</span> 	return ret;
 }
 
<span
class="add">+static int files_fsck(struct ref_store *ref_store,
+		      struct fsck_options *o)
+{
+	int ret;
+	struct files_ref_store *refs =
+		files_downcast(ref_store, REF_STORE_READ, &#34;fsck&#34;);
+
+	ret = refs-&gt;packed_ref_store-&gt;be-&gt;fsck(refs-&gt;packed_ref_store, o);
+	return ret;
+}
+
</span> struct ref_storage_be refs_be_files = {
 	.name = &#34;files&#34;,
 	.init = files_ref_store_init,
<span
class="hunk">@@ -3431,5 +3442,7 @@ struct ref_storage_be refs_be_files = {
</span> 	.reflog_exists = files_reflog_exists,
 	.create_reflog = files_create_reflog,
 	.delete_reflog = files_delete_reflog,
<span
class="del">-	.reflog_expire = files_reflog_expire
</span><span
class="add">+	.reflog_expire = files_reflog_expire,
+
+	.fsck = files_fsck,
</span> };
<span
class="head">diff --git a/refs/packed-backend.c b/refs/packed-backend.c
index c4c1e36aa2..ad3e8fb1d1 100644
--- a/refs/packed-backend.c
+++ b/refs/packed-backend.c
</span><span
class="hunk">@@ -1733,6 +1733,12 @@ static struct ref_iterator *packed_reflog_iterator_begin(struct ref_store *ref_s
</span> 	return empty_ref_iterator_begin();
 }
 
<span
class="add">+static int packed_fsck(struct ref_store *ref_store,
+		       struct fsck_options *o)
+{
+	return 0;
+}
+
</span> struct ref_storage_be refs_be_packed = {
 	.name = &#34;packed&#34;,
 	.init = packed_ref_store_init,
<span
class="hunk">@@ -1760,4 +1766,6 @@ struct ref_storage_be refs_be_packed = {
</span> 	.create_reflog = NULL,
 	.delete_reflog = NULL,
 	.reflog_expire = NULL,
<span
class="add">+
+	.fsck = packed_fsck,
</span> };
<span
class="head">diff --git a/refs/refs-internal.h b/refs/refs-internal.h
index cbcb6f9c36..280acb7f9e 100644
--- a/refs/refs-internal.h
+++ b/refs/refs-internal.h
</span><span
class="hunk">@@ -4,6 +4,7 @@
</span> #include &#34;refs.h&#34;
 #include &#34;iterator.h&#34;
 
<span
class="add">+struct fsck_options;
</span> struct ref_transaction;
 
 /*
<span
class="hunk">@@ -650,6 +651,9 @@ typedef int read_raw_ref_fn(struct ref_store *ref_store, const char *refname,
</span> typedef int read_symbolic_ref_fn(struct ref_store *ref_store, const char *refname,
 				 struct strbuf *referent);
 
<span
class="add">+typedef int fsck_fn(struct ref_store *ref_store,
+		    struct fsck_options *o);
+
</span> struct ref_storage_be {
 	const char *name;
 	ref_store_init_fn *init;
<span
class="hunk">@@ -677,6 +681,8 @@ struct ref_storage_be {
</span> 	create_reflog_fn *create_reflog;
 	delete_reflog_fn *delete_reflog;
 	reflog_expire_fn *reflog_expire;
<span
class="add">+
+	fsck_fn *fsck;
</span> };
 
 extern struct ref_storage_be refs_be_files;
<span
class="head">diff --git a/refs/reftable-backend.c b/refs/reftable-backend.c
index 3a75d63eb5..2b2630d47a 100644
--- a/refs/reftable-backend.c
+++ b/refs/reftable-backend.c
</span><span
class="hunk">@@ -2281,6 +2281,12 @@ static int reftable_be_reflog_expire(struct ref_store *ref_store,
</span> 	return ret;
 }
 
<span
class="add">+static int reftable_be_fsck(struct ref_store *ref_store,
+			    struct fsck_options *o)
+{
+	return 0;
+}
+
</span> struct ref_storage_be refs_be_reftable = {
 	.name = &#34;reftable&#34;,
 	.init = reftable_be_init,
<span
class="hunk">@@ -2308,4 +2314,6 @@ struct ref_storage_be refs_be_reftable = {
</span> 	.create_reflog = reftable_be_create_reflog,
 	.delete_reflog = reftable_be_delete_reflog,
 	.reflog_expire = reftable_be_reflog_expire,
<span
class="add">+
+	.fsck = reftable_be_fsck,
</span> };
-- 
2.45.2

</pre></div></content></entry><entry><author><name>shejialuo</name><email>shejialuo@gmail.com</email></author><title>[GSoC][PATCH v4 1/7] fsck: add refs check interfaces to interact with fsck error levels</title><updated>2024-06-19T07:41:03Z</updated><link
href="http://lore.kernel.org/git/ZnKLja6bSNLukkTR@ArchLinux/"/><id>urn:uuid:ddda540b-7210-4f8d-291b-2ffd1a49fdfc</id><thr:in-reply-to
ref="urn:uuid:67cc5cb7-690b-6bd7-e8b6-8d2a3608a3b6"
href="http://lore.kernel.org/git/ZnKKy52QFO2UhqM6@ArchLinux/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The git-fsck(1) focuses on object database consistency check. It relies
on the &#34;fsck_options&#34; to interact with fsck error levels. However,
&#34;fsck_options&#34; aims at checking the object database which contains a lot
of fields only related to object database.

In order to add ref operations, create a new struct named
&#34;fsck_refs_options&#34; and a new struct named &#34;fsck_objs_options&#34;. Remove
object-related fields from &#34;fsck_options&#34; to &#34;fsck_objs_options&#34;. Change
the &#34;fsck_options&#34; with three parts of members:

1. The &#34;fsck_refs_options&#34;.
2. The &#34;fsck_objs_options&#34;.
3. The common settings both for refs and objects. Because we leave
   common settings in &#34;fsck_options&#34;. The setup process could be fully
   reused without any code changing.

Also add related macros to align with the current code. Because we
remove some fields from &#34;fsck_options&#34; to &#34;fsck_objs_options&#34;. Change
the influenced code to use the &#34;fsck_options.objs_options&#34; instead of
using &#34;fsck_options&#34; itself.

The static function &#34;report&#34; provided by &#34;fsck.c&#34; aims at reporting the
problems related to object database which cannot be reused for refs.
Provide &#34;fsck_refs_report&#34; function to integrate the fsck error levels
into reference consistency check.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Karthik Nayak &lt;karthik.188@gmail.com&gt;
Signed-off-by: shejialuo &lt;shejialuo@gmail.com&gt;
---
 builtin/fsck.c           |   8 +--
 builtin/index-pack.c     |   2 +-
 builtin/mktag.c          |   5 +-
 builtin/unpack-objects.c |   2 +-
 fetch-pack.c             |   8 +--
 fsck.c                   | 113 +++++++++++++++++++++++++++++----------
 fsck.h                   |  79 ++++++++++++++++++++-------
 object-file.c            |   2 +-
 8 files <a href="http://lore.kernel.org/git/ZnKLja6bSNLukkTR@ArchLinux/#related">changed</a>, 161 insertions(+), 58 deletions(-)

<span
class="head">diff --git a/builtin/fsck.c b/builtin/fsck.c
index d13a226c2e..a5b82e228c 100644
--- a/builtin/fsck.c
+++ b/builtin/fsck.c
</span><span
class="hunk">@@ -233,7 +233,7 @@ static void mark_unreachable_referents(const struct object_id *oid)
</span> 			object_as_type(obj, type, 0);
 	}
 
<span
class="del">-	options.walk = mark_used;
</span><span
class="add">+	options.objs_options.walk = mark_used;
</span> 	fsck_walk(obj, NULL, &#38;options);
 	if (obj-&gt;type == OBJ_TREE)
 		free_tree_buffer((struct tree *)obj);
<span
class="hunk">@@ -936,9 +936,9 @@ int cmd_fsck(int argc, const char **argv, const char *prefix)
</span> 
 	argc = parse_options(argc, argv, prefix, fsck_opts, fsck_usage, 0);
 
<span
class="del">-	fsck_walk_options.walk = mark_object;
-	fsck_obj_options.walk = mark_used;
-	fsck_obj_options.error_func = fsck_error_func;
</span><span
class="add">+	fsck_walk_options.objs_options.walk = mark_object;
+	fsck_obj_options.objs_options.walk = mark_used;
+	fsck_obj_options.objs_options.error_func = fsck_error_func;
</span> 	if (check_strict)
 		fsck_obj_options.strict = 1;
 
<span
class="head">diff --git a/builtin/index-pack.c b/builtin/index-pack.c
index 856428fef9..8824d7b8a9 100644
--- a/builtin/index-pack.c
+++ b/builtin/index-pack.c
</span><span
class="hunk">@@ -1746,7 +1746,7 @@ int cmd_index_pack(int argc, const char **argv, const char *prefix)
</span> 		usage(index_pack_usage);
 
 	disable_replace_refs();
<span
class="del">-	fsck_options.walk = mark_link;
</span><span
class="add">+	fsck_options.objs_options.walk = mark_link;
</span> 
 	reset_pack_idx_option(&#38;opts);
 	opts.flags |= WRITE_REV;
<span
class="head">diff --git a/builtin/mktag.c b/builtin/mktag.c
index 4767f1a97e..e88475f009 100644
--- a/builtin/mktag.c
+++ b/builtin/mktag.c
</span><span
class="hunk">@@ -91,8 +91,9 @@ int cmd_mktag(int argc, const char **argv, const char *prefix)
</span> 	if (strbuf_read(&#38;buf, 0, 0) &lt; 0)
 		die_errno(_(&#34;could not read from stdin&#34;));
 
<span
class="del">-	fsck_options.error_func = mktag_fsck_error_func;
-	fsck_set_msg_type_from_ids(&#38;fsck_options, FSCK_MSG_EXTRA_HEADER_ENTRY,
</span><span
class="add">+	fsck_options.objs_options.error_func = mktag_fsck_error_func;
+	fsck_set_msg_type_from_ids(&#38;fsck_options,
+				   FSCK_MSG_EXTRA_HEADER_ENTRY,
</span> 				   FSCK_WARN);
 	/* config might set fsck.extraHeaderEntry=* again */
 	git_config(git_fsck_config, &#38;fsck_options);
<span
class="head">diff --git a/builtin/unpack-objects.c b/builtin/unpack-objects.c
index f1c85a00ae..368810a2a1 100644
--- a/builtin/unpack-objects.c
+++ b/builtin/unpack-objects.c
</span><span
class="hunk">@@ -239,7 +239,7 @@ static int check_object(struct object *obj, enum object_type type,
</span> 		die(&#34;Whoops! Cannot find object &#39;%s&#39;&#34;, oid_to_hex(&#38;obj-&gt;oid));
 	if (fsck_object(obj, obj_buf-&gt;buffer, obj_buf-&gt;size, &#38;fsck_options))
 		die(&#34;fsck error in packed object&#34;);
<span
class="del">-	fsck_options.walk = check_object;
</span><span
class="add">+	fsck_options.objs_options.walk = check_object;
</span> 	if (fsck_walk(obj, NULL, &#38;fsck_options))
 		die(&#34;Error on reachable objects of %s&#34;, oid_to_hex(&#38;obj-&gt;oid));
 	write_cached_object(obj, obj_buf);
<span
class="head">diff --git a/fetch-pack.c b/fetch-pack.c
index eba9e420ea..148f9bd371 100644
--- a/fetch-pack.c
+++ b/fetch-pack.c
</span><span
class="hunk">@@ -1220,7 +1220,7 @@ static struct ref *do_fetch_pack(struct fetch_pack_args *args,
</span> 	} else
 		alternate_shallow_file = NULL;
 	if (get_pack(args, fd, pack_lockfiles, NULL, sought, nr_sought,
<span
class="del">-		     &#38;fsck_options.gitmodules_found))
</span><span
class="add">+		     &#38;fsck_options.objs_options.gitmodules_found))
</span> 		die(_(&#34;git fetch-pack: fetch failed.&#34;));
 	if (fsck_finish(&#38;fsck_options))
 		die(&#34;fsck failed&#34;);
<span
class="hunk">@@ -1780,7 +1780,8 @@ static struct ref *do_fetch_pack_v2(struct fetch_pack_args *args,
</span> 
 			if (get_pack(args, fd, pack_lockfiles,
 				     packfile_uris.nr ? &#38;index_pack_args : NULL,
<span
class="del">-				     sought, nr_sought, &#38;fsck_options.gitmodules_found))
</span><span
class="add">+				     sought, nr_sought,
+				     &#38;fsck_options.objs_options.gitmodules_found))
</span> 				die(_(&#34;git fetch-pack: fetch failed.&#34;));
 			do_check_stateless_delimiter(args-&gt;stateless_rpc, &#38;reader);
 
<span
class="hunk">@@ -1823,7 +1824,8 @@ static struct ref *do_fetch_pack_v2(struct fetch_pack_args *args,
</span> 
 		packname[the_hash_algo-&gt;hexsz] = &#39;\0&#39;;
 
<span
class="del">-		parse_gitmodules_oids(cmd.out, &#38;fsck_options.gitmodules_found);
</span><span
class="add">+		parse_gitmodules_oids(cmd.out,
+				      &#38;fsck_options.objs_options.gitmodules_found);
</span> 
 		close(cmd.out);
 
<span
class="head">diff --git a/fsck.c b/fsck.c
index e193930ae7..4949d2e110 100644
--- a/fsck.c
+++ b/fsck.c
</span><span
class="hunk">@@ -203,7 +203,8 @@ void fsck_set_msg_types(struct fsck_options *options, const char *values)
</span> 		if (!strcmp(buf, &#34;skiplist&#34;)) {
 			if (equal == len)
 				die(&#34;skiplist requires a path&#34;);
<span
class="del">-			oidset_parse_file(&#38;options-&gt;skiplist, buf + equal + 1);
</span><span
class="add">+			oidset_parse_file(&#38;options-&gt;objs_options.skiplist,
+					  buf + equal + 1);
</span> 			buf += len + 1;
 			continue;
 		}
<span
class="hunk">@@ -220,7 +221,7 @@ void fsck_set_msg_types(struct fsck_options *options, const char *values)
</span> static int object_on_skiplist(struct fsck_options *opts,
 			      const struct object_id *oid)
 {
<span
class="del">-	return opts &#38;&#38; oid &#38;&#38; oidset_contains(&#38;opts-&gt;skiplist, oid);
</span><span
class="add">+	return opts &#38;&#38; oid &#38;&#38; oidset_contains(&#38;opts-&gt;objs_options.skiplist, oid);
</span> }
 
 __attribute__((format (printf, 5, 6)))
<span
class="hunk">@@ -249,8 +250,8 @@ static int report(struct fsck_options *options,
</span> 
 	va_start(ap, fmt);
 	strbuf_vaddf(&#38;sb, fmt, ap);
<span
class="del">-	result = options-&gt;error_func(options, oid, object_type,
-				     msg_type, msg_id, sb.buf);
</span><span
class="add">+	result = options-&gt;objs_options.error_func(options, oid, object_type,
+						  msg_type, msg_id, sb.buf);
</span> 	strbuf_release(&#38;sb);
 	va_end(ap);
 
<span
class="hunk">@@ -259,20 +260,20 @@ static int report(struct fsck_options *options,
</span> 
 void fsck_enable_object_names(struct fsck_options *options)
 {
<span
class="del">-	if (!options-&gt;object_names)
-		options-&gt;object_names = kh_init_oid_map();
</span><span
class="add">+	if (!options-&gt;objs_options.object_names)
+		options-&gt;objs_options.object_names = kh_init_oid_map();
</span> }
 
 const char *fsck_get_object_name(struct fsck_options *options,
 				 const struct object_id *oid)
 {
 	khiter_t pos;
<span
class="del">-	if (!options-&gt;object_names)
</span><span
class="add">+	if (!options-&gt;objs_options.object_names)
</span> 		return NULL;
<span
class="del">-	pos = kh_get_oid_map(options-&gt;object_names, *oid);
-	if (pos &gt;= kh_end(options-&gt;object_names))
</span><span
class="add">+	pos = kh_get_oid_map(options-&gt;objs_options.object_names, *oid);
+	if (pos &gt;= kh_end(options-&gt;objs_options.object_names))
</span> 		return NULL;
<span
class="del">-	return kh_value(options-&gt;object_names, pos);
</span><span
class="add">+	return kh_value(options-&gt;objs_options.object_names, pos);
</span> }
 
 void fsck_put_object_name(struct fsck_options *options,
<span
class="hunk">@@ -284,15 +285,17 @@ void fsck_put_object_name(struct fsck_options *options,
</span> 	khiter_t pos;
 	int hashret;
 
<span
class="del">-	if (!options-&gt;object_names)
</span><span
class="add">+	if (!options-&gt;objs_options.object_names)
</span> 		return;
 
<span
class="del">-	pos = kh_put_oid_map(options-&gt;object_names, *oid, &#38;hashret);
</span><span
class="add">+	pos = kh_put_oid_map(options-&gt;objs_options.object_names,
+			     *oid, &#38;hashret);
</span> 	if (!hashret)
 		return;
 	va_start(ap, fmt);
 	strbuf_vaddf(&#38;buf, fmt, ap);
<span
class="del">-	kh_value(options-&gt;object_names, pos) = strbuf_detach(&#38;buf, NULL);
</span><span
class="add">+	kh_value(options-&gt;objs_options.object_names, pos) =
+		strbuf_detach(&#38;buf, NULL);
</span> 	va_end(ap);
 }
 
<span
class="hunk">@@ -318,6 +321,7 @@ const char *fsck_describe_object(struct fsck_options *options,
</span> 
 static int fsck_walk_tree(struct tree *tree, void *data, struct fsck_options *options)
 {
<span
class="add">+	struct fsck_objs_options *objs_options = &#38;options-&gt;objs_options;
</span> 	struct tree_desc desc;
 	struct name_entry entry;
 	int res = 0;
<span
class="hunk">@@ -342,14 +346,14 @@ static int fsck_walk_tree(struct tree *tree, void *data, struct fsck_options *op
</span> 			if (name &#38;&#38; obj)
 				fsck_put_object_name(options, &#38;entry.oid, &#34;%s%s/&#34;,
 						     name, entry.path);
<span
class="del">-			result = options-&gt;walk(obj, OBJ_TREE, data, options);
</span><span
class="add">+			result = objs_options-&gt;walk(obj, OBJ_TREE, data, options);
</span> 		}
 		else if (S_ISREG(entry.mode) || S_ISLNK(entry.mode)) {
 			obj = (struct object *)lookup_blob(the_repository, &#38;entry.oid);
 			if (name &#38;&#38; obj)
 				fsck_put_object_name(options, &#38;entry.oid, &#34;%s%s&#34;,
 						     name, entry.path);
<span
class="del">-			result = options-&gt;walk(obj, OBJ_BLOB, data, options);
</span><span
class="add">+			result = objs_options-&gt;walk(obj, OBJ_BLOB, data, options);
</span> 		}
 		else {
 			result = error(&#34;in tree %s: entry %s has bad mode %.6o&#34;,
<span
class="hunk">@@ -366,6 +370,7 @@ static int fsck_walk_tree(struct tree *tree, void *data, struct fsck_options *op
</span> 
 static int fsck_walk_commit(struct commit *commit, void *data, struct fsck_options *options)
 {
<span
class="add">+	struct fsck_objs_options *objs_options = &#38;options-&gt;objs_options;
</span> 	int counter = 0, generation = 0, name_prefix_len = 0;
 	struct commit_list *parents;
 	int res;
<span
class="hunk">@@ -380,8 +385,8 @@ static int fsck_walk_commit(struct commit *commit, void *data, struct fsck_optio
</span> 		fsck_put_object_name(options, get_commit_tree_oid(commit),
 				     &#34;%s:&#34;, name);
 
<span
class="del">-	result = options-&gt;walk((struct object *) repo_get_commit_tree(the_repository, commit),
-			       OBJ_TREE, data, options);
</span><span
class="add">+	result = objs_options-&gt;walk((struct object *) repo_get_commit_tree(the_repository, commit),
+				    OBJ_TREE, data, options);
</span> 	if (result &lt; 0)
 		return result;
 	res = result;
<span
class="hunk">@@ -423,7 +428,8 @@ static int fsck_walk_commit(struct commit *commit, void *data, struct fsck_optio
</span> 			else
 				fsck_put_object_name(options, oid, &#34;%s^&#34;, name);
 		}
<span
class="del">-		result = options-&gt;walk((struct object *)parents-&gt;item, OBJ_COMMIT, data, options);
</span><span
class="add">+		result = objs_options-&gt;walk((struct object *)parents-&gt;item,
+					    OBJ_COMMIT, data, options);
</span> 		if (result &lt; 0)
 			return result;
 		if (!res)
<span
class="hunk">@@ -436,12 +442,13 @@ static int fsck_walk_commit(struct commit *commit, void *data, struct fsck_optio
</span> static int fsck_walk_tag(struct tag *tag, void *data, struct fsck_options *options)
 {
 	const char *name = fsck_get_object_name(options, &#38;tag-&gt;object.oid);
<span
class="add">+	struct fsck_objs_options *objs_options = &#38;options-&gt;objs_options;
</span> 
 	if (parse_tag(tag))
 		return -1;
 	if (name)
 		fsck_put_object_name(options, &#38;tag-&gt;tagged-&gt;oid, &#34;%s&#34;, name);
<span
class="del">-	return options-&gt;walk(tag-&gt;tagged, OBJ_ANY, data, options);
</span><span
class="add">+	return objs_options-&gt;walk(tag-&gt;tagged, OBJ_ANY, data, options);
</span> }
 
 int fsck_walk(struct object *obj, void *data, struct fsck_options *options)
<span
class="hunk">@@ -598,6 +605,7 @@ static int fsck_tree(const struct object_id *tree_oid,
</span> 	unsigned o_mode;
 	const char *o_name;
 	struct name_stack df_dup_candidates = { NULL };
<span
class="add">+	struct fsck_objs_options *objs_options = &#38;options-&gt;objs_options;
</span> 
 	if (init_tree_desc_gently(&#38;desc, tree_oid, buffer, size,
 				  TREE_DESC_RAW_MODES)) {
<span
class="hunk">@@ -628,7 +636,7 @@ static int fsck_tree(const struct object_id *tree_oid,
</span> 
 		if (is_hfs_dotgitmodules(name) || is_ntfs_dotgitmodules(name)) {
 			if (!S_ISLNK(mode))
<span
class="del">-				oidset_insert(&#38;options-&gt;gitmodules_found,
</span><span
class="add">+				oidset_insert(&#38;objs_options-&gt;gitmodules_found,
</span> 					      entry_oid);
 			else
 				retval += report(options,
<span
class="hunk">@@ -639,7 +647,7 @@ static int fsck_tree(const struct object_id *tree_oid,
</span> 
 		if (is_hfs_dotgitattributes(name) || is_ntfs_dotgitattributes(name)) {
 			if (!S_ISLNK(mode))
<span
class="del">-				oidset_insert(&#38;options-&gt;gitattributes_found,
</span><span
class="add">+				oidset_insert(&#38;objs_options-&gt;gitattributes_found,
</span> 					      entry_oid);
 			else
 				retval += report(options, tree_oid, OBJ_TREE,
<span
class="hunk">@@ -666,7 +674,7 @@ static int fsck_tree(const struct object_id *tree_oid,
</span> 				has_dotgit |= is_ntfs_dotgit(backslash);
 				if (is_ntfs_dotgitmodules(backslash)) {
 					if (!S_ISLNK(mode))
<span
class="del">-						oidset_insert(&#38;options-&gt;gitmodules_found,
</span><span
class="add">+						oidset_insert(&#38;objs_options-&gt;gitmodules_found,
</span> 							      entry_oid);
 					else
 						retval += report(options, tree_oid, OBJ_TREE,
<span
class="hunk">@@ -1102,16 +1110,17 @@ static int fsck_gitmodules_fn(const char *var, const char *value,
</span> static int fsck_blob(const struct object_id *oid, const char *buf,
 		     unsigned long size, struct fsck_options *options)
 {
<span
class="add">+	struct fsck_objs_options *objs_options = &#38;options-&gt;objs_options;
</span> 	int ret = 0;
 
 	if (object_on_skiplist(options, oid))
 		return 0;
 
<span
class="del">-	if (oidset_contains(&#38;options-&gt;gitmodules_found, oid)) {
</span><span
class="add">+	if (oidset_contains(&#38;objs_options-&gt;gitmodules_found, oid)) {
</span> 		struct config_options config_opts = { 0 };
 		struct fsck_gitmodules_data data;
 
<span
class="del">-		oidset_insert(&#38;options-&gt;gitmodules_done, oid);
</span><span
class="add">+		oidset_insert(&#38;objs_options-&gt;gitmodules_done, oid);
</span> 
 		if (!buf) {
 			/*
<span
class="hunk">@@ -1137,13 +1146,14 @@ static int fsck_blob(const struct object_id *oid, const char *buf,
</span> 		ret |= data.ret;
 	}
 
<span
class="del">-	if (oidset_contains(&#38;options-&gt;gitattributes_found, oid)) {
</span><span
class="add">+	if (oidset_contains(&#38;objs_options-&gt;gitattributes_found, oid)) {
</span> 		const char *ptr;
 
<span
class="del">-		oidset_insert(&#38;options-&gt;gitattributes_done, oid);
</span><span
class="add">+		oidset_insert(&#38;objs_options-&gt;gitattributes_done, oid);
</span> 
 		if (!buf || size &gt; ATTR_MAX_FILE_SIZE) {
 			/*
<span
class="add">+
</span> 			 * A missing buffer here is a sign that the caller found the
 			 * blob too gigantic to load into memory. Let&#39;s just consider
 			 * that an error.
<span
class="hunk">@@ -1197,6 +1207,20 @@ int fsck_buffer(const struct object_id *oid, enum object_type type,
</span> 		      type);
 }
 
<span
class="add">+int fsck_refs_error_function(struct fsck_options *o UNUSED,
+			     const char *name,
+			     enum fsck_msg_type msg_type,
+			     enum fsck_msg_id msg_id UNUSED,
+			     const char *message)
+{
+	if (msg_type == FSCK_WARN) {
+		warning(&#34;%s: %s&#34;, name, message);
+		return 0;
+	}
+	error(&#34;%s: %s&#34;, name, message);
+	return 1;
+}
+
</span> int fsck_error_function(struct fsck_options *o,
 			const struct object_id *oid,
 			enum object_type object_type UNUSED,
<span
class="hunk">@@ -1255,18 +1279,51 @@ static int fsck_blobs(struct oidset *blobs_found, struct oidset *blobs_done,
</span> 
 int fsck_finish(struct fsck_options *options)
 {
<span
class="add">+	struct fsck_objs_options *objs_options = &#38;options-&gt;objs_options;
</span> 	int ret = 0;
 
<span
class="del">-	ret |= fsck_blobs(&#38;options-&gt;gitmodules_found, &#38;options-&gt;gitmodules_done,
</span><span
class="add">+	ret |= fsck_blobs(&#38;objs_options-&gt;gitmodules_found,
+			  &#38;objs_options-&gt;gitmodules_done,
</span> 			  FSCK_MSG_GITMODULES_MISSING, FSCK_MSG_GITMODULES_BLOB,
 			  options, &#34;.gitmodules&#34;);
<span
class="del">-	ret |= fsck_blobs(&#38;options-&gt;gitattributes_found, &#38;options-&gt;gitattributes_done,
</span><span
class="add">+	ret |= fsck_blobs(&#38;objs_options-&gt;gitattributes_found,
+			  &#38;objs_options-&gt;gitattributes_done,
</span> 			  FSCK_MSG_GITATTRIBUTES_MISSING, FSCK_MSG_GITATTRIBUTES_BLOB,
 			  options, &#34;.gitattributes&#34;);
 
 	return ret;
 }
 
<span
class="add">+int fsck_refs_report(struct fsck_options *o,
+		     const char *name,
+		     enum fsck_msg_id msg_id,
+		     const char *fmt, ...)
+{
+	va_list ap;
+	struct strbuf sb = STRBUF_INIT;
+	enum fsck_msg_type msg_type = fsck_msg_type(msg_id, o);
+	int ret = 0;
+
+	if (msg_type == FSCK_IGNORE)
+		return 0;
+
+	if (msg_type == FSCK_FATAL)
+		msg_type = FSCK_ERROR;
+	else if (msg_type == FSCK_INFO)
+		msg_type = FSCK_WARN;
+
+	prepare_msg_ids();
+	strbuf_addf(&#38;sb, &#34;%s: &#34;, msg_id_info[msg_id].camelcased);
+
+	va_start(ap, fmt);
+	strbuf_vaddf(&#38;sb, fmt, ap);
+	ret = o-&gt;refs_options.error_func(o, name, msg_type, msg_id, sb.buf);
+	strbuf_release(&#38;sb);
+	va_end(ap);
+
+	return ret;
+}
+
</span> int git_fsck_config(const char *var, const char *value,
 		    const struct config_context *ctx, void *cb)
 {
<span
class="head">diff --git a/fsck.h b/fsck.h
index 6085a384f6..0391dffbb0 100644
--- a/fsck.h
+++ b/fsck.h
</span><span
class="hunk">@@ -103,6 +103,21 @@ void fsck_set_msg_type(struct fsck_options *options,
</span> void fsck_set_msg_types(struct fsck_options *options, const char *values);
 int is_valid_msg_type(const char *msg_id, const char *msg_type);
 
<span
class="add">+/*
+ * callback function for fsck refs and reflogs.
+ */
+typedef int (*fsck_refs_error)(struct fsck_options *o,
+			       const char *name,
+			       enum fsck_msg_type msg_type,
+			       enum fsck_msg_id msg_id,
+			       const char *message);
+
+int fsck_refs_error_function(struct fsck_options *o,
+			     const char *name,
+			     enum fsck_msg_type msg_type,
+			     enum fsck_msg_id msg_id,
+			     const char *message);
+
</span> /*
  * callback function for fsck_walk
  * type is the expected type of the object or OBJ_ANY
<span
class="hunk">@@ -115,10 +130,12 @@ typedef int (*fsck_walk_func)(struct object *obj, enum object_type object_type,
</span> 			      void *data, struct fsck_options *options);
 
 /* callback for fsck_object, type is FSCK_ERROR or FSCK_WARN */
<span
class="del">-typedef int (*fsck_error)(struct fsck_options *o,
-			  const struct object_id *oid, enum object_type object_type,
-			  enum fsck_msg_type msg_type, enum fsck_msg_id msg_id,
-			  const char *message);
</span><span
class="add">+typedef int (*fsck_obj_error)(struct fsck_options *o,
+			      const struct object_id *oid,
+			      enum object_type object_type,
+			      enum fsck_msg_type msg_type,
+			      enum fsck_msg_id msg_id,
+			      const char *message);
</span> 
 int fsck_error_function(struct fsck_options *o,
 			const struct object_id *oid, enum object_type object_type,
<span
class="hunk">@@ -131,11 +148,17 @@ int fsck_error_cb_print_missing_gitmodules(struct fsck_options *o,
</span> 					   enum fsck_msg_id msg_id,
 					   const char *message);
 
<span
class="del">-struct fsck_options {
</span><span
class="add">+struct fsck_refs_options {
+	fsck_refs_error error_func;
+};
+
+#define FSCK_REFS_OPTIONS_DEFAULT { \
+	.error_func = fsck_refs_error_function, \
+}
+
+struct fsck_objs_options {
</span> 	fsck_walk_func walk;
<span
class="del">-	fsck_error error_func;
-	unsigned strict:1;
-	enum fsck_msg_type *msg_type;
</span><span
class="add">+	fsck_obj_error error_func;
</span> 	struct oidset skiplist;
 	struct oidset gitmodules_found;
 	struct oidset gitmodules_done;
<span
class="hunk">@@ -144,29 +167,43 @@ struct fsck_options {
</span> 	kh_oid_map_t *object_names;
 };
 
<span
class="del">-#define FSCK_OPTIONS_DEFAULT { \
</span><span
class="add">+#define FSCK_OBJS_OPTIONS_DEFAULT { \
+	.error_func = fsck_error_function, \
</span> 	.skiplist = OIDSET_INIT, \
 	.gitmodules_found = OIDSET_INIT, \
 	.gitmodules_done = OIDSET_INIT, \
 	.gitattributes_found = OIDSET_INIT, \
 	.gitattributes_done = OIDSET_INIT, \
<span
class="del">-	.error_func = fsck_error_function \
</span> }
<span
class="del">-#define FSCK_OPTIONS_STRICT { \
-	.strict = 1, \
</span><span
class="add">+#define FSCK_OBJS_OPTIONS_MISSING_GITMODULES { \
+	.error_func = fsck_error_cb_print_missing_gitmodules, \
</span> 	.gitmodules_found = OIDSET_INIT, \
 	.gitmodules_done = OIDSET_INIT, \
 	.gitattributes_found = OIDSET_INIT, \
 	.gitattributes_done = OIDSET_INIT, \
<span
class="del">-	.error_func = fsck_error_function, \
</span><span
class="add">+}
+
+struct fsck_options {
+	struct fsck_refs_options refs_options;
+	struct fsck_objs_options objs_options;
+	enum fsck_msg_type *msg_type;
+	unsigned strict:1,
+		 verbose:1;
+};
+
+#define FSCK_OPTIONS_DEFAULT { \
+	.refs_options = FSCK_REFS_OPTIONS_DEFAULT, \
+	.objs_options = FSCK_OBJS_OPTIONS_DEFAULT, \
+}
+#define FSCK_OPTIONS_STRICT { \
+	.refs_options = FSCK_REFS_OPTIONS_DEFAULT, \
+	.objs_options = FSCK_OBJS_OPTIONS_DEFAULT, \
+	.strict = 1, \
</span> }
 #define FSCK_OPTIONS_MISSING_GITMODULES { \
<span
class="add">+	.refs_options = FSCK_REFS_OPTIONS_DEFAULT, \
+	.objs_options = FSCK_OBJS_OPTIONS_MISSING_GITMODULES, \
</span> 	.strict = 1, \
<span
class="del">-	.gitmodules_found = OIDSET_INIT, \
-	.gitmodules_done = OIDSET_INIT, \
-	.gitattributes_found = OIDSET_INIT, \
-	.gitattributes_done = OIDSET_INIT, \
-	.error_func = fsck_error_cb_print_missing_gitmodules, \
</span> }
 
 /* descend in all linked child objects
<span
class="hunk">@@ -209,6 +246,12 @@ int fsck_tag_standalone(const struct object_id *oid, const char *buffer,
</span>  */
 int fsck_finish(struct fsck_options *options);
 
<span
class="add">+__attribute__((format (printf, 4, 5)))
+int fsck_refs_report(struct fsck_options *o,
+		     const char *name,
+		     enum fsck_msg_id msg_id,
+		     const char *fmt, ...);
+
</span> /*
  * Subsystem for storing human-readable names for each object.
  *
<span
class="head">diff --git a/object-file.c b/object-file.c
index d3cf4b8b2e..b027d70725 100644
--- a/object-file.c
+++ b/object-file.c
</span><span
class="hunk">@@ -2510,7 +2510,7 @@ static int index_mem(struct index_state *istate,
</span> 		struct fsck_options opts = FSCK_OPTIONS_DEFAULT;
 
 		opts.strict = 1;
<span
class="del">-		opts.error_func = hash_format_check_report;
</span><span
class="add">+		opts.objs_options.error_func = hash_format_check_report;
</span> 		if (fsck_buffer(null_oid(), type, buf, size, &#38;opts))
 			die(_(&#34;refusing to create malformed object&#34;));
 		fsck_finish(&#38;opts);
-- 
2.45.2

</pre></div></content></entry><entry><author><name>shejialuo</name><email>shejialuo@gmail.com</email></author><title>[GSoC][PATCH v4 0/7] ref consistency check infra setup</title><updated>2024-06-19T07:37:49Z</updated><link
href="http://lore.kernel.org/git/ZnKKy52QFO2UhqM6@ArchLinux/"/><id>urn:uuid:67cc5cb7-690b-6bd7-e8b6-8d2a3608a3b6</id><thr:in-reply-to
ref="urn:uuid:296e3964-9ee9-6b3a-4238-4b7fabb59c77"
href="http://lore.kernel.org/git/20240612085349.710785-1-shejialuo@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Hi All:

This version mainly focuses on solving following reviews:

1. As Junio said, it&#39;s a bad idea to convert the &#34;fsck_refs_options *&#34;
to &#34;fsck_options *&#34; or convert the &#34;fsck_options *&#34; to
&#34;fsck_refs_options *&#34;. So this version, I changed a lot for the first
patch. I refactor the &#34;fsck_options *&#34; which contains refs-specific,
objs-specific and common settings. This designs allows us to use
combination to make the code much more clean.
2. As Karthik said, I should enhance documents for &#34;git refs verify&#34;.
This version does this.

And Junio found that the commit the previous series based on is strange.
In order to make our life easier, I change the based on commit. Now it
is based on the top master. And I will always keep the code align with
the master to avoid strange things.

  66ac6e4bcd (The fourteenth batch, 2024-06-17)

Thanks

shejialuo (7):
  fsck: add refs check interfaces to interact with fsck error levels
  refs: set up ref consistency check infrastructure
  builtin/refs: add verify subcommand
  builtin/fsck: add `git-refs verify` child process
  files-backend: add unified interface for refs scanning
  fsck: add ref name check for files backend
  fsck: add ref content check for files backend

 Documentation/fsck-msgids.txt |  12 ++
 Documentation/git-refs.txt    |  13 ++
 builtin/fsck.c                |  25 +++-
 builtin/index-pack.c          |   2 +-
 builtin/mktag.c               |   5 +-
 builtin/refs.c                |  45 ++++++
 builtin/unpack-objects.c      |   2 +-
 fetch-pack.c                  |   8 +-
 fsck.c                        | 113 +++++++++++----
 fsck.h                        |  83 ++++++++---
 object-file.c                 |   2 +-
 refs.c                        |   7 +-
 refs.h                        |   8 ++
 refs/debug.c                  |  11 ++
 refs/files-backend.c          | 255 +++++++++++++++++++++++++++++++++-
 refs/packed-backend.c         |   8 ++
 refs/refs-internal.h          |  11 +-
 refs/reftable-backend.c       |   8 ++
 t/t0602-reffiles-fsck.sh      | 211 ++++++++++++++++++++++++++++
 19 files changed, 765 insertions(+), 64 deletions(-)
 create mode 100755 t/t0602-reffiles-fsck.sh

Range-diff against v3:
1:  b8d20c4be9 &lt; -:  ---------- fsck: add refs check interfaces to interface with fsck error levels
-:  ---------- &gt; 1:  2d2c1f2cd3 fsck: add refs check interfaces to interact with fsck error levels
2:  c7ed95d6b4 ! 2:  4bacffe44e refs: set up ref consistency check infrastructure
    @@ refs.c: int check_refname_format(const char *refname, int flags)
      	return check_or_sanitize_refname(refname, flags, NULL);
      }
      
    -+int refs_fsck(struct ref_store *refs, struct fsck_refs_options *o)
    ++int refs_fsck(struct ref_store *refs, struct fsck_options *o)
     +{
     +	return refs-&gt;be-&gt;fsck(refs, o);
     +}
    @@ refs.h
      
      #include &#34;commit.h&#34;
      
    -+struct fsck_refs_options;
    ++struct fsck_options;
      struct object_id;
      struct ref_store;
      struct repository;
    @@ refs.h: int refs_for_each_reflog(struct ref_store *refs, each_reflog_fn fn, void
     + * reflogs are consistent, and non-zero otherwise. The errors will be
     + * written to stderr.
     + */
    -+int refs_fsck(struct ref_store *refs, struct fsck_refs_options *o);
    ++int refs_fsck(struct ref_store *refs, struct fsck_options *o);
     +
      /*
       * Apply the rules from check_refname_format, but mutate the result until it
    @@ refs/debug.c: static int debug_reflog_expire(struct ref_store *ref_store, const
      }
      
     +static int debug_fsck(struct ref_store *ref_store,
    -+		      struct fsck_refs_options *o)
    ++		      struct fsck_options *o)
     +{
     +	struct debug_ref_store *drefs = (struct debug_ref_store *)ref_store;
     +	int res = drefs-&gt;refs-&gt;be-&gt;fsck(drefs-&gt;refs, o);
    @@ refs/files-backend.c: static int files_ref_store_remove_on_disk(struct ref_store
      }
      
     +static int files_fsck(struct ref_store *ref_store,
    -+		      struct fsck_refs_options *o)
    ++		      struct fsck_options *o)
     +{
     +	int ret;
     +	struct files_ref_store *refs =
    @@ refs/packed-backend.c: static struct ref_iterator *packed_reflog_iterator_begin(
      }
      
     +static int packed_fsck(struct ref_store *ref_store,
    -+		       struct fsck_refs_options *o)
    ++		       struct fsck_options *o)
     +{
     +	return 0;
     +}
    @@ refs/refs-internal.h
      #include &#34;refs.h&#34;
      #include &#34;iterator.h&#34;
      
    -+struct fsck_refs_options;
    ++struct fsck_options;
      struct ref_transaction;
      
      /*
    @@ refs/refs-internal.h: typedef int read_raw_ref_fn(struct ref_store *ref_store, c
      				 struct strbuf *referent);
      
     +typedef int fsck_fn(struct ref_store *ref_store,
    -+		    struct fsck_refs_options *o);
    ++		    struct fsck_options *o);
     +
      struct ref_storage_be {
      	const char *name;
    @@ refs/reftable-backend.c: static int reftable_be_reflog_expire(struct ref_store *
      }
      
     +static int reftable_be_fsck(struct ref_store *ref_store,
    -+			    struct fsck_refs_options *o)
    ++			    struct fsck_options *o)
     +{
     +	return 0;
     +}
3:  373f470fdc ! 3:  f00acab4d1 builtin/refs: add verify subcommand
    @@ Documentation/git-refs.txt: include::ref-storage-format.txt[]
     +
     +--strict::
     +	Enable more strict checking, every WARN severity for the `Fsck Messages`
    -+	be seen as ERROR.
    ++	be seen as ERROR. See linkgit:git-fsck[1].
     +
     +--verbose::
     +	When verifying the reference database consistency, be chatty.
    @@ builtin/refs.c: static int cmd_refs_migrate(int argc, const char **argv, const c
     +	};
     +	int ret = 0;
     +	unsigned int verbose = 0, strict = 0;
    -+	struct fsck_refs_options fsck_refs_options = FSCK_REFS_OPTIONS_DEFAULT;
    ++	struct fsck_options fsck_options = FSCK_OPTIONS_DEFAULT;
     +	struct option options[] = {
     +		OPT__VERBOSE(&#38;verbose, N_(&#34;be verbose&#34;)),
     +		OPT_BOOL(0, &#34;strict&#34;, &#38;strict, N_(&#34;enable strict checking&#34;)),
    @@ builtin/refs.c: static int cmd_refs_migrate(int argc, const char **argv, const c
     +		usage(_(&#34;too many arguments&#34;));
     +
     +	if (verbose)
    -+		fsck_refs_options.verbose = 1;
    ++		fsck_options.verbose = 1;
     +	if (strict)
    -+		fsck_refs_options.strict = 1;
    ++		fsck_options.strict = 1;
     +
    -+	git_config(git_fsck_refs_config, &#38;fsck_refs_options);
    ++	git_config(git_fsck_config, &#38;fsck_options);
     +	prepare_repo_settings(the_repository);
     +
    -+	ret = refs_fsck(get_main_ref_store(the_repository), &#38;fsck_refs_options);
    ++	ret = refs_fsck(get_main_ref_store(the_repository), &#38;fsck_options);
     +
     +	/*
    -+	 * Explicitly free the allocated array. This is necessary because
    -+	 * this program is executed as child process of git-fsck(1) and the
    -+	 * allocated array may not freed when git-fsck(1) aborts somewhere.
    ++	 * Explicitly free the allocated array and object skiplist set. Because
    ++	 * we reuse `git_fsck_config` here. It will still set the skiplist.
     +	 */
    -+	free(fsck_refs_options.msg_type);
    ++	free(fsck_options.msg_type);
    ++	oidset_clear(&#38;fsck_options.objs_options.skiplist);
     +	return ret;
     +}
     +
4:  4f8ebea573 = 4:  6494f5b0c2 builtin/fsck: add `git-refs verify` child process
5:  6062b3b453 ! 5:  2c064f4f71 files-backend: add unified interface for refs scanning
    @@ refs/files-backend.c: static int files_ref_store_remove_on_disk(struct ref_store
     + * the whole directory. This function is used as the callback for each
     + * regular file or symlink in the directory.
     + */
    -+typedef int (*files_fsck_refs_fn)(struct fsck_refs_options *o,
    ++typedef int (*files_fsck_refs_fn)(struct fsck_options *o,
     +				  const char *gitdir,
     +				  const char *refs_check_dir,
     +				  struct dir_iterator *iter);
     +
     +static int files_fsck_refs_dir(struct ref_store *ref_store,
    -+			       struct fsck_refs_options *o,
    ++			       struct fsck_options *o,
     +			       const char *refs_check_dir,
     +			       files_fsck_refs_fn *fsck_refs_fns)
     +{
    @@ refs/files-backend.c: static int files_ref_store_remove_on_disk(struct ref_store
     +}
     +
     +static int files_fsck_refs(struct ref_store *ref_store,
    -+			   struct fsck_refs_options *o)
    ++			   struct fsck_options *o)
     +{
     +	int ret;
     +	files_fsck_refs_fn fsck_refs_fns[]= {
    @@ refs/files-backend.c: static int files_ref_store_remove_on_disk(struct ref_store
     +}
     +
      static int files_fsck(struct ref_store *ref_store,
    - 		      struct fsck_refs_options *o)
    + 		      struct fsck_options *o)
      {
     @@ refs/files-backend.c: static int files_fsck(struct ref_store *ref_store,
      	struct files_ref_store *refs =
6:  87a22f4c7f ! 6:  88b54b9e1a fsck: add ref name check for files backend
    @@ fsck.h: enum fsck_msg_type {
      	FUNC(BAD_TREE_SHA1, ERROR) \
     
      ## refs/files-backend.c ##
    -@@ refs/files-backend.c: typedef int (*files_fsck_refs_fn)(struct fsck_refs_options *o,
    +@@ refs/files-backend.c: typedef int (*files_fsck_refs_fn)(struct fsck_options *o,
      				  const char *refs_check_dir,
      				  struct dir_iterator *iter);
      
    -+static int files_fsck_refs_name(struct fsck_refs_options *o,
    ++static int files_fsck_refs_name(struct fsck_options *o,
     +				const char *gitdir UNUSED,
     +				const char *refs_check_dir,
     +				struct dir_iterator *iter)
    @@ refs/files-backend.c: typedef int (*files_fsck_refs_fn)(struct fsck_refs_options
     +}
     +
      static int files_fsck_refs_dir(struct ref_store *ref_store,
    - 			       struct fsck_refs_options *o,
    + 			       struct fsck_options *o,
      			       const char *refs_check_dir,
     @@ refs/files-backend.c: static int files_fsck_refs(struct ref_store *ref_store,
      {
7:  b945f61ef1 ! 7:  8309a4746a fsck: add ref content check for files backend
    @@ refs/files-backend.c: int parse_loose_ref_contents(const char *buf, struct objec
      	return 0;
      }
      
    -@@ refs/files-backend.c: static int files_fsck_refs_name(struct fsck_refs_options *o,
    +@@ refs/files-backend.c: static int files_fsck_refs_name(struct fsck_options *o,
      	return ret;
      }
      
    @@ refs/files-backend.c: static int files_fsck_refs_name(struct fsck_refs_options *
     + * would be the content after &#34;refs:&#34;. For symblic link, &#34;pointee_name&#34; would
     + * be the relative path agaignst &#34;gitdir&#34;.
     + */
    -+static int files_fsck_symref_target(struct fsck_refs_options *o,
    ++static int files_fsck_symref_target(struct fsck_options *o,
     +				    const char *refname,
     +				    const char *pointee_name,
     +				    const char *pointee_path)
    @@ refs/files-backend.c: static int files_fsck_refs_name(struct fsck_refs_options *
     +	return ret;
     +}
     +
    -+static int files_fsck_refs_content(struct fsck_refs_options *o,
    ++static int files_fsck_refs_content(struct fsck_options *o,
     +				   const char *gitdir,
     +				   const char *refs_check_dir,
     +				   struct dir_iterator *iter)
    @@ refs/files-backend.c: static int files_fsck_refs_name(struct fsck_refs_options *
     +}
     +
      static int files_fsck_refs_dir(struct ref_store *ref_store,
    - 			       struct fsck_refs_options *o,
    + 			       struct fsck_options *o,
      			       const char *refs_check_dir,
     @@ refs/files-backend.c: static int files_fsck_refs(struct ref_store *ref_store,
      	int ret;
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Johannes Schindelin via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH] mingw: drop bogus (and unneeded) declaration of `_pgmptr`</title><updated>2024-06-19T06:10:01Z</updated><link
href="http://lore.kernel.org/git/pull.1752.git.1718777398765.gitgitgadget@gmail.com/"/><id>urn:uuid:4c60bb18-14c6-fe1d-287d-5228aec1f344</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Johannes Schindelin &lt;johannes.schindelin@gmx.de&gt;

In 08809c09aa13 (mingw: add a helper function to attach GDB to the
current process, 2020-02-13), I added a declaration that was not needed.
Back then, that did not matter, but now that the declaration of that
symbol was changed in mingw-w64&#39;s headers, it causes the following
compile error:

      CC compat/mingw.o
  compat/mingw.c: In function &#39;open_in_gdb&#39;:
  compat/mingw.c:35:9: error: function declaration isn&#39;t a prototype [-Werror=strict-prototypes]
     35 |         extern char *_pgmptr;
        |         ^~~~~~
  In file included from C:/git-sdk-64/usr/src/git/build-installers/mingw64/lib/gcc/x86_64-w64-mingw32/14.1.0/include/mm_malloc.h:27,
                   from C:/git-sdk-64/usr/src/git/build-installers/mingw64/lib/gcc/x86_64-w64-mingw32/14.1.0/include/xmmintrin.h:34,
                   from C:/git-sdk-64/usr/src/git/build-installers/mingw64/lib/gcc/x86_64-w64-mingw32/14.1.0/include/immintrin.h:31,
                   from C:/git-sdk-64/usr/src/git/build-installers/mingw64/lib/gcc/x86_64-w64-mingw32/14.1.0/include/x86intrin.h:32,
                   from C:/git-sdk-64/usr/src/git/build-installers/mingw64/include/winnt.h:1658,
                   from C:/git-sdk-64/usr/src/git/build-installers/mingw64/include/minwindef.h:163,
                   from C:/git-sdk-64/usr/src/git/build-installers/mingw64/include/windef.h:9,
                   from C:/git-sdk-64/usr/src/git/build-installers/mingw64/include/windows.h:69,
                   from C:/git-sdk-64/usr/src/git/build-installers/mingw64/include/winsock2.h:23,
                   from compat/../git-compat-util.h:215,
                   from compat/mingw.c:1:
  compat/mingw.c:35:22: error: &#39;__p__pgmptr&#39; redeclared without dllimport attribute: previous dllimport ignored [-Werror=attributes]
     35 |         extern char *_pgmptr;
        |                      ^~~~~~~

Let&#39;s just drop the declaration and get rid of this compile error.

Signed-off-by: Johannes Schindelin &lt;johannes.schindelin@gmx.de&gt;
---
    mingw: drop bogus (and unneeded) declaration of _pgmptr
    
    Ran into this in
    <a
href="https://github.com/git-for-windows/git-sdk-64/actions/runs/9558244721/job/26346637793">https://github.com/git-for-windows/git-sdk-64/actions/runs/9558244721/job/26346637793</a>.

Published-As: <a
href="https://github.com/gitgitgadget/git/releases/tag/pr-1752%2Fdscho%2Fdrop-bogus-_pgmptr-declaration-v1">https://github.com/gitgitgadget/git/releases/tag/pr-1752%2Fdscho%2Fdrop-bogus-_pgmptr-declaration-v1</a>
Fetch-It-Via: git fetch <a
href="https://github.com/gitgitgadget/git">https://github.com/gitgitgadget/git</a> pr-1752/dscho/drop-bogus-_pgmptr-declaration-v1
Pull-Request: <a
href="https://github.com/gitgitgadget/git/pull/1752">https://github.com/gitgitgadget/git/pull/1752</a>

 compat/mingw.c | 1 -
 1 file <a href="http://lore.kernel.org/git/pull.1752.git.1718777398765.gitgitgadget@gmail.com/#related">changed</a>, 1 deletion(-)

<span
class="head">diff --git a/compat/mingw.c b/compat/mingw.c
index 6b36d0387aa..41d8ca335d2 100644
--- a/compat/mingw.c
+++ b/compat/mingw.c
</span><span
class="hunk">@@ -16,7 +16,6 @@ static const int delay[] = { 0, 1, 10, 20, 40 };
</span> void open_in_gdb(void)
 {
 	static struct child_process cp = CHILD_PROCESS_INIT;
<span
class="del">-	extern char *_pgmptr;
</span> 
 	argv_array_pushl(&#38;cp.args, &#34;mintty&#34;, &#34;gdb&#34;, NULL);
 	argv_array_pushf(&#38;cp.args, &#34;--pid=%d&#34;, getpid());

base-commit: 08809c09aa1351b603e9c55734105cd2e3c24c41
-- 
gitgitgadget
</pre></div></content></entry><entry><author><name>Xing Xin via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v8 3/3] unbundle: extend object verification for fetches</title><updated>2024-06-19T04:07:41Z</updated><link
href="http://lore.kernel.org/git/698dd6e49b78d1f14c9eda1a1161fe3eff10028e.1718770053.git.gitgitgadget@gmail.com/"/><id>urn:uuid:4cb030fb-8791-1d4d-ffe7-a129740ea868</id><thr:in-reply-to
ref="urn:uuid:79096107-6ce1-ac03-39bc-e266bf6fb853"
href="http://lore.kernel.org/git/pull.1730.v8.git.1718770053.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Xing Xin &lt;xingxin.xx@bytedance.com&gt;

The existing fetch.fsckObjects and transfer.fsckObjects configurations
were not fully applied to bundle-involved fetches, including direct
bundle fetches and bundle-uri enabled fetches. Furthermore, there was no
object verification support for unbundle.

This commit extends object verification support in `bundle.c:unbundle`
by adding the `VERIFY_BUNDLE_FSCK` option to `verify_bundle_flags`. When
this option is enabled, we append the `--fsck-objects` flag to
`git-index-pack`.

The `VERIFY_BUNDLE_FSCK` option is now used by bundle-involved fetches,
where we use `fetch-pack.c:fetch_pack_fsck_objects` to determine whether
to enable this option for `bundle.c:unbundle`, specifically in:

- `transport.c:fetch_refs_from_bundle` for direct bundle fetches.
- `bundle-uri.c:unbundle_from_file` for bundle-uri enabled fetches.

This addition ensures a consistent logic for object verification during
fetches. Tests have been added to confirm functionality in the scenarios
mentioned above.

Reviewed-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Signed-off-by: Xing Xin &lt;xingxin.xx@bytedance.com&gt;
---
 bundle-uri.c                |  3 ++-
 bundle.c                    |  3 +++
 bundle.h                    |  1 +
 t/t5558-clone-bundle-uri.sh | 34 +++++++++++++++++++++++++++++++++-
 t/t5607-clone-bundle.sh     | 35 +++++++++++++++++++++++++++++++++++
 transport.c                 |  3 ++-
 6 files <a href="http://lore.kernel.org/git/698dd6e49b78d1f14c9eda1a1161fe3eff10028e.1718770053.git.gitgitgadget@gmail.com/#related">changed</a>, 76 insertions(+), 3 deletions(-)

<span
class="head">diff --git a/bundle-uri.c b/bundle-uri.c
index 65666a11d9c..ed9b49fdbc1 100644
--- a/bundle-uri.c
+++ b/bundle-uri.c
</span><span
class="hunk">@@ -9,6 +9,7 @@
</span> #include &#34;hashmap.h&#34;
 #include &#34;pkt-line.h&#34;
 #include &#34;config.h&#34;
<span
class="add">+#include &#34;fetch-pack.h&#34;
</span> #include &#34;remote.h&#34;
 
 static struct {
<span
class="hunk">@@ -373,7 +374,7 @@ static int unbundle_from_file(struct repository *r, const char *file)
</span> 	 * the prerequisite commits.
 	 */
 	if ((result = unbundle(r, &#38;header, bundle_fd, NULL,
<span
class="del">-			       VERIFY_BUNDLE_QUIET)))
</span><span
class="add">+			       VERIFY_BUNDLE_QUIET | (fetch_pack_fsck_objects() ? VERIFY_BUNDLE_FSCK : 0))))
</span> 		return 1;
 
 	/*
<span
class="head">diff --git a/bundle.c b/bundle.c
index 95367c2d0a0..f124a2a5626 100644
--- a/bundle.c
+++ b/bundle.c
</span><span
class="hunk">@@ -625,6 +625,9 @@ int unbundle(struct repository *r, struct bundle_header *header,
</span> 	if (header-&gt;filter.choice)
 		strvec_push(&#38;ip.args, &#34;--promisor=from-bundle&#34;);
 
<span
class="add">+	if (flags &#38; VERIFY_BUNDLE_FSCK)
+		strvec_push(&#38;ip.args, &#34;--fsck-objects&#34;);
+
</span> 	if (extra_index_pack_args) {
 		strvec_pushv(&#38;ip.args, extra_index_pack_args-&gt;v);
 		strvec_clear(extra_index_pack_args);
<span
class="head">diff --git a/bundle.h b/bundle.h
index 021adbdcbb3..5ccc9a061a4 100644
--- a/bundle.h
+++ b/bundle.h
</span><span
class="hunk">@@ -33,6 +33,7 @@ int create_bundle(struct repository *r, const char *path,
</span> enum verify_bundle_flags {
 	VERIFY_BUNDLE_VERBOSE = (1 &lt;&lt; 0),
 	VERIFY_BUNDLE_QUIET = (1 &lt;&lt; 1),
<span
class="add">+	VERIFY_BUNDLE_FSCK = (1 &lt;&lt; 2),
</span> };
 
 int verify_bundle(struct repository *r, struct bundle_header *header,
<span
class="head">diff --git a/t/t5558-clone-bundle-uri.sh b/t/t5558-clone-bundle-uri.sh
index a0895913fe9..cd05321e176 100755
--- a/t/t5558-clone-bundle-uri.sh
+++ b/t/t5558-clone-bundle-uri.sh
</span><span
class="hunk">@@ -36,7 +36,22 @@ test_expect_success &#39;create bundle&#39; &#39;
</span> 		sed -e &#34;/^$/q&#34; -e &#34;s/$commit_a /$commit_b /&#34; \
 			&lt;A.bundle &gt;bad-header.bundle &#38;&#38;
 		convert_bundle_to_pack \
<span
class="del">-			&lt;A.bundle &gt;&gt;bad-header.bundle
</span><span
class="add">+			&lt;A.bundle &gt;&gt;bad-header.bundle &#38;&#38;
+
+		tree_b=$(git rev-parse B^{tree}) &#38;&#38;
+		cat &gt;data &lt;&lt;-EOF &#38;&#38;
+		tree $tree_b
+		parent $commit_b
+		author A U Thor
+		committer A U Thor
+
+		commit: this is a commit with bad emails
+
+		EOF
+		bad_commit=$(git hash-object --literally -t commit -w --stdin &lt;data) &#38;&#38;
+		git branch bad $bad_commit &#38;&#38;
+		git bundle create bad-object.bundle bad &#38;&#38;
+		git update-ref -d refs/heads/bad
</span> 	)
 &#39;
 
<span
class="hunk">@@ -58,6 +73,23 @@ test_expect_success &#39;clone with bundle that has bad header&#39; &#39;
</span> 	test_grep ! &#34;refs/bundles/&#34; refs
 &#39;
 
<span
class="add">+test_expect_success &#39;clone with bundle that has bad object&#39; &#39;
+	# Unbundle succeeds if no fsckObjects configured.
+	git clone --bundle-uri=&#34;clone-from/bad-object.bundle&#34; \
+		clone-from clone-bad-object-no-fsck &#38;&#38;
+	git -C clone-bad-object-no-fsck for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
+	grep &#34;refs/bundles/&#34; refs &gt;actual &#38;&#38;
+	test_write_lines refs/bundles/bad &gt;expect &#38;&#38;
+	test_cmp expect actual &#38;&#38;
+
+	# Unbundle fails with fsckObjects set true, but clone can still proceed.
+	git -c fetch.fsckObjects=true clone --bundle-uri=&#34;clone-from/bad-object.bundle&#34; \
+		clone-from clone-bad-object-fsck 2&gt;err &#38;&#38;
+	test_grep &#34;missingEmail&#34; err &#38;&#38;
+	git -C clone-bad-object-fsck for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
+	test_grep ! &#34;refs/bundles/&#34; refs
+&#39;
+
</span> test_expect_success &#39;clone with path bundle and non-default hash&#39; &#39;
 	test_when_finished &#34;rm -rf clone-path-non-default-hash&#34; &#38;&#38;
 	GIT_DEFAULT_HASH=sha256 git clone --bundle-uri=&#34;clone-from/B.bundle&#34; \
<span
class="head">diff --git a/t/t5607-clone-bundle.sh b/t/t5607-clone-bundle.sh
index 0d1e92d9963..489c6570da5 100755
--- a/t/t5607-clone-bundle.sh
+++ b/t/t5607-clone-bundle.sh
</span><span
class="hunk">@@ -138,6 +138,41 @@ test_expect_success &#39;fetch SHA-1 from bundle&#39; &#39;
</span> 	git fetch --no-tags foo/tip.bundle &#34;$(cat hash)&#34;
 &#39;
 
<span
class="add">+test_expect_success &#39;clone bundle with different fsckObjects configurations&#39; &#39;
+	test_create_repo bundle-fsck &#38;&#38;
+	(
+		cd bundle-fsck &#38;&#38;
+		test_commit A &#38;&#38;
+		commit_a=$(git rev-parse A) &#38;&#38;
+		tree_a=$(git rev-parse A^{tree}) &#38;&#38;
+		cat &gt;data &lt;&lt;-EOF &#38;&#38;
+		tree $tree_a
+		parent $commit_a
+		author A U Thor
+		committer A U Thor
+
+		commit: this is a commit with bad emails
+
+		EOF
+		bad_commit=$(git hash-object --literally -t commit -w --stdin &lt;data) &#38;&#38;
+		git branch bad $bad_commit &#38;&#38;
+		git bundle create bad.bundle bad
+	) &#38;&#38;
+
+	git clone bundle-fsck/bad.bundle bundle-no-fsck &#38;&#38;
+
+	git -c fetch.fsckObjects=false -c transfer.fsckObjects=true \
+		clone bundle-fsck/bad.bundle bundle-fetch-no-fsck &#38;&#38;
+
+	test_must_fail git -c fetch.fsckObjects=true \
+		clone bundle-fsck/bad.bundle bundle-fetch-fsck 2&gt;err &#38;&#38;
+	test_grep &#34;missingEmail&#34; err &#38;&#38;
+
+	test_must_fail git -c transfer.fsckObjects=true \
+		clone bundle-fsck/bad.bundle bundle-transfer-fsck 2&gt;err &#38;&#38;
+	test_grep &#34;missingEmail&#34; err
+&#39;
+
</span> test_expect_success &#39;git bundle uses expected default format&#39; &#39;
 	git bundle create bundle HEAD^.. &#38;&#38;
 	cat &gt;expect &lt;&lt;-EOF &#38;&#38;
<span
class="head">diff --git a/transport.c b/transport.c
index 0ad04b77fd2..a93c4171f7b 100644
--- a/transport.c
+++ b/transport.c
</span><span
class="hunk">@@ -184,7 +184,8 @@ static int fetch_refs_from_bundle(struct transport *transport,
</span> 	if (!data-&gt;get_refs_from_bundle_called)
 		get_refs_from_bundle_inner(transport);
 	ret = unbundle(the_repository, &#38;data-&gt;header, data-&gt;fd,
<span
class="del">-		       &#38;extra_index_pack_args, 0);
</span><span
class="add">+		       &#38;extra_index_pack_args,
+		       fetch_pack_fsck_objects() ? VERIFY_BUNDLE_FSCK : 0);
</span> 	transport-&gt;hash_algo = data-&gt;header.hash_algo;
 	return ret;
 }
-- 
gitgitgadget
</pre></div></content></entry><entry><author><name>Xing Xin via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v8 2/3] fetch-pack: expose fsckObjects configuration logic</title><updated>2024-06-19T04:07:40Z</updated><link
href="http://lore.kernel.org/git/518584c8698b9ab7d7145b841c22c5c3e430afa0.1718770053.git.gitgitgadget@gmail.com/"/><id>urn:uuid:05406ae4-e3df-8df9-3d4d-3b061d3c99b3</id><thr:in-reply-to
ref="urn:uuid:79096107-6ce1-ac03-39bc-e266bf6fb853"
href="http://lore.kernel.org/git/pull.1730.v8.git.1718770053.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Xing Xin &lt;xingxin.xx@bytedance.com&gt;

Currently, we can use &#34;transfer.fsckObjects&#34; and the more specific
&#34;fetch.fsckObjects&#34; to control checks for broken objects in received
packs during fetches. However, these configurations were only
acknowledged by `fetch-pack.c:get_pack` and did not take effect in
direct bundle fetches or fetches with _bundle-uri_ enabled.

This commit exposes the fetch-then-transfer configuration logic by
adding a new function `fetch_pack_fsck_objects` in fetch-pack.h. This
new function is used to replace the assignment for `fsck_objects` in
`fetch-pack.c:get_pack`. In the next commit, this function will also be
used to extend fsck support for bundle-involved fetches.

Helped-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Helped-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Signed-off-by: Xing Xin &lt;xingxin.xx@bytedance.com&gt;
---
 fetch-pack.c | 17 +++++++++++------
 fetch-pack.h |  5 +++++
 2 files <a href="http://lore.kernel.org/git/518584c8698b9ab7d7145b841c22c5c3e430afa0.1718770053.git.gitgitgadget@gmail.com/#related">changed</a>, 16 insertions(+), 6 deletions(-)

<span
class="head">diff --git a/fetch-pack.c b/fetch-pack.c
index 7d2aef21add..3acff2baf09 100644
--- a/fetch-pack.c
+++ b/fetch-pack.c
</span><span
class="hunk">@@ -954,12 +954,7 @@ static int get_pack(struct fetch_pack_args *args,
</span> 		strvec_push(&#38;cmd.args, alternate_shallow_file);
 	}
 
<span
class="del">-	if (fetch_fsck_objects &gt;= 0
-	    ? fetch_fsck_objects
-	    : transfer_fsck_objects &gt;= 0
-	    ? transfer_fsck_objects
-	    : 0)
-		fsck_objects = 1;
</span><span
class="add">+	fsck_objects = fetch_pack_fsck_objects();
</span> 
 	if (do_keep || args-&gt;from_promisor || index_pack_args || fsck_objects) {
 		if (pack_lockfiles || fsck_objects)
<span
class="hunk">@@ -2046,6 +2041,16 @@ static const struct object_id *iterate_ref_map(void *cb_data)
</span> 	return &#38;ref-&gt;old_oid;
 }
 
<span
class="add">+int fetch_pack_fsck_objects(void)
+{
+	fetch_pack_setup();
+	if (fetch_fsck_objects &gt;= 0)
+		return fetch_fsck_objects;
+	if (transfer_fsck_objects &gt;= 0)
+		return transfer_fsck_objects;
+	return 0;
+}
+
</span> struct ref *fetch_pack(struct fetch_pack_args *args,
 		       int fd[],
 		       const struct ref *ref,
<span
class="head">diff --git a/fetch-pack.h b/fetch-pack.h
index 6775d265175..b5c579cdae2 100644
--- a/fetch-pack.h
+++ b/fetch-pack.h
</span><span
class="hunk">@@ -101,4 +101,9 @@ void negotiate_using_fetch(const struct oid_array *negotiation_tips,
</span>  */
 int report_unmatched_refs(struct ref **sought, int nr_sought);
 
<span
class="add">+/*
+ * Return true if checks for broken objects in received pack are required.
+ */
+int fetch_pack_fsck_objects(void);
+
</span> #endif
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Xing Xin via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v8 1/3] bundle-uri: verify oid before writing refs</title><updated>2024-06-19T04:07:40Z</updated><link
href="http://lore.kernel.org/git/d8fbde2dcd49d2a2a37e35f456830c51709cd743.1718770053.git.gitgitgadget@gmail.com/"/><id>urn:uuid:58f21b3a-7a54-e5b6-f6c0-f17c312c8373</id><thr:in-reply-to
ref="urn:uuid:79096107-6ce1-ac03-39bc-e266bf6fb853"
href="http://lore.kernel.org/git/pull.1730.v8.git.1718770053.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Xing Xin &lt;xingxin.xx@bytedance.com&gt;

When using the bundle-uri mechanism with a bundle list containing
multiple interrelated bundles, we encountered a bug where tips from
downloaded bundles were not discovered, thus resulting in rather slow
clones. This was particularly problematic when employing the
&#34;creationTokens&#34; heuristic.

To reproduce this issue, consider a repository with a single branch
&#34;main&#34; pointing to commit &#34;A&#34;. Firstly, create a base bundle with:

  git bundle create base.bundle main

Then, add a new commit &#34;B&#34; on top of &#34;A&#34;, and create an incremental
bundle for &#34;main&#34;:

  git bundle create incr.bundle A..main

Now, generate a bundle list with the following content:

  [bundle]
      version = 1
      mode = all
      heuristic = creationToken

  [bundle &#34;base&#34;]
      uri = base.bundle
      creationToken = 1

  [bundle &#34;incr&#34;]
      uri = incr.bundle
      creationToken = 2

A fresh clone with the bundle list above should result in a reference
&#34;refs/bundles/main&#34; pointing to &#34;B&#34; in the new repository. However, git
would still download everything from the server, as if it had fetched
nothing locally.

So why the &#34;refs/bundles/main&#34; is not discovered? After some digging I
found that:

1. Bundles in bundle list are downloaded to local files via
   `bundle-uri.c:download_bundle_list` or via
   `bundle-uri.c:fetch_bundles_by_token` for the &#34;creationToken&#34;
   heuristic.
2. Each bundle is unbundled via `bundle-uri.c:unbundle_from_file`, which
   is called by `bundle-uri.c:unbundle_all_bundles` or called within
   `bundle-uri.c:fetch_bundles_by_token` for the &#34;creationToken&#34;
   heuristic.
3. To get all prerequisites of the bundle, the bundle header is read
   inside `bundle-uri.c:unbundle_from_file` to by calling
   `bundle.c:read_bundle_header`.
4. Then it calls `bundle.c:unbundle`, which calls
   `bundle.c:verify_bundle` to ensure the repository contains all the
   prerequisites.
5. `bundle.c:verify_bundle` calls `parse_object`, which eventually
   invokes `packfile.c:prepare_packed_git` or
   `packfile.c:reprepare_packed_git`, filling
   `raw_object_store-&gt;packed_git` and setting `packed_git_initialized`.
6. If `bundle.c:unbundle` succeeds, it writes refs via
   `refs.c:refs_update_ref` with `REF_SKIP_OID_VERIFICATION` set. Here
   bundle refs which can target arbitrary objects are written to the
   repository.
7. Finally, in `fetch-pack.c:do_fetch_pack_v2`, the functions
   `fetch-pack.c:mark_complete_and_common_ref` and
   `fetch-pack.c:mark_tips` are called with `OBJECT_INFO_QUICK` set to
   find local tips for negotiation. The `OBJECT_INFO_QUICK` flag
   prevents `packfile.c:reprepare_packed_git` from being called,
   resulting in failures to parse OIDs that reside only in the latest
   bundle.

In the example above, when unbunding &#34;incr.bundle&#34;, &#34;base.pack&#34; is added
to `packed_git` due to prerequisites verification. However, &#34;B&#34; cannot
be found for negotiation because it exists in &#34;incr.pack&#34;, which is not
included in `packed_git`.

Fix the bug by removing `REF_SKIP_OID_VERIFICATION` flag when writing
bundle refs. When `refs.c:refs_update_ref` is called to write the
corresponding bundle refs, it triggers `refs.c:ref_transaction_commit`.
This, in turn, invokes `refs.c:ref_transaction_prepare`, which calls
`transaction_prepare` of the refs storage backend. For files backend, it
is `files-backend.c:files_transaction_prepare`, and for reftable
backend, it is `reftable-backend.c:reftable_be_transaction_prepare`.
Both functions eventually call `object.c:parse_object`, which can invoke
`packfile.c:reprepare_packed_git` to refresh `packed_git`. This ensures
that bundle refs point to valid objects and that all tips from bundle
refs are correctly parsed during subsequent negotiations.

A set of negotiation-related tests for cloning with bundle-uri has been
included to demonstrate that downloaded bundles are utilized to
accelerate fetching.

Additionally, another test has been added to show that bundles with
incorrect headers, where refs point to non-existent objects, do not
result in any bundle refs being created in the repository.

Reviewed-by: Karthik Nayak &lt;karthik.188@gmail.com&gt;
Reviewed-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Signed-off-by: Xing Xin &lt;xingxin.xx@bytedance.com&gt;
---
 bundle-uri.c                |   3 +-
 t/t5558-clone-bundle-uri.sh | 155 +++++++++++++++++++++++++++++++++++-
 2 files <a href="http://lore.kernel.org/git/d8fbde2dcd49d2a2a37e35f456830c51709cd743.1718770053.git.gitgitgadget@gmail.com/#related">changed</a>, 152 insertions(+), 6 deletions(-)

<span
class="head">diff --git a/bundle-uri.c b/bundle-uri.c
index 91b3319a5c1..65666a11d9c 100644
--- a/bundle-uri.c
+++ b/bundle-uri.c
</span><span
class="hunk">@@ -400,8 +400,7 @@ static int unbundle_from_file(struct repository *r, const char *file)
</span> 		refs_update_ref(get_main_ref_store(the_repository),
 				&#34;fetched bundle&#34;, bundle_ref.buf, oid,
 				has_old ? &#38;old_oid : NULL,
<span
class="del">-				REF_SKIP_OID_VERIFICATION,
-				UPDATE_REFS_MSG_ON_ERR);
</span><span
class="add">+				0, UPDATE_REFS_MSG_ON_ERR);
</span> 	}
 
 	bundle_header_release(&#38;header);
<span
class="head">diff --git a/t/t5558-clone-bundle-uri.sh b/t/t5558-clone-bundle-uri.sh
index 1ca5f745e73..a0895913fe9 100755
--- a/t/t5558-clone-bundle-uri.sh
+++ b/t/t5558-clone-bundle-uri.sh
</span><span
class="hunk">@@ -3,6 +3,7 @@
</span> test_description=&#39;test fetching bundles with --bundle-uri&#39;
 
 . ./test-lib.sh
<span
class="add">+. &#34;$TEST_DIRECTORY&#34;/lib-bundle.sh
</span> 
 test_expect_success &#39;fail to clone from non-existent file&#39; &#39;
 	test_when_finished rm -rf test &#38;&#38;
<span
class="hunk">@@ -19,10 +20,24 @@ test_expect_success &#39;fail to clone from non-bundle file&#39; &#39;
</span> 
 test_expect_success &#39;create bundle&#39; &#39;
 	git init clone-from &#38;&#38;
<span
class="del">-	git -C clone-from checkout -b topic &#38;&#38;
-	test_commit -C clone-from A &#38;&#38;
-	test_commit -C clone-from B &#38;&#38;
-	git -C clone-from bundle create B.bundle topic
</span><span
class="add">+	(
+		cd clone-from &#38;&#38;
+		git checkout -b topic &#38;&#38;
+
+		test_commit A &#38;&#38;
+		git bundle create A.bundle topic &#38;&#38;
+
+		test_commit B &#38;&#38;
+		git bundle create B.bundle topic &#38;&#38;
+
+		# Create a bundle with reference pointing to non-existent object.
+		commit_a=$(git rev-parse A) &#38;&#38;
+		commit_b=$(git rev-parse B) &#38;&#38;
+		sed -e &#34;/^$/q&#34; -e &#34;s/$commit_a /$commit_b /&#34; \
+			&lt;A.bundle &gt;bad-header.bundle &#38;&#38;
+		convert_bundle_to_pack \
+			&lt;A.bundle &gt;&gt;bad-header.bundle
+	)
</span> &#39;
 
 test_expect_success &#39;clone with path bundle&#39; &#39;
<span
class="hunk">@@ -33,6 +48,16 @@ test_expect_success &#39;clone with path bundle&#39; &#39;
</span> 	test_cmp expect actual
 &#39;
 
<span
class="add">+test_expect_success &#39;clone with bundle that has bad header&#39; &#39;
+	# Write bundle ref fails, but clone can still proceed.
+	git clone --bundle-uri=&#34;clone-from/bad-header.bundle&#34; \
+		clone-from clone-bad-header 2&gt;err &#38;&#38;
+	commit_b=$(git -C clone-from rev-parse B) &#38;&#38;
+	test_grep &#34;trying to write ref &#39;\&#39;&#39;refs/bundles/topic&#39;\&#39;&#39; with nonexistent object $commit_b&#34; err &#38;&#38;
+	git -C clone-bad-header for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
+	test_grep ! &#34;refs/bundles/&#34; refs
+&#39;
+
</span> test_expect_success &#39;clone with path bundle and non-default hash&#39; &#39;
 	test_when_finished &#34;rm -rf clone-path-non-default-hash&#34; &#38;&#38;
 	GIT_DEFAULT_HASH=sha256 git clone --bundle-uri=&#34;clone-from/B.bundle&#34; \
<span
class="hunk">@@ -259,6 +284,128 @@ test_expect_success &#39;clone bundle list (file, any mode, all failures)&#39; &#39;
</span> 	! grep &#34;refs/bundles/&#34; refs
 &#39;
 
<span
class="add">+test_expect_success &#39;negotiation: bundle with part of wanted commits&#39; &#39;
+	test_when_finished &#34;rm -f trace*.txt&#34; &#38;&#38;
+	GIT_TRACE_PACKET=&#34;$(pwd)/trace-packet.txt&#34; \
+	git clone --no-local --bundle-uri=&#34;clone-from/A.bundle&#34; \
+		clone-from nego-bundle-part &#38;&#38;
+	git -C nego-bundle-part for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
+	grep &#34;refs/bundles/&#34; refs &gt;actual &#38;&#38;
+	test_write_lines refs/bundles/topic &gt;expect &#38;&#38;
+	test_cmp expect actual &#38;&#38;
+	# Ensure that refs/bundles/topic are sent as &#34;have&#34;.
+	tip=$(git -C clone-from rev-parse A) &#38;&#38;
+	test_grep &#34;clone&gt; have $tip&#34; trace-packet.txt
+&#39;
+
+test_expect_success &#39;negotiation: bundle with all wanted commits&#39; &#39;
+	test_when_finished &#34;rm -f trace*.txt&#34; &#38;&#38;
+	GIT_TRACE_PACKET=&#34;$(pwd)/trace-packet.txt&#34; \
+	git clone --no-local --single-branch --branch=topic --no-tags \
+		--bundle-uri=&#34;clone-from/B.bundle&#34; \
+		clone-from nego-bundle-all &#38;&#38;
+	git -C nego-bundle-all for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
+	grep &#34;refs/bundles/&#34; refs &gt;actual &#38;&#38;
+	test_write_lines refs/bundles/topic &gt;expect &#38;&#38;
+	test_cmp expect actual &#38;&#38;
+	# We already have all needed commits so no &#34;want&#34; needed.
+	test_grep ! &#34;clone&gt; want &#34; trace-packet.txt
+&#39;
+
+test_expect_success &#39;negotiation: bundle list (no heuristic)&#39; &#39;
+	test_when_finished &#34;rm -f trace*.txt&#34; &#38;&#38;
+	cat &gt;bundle-list &lt;&lt;-EOF &#38;&#38;
+	[bundle]
+		version = 1
+		mode = all
+
+	[bundle &#34;bundle-1&#34;]
+		uri = file://$(pwd)/clone-from/bundle-1.bundle
+
+	[bundle &#34;bundle-2&#34;]
+		uri = file://$(pwd)/clone-from/bundle-2.bundle
+	EOF
+
+	GIT_TRACE_PACKET=&#34;$(pwd)/trace-packet.txt&#34; \
+	git clone --no-local --bundle-uri=&#34;file://$(pwd)/bundle-list&#34; \
+		clone-from nego-bundle-list-no-heuristic &#38;&#38;
+
+	git -C nego-bundle-list-no-heuristic for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
+	grep &#34;refs/bundles/&#34; refs &gt;actual &#38;&#38;
+	cat &gt;expect &lt;&lt;-\EOF &#38;&#38;
+	refs/bundles/base
+	refs/bundles/left
+	EOF
+	test_cmp expect actual &#38;&#38;
+	tip=$(git -C nego-bundle-list-no-heuristic rev-parse refs/bundles/left) &#38;&#38;
+	test_grep &#34;clone&gt; have $tip&#34; trace-packet.txt
+&#39;
+
+test_expect_success &#39;negotiation: bundle list (creationToken)&#39; &#39;
+	test_when_finished &#34;rm -f trace*.txt&#34; &#38;&#38;
+	cat &gt;bundle-list &lt;&lt;-EOF &#38;&#38;
+	[bundle]
+		version = 1
+		mode = all
+		heuristic = creationToken
+
+	[bundle &#34;bundle-1&#34;]
+		uri = file://$(pwd)/clone-from/bundle-1.bundle
+		creationToken = 1
+
+	[bundle &#34;bundle-2&#34;]
+		uri = file://$(pwd)/clone-from/bundle-2.bundle
+		creationToken = 2
+	EOF
+
+	GIT_TRACE_PACKET=&#34;$(pwd)/trace-packet.txt&#34; \
+	git clone --no-local --bundle-uri=&#34;file://$(pwd)/bundle-list&#34; \
+		clone-from nego-bundle-list-heuristic &#38;&#38;
+
+	git -C nego-bundle-list-heuristic for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
+	grep &#34;refs/bundles/&#34; refs &gt;actual &#38;&#38;
+	cat &gt;expect &lt;&lt;-\EOF &#38;&#38;
+	refs/bundles/base
+	refs/bundles/left
+	EOF
+	test_cmp expect actual &#38;&#38;
+	tip=$(git -C nego-bundle-list-heuristic rev-parse refs/bundles/left) &#38;&#38;
+	test_grep &#34;clone&gt; have $tip&#34; trace-packet.txt
+&#39;
+
+test_expect_success &#39;negotiation: bundle list with all wanted commits&#39; &#39;
+	test_when_finished &#34;rm -f trace*.txt&#34; &#38;&#38;
+	cat &gt;bundle-list &lt;&lt;-EOF &#38;&#38;
+	[bundle]
+		version = 1
+		mode = all
+		heuristic = creationToken
+
+	[bundle &#34;bundle-1&#34;]
+		uri = file://$(pwd)/clone-from/bundle-1.bundle
+		creationToken = 1
+
+	[bundle &#34;bundle-2&#34;]
+		uri = file://$(pwd)/clone-from/bundle-2.bundle
+		creationToken = 2
+	EOF
+
+	GIT_TRACE_PACKET=&#34;$(pwd)/trace-packet.txt&#34; \
+	git clone --no-local --single-branch --branch=left --no-tags \
+		--bundle-uri=&#34;file://$(pwd)/bundle-list&#34; \
+		clone-from nego-bundle-list-all &#38;&#38;
+
+	git -C nego-bundle-list-all for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
+	grep &#34;refs/bundles/&#34; refs &gt;actual &#38;&#38;
+	cat &gt;expect &lt;&lt;-\EOF &#38;&#38;
+	refs/bundles/base
+	refs/bundles/left
+	EOF
+	test_cmp expect actual &#38;&#38;
+	# We already have all needed commits so no &#34;want&#34; needed.
+	test_grep ! &#34;clone&gt; want &#34; trace-packet.txt
+&#39;
+
</span> #########################################################################
 # HTTP tests begin here
 
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>blanet via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v8 0/3] object checking related additions and fixes for bundles in fetches</title><updated>2024-06-19T04:07:37Z</updated><link
href="http://lore.kernel.org/git/pull.1730.v8.git.1718770053.gitgitgadget@gmail.com/"/><id>urn:uuid:79096107-6ce1-ac03-39bc-e266bf6fb853</id><thr:in-reply-to
ref="urn:uuid:a88ab440-4a6d-0645-abb8-1c780348e756"
href="http://lore.kernel.org/git/pull.1730.v7.git.1718632535.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">While attempting to fix a reference negotiation bug in bundle-uri, we
identified that the fetch process lacks some crucial object validation
checks when processing bundles. The primary issues are:

 1. In the bundle-uri scenario, object IDs were not validated before writing
    bundle references. This was the root cause of the original negotiation
    bug in bundle-uri and could lead to potential repository corruption.
 2. The existing &#34;fetch.fsckObjects&#34; and &#34;transfer.fsckObjects&#34;
    configurations were not applied when directly fetching bundles or
    fetching with bundle-uri enabled. In fact, there were no object
    validation supports for unbundle.

The first patch addresses the bundle-uri negotiation issue by removing the
REF_SKIP_OID_VERIFICATION flag when writing bundle references.

Patches 2 through 3 extend verify_bundle_flags for bundle.c:unbundle to add
support for object validation (fsck) in fetch scenarios, mainly following
the suggestions from Junio and Patrick on the mailing list.

Xing Xin (3):
  bundle-uri: verify oid before writing refs
  fetch-pack: expose fsckObjects configuration logic
  unbundle: extend object verification for fetches

 bundle-uri.c                |   6 +-
 bundle.c                    |   3 +
 bundle.h                    |   1 +
 fetch-pack.c                |  17 ++--
 fetch-pack.h                |   5 +
 t/t5558-clone-bundle-uri.sh | 187 +++++++++++++++++++++++++++++++++++-
 t/t5607-clone-bundle.sh     |  35 +++++++
 transport.c                 |   3 +-
 8 files changed, 243 insertions(+), 14 deletions(-)


base-commit: b9cfe4845cb2562584837bc0101c0ab76490a239
Published-As: <a
href="https://github.com/gitgitgadget/git/releases/tag/pr-1730%2Fblanet%2Fxx%2Fbundle-uri-bug-using-bundle-list-v8">https://github.com/gitgitgadget/git/releases/tag/pr-1730%2Fblanet%2Fxx%2Fbundle-uri-bug-using-bundle-list-v8</a>
Fetch-It-Via: git fetch <a
href="https://github.com/gitgitgadget/git">https://github.com/gitgitgadget/git</a> pr-1730/blanet/xx/bundle-uri-bug-using-bundle-list-v8
Pull-Request: <a
href="https://github.com/gitgitgadget/git/pull/1730">https://github.com/gitgitgadget/git/pull/1730</a>

Range-diff vs v7:

 1:  fc9f44fda00 ! 1:  d8fbde2dcd4 bundle-uri: verify oid before writing refs
     @@ t/t5558-clone-bundle-uri.sh: test_expect_success &#39;fail to clone from non-bundle
      +		git bundle create B.bundle topic &#38;&#38;
      +
      +		# Create a bundle with reference pointing to non-existent object.
     -+		sed -e &#34;/^$/q&#34; -e &#34;s/$(git rev-parse A) /$(git rev-parse B) /&#34; \
     ++		commit_a=$(git rev-parse A) &#38;&#38;
     ++		commit_b=$(git rev-parse B) &#38;&#38;
     ++		sed -e &#34;/^$/q&#34; -e &#34;s/$commit_a /$commit_b /&#34; \
      +			&lt;A.bundle &gt;bad-header.bundle &#38;&#38;
      +		convert_bundle_to_pack \
      +			&lt;A.bundle &gt;&gt;bad-header.bundle
     @@ t/t5558-clone-bundle-uri.sh: test_expect_success &#39;clone with path bundle&#39; &#39;
      +	commit_b=$(git -C clone-from rev-parse B) &#38;&#38;
      +	test_grep &#34;trying to write ref &#39;\&#39;&#39;refs/bundles/topic&#39;\&#39;&#39; with nonexistent object $commit_b&#34; err &#38;&#38;
      +	git -C clone-bad-header for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
     -+	! grep &#34;refs/bundles/&#34; refs
     ++	test_grep ! &#34;refs/bundles/&#34; refs
      +&#39;
      +
       test_expect_success &#39;clone with path bundle and non-default hash&#39; &#39;
     @@ t/t5558-clone-bundle-uri.sh: test_expect_success &#39;clone bundle list (file, any m
      +	test_write_lines refs/bundles/topic &gt;expect &#38;&#38;
      +	test_cmp expect actual &#38;&#38;
      +	# Ensure that refs/bundles/topic are sent as &#34;have&#34;.
     -+	test_grep &#34;clone&gt; have $(git -C clone-from rev-parse A)&#34; trace-packet.txt
     ++	tip=$(git -C clone-from rev-parse A) &#38;&#38;
     ++	test_grep &#34;clone&gt; have $tip&#34; trace-packet.txt
      +&#39;
      +
      +test_expect_success &#39;negotiation: bundle with all wanted commits&#39; &#39;
     @@ t/t5558-clone-bundle-uri.sh: test_expect_success &#39;clone bundle list (file, any m
      +	test_write_lines refs/bundles/topic &gt;expect &#38;&#38;
      +	test_cmp expect actual &#38;&#38;
      +	# We already have all needed commits so no &#34;want&#34; needed.
     -+	! grep &#34;clone&gt; want &#34; trace-packet.txt
     ++	test_grep ! &#34;clone&gt; want &#34; trace-packet.txt
      +&#39;
      +
      +test_expect_success &#39;negotiation: bundle list (no heuristic)&#39; &#39;
     @@ t/t5558-clone-bundle-uri.sh: test_expect_success &#39;clone bundle list (file, any m
      +	refs/bundles/left
      +	EOF
      +	test_cmp expect actual &#38;&#38;
     -+	test_grep &#34;clone&gt; have $(git -C nego-bundle-list-no-heuristic rev-parse refs/bundles/left)&#34; trace-packet.txt
     ++	tip=$(git -C nego-bundle-list-no-heuristic rev-parse refs/bundles/left) &#38;&#38;
     ++	test_grep &#34;clone&gt; have $tip&#34; trace-packet.txt
      +&#39;
      +
      +test_expect_success &#39;negotiation: bundle list (creationToken)&#39; &#39;
     @@ t/t5558-clone-bundle-uri.sh: test_expect_success &#39;clone bundle list (file, any m
      +	refs/bundles/left
      +	EOF
      +	test_cmp expect actual &#38;&#38;
     -+	test_grep &#34;clone&gt; have $(git -C nego-bundle-list-heuristic rev-parse refs/bundles/left)&#34; trace-packet.txt
     ++	tip=$(git -C nego-bundle-list-heuristic rev-parse refs/bundles/left) &#38;&#38;
     ++	test_grep &#34;clone&gt; have $tip&#34; trace-packet.txt
      +&#39;
      +
      +test_expect_success &#39;negotiation: bundle list with all wanted commits&#39; &#39;
     @@ t/t5558-clone-bundle-uri.sh: test_expect_success &#39;clone bundle list (file, any m
      +	EOF
      +	test_cmp expect actual &#38;&#38;
      +	# We already have all needed commits so no &#34;want&#34; needed.
     -+	! grep &#34;clone&gt; want &#34; trace-packet.txt
     ++	test_grep ! &#34;clone&gt; want &#34; trace-packet.txt
      +&#39;
      +
       #########################################################################
 2:  3dc0d9dd22f ! 2:  518584c8698 fetch-pack: expose fsckObjects configuration logic
     @@ Commit message
          &#34;fetch.fsckObjects&#34; to control checks for broken objects in received
          packs during fetches. However, these configurations were only
          acknowledged by `fetch-pack.c:get_pack` and did not take effect in
     -    direct bundle fetches and fetches with _bundle-uri_ enabled.
     +    direct bundle fetches or fetches with _bundle-uri_ enabled.
      
          This commit exposes the fetch-then-transfer configuration logic by
          adding a new function `fetch_pack_fsck_objects` in fetch-pack.h. This
          new function is used to replace the assignment for `fsck_objects` in
     -    `fetch-pack.c:get_pack`. In the next commit, it will also be used by
     -    `bundle.c:unbundle` to better fit fetching scenarios.
     +    `fetch-pack.c:get_pack`. In the next commit, this function will also be
     +    used to extend fsck support for bundle-involved fetches.
      
          Helped-by: Junio C Hamano &lt;gitster@pobox.com&gt;
          Helped-by: Patrick Steinhardt &lt;ps@pks.im&gt;
 3:  2f15099bbb9 ! 3:  698dd6e49b7 unbundle: extend object verification for fetches
     @@ bundle.h: int create_bundle(struct repository *r, const char *path,
      
       ## t/t5558-clone-bundle-uri.sh ##
      @@ t/t5558-clone-bundle-uri.sh: test_expect_success &#39;create bundle&#39; &#39;
     - 		sed -e &#34;/^$/q&#34; -e &#34;s/$(git rev-parse A) /$(git rev-parse B) /&#34; \
     + 		sed -e &#34;/^$/q&#34; -e &#34;s/$commit_a /$commit_b /&#34; \
       			&lt;A.bundle &gt;bad-header.bundle &#38;&#38;
       		convert_bundle_to_pack \
      -			&lt;A.bundle &gt;&gt;bad-header.bundle
      +			&lt;A.bundle &gt;&gt;bad-header.bundle &#38;&#38;
      +
     ++		tree_b=$(git rev-parse B^{tree}) &#38;&#38;
      +		cat &gt;data &lt;&lt;-EOF &#38;&#38;
     -+		tree $(git rev-parse HEAD^{tree})
     -+		parent $(git rev-parse HEAD)
     ++		tree $tree_b
     ++		parent $commit_b
      +		author A U Thor
      +		committer A U Thor
      +
      +		commit: this is a commit with bad emails
      +
      +		EOF
     -+		git hash-object --literally -t commit -w --stdin &lt;data &gt;commit &#38;&#38;
     -+		git branch bad $(cat commit) &#38;&#38;
     ++		bad_commit=$(git hash-object --literally -t commit -w --stdin &lt;data) &#38;&#38;
     ++		git branch bad $bad_commit &#38;&#38;
      +		git bundle create bad-object.bundle bad &#38;&#38;
      +		git update-ref -d refs/heads/bad
       	)
       &#39;
       
      @@ t/t5558-clone-bundle-uri.sh: test_expect_success &#39;clone with bundle that has bad header&#39; &#39;
     - 	! grep &#34;refs/bundles/&#34; refs
     + 	test_grep ! &#34;refs/bundles/&#34; refs
       &#39;
       
      +test_expect_success &#39;clone with bundle that has bad object&#39; &#39;
     -+	# Unbundle succeeds if no fsckObjects confugured.
     ++	# Unbundle succeeds if no fsckObjects configured.
      +	git clone --bundle-uri=&#34;clone-from/bad-object.bundle&#34; \
      +		clone-from clone-bad-object-no-fsck &#38;&#38;
      +	git -C clone-bad-object-no-fsck for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
     @@ t/t5558-clone-bundle-uri.sh: test_expect_success &#39;clone with bundle that has bad
      +		clone-from clone-bad-object-fsck 2&gt;err &#38;&#38;
      +	test_grep &#34;missingEmail&#34; err &#38;&#38;
      +	git -C clone-bad-object-fsck for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
     -+	! grep &#34;refs/bundles/&#34; refs
     ++	test_grep ! &#34;refs/bundles/&#34; refs
      +&#39;
      +
       test_expect_success &#39;clone with path bundle and non-default hash&#39; &#39;
     @@ t/t5607-clone-bundle.sh: test_expect_success &#39;fetch SHA-1 from bundle&#39; &#39;
      +	test_create_repo bundle-fsck &#38;&#38;
      +	(
      +		cd bundle-fsck &#38;&#38;
     -+		test_commit first &#38;&#38;
     ++		test_commit A &#38;&#38;
     ++		commit_a=$(git rev-parse A) &#38;&#38;
     ++		tree_a=$(git rev-parse A^{tree}) &#38;&#38;
      +		cat &gt;data &lt;&lt;-EOF &#38;&#38;
     -+		tree $(git rev-parse HEAD^{tree})
     -+		parent $(git rev-parse HEAD)
     ++		tree $tree_a
     ++		parent $commit_a
      +		author A U Thor
      +		committer A U Thor
      +
      +		commit: this is a commit with bad emails
      +
      +		EOF
     -+		git hash-object --literally -t commit -w --stdin &lt;data &gt;commit &#38;&#38;
     -+		git branch bad $(cat commit) &#38;&#38;
     ++		bad_commit=$(git hash-object --literally -t commit -w --stdin &lt;data) &#38;&#38;
     ++		git branch bad $bad_commit &#38;&#38;
      +		git bundle create bad.bundle bad
      +	) &#38;&#38;
      +

-- 
gitgitgadget
</pre></div></content></entry><entry><author><name>Elijah Newren via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 7/7] merge-ort: convert more error() cases to path_msg()</title><updated>2024-06-19T03:00:32Z</updated><link
href="http://lore.kernel.org/git/500433edf49a4df448b330e4ed9201cfac83cecf.1718766019.git.gitgitgadget@gmail.com/"/><id>urn:uuid:b6a84586-a2c3-a9c7-a14b-fda351c9b152</id><thr:in-reply-to
ref="urn:uuid:023fc3ae-3ecd-a37b-19ae-4c94004bf6f9"
href="http://lore.kernel.org/git/pull.1748.v2.git.1718766019.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Elijah Newren &lt;newren@gmail.com&gt;

merge_submodule() stores errors using path_msg(), whereas other call
sites make use of the error() function.  This is inconsistent, and
moving towards path_msg() seems more friendly for libification efforts
since it will allow the caller to determine whether the error messages
need to be printed.

Note that this deferred handling of error messages changes the error
message in a recursive merge from
  error: failed to execute internal merge
to
  From inner merge:  error: failed to execute internal merge
which provides a little more information about the error which may be
useful.  Since the recursive merge strategy still only shows the older
error, we had to adjust the new testcase introduced a few commits ago to
just search for the older message somewhere in the output.

Signed-off-by: Elijah Newren &lt;newren@gmail.com&gt;
---
 merge-ort.c           | 53 +++++++++++++++++++++++++++++++++----------
 t/t6406-merge-attr.sh |  2 +-
 2 files <a href="http://lore.kernel.org/git/500433edf49a4df448b330e4ed9201cfac83cecf.1718766019.git.gitgitgadget@gmail.com/#related">changed</a>, 42 insertions(+), 13 deletions(-)

<span
class="head">diff --git a/merge-ort.c b/merge-ort.c
index b337e4d74ef..8dfe80f1009 100644
--- a/merge-ort.c
+++ b/merge-ort.c
</span><span
class="hunk">@@ -558,6 +558,10 @@ enum conflict_and_info_types {
</span> 	 * Keep this group _last_ other than NB_TOTAL_TYPES
 	 */
 	ERROR_SUBMODULE_CORRUPT,
<span
class="add">+	ERROR_THREEWAY_CONTENT_MERGE_FAILED,
+	ERROR_OBJECT_WRITE_FAILED,
+	ERROR_OBJECT_READ_FAILED,
+	ERROR_OBJECT_NOT_A_BLOB,
</span> 
 	/* Keep this entry _last_ in the list */
 	NB_TOTAL_TYPES,
<span
class="hunk">@@ -615,6 +619,14 @@ static const char *type_short_descriptions[] = {
</span> 	/* Something is seriously wrong; cannot even perform merge */
 	[ERROR_SUBMODULE_CORRUPT] =
 		&#34;ERROR (submodule corrupt)&#34;,
<span
class="add">+	[ERROR_THREEWAY_CONTENT_MERGE_FAILED] =
+		&#34;ERROR (three-way content merge failed)&#34;,
+	[ERROR_OBJECT_WRITE_FAILED] =
+		&#34;ERROR (object write failed)&#34;,
+	[ERROR_OBJECT_READ_FAILED] =
+		&#34;ERROR (object read failed)&#34;,
+	[ERROR_OBJECT_NOT_A_BLOB] =
+		&#34;ERROR (object is not a blob)&#34;,
</span> };
 
 struct logical_conflict_info {
<span
class="hunk">@@ -2190,15 +2202,24 @@ static int handle_content_merge(struct merge_options *opt,
</span> 					  pathnames, extra_marker_size,
 					  &#38;result_buf);
 
<span
class="del">-		if ((merge_status &lt; 0) || !result_buf.ptr)
-			ret = error(_(&#34;failed to execute internal merge&#34;));
</span><span
class="add">+		if ((merge_status &lt; 0) || !result_buf.ptr) {
+			path_msg(opt, ERROR_THREEWAY_CONTENT_MERGE_FAILED, 0,
+				 pathnames[0], pathnames[1], pathnames[2], NULL,
+				 _(&#34;error: failed to execute internal merge for %s&#34;),
+				 path);
+			ret = -1;
+		}
</span> 
 		if (!ret &#38;&#38;
 		    write_object_file(result_buf.ptr, result_buf.size,
<span
class="del">-				      OBJ_BLOB, &#38;result-&gt;oid))
-			ret = error(_(&#34;unable to add %s to database&#34;), path);
-
</span><span
class="add">+				      OBJ_BLOB, &#38;result-&gt;oid)) {
+			path_msg(opt, ERROR_OBJECT_WRITE_FAILED, 0,
+				 pathnames[0], pathnames[1], pathnames[2], NULL,
+				 _(&#34;error: unable to add %s to database&#34;), path);
+			ret = -1;
+		}
</span> 		free(result_buf.ptr);
<span
class="add">+
</span> 		if (ret)
 			return -1;
 		if (merge_status &gt; 0)
<span
class="hunk">@@ -3577,18 +3598,26 @@ static int sort_dirs_next_to_their_children(const char *one, const char *two)
</span> 		return c1 - c2;
 }
 
<span
class="del">-static int read_oid_strbuf(const struct object_id *oid,
-			   struct strbuf *dst)
</span><span
class="add">+static int read_oid_strbuf(struct merge_options *opt,
+			   const struct object_id *oid,
+			   struct strbuf *dst,
+			   const char *path)
</span> {
 	void *buf;
 	enum object_type type;
 	unsigned long size;
 	buf = repo_read_object_file(the_repository, oid, &#38;type, &#38;size);
<span
class="del">-	if (!buf)
-		return error(_(&#34;cannot read object %s&#34;), oid_to_hex(oid));
</span><span
class="add">+	if (!buf) {
+		path_msg(opt, ERROR_OBJECT_READ_FAILED, 0,
+			 path, NULL, NULL, NULL,
+			 _(&#34;error: cannot read object %s&#34;), oid_to_hex(oid));
+		return -1;
+	}
</span> 	if (type != OBJ_BLOB) {
 		free(buf);
<span
class="del">-		return error(_(&#34;object %s is not a blob&#34;), oid_to_hex(oid));
</span><span
class="add">+		path_msg(opt, ERROR_OBJECT_NOT_A_BLOB, 0,
+			 path, NULL, NULL, NULL,
+			 _(&#34;error: object %s is not a blob&#34;), oid_to_hex(oid));
</span> 	}
 	strbuf_attach(dst, buf, size, size + 1);
 	return 0;
<span
class="hunk">@@ -3612,8 +3641,8 @@ static int blob_unchanged(struct merge_options *opt,
</span> 	if (oideq(&#38;base-&gt;oid, &#38;side-&gt;oid))
 		return 1;
 
<span
class="del">-	if (read_oid_strbuf(&#38;base-&gt;oid, &#38;basebuf) ||
-	    read_oid_strbuf(&#38;side-&gt;oid, &#38;sidebuf))
</span><span
class="add">+	if (read_oid_strbuf(opt, &#38;base-&gt;oid, &#38;basebuf, path) ||
+	    read_oid_strbuf(opt, &#38;side-&gt;oid, &#38;sidebuf, path))
</span> 		goto error_return;
 	/*
 	 * Note: binary | is used so that both renormalizations are
<span
class="head">diff --git a/t/t6406-merge-attr.sh b/t/t6406-merge-attr.sh
index b6db5c2cc36..9bf95249347 100755
--- a/t/t6406-merge-attr.sh
+++ b/t/t6406-merge-attr.sh
</span><span
class="hunk">@@ -295,7 +295,7 @@ test_expect_success !WINDOWS &#39;custom merge driver that is killed with a signal o
</span> 	&gt;./please-abort &#38;&#38;
 	echo &#34;* merge=custom&#34; &gt;.gitattributes &#38;&#38;
 	test_expect_code 2 git merge recursive-a 2&gt;err &#38;&#38;
<span
class="del">-	grep &#34;^error: failed to execute internal merge&#34; err &#38;&#38;
</span><span
class="add">+	grep &#34;error: failed to execute internal merge&#34; err &#38;&#38;
</span> 	git ls-files -u &gt;output &#38;&#38;
 	git diff --name-only HEAD &gt;&gt;output &#38;&#38;
 	test_must_be_empty output
-- 
gitgitgadget
</pre></div></content></entry><entry><author><name>Elijah Newren via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 6/7] merge-ort: upon merge abort, only show messages causing the abort</title><updated>2024-06-19T03:00:30Z</updated><link
href="http://lore.kernel.org/git/6756956d0c7e3672a1a3b362b31b9d7e29bc5b9f.1718766019.git.gitgitgadget@gmail.com/"/><id>urn:uuid:24d49753-eda0-3412-85eb-73d559c28e4b</id><thr:in-reply-to
ref="urn:uuid:023fc3ae-3ecd-a37b-19ae-4c94004bf6f9"
href="http://lore.kernel.org/git/pull.1748.v2.git.1718766019.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Elijah Newren &lt;newren@gmail.com&gt;

When something goes wrong enough that we need to abort early and not
even attempt merging the remaining files, it probably does not make
sense to report conflicts messages for the subset of files we processed
before hitting the fatal error.  Instead, only show the messages
associated with paths where we hit the fatal error.  Also, print these
messages to stderr rather than stdout.

Signed-off-by: Elijah Newren &lt;newren@gmail.com&gt;
---
 merge-ort.c | 78 ++++++++++++++++++++++++++++++++++++-----------------
 1 file <a href="http://lore.kernel.org/git/6756956d0c7e3672a1a3b362b31b9d7e29bc5b9f.1718766019.git.gitgitgadget@gmail.com/#related">changed</a>, 53 insertions(+), 25 deletions(-)

<span
class="head">diff --git a/merge-ort.c b/merge-ort.c
index d0b13463283..b337e4d74ef 100644
--- a/merge-ort.c
+++ b/merge-ort.c
</span><span
class="hunk">@@ -543,10 +543,24 @@ enum conflict_and_info_types {
</span> 	CONFLICT_SUBMODULE_HISTORY_NOT_AVAILABLE,
 	CONFLICT_SUBMODULE_MAY_HAVE_REWINDS,
 	CONFLICT_SUBMODULE_NULL_MERGE_BASE,
<span
class="del">-	CONFLICT_SUBMODULE_CORRUPT,
</span><span
class="add">+
+	/* INSERT NEW ENTRIES HERE */
+
+	/*
+	 * Keep this entry after all regular conflict and info types; only
+	 * errors (failures causing immediate abort of the merge) should
+	 * come after this.
+	 */
+	NB_REGULAR_CONFLICT_TYPES,
+
+	/*
+	 * Something is seriously wrong; cannot even perform merge;
+	 * Keep this group _last_ other than NB_TOTAL_TYPES
+	 */
+	ERROR_SUBMODULE_CORRUPT,
</span> 
 	/* Keep this entry _last_ in the list */
<span
class="del">-	NB_CONFLICT_TYPES,
</span><span
class="add">+	NB_TOTAL_TYPES,
</span> };
 
 /*
<span
class="hunk">@@ -597,8 +611,10 @@ static const char *type_short_descriptions[] = {
</span> 		&#34;CONFLICT (submodule may have rewinds)&#34;,
 	[CONFLICT_SUBMODULE_NULL_MERGE_BASE] =
 		&#34;CONFLICT (submodule lacks merge base)&#34;,
<span
class="del">-	[CONFLICT_SUBMODULE_CORRUPT] =
-		&#34;CONFLICT (submodule corrupt)&#34;
</span><span
class="add">+
+	/* Something is seriously wrong; cannot even perform merge */
+	[ERROR_SUBMODULE_CORRUPT] =
+		&#34;ERROR (submodule corrupt)&#34;,
</span> };
 
 struct logical_conflict_info {
<span
class="hunk">@@ -762,7 +778,8 @@ static void path_msg(struct merge_options *opt,
</span> 
 	/* Sanity checks */
 	assert(omittable_hint ==
<span
class="del">-	       !starts_with(type_short_descriptions[type], &#34;CONFLICT&#34;) ||
</span><span
class="add">+	       (!starts_with(type_short_descriptions[type], &#34;CONFLICT&#34;) &#38;&#38;
+		!starts_with(type_short_descriptions[type], &#34;ERROR&#34;)) ||
</span> 	       type == CONFLICT_DIR_RENAME_SUGGESTED);
 	if (opt-&gt;record_conflict_msgs_as_headers &#38;&#38; omittable_hint)
 		return; /* Do not record mere hints in headers */
<span
class="hunk">@@ -1817,9 +1834,9 @@ static int merge_submodule(struct merge_options *opt,
</span> 	/* check whether both changes are forward */
 	ret2 = repo_in_merge_bases(&#38;subrepo, commit_o, commit_a);
 	if (ret2 &lt; 0) {
<span
class="del">-		path_msg(opt, CONFLICT_SUBMODULE_CORRUPT, 0,
</span><span
class="add">+		path_msg(opt, ERROR_SUBMODULE_CORRUPT, 0,
</span> 			 path, NULL, NULL, NULL,
<span
class="del">-			 _(&#34;Failed to merge submodule %s &#34;
</span><span
class="add">+			 _(&#34;error: failed to merge submodule %s &#34;
</span> 			   &#34;(repository corrupt)&#34;),
 			 path);
 		ret = -1;
<span
class="hunk">@@ -1828,9 +1845,9 @@ static int merge_submodule(struct merge_options *opt,
</span> 	if (ret2 &gt; 0)
 		ret2 = repo_in_merge_bases(&#38;subrepo, commit_o, commit_b);
 	if (ret2 &lt; 0) {
<span
class="del">-		path_msg(opt, CONFLICT_SUBMODULE_CORRUPT, 0,
</span><span
class="add">+		path_msg(opt, ERROR_SUBMODULE_CORRUPT, 0,
</span> 			 path, NULL, NULL, NULL,
<span
class="del">-			 _(&#34;Failed to merge submodule %s &#34;
</span><span
class="add">+			 _(&#34;error: failed to merge submodule %s &#34;
</span> 			   &#34;(repository corrupt)&#34;),
 			 path);
 		ret = -1;
<span
class="hunk">@@ -1848,9 +1865,9 @@ static int merge_submodule(struct merge_options *opt,
</span> 	/* Case #1: a is contained in b or vice versa */
 	ret2 = repo_in_merge_bases(&#38;subrepo, commit_a, commit_b);
 	if (ret2 &lt; 0) {
<span
class="del">-		path_msg(opt, CONFLICT_SUBMODULE_CORRUPT, 0,
</span><span
class="add">+		path_msg(opt, ERROR_SUBMODULE_CORRUPT, 0,
</span> 			 path, NULL, NULL, NULL,
<span
class="del">-			 _(&#34;Failed to merge submodule %s &#34;
</span><span
class="add">+			 _(&#34;error: failed to merge submodule %s &#34;
</span> 			   &#34;(repository corrupt)&#34;),
 			 path);
 		ret = -1;
<span
class="hunk">@@ -1867,9 +1884,9 @@ static int merge_submodule(struct merge_options *opt,
</span> 	}
 	ret2 = repo_in_merge_bases(&#38;subrepo, commit_b, commit_a);
 	if (ret2 &lt; 0) {
<span
class="del">-		path_msg(opt, CONFLICT_SUBMODULE_CORRUPT, 0,
</span><span
class="add">+		path_msg(opt, ERROR_SUBMODULE_CORRUPT, 0,
</span> 			 path, NULL, NULL, NULL,
<span
class="del">-			 _(&#34;Failed to merge submodule %s &#34;
</span><span
class="add">+			 _(&#34;error: failed to merge submodule %s &#34;
</span> 			   &#34;(repository corrupt)&#34;),
 			 path);
 		ret = -1;
<span
class="hunk">@@ -1901,9 +1918,9 @@ static int merge_submodule(struct merge_options *opt,
</span> 					 &#38;merges);
 	switch (parent_count) {
 	case -1:
<span
class="del">-		path_msg(opt, CONFLICT_SUBMODULE_CORRUPT, 0,
</span><span
class="add">+		path_msg(opt, ERROR_SUBMODULE_CORRUPT, 0,
</span> 			 path, NULL, NULL, NULL,
<span
class="del">-			 _(&#34;Failed to merge submodule %s &#34;
</span><span
class="add">+			 _(&#34;error: failed to merge submodule %s &#34;
</span> 			   &#34;(repository corrupt)&#34;),
 			 path);
 		ret = -1;
<span
class="hunk">@@ -4646,6 +4663,7 @@ void merge_display_update_messages(struct merge_options *opt,
</span> 	struct hashmap_iter iter;
 	struct strmap_entry *e;
 	struct string_list olist = STRING_LIST_INIT_NODUP;
<span
class="add">+	FILE *o = stdout;
</span> 
 	if (opt-&gt;record_conflict_msgs_as_headers)
 		BUG(&#34;Either display conflict messages or record them as headers, not both&#34;);
<span
class="hunk">@@ -4662,6 +4680,10 @@ void merge_display_update_messages(struct merge_options *opt,
</span> 	}
 	string_list_sort(&#38;olist);
 
<span
class="add">+	/* Print to stderr if we hit errors rather than just conflicts */
+	if (result-&gt;clean &lt; 0)
+		o = stderr;
+
</span> 	/* Iterate over the items, printing them */
 	for (int path_nr = 0; path_nr &lt; olist.nr; ++path_nr) {
 		struct string_list *conflicts = olist.items[path_nr].util;
<span
class="hunk">@@ -4669,25 +4691,31 @@ void merge_display_update_messages(struct merge_options *opt,
</span> 			struct logical_conflict_info *info =
 				conflicts-&gt;items[i].util;
 
<span
class="add">+			/* On failure, ignore regular conflict types */
+			if (result-&gt;clean &lt; 0 &#38;&#38;
+			    info-&gt;type &lt; NB_REGULAR_CONFLICT_TYPES)
+				continue;
+
</span> 			if (detailed) {
<span
class="del">-				printf(&#34;%lu&#34;, (unsigned long)info-&gt;paths.nr);
-				putchar(&#39;\0&#39;);
</span><span
class="add">+				fprintf(o, &#34;%lu&#34;, (unsigned long)info-&gt;paths.nr);
+				fputc(&#39;\0&#39;, o);
</span> 				for (int n = 0; n &lt; info-&gt;paths.nr; n++) {
<span
class="del">-					fputs(info-&gt;paths.v[n], stdout);
-					putchar(&#39;\0&#39;);
</span><span
class="add">+					fputs(info-&gt;paths.v[n], o);
+					fputc(&#39;\0&#39;, o);
</span> 				}
<span
class="del">-				fputs(type_short_descriptions[info-&gt;type],
-				      stdout);
-				putchar(&#39;\0&#39;);
</span><span
class="add">+				fputs(type_short_descriptions[info-&gt;type], o);
+				fputc(&#39;\0&#39;, o);
</span> 			}
<span
class="del">-			puts(conflicts-&gt;items[i].string);
</span><span
class="add">+			fputs(conflicts-&gt;items[i].string, o);
+			fputc(&#39;\n&#39;, o);
</span> 			if (detailed)
<span
class="del">-				putchar(&#39;\0&#39;);
</span><span
class="add">+				fputc(&#39;\0&#39;, o);
</span> 		}
 	}
 	string_list_clear(&#38;olist, 0);
 
<span
class="del">-	print_submodule_conflict_suggestion(&#38;opti-&gt;conflicted_submodules);
</span><span
class="add">+	if (result-&gt;clean &gt;= 0)
+		print_submodule_conflict_suggestion(&#38;opti-&gt;conflicted_submodules);
</span> 
 	/* Also include needed rename limit adjustment now */
 	diff_warn_rename_limit(&#34;merge.renamelimit&#34;,
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Elijah Newren via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 5/7] merge-ort: loosen commented requirements</title><updated>2024-06-19T03:00:29Z</updated><link
href="http://lore.kernel.org/git/750acae4dba009d7a2f2e10b3767fcecf3a4748c.1718766019.git.gitgitgadget@gmail.com/"/><id>urn:uuid:845e65e7-822c-45f9-93d1-4a8cf130550a</id><thr:in-reply-to
ref="urn:uuid:023fc3ae-3ecd-a37b-19ae-4c94004bf6f9"
href="http://lore.kernel.org/git/pull.1748.v2.git.1718766019.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Elijah Newren &lt;newren@gmail.com&gt;

The comment above type_short_descriptions claimed that the order had to
match what was found in the conflict_info_and_types enum.  Since
type_short_descriptions uses designated initializers, the order should
not actually matter; I am guessing that positional initializers may have
been under consideration when that comment was added, but the comment
was not updated when designated initializers were chosen.

Signed-off-by: Elijah Newren &lt;newren@gmail.com&gt;
---
 merge-ort.c | 2 +-
 1 file <a href="http://lore.kernel.org/git/750acae4dba009d7a2f2e10b3767fcecf3a4748c.1718766019.git.gitgitgadget@gmail.com/#related">changed</a>, 1 insertion(+), 1 deletion(-)

<span
class="head">diff --git a/merge-ort.c b/merge-ort.c
index d187c966c6a..d0b13463283 100644
--- a/merge-ort.c
+++ b/merge-ort.c
</span><span
class="hunk">@@ -553,7 +553,7 @@ enum conflict_and_info_types {
</span>  * Short description of conflict type, relied upon by external tools.
  *
  * We can add more entries, but DO NOT change any of these strings.  Also,
<span
class="del">- * Order MUST match conflict_info_and_types.
</span><span
class="add">+ * please ensure the order matches what is used in conflict_info_and_types.
</span>  */
 static const char *type_short_descriptions[] = {
 	/*** &#34;Simple&#34; conflicts and informational messages ***/
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Elijah Newren via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 4/7] merge-ort: clearer propagation of failure-to-function from merge_submodule</title><updated>2024-06-19T03:00:28Z</updated><link
href="http://lore.kernel.org/git/2813a15b48b70ead7e3fd062d1b49baee665fc9d.1718766019.git.gitgitgadget@gmail.com/"/><id>urn:uuid:639500c0-b005-4390-deb5-b3079927a9dc</id><thr:in-reply-to
ref="urn:uuid:023fc3ae-3ecd-a37b-19ae-4c94004bf6f9"
href="http://lore.kernel.org/git/pull.1748.v2.git.1718766019.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Elijah Newren &lt;newren@gmail.com&gt;

The &#39;clean&#39; member variable is somewhat of a tri-state (1 = clean, 0 =
conflicted, -1 = failure-to-determine), but we often like to think of
it as binary (ignoring the possibility of a negative value) and use
constructs like &#39;!clean&#39; to reflect this.  However, these constructs
can make codepaths more difficult to understand, unless we handle the
negative case early and return pre-emptively; do that in
handle_content_merge() to make the code a bit easier to read.

Signed-off-by: Elijah Newren &lt;newren@gmail.com&gt;
---
 merge-ort.c | 2 ++
 1 file <a href="http://lore.kernel.org/git/2813a15b48b70ead7e3fd062d1b49baee665fc9d.1718766019.git.gitgitgadget@gmail.com/#related">changed</a>, 2 insertions(+)

<span
class="head">diff --git a/merge-ort.c b/merge-ort.c
index be0f5bc3838..d187c966c6a 100644
--- a/merge-ort.c
+++ b/merge-ort.c
</span><span
class="hunk">@@ -2193,6 +2193,8 @@ static int handle_content_merge(struct merge_options *opt,
</span> 		clean = merge_submodule(opt, pathnames[0],
 					two_way ? null_oid() : &#38;o-&gt;oid,
 					&#38;a-&gt;oid, &#38;b-&gt;oid, &#38;result-&gt;oid);
<span
class="add">+		if (clean &lt; 0)
+			return -1;
</span> 		if (opt-&gt;priv-&gt;call_depth &#38;&#38; two_way &#38;&#38; !clean) {
 			result-&gt;mode = o-&gt;mode;
 			oidcpy(&#38;result-&gt;oid, &#38;o-&gt;oid);
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Elijah Newren via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title
type="html">[PATCH v2 3/7] merge-ort: fix type of local &#39;clean&#39; var in handle_content_merge()</title><updated>2024-06-19T03:00:27Z</updated><link
href="http://lore.kernel.org/git/034b91db1d2ed78995b52c014de313744972ff40.1718766019.git.gitgitgadget@gmail.com/"/><id>urn:uuid:e4f32e38-a29f-9406-b2dc-abaec65edf33</id><thr:in-reply-to
ref="urn:uuid:023fc3ae-3ecd-a37b-19ae-4c94004bf6f9"
href="http://lore.kernel.org/git/pull.1748.v2.git.1718766019.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Elijah Newren &lt;newren@gmail.com&gt;

handle_content_merge() returns an int.  Every caller of
handle_content_merge() expects an int.  However, we declare a local
variable &#39;clean&#39; that we use for the return value to be unsigned.  To
make matters worse, we also assign &#39;clean&#39; the return value of
merge_submodule() in one codepath, which is defined to return an int.
It seems that the only reason to have &#39;clean&#39; be unsigned was to allow a
cutesy bit manipulation operation to be well-defined.  Fix the type of
the &#39;clean&#39; local in handle_content_merge().

Signed-off-by: Elijah Newren &lt;newren@gmail.com&gt;
---
 merge-ort.c | 5 +++--
 1 file <a href="http://lore.kernel.org/git/034b91db1d2ed78995b52c014de313744972ff40.1718766019.git.gitgitgadget@gmail.com/#related">changed</a>, 3 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/merge-ort.c b/merge-ort.c
index dc62aaf6d11..be0f5bc3838 100644
--- a/merge-ort.c
+++ b/merge-ort.c
</span><span
class="hunk">@@ -2109,7 +2109,7 @@ static int handle_content_merge(struct merge_options *opt,
</span> 	 * merges, which happens for example with rename/rename(2to1) and
 	 * rename/add conflicts.
 	 */
<span
class="del">-	unsigned clean = 1;
</span><span
class="add">+	int clean = 1;
</span> 
 	/*
 	 * handle_content_merge() needs both files to be of the same type, i.e.
<span
class="hunk">@@ -2184,7 +2184,8 @@ static int handle_content_merge(struct merge_options *opt,
</span> 		free(result_buf.ptr);
 		if (ret)
 			return -1;
<span
class="del">-		clean &#38;= (merge_status == 0);
</span><span
class="add">+		if (merge_status &gt; 0)
+			clean = 0;
</span> 		path_msg(opt, INFO_AUTO_MERGING, 1, path, NULL, NULL, NULL,
 			 _(&#34;Auto-merging %s&#34;), path);
 	} else if (S_ISGITLINK(a-&gt;mode)) {
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Elijah Newren via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 2/7] merge-ort: maintain expected invariant for priv member</title><updated>2024-06-19T03:00:25Z</updated><link
href="http://lore.kernel.org/git/d1adec6d10556e247c21f94420879724fa2c6436.1718766019.git.gitgitgadget@gmail.com/"/><id>urn:uuid:15d8fcf5-e31e-0ac0-09bd-d348ec8c8613</id><thr:in-reply-to
ref="urn:uuid:023fc3ae-3ecd-a37b-19ae-4c94004bf6f9"
href="http://lore.kernel.org/git/pull.1748.v2.git.1718766019.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Elijah Newren &lt;newren@gmail.com&gt;

The calling convention for the merge machinery is
   One call to          init_merge_options()
   One or more calls to merge_incore_[non]recursive()
   One call to          merge_finalize()
      (possibly indirectly via merge_switch_to_result())
Both merge_switch_to_result() and merge_finalize() expect
   opt-&gt;priv == NULL &#38;&#38; result-&gt;priv != NULL
which is supposed to be set up by our move_opt_priv_to_result_priv()
function.  However, two codepaths dealing with error cases did not
execute this necessary logic, which could result in assertion failures
(or, if assertions were compiled out, could result in segfaults).  Fix
the oversight and add a test that would have caught one of these
problems.

While at it, also tighten an existing test for a non-recursive merge
to verify that it fails with appropriate status.  Most merge tests in
the testsuite check either for success or conflicts; those testing for
neither are rare and it is good to ensure they support the invariant
assumed by builtin/merge.c in this comment:
    /*
     * The backend exits with 1 when conflicts are
     * left to be resolved, with 2 when it does not
     * handle the given merge at all.
     */
So, explicitly check for the exit status of 2 in these cases.

Reported-by: Matt Cree &lt;matt.cree@gearset.com&gt;
Signed-off-by: Elijah Newren &lt;newren@gmail.com&gt;
---
 merge-ort.c           |  3 ++-
 t/t6406-merge-attr.sh | 42 +++++++++++++++++++++++++++++++++++++++++-
 2 files <a href="http://lore.kernel.org/git/d1adec6d10556e247c21f94420879724fa2c6436.1718766019.git.gitgitgadget@gmail.com/#related">changed</a>, 43 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/merge-ort.c b/merge-ort.c
index 700ddfccb90..dc62aaf6d11 100644
--- a/merge-ort.c
+++ b/merge-ort.c
</span><span
class="hunk">@@ -5050,6 +5050,7 @@ static void merge_ort_nonrecursive_internal(struct merge_options *opt,
</span> 		    oid_to_hex(&#38;side1-&gt;object.oid),
 		    oid_to_hex(&#38;side2-&gt;object.oid));
 		result-&gt;clean = -1;
<span
class="add">+		move_opt_priv_to_result_priv(opt, result);
</span> 		return;
 	}
 	trace2_region_leave(&#34;merge&#34;, &#34;collect_merge_info&#34;, opt-&gt;repo);
<span
class="hunk">@@ -5080,7 +5081,7 @@ static void merge_ort_nonrecursive_internal(struct merge_options *opt,
</span> 		/* existence of conflicted entries implies unclean */
 		result-&gt;clean &#38;= strmap_empty(&#38;opt-&gt;priv-&gt;conflicted);
 	}
<span
class="del">-	if (!opt-&gt;priv-&gt;call_depth)
</span><span
class="add">+	if (!opt-&gt;priv-&gt;call_depth || result-&gt;clean &lt; 0)
</span> 		move_opt_priv_to_result_priv(opt, result);
 }
 
<span
class="head">diff --git a/t/t6406-merge-attr.sh b/t/t6406-merge-attr.sh
index 156a1efacfe..b6db5c2cc36 100755
--- a/t/t6406-merge-attr.sh
+++ b/t/t6406-merge-attr.sh
</span><span
class="hunk">@@ -185,7 +185,7 @@ test_expect_success !WINDOWS &#39;custom merge driver that is killed with a signal&#39;
</span> 
 	&gt;./please-abort &#38;&#38;
 	echo &#34;* merge=custom&#34; &gt;.gitattributes &#38;&#38;
<span
class="del">-	test_must_fail git merge main 2&gt;err &#38;&#38;
</span><span
class="add">+	test_expect_code 2 git merge main 2&gt;err &#38;&#38;
</span> 	grep &#34;^error: failed to execute internal merge&#34; err &#38;&#38;
 	git ls-files -u &gt;output &#38;&#38;
 	git diff --name-only HEAD &gt;&gt;output &#38;&#38;
<span
class="hunk">@@ -261,4 +261,44 @@ test_expect_success &#39;binary files with union attribute&#39; &#39;
</span> 	grep -i &#34;warning.*cannot merge.*HEAD vs. bin-main&#34; output
 &#39;
 
<span
class="add">+test_expect_success !WINDOWS &#39;custom merge driver that is killed with a signal on recursive merge&#39; &#39;
+	test_when_finished &#34;rm -f output please-abort&#34; &#38;&#38;
+	test_when_finished &#34;git checkout side&#34; &#38;&#38;
+
+	git reset --hard anchor &#38;&#38;
+
+	git checkout -b base-a main^ &#38;&#38;
+	echo base-a &gt;text &#38;&#38;
+	git commit -m base-a text &#38;&#38;
+
+	git checkout -b base-b main^ &#38;&#38;
+	echo base-b &gt;text &#38;&#38;
+	git commit -m base-b text &#38;&#38;
+
+	git checkout -b recursive-a base-a &#38;&#38;
+	test_must_fail git merge base-b &#38;&#38;
+	echo recursive-a &gt;text &#38;&#38;
+	git add text &#38;&#38;
+	git commit -m recursive-a &#38;&#38;
+
+	git checkout -b recursive-b base-b &#38;&#38;
+	test_must_fail git merge base-a &#38;&#38;
+	echo recursive-b &gt;text &#38;&#38;
+	git add text &#38;&#38;
+	git commit -m recursive-b &#38;&#38;
+
+	git config --replace-all \
+	merge.custom.driver &#34;./custom-merge %O %A %B 0 %P %S %X %Y&#34; &#38;&#38;
+	git config --replace-all \
+	merge.custom.name &#34;custom merge driver for testing&#34; &#38;&#38;
+
+	&gt;./please-abort &#38;&#38;
+	echo &#34;* merge=custom&#34; &gt;.gitattributes &#38;&#38;
+	test_expect_code 2 git merge recursive-a 2&gt;err &#38;&#38;
+	grep &#34;^error: failed to execute internal merge&#34; err &#38;&#38;
+	git ls-files -u &gt;output &#38;&#38;
+	git diff --name-only HEAD &gt;&gt;output &#38;&#38;
+	test_must_be_empty output
+&#39;
+
</span> test_done
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Elijah Newren via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 1/7] merge-ort: extract handling of priv member into reusable function</title><updated>2024-06-19T03:00:24Z</updated><link
href="http://lore.kernel.org/git/5c50c0b3aadbefc7973a2e8d77890808c95875d6.1718766019.git.gitgitgadget@gmail.com/"/><id>urn:uuid:be28c9d8-57c4-7779-0e17-2c70ba0f220c</id><thr:in-reply-to
ref="urn:uuid:023fc3ae-3ecd-a37b-19ae-4c94004bf6f9"
href="http://lore.kernel.org/git/pull.1748.v2.git.1718766019.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Elijah Newren &lt;newren@gmail.com&gt;

In preparation for a subsequent commit which will ensure we do not
forget to maintain our invariants for the priv member in error
codepaths, extract the necessary functionality out into a separate
function.  This change is cosmetic at this point, and introduces no
changes beyond an extra assertion sanity check.

Signed-off-by: Elijah Newren &lt;newren@gmail.com&gt;
---
 merge-ort.c | 27 ++++++++++++++++++++++-----
 1 file <a href="http://lore.kernel.org/git/5c50c0b3aadbefc7973a2e8d77890808c95875d6.1718766019.git.gitgitgadget@gmail.com/#related">changed</a>, 22 insertions(+), 5 deletions(-)

<span
class="head">diff --git a/merge-ort.c b/merge-ort.c
index eaede6cead9..700ddfccb90 100644
--- a/merge-ort.c
+++ b/merge-ort.c
</span><span
class="hunk">@@ -5000,6 +5000,26 @@ static void merge_check_renames_reusable(struct merge_result *result,
</span> 
 /*** Function Grouping: merge_incore_*() and their internal variants ***/
 
<span
class="add">+static void move_opt_priv_to_result_priv(struct merge_options *opt,
+					 struct merge_result *result)
+{
+	/*
+	 * opt-&gt;priv and result-&gt;priv are a bit weird.  opt-&gt;priv contains
+	 * information that we can re-use in subsequent merge operations to
+	 * enable our cached renames optimization.  The best way to provide
+	 * that to subsequent merges is putting it in result-&gt;priv.
+	 * However, putting it directly there would mean retrofitting lots
+	 * of functions in this file to also take a merge_result pointer,
+	 * which is ugly and annoying.  So, we just make sure at the end of
+	 * the merge (the outer merge if there are internal recursive ones)
+	 * to move it.
+	 */
+	assert(opt-&gt;priv &#38;&#38; !result-&gt;priv);
+	result-&gt;priv = opt-&gt;priv;
+	result-&gt;_properly_initialized = RESULT_INITIALIZED;
+	opt-&gt;priv = NULL;
+}
+
</span> /*
  * Originally from merge_trees_internal(); heavily adapted, though.
  */
<span
class="hunk">@@ -5060,11 +5080,8 @@ static void merge_ort_nonrecursive_internal(struct merge_options *opt,
</span> 		/* existence of conflicted entries implies unclean */
 		result-&gt;clean &#38;= strmap_empty(&#38;opt-&gt;priv-&gt;conflicted);
 	}
<span
class="del">-	if (!opt-&gt;priv-&gt;call_depth) {
-		result-&gt;priv = opt-&gt;priv;
-		result-&gt;_properly_initialized = RESULT_INITIALIZED;
-		opt-&gt;priv = NULL;
-	}
</span><span
class="add">+	if (!opt-&gt;priv-&gt;call_depth)
+		move_opt_priv_to_result_priv(opt, result);
</span> }
 
 /*
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Elijah Newren via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v2 0/7] Fix and improve some error codepaths in merge-ort</title><updated>2024-06-19T03:00:24Z</updated><link
href="http://lore.kernel.org/git/pull.1748.v2.git.1718766019.gitgitgadget@gmail.com/"/><id>urn:uuid:023fc3ae-3ecd-a37b-19ae-4c94004bf6f9</id><thr:in-reply-to
ref="urn:uuid:853d7c59-4305-0d31-d405-79c6aa3181c5"
href="http://lore.kernel.org/git/pull.1748.git.1718310307.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Changes since v1:

 * Remove the conditional outside of move_opt_priv_to_result_priv() for
   patches 1 &#38; 2
 * Fix the consistency issues in patch 6 (refer to updated enum value in
   comment, use consistent prefix on error messages)
 * Fix typo in patch 2
 * Fix incorrect claim in commit message of patch 2 and provide more detail
   about which merges we are interested in checking for a very specific exit
   code.

This series started as a just a fix for the abort hit in merge-ort when
custom merge drivers error out (see
<a
href="https://lore.kernel.org/git/75F8BD12-7743-4863-B4C5-049FDEC4645E@gearset.com/">https://lore.kernel.org/git/75F8BD12-7743-4863-B4C5-049FDEC4645E@gearset.com/</a>).
However, while working on that, I found a few other issues around error
codepaths in merge-ort. So this series:

 * Patches 1-2: fix the reported abort problem
 * Patches 3-4: make code in handle_content_merges() easier to handle when
   we hit errors
 * Patch 5: fix a misleading comment
 * Patches 6-7: make error handling (immediate print vs. letting callers get
   the error information) more consistent

The last two patches change the behavior slightly for error codepaths, and
there&#39;s a question about whether we should show only the error messages that
caused an early termination of the merge, or if we should also show any
conflict messages for other paths that were handled before we hit the early
termination. These patches made a decision but feel free to take those last
two patches as more of an RFC.

Elijah Newren (7):
  merge-ort: extract handling of priv member into reusable function
  merge-ort: maintain expected invariant for priv member
  merge-ort: fix type of local &#39;clean&#39; var in handle_content_merge()
  merge-ort: clearer propagation of failure-to-function from
    merge_submodule
  merge-ort: loosen commented requirements
  merge-ort: upon merge abort, only show messages causing the abort
  merge-ort: convert more error() cases to path_msg()

 merge-ort.c           | 168 +++++++++++++++++++++++++++++++-----------
 t/t6406-merge-attr.sh |  42 ++++++++++-
 2 files changed, 164 insertions(+), 46 deletions(-)


base-commit: 8d94cfb54504f2ec9edc7ca3eb5c29a3dd3675ae
Published-As: <a
href="https://github.com/gitgitgadget/git/releases/tag/pr-1748%2Fnewren%2Ffix-error-cases-v2">https://github.com/gitgitgadget/git/releases/tag/pr-1748%2Fnewren%2Ffix-error-cases-v2</a>
Fetch-It-Via: git fetch <a
href="https://github.com/gitgitgadget/git">https://github.com/gitgitgadget/git</a> pr-1748/newren/fix-error-cases-v2
Pull-Request: <a
href="https://github.com/gitgitgadget/git/pull/1748">https://github.com/gitgitgadget/git/pull/1748</a>

Range-diff vs v1:

 1:  d4ba1fccd91 ! 1:  5c50c0b3aad merge-ort: extract handling of priv member into reusable function
     @@ merge-ort.c: static void merge_check_renames_reusable(struct merge_result *resul
      +	 * to move it.
      +	 */
      +	assert(opt-&gt;priv &#38;&#38; !result-&gt;priv);
     -+	if (!opt-&gt;priv-&gt;call_depth) {
     -+		result-&gt;priv = opt-&gt;priv;
     -+		result-&gt;_properly_initialized = RESULT_INITIALIZED;
     -+		opt-&gt;priv = NULL;
     -+	}
     ++	result-&gt;priv = opt-&gt;priv;
     ++	result-&gt;_properly_initialized = RESULT_INITIALIZED;
     ++	opt-&gt;priv = NULL;
      +}
      +
       /*
     @@ merge-ort.c: static void merge_ort_nonrecursive_internal(struct merge_options *o
      -		result-&gt;_properly_initialized = RESULT_INITIALIZED;
      -		opt-&gt;priv = NULL;
      -	}
     -+	move_opt_priv_to_result_priv(opt, result);
     ++	if (!opt-&gt;priv-&gt;call_depth)
     ++		move_opt_priv_to_result_priv(opt, result);
       }
       
       /*
 2:  17c97301baa ! 2:  d1adec6d105 merge-ort: maintain expected invariant for priv member
     @@ Commit message
          Both merge_switch_to_result() and merge_finalize() expect
             opt-&gt;priv == NULL &#38;&#38; result-&gt;priv != NULL
          which is supposed to be set up by our move_opt_priv_to_result_priv()
     -    function.  However, two codepath dealing with error cases did not
     +    function.  However, two codepaths dealing with error cases did not
          execute this necessary logic, which could result in assertion failures
          (or, if assertions were compiled out, could result in segfaults).  Fix
          the oversight and add a test that would have caught one of these
          problems.
      
          While at it, also tighten an existing test for a non-recursive merge
     -    to verify that it fails correctly, i.e. with the expected exit code
     -    rather than with an assertion failure.
     +    to verify that it fails with appropriate status.  Most merge tests in
     +    the testsuite check either for success or conflicts; those testing for
     +    neither are rare and it is good to ensure they support the invariant
     +    assumed by builtin/merge.c in this comment:
     +        /*
     +         * The backend exits with 1 when conflicts are
     +         * left to be resolved, with 2 when it does not
     +         * handle the given merge at all.
     +         */
     +    So, explicitly check for the exit status of 2 in these cases.
      
          Reported-by: Matt Cree &lt;matt.cree@gearset.com&gt;
          Signed-off-by: Elijah Newren &lt;newren@gmail.com&gt;
      
       ## merge-ort.c ##
     -@@ merge-ort.c: static void move_opt_priv_to_result_priv(struct merge_options *opt,
     - 	 * to move it.
     - 	 */
     - 	assert(opt-&gt;priv &#38;&#38; !result-&gt;priv);
     --	if (!opt-&gt;priv-&gt;call_depth) {
     -+	if (!opt-&gt;priv-&gt;call_depth || result-&gt;clean &lt; 0) {
     - 		result-&gt;priv = opt-&gt;priv;
     - 		result-&gt;_properly_initialized = RESULT_INITIALIZED;
     - 		opt-&gt;priv = NULL;
      @@ merge-ort.c: static void merge_ort_nonrecursive_internal(struct merge_options *opt,
       		    oid_to_hex(&#38;side1-&gt;object.oid),
       		    oid_to_hex(&#38;side2-&gt;object.oid));
     @@ merge-ort.c: static void merge_ort_nonrecursive_internal(struct merge_options *o
       		return;
       	}
       	trace2_region_leave(&#34;merge&#34;, &#34;collect_merge_info&#34;, opt-&gt;repo);
     +@@ merge-ort.c: static void merge_ort_nonrecursive_internal(struct merge_options *opt,
     + 		/* existence of conflicted entries implies unclean */
     + 		result-&gt;clean &#38;= strmap_empty(&#38;opt-&gt;priv-&gt;conflicted);
     + 	}
     +-	if (!opt-&gt;priv-&gt;call_depth)
     ++	if (!opt-&gt;priv-&gt;call_depth || result-&gt;clean &lt; 0)
     + 		move_opt_priv_to_result_priv(opt, result);
     + }
     + 
      
       ## t/t6406-merge-attr.sh ##
      @@ t/t6406-merge-attr.sh: test_expect_success !WINDOWS &#39;custom merge driver that is killed with a signal&#39;
 3:  23bb3386114 = 3:  034b91db1d2 merge-ort: fix type of local &#39;clean&#39; var in handle_content_merge()
 4:  2789c58cd3f = 4:  2813a15b48b merge-ort: clearer propagation of failure-to-function from merge_submodule
 5:  975fbddf305 = 5:  750acae4dba merge-ort: loosen commented requirements
 6:  71391b18c1a ! 6:  6756956d0c7 merge-ort: upon merge abort, only show messages causing the abort
     @@ merge-ort.c: enum conflict_and_info_types {
      +
      +	/*
      +	 * Something is seriously wrong; cannot even perform merge;
     -+	 * Keep this group _last_ other than NB_CONFLICT_TYPES
     ++	 * Keep this group _last_ other than NB_TOTAL_TYPES
      +	 */
      +	ERROR_SUBMODULE_CORRUPT,
       
     @@ merge-ort.c: static int merge_submodule(struct merge_options *opt,
      -		path_msg(opt, CONFLICT_SUBMODULE_CORRUPT, 0,
      +		path_msg(opt, ERROR_SUBMODULE_CORRUPT, 0,
       			 path, NULL, NULL, NULL,
     - 			 _(&#34;Failed to merge submodule %s &#34;
     +-			 _(&#34;Failed to merge submodule %s &#34;
     ++			 _(&#34;error: failed to merge submodule %s &#34;
       			   &#34;(repository corrupt)&#34;),
     + 			 path);
     + 		ret = -1;
      @@ merge-ort.c: static int merge_submodule(struct merge_options *opt,
       	}
       	ret2 = repo_in_merge_bases(&#38;subrepo, commit_b, commit_a);
 7:  32ae44b6260 ! 7:  500433edf49 merge-ort: convert more error() cases to path_msg()
     @@ Commit message
      
       ## merge-ort.c ##
      @@ merge-ort.c: enum conflict_and_info_types {
     - 	 * Keep this group _last_ other than NB_CONFLICT_TYPES
     + 	 * Keep this group _last_ other than NB_TOTAL_TYPES
       	 */
       	ERROR_SUBMODULE_CORRUPT,
      +	ERROR_THREEWAY_CONTENT_MERGE_FAILED,

-- 
gitgitgadget
</pre></div></content></entry><entry><author><name>Junio C Hamano</name><email>gitster@pobox.com</email></author><title>[PATCH 4/4] submodule: ignore .gitmodules that is not a regular file</title><updated>2024-06-18T23:44:53Z</updated><link
href="http://lore.kernel.org/git/20240618234436.4107855-5-gitster@pobox.com/"/><id>urn:uuid:176b8abe-1bf1-c4dd-5afc-99a136ddd57e</id><thr:in-reply-to
ref="urn:uuid:596449d6-b857-7afe-45de-ba361d4d1ee9"
href="http://lore.kernel.org/git/20240618234436.4107855-1-gitster@pobox.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">If .gitmodules exists in the working tree but is a directory, it
would have just tried to use it as if it were a file.  On a platform
that needs FREAD_READS_DIRECTORIES, this would have been hidden by
our own fopen() that pretends as if directory did not exist, so it
is a no-op.  Just to add some documentation value, make sure we
check with file_exists_as_file() instead of file_exists(), the
latter of which will be happy as long as the given path exists no
matter what it is.

Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
---
 dir.c              | 6 ++++++
 dir.h              | 1 +
 submodule-config.c | 2 +-
 3 files <a href="http://lore.kernel.org/git/20240618234436.4107855-5-gitster@pobox.com/#related">changed</a>, 8 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/dir.c b/dir.c
index 73f89f4d8c..d943da93df 100644
--- a/dir.c
+++ b/dir.c
</span><span
class="hunk">@@ -3142,6 +3142,12 @@ int file_exists(const char *f)
</span> 	return lstat(f, &#38;sb) == 0;
 }
 
<span
class="add">+int file_exists_as_file(const char *path)
+{
+	struct stat st;
+	return lstat(path, &#38;st) == 0 &#38;&#38; S_ISREG(st.st_mode);
+}
+
</span> int repo_file_exists(struct repository *repo, const char *path)
 {
 	if (repo != the_repository)
<span
class="head">diff --git a/dir.h b/dir.h
index 1398a53fb4..3612dbbf9e 100644
--- a/dir.h
+++ b/dir.h
</span><span
class="hunk">@@ -475,6 +475,7 @@ void dir_clear(struct dir_struct *dir);
</span> 
 int repo_file_exists(struct repository *repo, const char *path);
 int file_exists(const char *);
<span
class="add">+int file_exists_as_file(const char *);
</span> 
 int is_inside_dir(const char *dir);
 int dir_inside_of(const char *subdir, const char *dir);
<span
class="head">diff --git a/submodule-config.c b/submodule-config.c
index ec45ea67b9..6c18ae3764 100644
--- a/submodule-config.c
+++ b/submodule-config.c
</span><span
class="hunk">@@ -801,7 +801,7 @@ static void config_from_gitmodules(config_fn_t fn, struct repository *repo, void
</span> 		char *oidstr = NULL;
 
 		file = repo_worktree_path(repo, GITMODULES_FILE);
<span
class="del">-		if (file_exists(file)) {
</span><span
class="add">+		if (file_exists_as_file(file)) {
</span> 			config_source.file = file;
 		} else if (repo_get_oid(repo, GITMODULES_INDEX, &#38;oid) &gt;= 0 ||
 			   repo_get_oid(repo, GITMODULES_HEAD, &#38;oid) &gt;= 0) {
-- 
2.45.2-711-gd2c001ca14

</pre></div></content></entry><entry><author><name>Junio C Hamano</name><email>gitster@pobox.com</email></author><title>[PATCH 3/4] exclude: notice and report read failure of .gitignore files</title><updated>2024-06-18T23:44:53Z</updated><link
href="http://lore.kernel.org/git/20240618234436.4107855-4-gitster@pobox.com/"/><id>urn:uuid:0a4dc819-35e5-e05f-9ea7-a8d353353659</id><thr:in-reply-to
ref="urn:uuid:596449d6-b857-7afe-45de-ba361d4d1ee9"
href="http://lore.kernel.org/git/20240618234436.4107855-1-gitster@pobox.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The code that reads .gitignore files was careless in dealing in
unusual circumstances.

 - It let read errors silently ignored.

 - It tried to read &#34;.gitignore&#34; that is a directory on platforms
   that allow open(2) to open directories.

To make the latter consistent with what we do for fopen() on
directories (&#34;git grep&#34; for FREAD_READS_DIRECTORIES for details),
check if we opened a directory, silently close it and return
success.  Catch all read errors before we close and report as
needed.

Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
---
 dir.c              |  6 ++++++
 t/t0008-ignores.sh | 18 ++++++++++++++++++
 2 files <a href="http://lore.kernel.org/git/20240618234436.4107855-4-gitster@pobox.com/#related">changed</a>, 24 insertions(+)

<span
class="head">diff --git a/dir.c b/dir.c
index ec875e3878..73f89f4d8c 100644
--- a/dir.c
+++ b/dir.c
</span><span
class="hunk">@@ -1127,6 +1127,10 @@ static int add_patterns(const char *fname, const char *base, int baselen,
</span> 						       oid_stat);
 		if (r != 1)
 			return r;
<span
class="add">+	} else if (S_ISDIR(st.st_mode)) {
+		/* On FREAD_READS_DIRECTORIES platforms */
+		close(fd);
+		return 0;
</span> 	} else {
 		size = xsize_t(st.st_size);
 		if (size == 0) {
<span
class="hunk">@@ -1140,6 +1144,8 @@ static int add_patterns(const char *fname, const char *base, int baselen,
</span> 		}
 		buf = xmallocz(size);
 		if (read_in_full(fd, buf, size) != size) {
<span
class="add">+			warning_errno(_(&#34;failed while reading gitignore file &#39;%s&#39;&#34;),
+				      fname);
</span> 			free(buf);
 			close(fd);
 			return -1;
<span
class="head">diff --git a/t/t0008-ignores.sh b/t/t0008-ignores.sh
index 02a18d4fdb..c367824c66 100755
--- a/t/t0008-ignores.sh
+++ b/t/t0008-ignores.sh
</span><span
class="hunk">@@ -953,4 +953,22 @@ test_expect_success EXPENSIVE &#39;large exclude file ignored in tree&#39; &#39;
</span> 	test_cmp expect err
 &#39;
 
<span
class="add">+test_expect_success POSIXPERM &#39;unreadable exclude file reported&#39; &#39;
+	test_when_finished &#34;rm -f .gitignore&#34; &#38;&#38;
+	&gt;.gitignore &#38;&#38;
+	chmod a= .gitignore &#38;&#38;
+	# we do not care if the pattern matches
+	{ git check-ignore xyzzy 2&gt;err || :; } &#38;&#38;
+	test_grep &#34;unable to access ${SQ}\.gitignore${SQ}:&#34; err
+&#39;
+
+test_expect_success &#39;.gitignore directory ignored&#39; &#39;
+	test_when_finished &#34;rm -rf .gitignore&#34; &#38;&#38;
+	rm -f .gitignore &#38;&#38;
+	mkdir .gitignore &#38;&#38;
+	# we do not care if the pattern matches
+	{ git check-ignore xyzzy 2&gt;err || :; } &#38;&#38;
+	test_grep ! &#34;failed while reading gitignore file ${SQ}\.gitignore${SQ}:&#34; err
+&#39;
+
</span> test_done
-- 
2.45.2-711-gd2c001ca14

</pre></div></content></entry><entry><author><name>Junio C Hamano</name><email>gitster@pobox.com</email></author><title>[PATCH 2/4] attr: notice and report read failure of .gitattributes files</title><updated>2024-06-18T23:44:46Z</updated><link
href="http://lore.kernel.org/git/20240618234436.4107855-3-gitster@pobox.com/"/><id>urn:uuid:0a1febbd-ebbc-b6ab-ffa0-7f7f081a2b82</id><thr:in-reply-to
ref="urn:uuid:596449d6-b857-7afe-45de-ba361d4d1ee9"
href="http://lore.kernel.org/git/20240618234436.4107855-1-gitster@pobox.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The code that reads .gitattributes files was careless in dealing in
unusual circumstances.

 - It let read errors silently ignored.

 - It tried to read &#34;.gitattributes&#34; that is a directory on
   platforms that allowed open(2) to open directories.

To make the latter consistent with what we do for fopen() on
directories (&#34;git grep&#34; for FREAD_READS_DIRECTORIES for details),
check if we opened a directory, silently close it and return
success.  Catch all read errors before we close and report as
needed.

Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
---
 attr.c                | 10 +++++++++-
 t/t0003-attributes.sh |  9 +++++++++
 2 files <a href="http://lore.kernel.org/git/20240618234436.4107855-3-gitster@pobox.com/#related">changed</a>, 18 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/attr.c b/attr.c
index 300f994ba6..9ab9cf1551 100644
--- a/attr.c
+++ b/attr.c
</span><span
class="hunk">@@ -747,6 +747,11 @@ static struct attr_stack *read_attr_from_file(const char *path, unsigned flags)
</span> 		fclose(fp);
 		return NULL;
 	}
<span
class="add">+	if (S_ISDIR(st.st_mode)) {
+		/* On FREAD_READS_DIRECTORIES platforms */
+		fclose(fp);
+		return NULL;
+	}
</span> 	if (st.st_size &gt;= ATTR_MAX_FILE_SIZE) {
 		warning(_(&#34;ignoring overly large gitattributes file &#39;%s&#39;&#34;), path);
 		fclose(fp);
<span
class="hunk">@@ -760,7 +765,10 @@ static struct attr_stack *read_attr_from_file(const char *path, unsigned flags)
</span> 		handle_attr_line(res, buf.buf, path, ++lineno, flags);
 	}
 
<span
class="del">-	fclose(fp);
</span><span
class="add">+	if (ferror(fp))
+		warning_errno(_(&#34;failed while reading gitattributes file &#39;%s&#39;&#34;), path);
+	if (fclose(fp))
+		warning_errno(_(&#34;cannot fclose gitattributes file &#39;%s&#39;&#34;), path);
</span> 	strbuf_release(&#38;buf);
 	return res;
 }
<span
class="head">diff --git a/t/t0003-attributes.sh b/t/t0003-attributes.sh
index 66ccb5889d..783c20146d 100755
--- a/t/t0003-attributes.sh
+++ b/t/t0003-attributes.sh
</span><span
class="hunk">@@ -603,6 +603,15 @@ test_expect_success EXPENSIVE &#39;large attributes blob ignored&#39; &#39;
</span> 	test_cmp expect err
 &#39;
 
<span
class="add">+test_expect_success &#39;.gitattribute directory behaves as if it does not exist&#39; &#39;
+	test_when_finished &#34;rm -fr dir&#34; &#38;&#38;
+	mkdir -p dir/.gitattributes &#38;&#38;
+	&gt;dir/ectory &#38;&#38;
+	git -C dir check-attr --all ectory &gt;out 2&gt;err &#38;&#38;
+	test_grep ! &#34;failed while reading&#34; err &#38;&#38;
+	test_grep ! &#34;cannot fclose&#34; err
+&#39;
+
</span> test_expect_success &#39;builtin object mode attributes work (dir and regular paths)&#39; &#39;
 	&gt;normal &#38;&#38;
 	attr_check_object_mode normal 100644 &#38;&#38;
-- 
2.45.2-711-gd2c001ca14

</pre></div></content></entry><entry><author><name>Junio C Hamano</name><email>gitster@pobox.com</email></author><title>[PATCH 1/4] .gitignore: introduce GITIGNORE_FILE CPP macro</title><updated>2024-06-18T23:44:45Z</updated><link
href="http://lore.kernel.org/git/20240618234436.4107855-2-gitster@pobox.com/"/><id>urn:uuid:dc3e8c4e-1e70-6726-e3ca-9da01fa5491b</id><thr:in-reply-to
ref="urn:uuid:596449d6-b857-7afe-45de-ba361d4d1ee9"
href="http://lore.kernel.org/git/20240618234436.4107855-1-gitster@pobox.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">GITATTRIBUTES_FILE and GITMODULES_FILE have their own CPP macros
that resolve to their string literals to help compilers catch typos.
Add one for &#34;.gitignore&#34; as well.

Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
---
 builtin/read-tree.c | 3 ++-
 dir.c               | 4 ++--
 environment.h       | 1 +
 3 files <a href="http://lore.kernel.org/git/20240618234436.4107855-2-gitster@pobox.com/#related">changed</a>, 5 insertions(+), 3 deletions(-)

<span
class="head">diff --git a/builtin/read-tree.c b/builtin/read-tree.c
index a8cf8504b8..bc12f5bd16 100644
--- a/builtin/read-tree.c
+++ b/builtin/read-tree.c
</span><span
class="hunk">@@ -6,6 +6,7 @@
</span> 
 #include &#34;builtin.h&#34;
 #include &#34;config.h&#34;
<span
class="add">+#include &#34;environment.h&#34;
</span> #include &#34;gettext.h&#34;
 #include &#34;hex.h&#34;
 #include &#34;lockfile.h&#34;
<span
class="hunk">@@ -65,7 +66,7 @@ static int exclude_per_directory_cb(const struct option *opt, const char *arg,
</span> 
 	if (!opts-&gt;update)
 		die(&#34;--exclude-per-directory is meaningless unless -u&#34;);
<span
class="del">-	if (strcmp(arg, &#34;.gitignore&#34;))
</span><span
class="add">+	if (strcmp(arg, GITIGNORE_FILE))
</span> 		die(&#34;--exclude-per-directory argument must be .gitignore&#34;);
 	return 0;
 }
<span
class="head">diff --git a/dir.c b/dir.c
index 45be4ad261..ec875e3878 100644
--- a/dir.c
+++ b/dir.c
</span><span
class="hunk">@@ -2888,7 +2888,7 @@ static void new_untracked_cache(struct index_state *istate, int flags)
</span> {
 	struct untracked_cache *uc = xcalloc(1, sizeof(*uc));
 	strbuf_init(&#38;uc-&gt;ident, 100);
<span
class="del">-	uc-&gt;exclude_per_dir = &#34;.gitignore&#34;;
</span><span
class="add">+	uc-&gt;exclude_per_dir = GITIGNORE_FILE;
</span> 	uc-&gt;dir_flags = flags &gt;= 0 ? flags : new_untracked_cache_flags(istate);
 	set_untracked_ident(uc);
 	istate-&gt;untracked = uc;
<span
class="hunk">@@ -3428,7 +3428,7 @@ static GIT_PATH_FUNC(git_path_info_exclude, &#34;info/exclude&#34;)
</span> 
 void setup_standard_excludes(struct dir_struct *dir)
 {
<span
class="del">-	dir-&gt;exclude_per_dir = &#34;.gitignore&#34;;
</span><span
class="add">+	dir-&gt;exclude_per_dir = GITIGNORE_FILE;
</span> 
 	/* core.excludesfile defaulting to $XDG_CONFIG_HOME/git/ignore */
 	if (!excludes_file)
<span
class="head">diff --git a/environment.h b/environment.h
index e9f01d4d11..39c3c24a3f 100644
--- a/environment.h
+++ b/environment.h
</span><span
class="hunk">@@ -43,6 +43,7 @@ const char *getenv_safe(struct strvec *argv, const char *name);
</span> #define GITMODULES_FILE &#34;.gitmodules&#34;
 #define GITMODULES_INDEX &#34;:.gitmodules&#34;
 #define GITMODULES_HEAD &#34;HEAD:.gitmodules&#34;
<span
class="add">+#define GITIGNORE_FILE &#34;.gitignore&#34;
</span> #define GIT_NOTES_REF_ENVIRONMENT &#34;GIT_NOTES_REF&#34;
 #define GIT_NOTES_DEFAULT_REF &#34;refs/notes/commits&#34;
 #define GIT_NOTES_DISPLAY_REF_ENVIRONMENT &#34;GIT_NOTES_DISPLAY_REF&#34;
-- 
2.45.2-711-gd2c001ca14

</pre></div></content></entry><entry><author><name>Junio C Hamano</name><email>gitster@pobox.com</email></author><title>[PATCH 0/4] .git{ignore,attributes} directories?</title><updated>2024-06-18T23:44:41Z</updated><link
href="http://lore.kernel.org/git/20240618234436.4107855-1-gitster@pobox.com/"/><id>urn:uuid:596449d6-b857-7afe-45de-ba361d4d1ee9</id><thr:in-reply-to
ref="urn:uuid:197df40f-b0a4-913d-563c-82e4f7e5b0ce"
href="http://lore.kernel.org/git/20240618233303.GA188880@coredump.intra.peff.net/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">We seem to blindly open .gitignore that is a directory and rely on
subsequent read() to be more-or-less silent to implement a &#34;non-file
.gitignore is silently ignored&#34; behaviour.

Let&#39;s be a bit more strict in detecting and reporting I/O errors,
and also stop reading from directories.

I think the first three are reasonable changes, but the last one is
of dubious value.

Junio C Hamano (4):
  .gitignore: introduce GITIGNORE_FILE CPP macro
  attr: notice and report read failure
  exclude: notice and report read failure of .gitignore files
  submodule: ignore .gitmodules that is not a regular file

 attr.c                | 10 +++++++++-
 builtin/read-tree.c   |  3 ++-
 dir.c                 | 16 ++++++++++++++--
 dir.h                 |  1 +
 environment.h         |  1 +
 submodule-config.c    |  2 +-
 t/t0003-attributes.sh |  9 +++++++++
 t/t0008-ignores.sh    | 18 ++++++++++++++++++
 8 files changed, 55 insertions(+), 5 deletions(-)

-- 
2.45.2-711-gd2c001ca14

</pre></div></content></entry><entry><author><name>Eric Wong</name><email>e@80x24.org</email></author><title
type="html">[PATCH v2 2/2] t1006: ensure cat-file info isn&#39;t buffered by default</title><updated>2024-06-18T21:30:47Z</updated><link
href="http://lore.kernel.org/git/20240618213041.M462972@dcvr/"/><id>urn:uuid:66317f55-758c-5935-2bc7-7130d536a680</id><thr:in-reply-to
ref="urn:uuid:05c9cc4f-02f3-496e-c622-889f6f7ab29c"
href="http://lore.kernel.org/git/xmqq1q4v5m5a.fsf@gitster.g/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Junio C Hamano &lt;gitster@pobox.com&gt; wrote:
<span
class="q">&gt; Eric Wong &lt;e@80x24.org&gt; writes:
&gt; 
&gt; &gt; Buffering by default breaks some 3rd-party Perl scripts using
&gt; &gt; cat-file, but this breakage was not detected anywhere in our
&gt; &gt; test suite.  The easiest place to test this behavior is with
&gt; &gt; Git.pm, since (AFAIK) other equivalent way to test this behavior
&gt; &gt; from Bourne shell and/or awk would require racy sleeps,
&gt; &gt; non-portable FIFOs or tedious C code.
&gt; 
&gt; Yes, using Perl is a good substitute for writing it in C in this
&gt; case.  I however question the choice to use t9700/test.pl here,
&gt; which is clearly stated that its purpose is to &#34;test perl interface
&gt; which is Git.pm&#34;, and added tests are not testing anything in Git.pm
&gt; at all.
&gt; 
&gt; Using t9700/test.pl only because it happens to use &#34;perl -MTest::More&#34;
&gt; sounds a bit eh, suboptimal.
</span>
*shrug*  I figure Test::More is common enough since it&#39;s part of
the Perl standard library; but I consider Perl a better scripting
language than sh by far and wish our whole test suite were Perl :&gt;

<span
class="q">&gt; It seems that there are Perl snippets in other tests (including
&gt; t1006 that is specifically about cat-file).  How involved would it
&gt; be to implement these new tests without modifying unrelated test
&gt; scripts?
</span>
<span
class="q">&gt; &gt;  t/t9700/test.pl | 14 ++++++++++++++
&gt; &gt;  1 file changed, 14 insertions(+)
</span>
More code than that.  At least IPC::Open2 takes care of the nasty
portability bits, but getting the Perl quoting nested properly
inside sh was confusing :x

v2: moved test to t1006 to avoid Test::More,
    add select timeout in case a buffering bug does get introduced,
    updated commit message and clarified the bug it&#39;s supposed
    to guard against
    (I initially tried stdio buffering, but moved away from it for the
    patch I&#39;m testing...)

----8&lt;----
Subject: [PATCH] t1006: ensure cat-file info isn&#39;t buffered by default

While working on buffering changes to `git cat-file&#39; in a
separate patch, I inadvertently made the output of --batch-check
and the `info&#39; command of --batch-command buffered as if
opt-&gt;buffer_output is turned on by default.

Buffering by default breaks some 3rd-party Perl scripts using
cat-file, but this breakage was not detected anywhere in our
test suite.  Add a small Perl snippet to test this problem since
(AFAIK) other equivalent ways to test this behavior from Bourne
shell and/or awk would require racy sleeps, non-portable FIFOs
or tedious C code.

Signed-off-by: Eric Wong &lt;e@80x24.org&gt;
---
 t/t1006-cat-file.sh | 30 ++++++++++++++++++++++++++++++
 1 file <a href="http://lore.kernel.org/git/20240618213041.M462972@dcvr/#related">changed</a>, 30 insertions(+)

<span
class="head">diff --git a/t/t1006-cat-file.sh b/t/t1006-cat-file.sh
index e12b221972..ff9bf213aa 100755
--- a/t/t1006-cat-file.sh
+++ b/t/t1006-cat-file.sh
</span><span
class="hunk">@@ -1294,4 +1294,34 @@ test_expect_success &#39;batch-command flush without --buffer&#39; &#39;
</span> 	grep &#34;^fatal:.*flush is only for --buffer mode.*&#34; err
 &#39;
 
<span
class="add">+script=&#39;
+use warnings;
+use strict;
+use IPC::Open2;
+my ($opt, $oid, $expect, @pfx) = @ARGV;
+my @cmd = (qw(git cat-file), $opt);
+my $pid = open2(my $out, my $in, @cmd) or die &#34;open2: @cmd&#34;;
+print $in @pfx, $oid, &#34;\n&#34; or die &#34;print $!&#34;;
+my $rvec = &#34;&#34;;
+vec($rvec, fileno($out), 1) = 1;
+select($rvec, undef, undef, 30) or die &#34;no response to `@pfx $oid` from @cmd&#34;;
+my $info = &lt;$out&gt;;
+chop($info) eq &#34;\n&#34; or die &#34;no LF&#34;;
+$info eq $expect or die &#34;`$info` != `$expect`&#34;;
+close $in or die &#34;close in $!&#34;;
+close $out or die &#34;close out $!&#34;;
+waitpid $pid, 0;
+$? == 0 or die &#34;\$?=$?&#34;;
+&#39;
+
+expect=&#34;$hello_oid blob $hello_size&#34;
+
+test_expect_success PERL &#39;--batch-check is unbuffered by default&#39; &#39;
+	perl -e &#34;$script&#34; -- --batch-check $hello_oid &#34;$expect&#34;
+&#39;
+
+test_expect_success PERL &#39;--batch-command info is unbuffered by default&#39; &#39;
+	perl -e &#34;$script&#34; -- --batch-command $hello_oid &#34;$expect&#34; &#34;info &#34;
+&#39;
+
</span> test_done
</pre></div></content></entry><entry><author><name>shejialuo</name><email>shejialuo@gmail.com</email></author><title>[PATCH v3 7/7] fsck: add ref content check for files backend</title><updated>2024-06-18T08:20:30Z</updated><link
href="http://lore.kernel.org/git/ZnFDSohT0_374NGS@ArchLinux/"/><id>urn:uuid:d3a1c924-d490-438a-3c43-bb6acd8f46d3</id><thr:in-reply-to
ref="urn:uuid:296e3964-9ee9-6b3a-4238-4b7fabb59c77"
href="http://lore.kernel.org/git/20240612085349.710785-1-shejialuo@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Enhance the git-fsck(1) command by adding a check for reference content
in the files backend. The new functionality ensures that symrefs, real
symbolic link and regular refs are validated correctly.

In order to check the trailing content of the regular refs, add a new
parameter `trailing` to `parse_loose_ref_contents`.

For symrefs, `parse_loose_ref_contents` will set the &#34;referent&#34;.
However, symbolic link could be either absolute or relative. Use
&#34;strbuf_add_real_path&#34; to read the symbolic link and convert the
relative path to absolute path. Then use &#34;skip_prefix&#34; to make it align
with symref &#34;referent&#34;.

Thus, the symrefs and symbolic links could share the same interface. Add
a new function &#34;files_fsck_symref_target&#34; which aims at checking the
following things:

1. whether the pointee is under the `refs/` directory.
2. whether the pointee name is correct.
3. whether the pointee path is a wrong type in filesystem.

Last, add the following FSCK MESSAGEs:

1. &#34;badRefContent(ERROR)&#34;: A ref has a bad content
2. &#34;badSymrefPointee(ERROR)&#34;: The pointee of a symref is bad.
3. &#34;trailingRefContent(WARN)&#34;: A ref content has trailing contents.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Karthik Nayak &lt;karthik.188@gmail.com&gt;
Signed-off-by: shejialuo &lt;shejialuo@gmail.com&gt;
---
 Documentation/fsck-msgids.txt |   9 +++
 fsck.h                        |   3 +
 refs.c                        |   2 +-
 refs/files-backend.c          | 145 +++++++++++++++++++++++++++++++++-
 refs/refs-internal.h          |   5 +-
 t/t0602-reffiles-fsck.sh      | 110 ++++++++++++++++++++++++++
 6 files <a href="http://lore.kernel.org/git/ZnFDSohT0_374NGS@ArchLinux/#related">changed</a>, 269 insertions(+), 5 deletions(-)

<span
class="head">diff --git a/Documentation/fsck-msgids.txt b/Documentation/fsck-msgids.txt
index cc85c897cc..ebe2de2bdc 100644
--- a/Documentation/fsck-msgids.txt
+++ b/Documentation/fsck-msgids.txt
</span><span
class="hunk">@@ -19,9 +19,15 @@
</span> `badParentSha1`::
 	(ERROR) A commit object has a bad parent sha1.
 
<span
class="add">+`badRefContent`::
+	(ERROR) A ref has a bad content.
+
</span> `badRefName`::
 	(ERROR) A ref has a bad name.
 
<span
class="add">+`badSymrefPointee`::
+	(ERROR) The pointee of a symref is bad.
+
</span> `badTagName`::
 	(INFO) A tag has an invalid format.
 
<span
class="hunk">@@ -179,6 +185,9 @@
</span> `symlinkTargetMissing`::
 	(ERROR) Unable to read symbolic link target&#39;s blob.
 
<span
class="add">+`trailingRefContent`::
+	(WARN) A ref content has trailing contents.
+
</span> `treeNotSorted`::
 	(ERROR) A tree is not properly sorted.
 
<span
class="head">diff --git a/fsck.h b/fsck.h
index 6b3e68b873..215b1466d2 100644
--- a/fsck.h
+++ b/fsck.h
</span><span
class="hunk">@@ -32,6 +32,8 @@ enum fsck_msg_type {
</span> 	FUNC(BAD_OBJECT_SHA1, ERROR) \
 	FUNC(BAD_PARENT_SHA1, ERROR) \
 	FUNC(BAD_REF_NAME, ERROR) \
<span
class="add">+	FUNC(BAD_REF_CONTENT, ERROR) \
+	FUNC(BAD_SYMREF_POINTEE, ERROR) \
</span> 	FUNC(BAD_TIMEZONE, ERROR) \
 	FUNC(BAD_TREE, ERROR) \
 	FUNC(BAD_TREE_SHA1, ERROR) \
<span
class="hunk">@@ -74,6 +76,7 @@ enum fsck_msg_type {
</span> 	FUNC(HAS_DOTDOT, WARN) \
 	FUNC(HAS_DOTGIT, WARN) \
 	FUNC(NULL_SHA1, WARN) \
<span
class="add">+	FUNC(TRAILING_REF_CONTENT, WARN) \
</span> 	FUNC(ZERO_PADDED_FILEMODE, WARN) \
 	FUNC(NUL_IN_COMMIT, WARN) \
 	FUNC(LARGE_PATHNAME, WARN) \
<span
class="head">diff --git a/refs.c b/refs.c
index 0922439275..1325f83269 100644
--- a/refs.c
+++ b/refs.c
</span><span
class="hunk">@@ -1744,7 +1744,7 @@ static int refs_read_special_head(struct ref_store *ref_store,
</span> 	}
 
 	result = parse_loose_ref_contents(content.buf, oid, referent, type,
<span
class="del">-					  failure_errno);
</span><span
class="add">+					  failure_errno, NULL);
</span> 
 done:
 	strbuf_release(&#38;full_path);
<span
class="head">diff --git a/refs/files-backend.c b/refs/files-backend.c
index 3f0b565a13..56a64cb97c 100644
--- a/refs/files-backend.c
+++ b/refs/files-backend.c
</span><span
class="hunk">@@ -1,4 +1,5 @@
</span> #include &#34;../git-compat-util.h&#34;
<span
class="add">+#include &#34;../abspath.h&#34;
</span> #include &#34;../copy.h&#34;
 #include &#34;../environment.h&#34;
 #include &#34;../gettext.h&#34;
<span
class="hunk">@@ -549,7 +550,7 @@ static int read_ref_internal(struct ref_store *ref_store, const char *refname,
</span> 	strbuf_rtrim(&#38;sb_contents);
 	buf = sb_contents.buf;
 
<span
class="del">-	ret = parse_loose_ref_contents(buf, oid, referent, type, &#38;myerr);
</span><span
class="add">+	ret = parse_loose_ref_contents(buf, oid, referent, type, &#38;myerr, NULL);
</span> 
 out:
 	if (ret &#38;&#38; !myerr)
<span
class="hunk">@@ -585,7 +586,7 @@ static int files_read_symbolic_ref(struct ref_store *ref_store, const char *refn
</span> 
 int parse_loose_ref_contents(const char *buf, struct object_id *oid,
 			     struct strbuf *referent, unsigned int *type,
<span
class="del">-			     int *failure_errno)
</span><span
class="add">+			     int *failure_errno, const char **trailing)
</span> {
 	const char *p;
 	if (skip_prefix(buf, &#34;ref:&#34;, &#38;buf)) {
<span
class="hunk">@@ -607,6 +608,10 @@ int parse_loose_ref_contents(const char *buf, struct object_id *oid,
</span> 		*failure_errno = EINVAL;
 		return -1;
 	}
<span
class="add">+
+	if (trailing)
+		*trailing = p;
+
</span> 	return 0;
 }
 
<span
class="hunk">@@ -3432,6 +3437,141 @@ static int files_fsck_refs_name(struct fsck_refs_options *o,
</span> 	return ret;
 }
 
<span
class="add">+/*
+ * Check the symref &#34;pointee_name&#34; and &#34;pointee_path&#34;. The caller should
+ * make sure that &#34;pointee_path&#34; is absolute. For symbolic ref, &#34;pointee_name&#34;
+ * would be the content after &#34;refs:&#34;. For symblic link, &#34;pointee_name&#34; would
+ * be the relative path agaignst &#34;gitdir&#34;.
+ */
+static int files_fsck_symref_target(struct fsck_refs_options *o,
+				    const char *refname,
+				    const char *pointee_name,
+				    const char *pointee_path)
+{
+	const char *p = NULL;
+	struct stat st;
+	int ret = 0;
+
+	if (!skip_prefix(pointee_name, &#34;refs/&#34;, &#38;p)) {
+
+		ret = fsck_refs_report(o, refname,
+				       FSCK_MSG_BAD_SYMREF_POINTEE,
+				       &#34;point to target out of refs hierarchy&#34;);
+		goto out;
+	}
+
+	if (check_refname_format(pointee_name, 0)) {
+		ret = fsck_refs_report(o, refname,
+				       FSCK_MSG_BAD_SYMREF_POINTEE,
+				       &#34;point to invalid refname&#34;);
+	}
+
+	if (lstat(pointee_path, &#38;st) &lt; 0)
+		goto out;
+
+	if (!S_ISREG(st.st_mode) &#38;&#38; !S_ISLNK(st.st_mode)) {
+		ret = fsck_refs_report(o, refname,
+				       FSCK_MSG_BAD_SYMREF_POINTEE,
+				       &#34;point to invalid target&#34;);
+		goto out;
+	}
+out:
+	return ret;
+}
+
+static int files_fsck_refs_content(struct fsck_refs_options *o,
+				   const char *gitdir,
+				   const char *refs_check_dir,
+				   struct dir_iterator *iter)
+{
+	struct strbuf pointee_path = STRBUF_INIT,
+		      ref_content = STRBUF_INIT,
+		      abs_gitdir = STRBUF_INIT,
+		      referent = STRBUF_INIT,
+		      refname = STRBUF_INIT;
+	const char *trailing = NULL;
+	int failure_errno = 0;
+	unsigned int type = 0;
+	struct object_id oid;
+	int ret = 0;
+
+	strbuf_addf(&#38;refname, &#34;%s/%s&#34;, refs_check_dir, iter-&gt;relative_path);
+
+	/*
+	 * If the file is a symlink, we need to only check the connectivity
+	 * of the destination object.
+	 */
+	if (S_ISLNK(iter-&gt;st.st_mode)) {
+		const char *pointee_name = NULL;
+
+		strbuf_add_real_path(&#38;pointee_path, iter-&gt;path.buf);
+
+		strbuf_add_absolute_path(&#38;abs_gitdir, gitdir);
+		strbuf_normalize_path(&#38;abs_gitdir);
+		if (!is_dir_sep(abs_gitdir.buf[abs_gitdir.len - 1]))
+			strbuf_addch(&#38;abs_gitdir, &#39;/&#39;);
+
+		if (!skip_prefix(pointee_path.buf,
+				 abs_gitdir.buf, &#38;pointee_name)) {
+			ret = fsck_refs_report(o, refname.buf,
+					       FSCK_MSG_BAD_SYMREF_POINTEE,
+					       &#34;point to target outside gitdir&#34;);
+			goto clean;
+		}
+
+		ret = files_fsck_symref_target(o, refname.buf, pointee_name,
+					       pointee_path.buf);
+		goto clean;
+	}
+
+	if (strbuf_read_file(&#38;ref_content, iter-&gt;path.buf, 0) &lt; 0) {
+		ret = error_errno(_(&#34;%s/%s: unable to read the ref&#34;),
+				  refs_check_dir, iter-&gt;relative_path);
+		goto clean;
+	}
+
+	if (parse_loose_ref_contents(ref_content.buf, &#38;oid,
+				     &#38;referent, &#38;type,
+				     &#38;failure_errno, &#38;trailing)) {
+		ret = fsck_refs_report(o, refname.buf,
+				       FSCK_MSG_BAD_REF_CONTENT,
+				       &#34;invalid ref content&#34;);
+		goto clean;
+	}
+
+	/*
+	 * If the ref is a symref, we need to check the destination name and
+	 * connectivity.
+	 */
+	if (referent.len &#38;&#38; (type &#38; REF_ISSYMREF)) {
+		strbuf_addf(&#38;pointee_path, &#34;%s/%s&#34;, gitdir, referent.buf);
+		strbuf_rtrim(&#38;referent);
+
+		ret = files_fsck_symref_target(o, refname.buf, referent.buf,
+					       pointee_path.buf);
+		goto clean;
+	} else {
+		/*
+		 * Only regular refs could have a trailing garbage. Should
+		 * be reported as a warning.
+		 */
+		if (trailing &#38;&#38; (*trailing != &#39;\0&#39; &#38;&#38; *trailing != &#39;\n&#39;)) {
+			ret = fsck_refs_report(o, refname.buf,
+					       FSCK_MSG_TRAILING_REF_CONTENT,
+					       &#34;trailing garbage in ref&#34;);
+			goto clean;
+		}
+	}
+
+clean:
+	strbuf_release(&#38;abs_gitdir);
+	strbuf_release(&#38;pointee_path);
+	strbuf_release(&#38;refname);
+	strbuf_release(&#38;ref_content);
+	strbuf_release(&#38;referent);
+	return ret;
+}
+
</span> static int files_fsck_refs_dir(struct ref_store *ref_store,
 			       struct fsck_refs_options *o,
 			       const char *refs_check_dir,
<span
class="hunk">@@ -3484,6 +3624,7 @@ static int files_fsck_refs(struct ref_store *ref_store,
</span> 	int ret;
 	files_fsck_refs_fn fsck_refs_fns[]= {
 		files_fsck_refs_name,
<span
class="add">+		files_fsck_refs_content,
</span> 		NULL
 	};
 
<span
class="head">diff --git a/refs/refs-internal.h b/refs/refs-internal.h
index 8f42f21e77..72f0945ada 100644
--- a/refs/refs-internal.h
+++ b/refs/refs-internal.h
</span><span
class="hunk">@@ -709,11 +709,12 @@ struct ref_store {
</span> 
 /*
  * Parse contents of a loose ref file. *failure_errno maybe be set to EINVAL for
<span
class="del">- * invalid contents.
</span><span
class="add">+ * invalid contents. Also *trailing is set to the first character after the
+ * refname or NULL if the referent is not empty.
</span>  */
 int parse_loose_ref_contents(const char *buf, struct object_id *oid,
 			     struct strbuf *referent, unsigned int *type,
<span
class="del">-			     int *failure_errno);
</span><span
class="add">+			     int *failure_errno, const char **trailing);
</span> 
 /*
  * Fill in the generic part of refs and add it to our collection of
<span
class="head">diff --git a/t/t0602-reffiles-fsck.sh b/t/t0602-reffiles-fsck.sh
index b2db58d2c6..35bf40ee64 100755
--- a/t/t0602-reffiles-fsck.sh
+++ b/t/t0602-reffiles-fsck.sh
</span><span
class="hunk">@@ -98,4 +98,114 @@ test_expect_success &#39;ref name check should be adapted into fsck messages&#39; &#39;
</span> 	)
 &#39;
 
<span
class="add">+test_expect_success &#39;regular ref content should be checked&#39; &#39;
+	test_when_finished &#34;rm -rf repo&#34; &#38;&#38;
+	git init repo &#38;&#38;
+	branch_dir_prefix=.git/refs/heads &#38;&#38;
+	tag_dir_prefix=.git/refs/tags &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		git commit --allow-empty -m initial &#38;&#38;
+		git checkout -b branch-1 &#38;&#38;
+		git tag tag-1 &#38;&#38;
+		git commit --allow-empty -m second &#38;&#38;
+		git checkout -b branch-2 &#38;&#38;
+		git tag tag-2 &#38;&#38;
+		git checkout -b a/b/tag-2
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		printf &#34;%s garbage&#34; &#34;$(git rev-parse branch-1)&#34; &gt; $branch_dir_prefix/branch-1-garbage &#38;&#38;
+		git fsck 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		warning: refs/heads/branch-1-garbage: trailingRefContent: trailing garbage in ref
+		EOF
+		rm $branch_dir_prefix/branch-1-garbage &#38;&#38;
+		test_cmp expect err
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		printf &#34;%s garbage&#34; &#34;$(git rev-parse tag-1)&#34; &gt; $tag_dir_prefix/tag-1-garbage &#38;&#38;
+		test_must_fail git -c fsck.trailingRefContent=error fsck 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		error: refs/tags/tag-1-garbage: trailingRefContent: trailing garbage in ref
+		EOF
+		rm $tag_dir_prefix/tag-1-garbage &#38;&#38;
+		test_cmp expect err
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		printf &#34;%s    &#34; &#34;$(git rev-parse tag-2)&#34; &gt; $tag_dir_prefix/tag-2-garbage &#38;&#38;
+		git fsck 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		warning: refs/tags/tag-2-garbage: trailingRefContent: trailing garbage in ref
+		EOF
+		rm $tag_dir_prefix/tag-2-garbage &#38;&#38;
+		test_cmp expect err
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		printf &#34;xfsazqfxcadas&#34; &gt; $tag_dir_prefix/tag-2-bad &#38;&#38;
+		test_must_fail git refs verify 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		error: refs/tags/tag-2-bad: badRefContent: invalid ref content
+		EOF
+		rm $tag_dir_prefix/tag-2-bad &#38;&#38;
+		test_cmp expect err
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		printf &#34;xfsazqfxcadas&#34; &gt; $branch_dir_prefix/a/b/branch-2-bad &#38;&#38;
+		test_must_fail git refs verify 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		error: refs/heads/a/b/branch-2-bad: badRefContent: invalid ref content
+		EOF
+		rm $branch_dir_prefix/a/b/branch-2-bad &#38;&#38;
+		test_cmp expect err
+	)
+&#39;
+
+test_expect_success &#39;symbolic ref content should be checked&#39; &#39;
+	test_when_finished &#34;rm -rf repo&#34; &#38;&#38;
+	git init repo &#38;&#38;
+	branch_dir_prefix=.git/refs/heads &#38;&#38;
+	tag_dir_prefix=.git/refs/tags &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		git commit --allow-empty -m initial &#38;&#38;
+		git checkout -b branch-1 &#38;&#38;
+		git tag tag-1
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		printf &#34;ref: refs/heads/.branch&#34; &gt; $branch_dir_prefix/branch-2-bad &#38;&#38;
+		test_must_fail git refs verify 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		error: refs/heads/branch-2-bad: badSymrefPointee: point to invalid refname
+		EOF
+		rm $branch_dir_prefix/branch-2-bad &#38;&#38;
+		test_cmp expect err
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		printf &#34;ref: refs/heads&#34; &gt; $branch_dir_prefix/branch-2-bad &#38;&#38;
+		test_must_fail git refs verify 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		error: refs/heads/branch-2-bad: badSymrefPointee: point to invalid target
+		EOF
+		rm $branch_dir_prefix/branch-2-bad &#38;&#38;
+		test_cmp expect err
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		printf &#34;ref: logs/maint-v2.45&#34; &gt; $branch_dir_prefix/branch-2-bad &#38;&#38;
+		test_must_fail git refs verify 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		error: refs/heads/branch-2-bad: badSymrefPointee: point to target out of refs hierarchy
+		EOF
+		rm $branch_dir_prefix/branch-2-bad &#38;&#38;
+		test_cmp expect err
+	)
+&#39;
+
</span> test_done
-- 
2.45.2

</pre></div></content></entry><entry><author><name>shejialuo</name><email>shejialuo@gmail.com</email></author><title>[PATCH v3 6/7] fsck: add ref name check for files backend</title><updated>2024-06-18T08:19:26Z</updated><link
href="http://lore.kernel.org/git/ZnFDCjgywD_Oatmz@ArchLinux/"/><id>urn:uuid:c1b6b0c1-4e4a-eb88-8732-ce29cf4b9b7c</id><thr:in-reply-to
ref="urn:uuid:296e3964-9ee9-6b3a-4238-4b7fabb59c77"
href="http://lore.kernel.org/git/20240612085349.710785-1-shejialuo@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The git-fsck(1) only implicitly checks the reference, it does not fully
check refs with bad format name such as standalone &#34;@&#34; and name ending
with &#34;.lock&#34;.

In order to provide such checks, add a new fsck message id &#34;badRefName&#34;
with default ERROR type. Use existing &#34;check_refname_format&#34; to explicit
check the ref name. And add a new unit test to verify the functionality.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Karthik Nayak &lt;karthik.188@gmail.com&gt;
Signed-off-by: shejialuo &lt;shejialuo@gmail.com&gt;
---
 Documentation/fsck-msgids.txt |   3 +
 fsck.h                        |   1 +
 refs/files-backend.c          |  20 +++++++
 t/t0602-reffiles-fsck.sh      | 101 ++++++++++++++++++++++++++++++++++
 4 files <a href="http://lore.kernel.org/git/ZnFDCjgywD_Oatmz@ArchLinux/#related">changed</a>, 125 insertions(+)
 create mode 100755 t/t0602-reffiles-fsck.sh

<span
class="head">diff --git a/Documentation/fsck-msgids.txt b/Documentation/fsck-msgids.txt
index 5edc06c658..cc85c897cc 100644
--- a/Documentation/fsck-msgids.txt
+++ b/Documentation/fsck-msgids.txt
</span><span
class="hunk">@@ -19,6 +19,9 @@
</span> `badParentSha1`::
 	(ERROR) A commit object has a bad parent sha1.
 
<span
class="add">+`badRefName`::
+	(ERROR) A ref has a bad name.
+
</span> `badTagName`::
 	(INFO) A tag has an invalid format.
 
<span
class="head">diff --git a/fsck.h b/fsck.h
index 6a38ac4a16..6b3e68b873 100644
--- a/fsck.h
+++ b/fsck.h
</span><span
class="hunk">@@ -31,6 +31,7 @@ enum fsck_msg_type {
</span> 	FUNC(BAD_NAME, ERROR) \
 	FUNC(BAD_OBJECT_SHA1, ERROR) \
 	FUNC(BAD_PARENT_SHA1, ERROR) \
<span
class="add">+	FUNC(BAD_REF_NAME, ERROR) \
</span> 	FUNC(BAD_TIMEZONE, ERROR) \
 	FUNC(BAD_TREE, ERROR) \
 	FUNC(BAD_TREE_SHA1, ERROR) \
<span
class="head">diff --git a/refs/files-backend.c b/refs/files-backend.c
index 74242dbba4..3f0b565a13 100644
--- a/refs/files-backend.c
+++ b/refs/files-backend.c
</span><span
class="hunk">@@ -3413,6 +3413,25 @@ typedef int (*files_fsck_refs_fn)(struct fsck_refs_options *o,
</span> 				  const char *refs_check_dir,
 				  struct dir_iterator *iter);
 
<span
class="add">+static int files_fsck_refs_name(struct fsck_refs_options *o,
+				const char *gitdir UNUSED,
+				const char *refs_check_dir,
+				struct dir_iterator *iter)
+{
+	struct strbuf sb = STRBUF_INIT;
+	int ret = 0;
+
+	if (check_refname_format(iter-&gt;basename, REFNAME_ALLOW_ONELEVEL)) {
+		strbuf_addf(&#38;sb, &#34;%s/%s&#34;, refs_check_dir, iter-&gt;relative_path);
+		ret = fsck_refs_report(o, sb.buf,
+				       FSCK_MSG_BAD_REF_NAME,
+				       &#34;invalid refname format&#34;);
+	}
+
+	strbuf_release(&#38;sb);
+	return ret;
+}
+
</span> static int files_fsck_refs_dir(struct ref_store *ref_store,
 			       struct fsck_refs_options *o,
 			       const char *refs_check_dir,
<span
class="hunk">@@ -3464,6 +3483,7 @@ static int files_fsck_refs(struct ref_store *ref_store,
</span> {
 	int ret;
 	files_fsck_refs_fn fsck_refs_fns[]= {
<span
class="add">+		files_fsck_refs_name,
</span> 		NULL
 	};
 
<span
class="head">diff --git a/t/t0602-reffiles-fsck.sh b/t/t0602-reffiles-fsck.sh
new file mode 100755
index 0000000000..b2db58d2c6
--- /dev/null
+++ b/t/t0602-reffiles-fsck.sh
</span><span
class="hunk">@@ -0,0 +1,101 @@
</span><span
class="add">+#!/bin/sh
+
+test_description=&#39;Test reffiles backend consistency check&#39;
+
+GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME=main
+export GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME
+GIT_TEST_DEFAULT_REF_FORMAT=files
+export GIT_TEST_DEFAULT_REF_FORMAT
+
+. ./test-lib.sh
+
+test_expect_success &#39;ref name should be checked&#39; &#39;
+	test_when_finished &#34;rm -rf repo&#34; &#38;&#38;
+	git init repo &#38;&#38;
+	branch_dir_prefix=.git/refs/heads &#38;&#38;
+	tag_dir_prefix=.git/refs/tags &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		git commit --allow-empty -m initial &#38;&#38;
+		git checkout -b branch-1 &#38;&#38;
+		git tag tag-1 &#38;&#38;
+		git commit --allow-empty -m second &#38;&#38;
+		git checkout -b branch-2 &#38;&#38;
+		git tag tag-2 &#38;&#38;
+		git tag multi_hierarchy/tag-2
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		cp $branch_dir_prefix/branch-1 $branch_dir_prefix/.branch-1 &#38;&#38;
+		test_must_fail git fsck 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		error: refs/heads/.branch-1: badRefName: invalid refname format
+		EOF
+		rm $branch_dir_prefix/.branch-1 &#38;&#38;
+		test_cmp expect err
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		cp $tag_dir_prefix/tag-1 $tag_dir_prefix/tag-1.lock &#38;&#38;
+		test_must_fail git fsck 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		error: refs/tags/tag-1.lock: badRefName: invalid refname format
+		EOF
+		rm $tag_dir_prefix/tag-1.lock &#38;&#38;
+		test_cmp expect err
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		cp $branch_dir_prefix/branch-1 $branch_dir_prefix/@ &#38;&#38;
+		test_must_fail git fsck 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		error: refs/heads/@: badRefName: invalid refname format
+		EOF
+		rm $branch_dir_prefix/@ &#38;&#38;
+		test_cmp expect err
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		cp $tag_dir_prefix/multi_hierarchy/tag-2 $tag_dir_prefix/multi_hierarchy/@ &#38;&#38;
+		test_must_fail git fsck 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		error: refs/tags/multi_hierarchy/@: badRefName: invalid refname format
+		EOF
+		rm $tag_dir_prefix/multi_hierarchy/@ &#38;&#38;
+		test_cmp expect err
+	)
+&#39;
+
+test_expect_success &#39;ref name check should be adapted into fsck messages&#39; &#39;
+	test_when_finished &#34;rm -rf repo&#34; &#38;&#38;
+	git init repo &#38;&#38;
+	branch_dir_prefix=.git/refs/heads &#38;&#38;
+	tag_dir_prefix=.git/refs/tags &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		git commit --allow-empty -m initial &#38;&#38;
+		git checkout -b branch-1 &#38;&#38;
+		git tag tag-1 &#38;&#38;
+		git commit --allow-empty -m second &#38;&#38;
+		git checkout -b branch-2 &#38;&#38;
+		git tag tag-2
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		cp $branch_dir_prefix/branch-1 $branch_dir_prefix/.branch-1 &#38;&#38;
+		git -c fsck.badRefName=warn fsck 2&gt;err &#38;&#38;
+		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
+		warning: refs/heads/.branch-1: badRefName: invalid refname format
+		EOF
+		rm $branch_dir_prefix/.branch-1 &#38;&#38;
+		test_cmp expect err
+	) &#38;&#38;
+	(
+		cd repo &#38;&#38;
+		cp $branch_dir_prefix/branch-1 $branch_dir_prefix/@ &#38;&#38;
+		git -c fsck.badRefName=ignore fsck 2&gt;err &#38;&#38;
+		test_must_be_empty err
+	)
+&#39;
+
+test_done
</span>-- 
2.45.2

</pre></div></content></entry><entry><author><name>shejialuo</name><email>shejialuo@gmail.com</email></author><title>[PATCH v3 5/7] files-backend: add unified interface for refs scanning</title><updated>2024-06-18T08:19:01Z</updated><link
href="http://lore.kernel.org/git/ZnFC8YgcfYhhYb2V@ArchLinux/"/><id>urn:uuid:c4e2698a-b2ff-425e-94ef-38b899f8258d</id><thr:in-reply-to
ref="urn:uuid:296e3964-9ee9-6b3a-4238-4b7fabb59c77"
href="http://lore.kernel.org/git/20240612085349.710785-1-shejialuo@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">For refs and reflogs, we need to scan its corresponding directories to
check every regular file or symbolic link which shares the same pattern.
Introduce a unified interface for scanning directories for
files-backend.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Karthik Nayak &lt;karthik.188@gmail.com&gt;
Signed-off-by: shejialuo &lt;shejialuo@gmail.com&gt;
---
 refs/files-backend.c | 77 +++++++++++++++++++++++++++++++++++++++++++-
 1 file <a href="http://lore.kernel.org/git/ZnFC8YgcfYhhYb2V@ArchLinux/#related">changed</a>, 76 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/refs/files-backend.c b/refs/files-backend.c
index e965345ad8..74242dbba4 100644
--- a/refs/files-backend.c
+++ b/refs/files-backend.c
</span><span
class="hunk">@@ -4,6 +4,7 @@
</span> #include &#34;../gettext.h&#34;
 #include &#34;../hash.h&#34;
 #include &#34;../hex.h&#34;
<span
class="add">+#include &#34;../fsck.h&#34;
</span> #include &#34;../refs.h&#34;
 #include &#34;refs-internal.h&#34;
 #include &#34;ref-cache.h&#34;
<span
class="hunk">@@ -3402,6 +3403,78 @@ static int files_ref_store_remove_on_disk(struct ref_store *ref_store,
</span> 	return ret;
 }
 
<span
class="add">+/*
+ * For refs and reflogs, they share a unified interface when scanning
+ * the whole directory. This function is used as the callback for each
+ * regular file or symlink in the directory.
+ */
+typedef int (*files_fsck_refs_fn)(struct fsck_refs_options *o,
+				  const char *gitdir,
+				  const char *refs_check_dir,
+				  struct dir_iterator *iter);
+
+static int files_fsck_refs_dir(struct ref_store *ref_store,
+			       struct fsck_refs_options *o,
+			       const char *refs_check_dir,
+			       files_fsck_refs_fn *fsck_refs_fns)
+{
+	const char *gitdir = ref_store-&gt;gitdir;
+	struct strbuf sb = STRBUF_INIT;
+	struct dir_iterator *iter;
+	int iter_status;
+	int ret = 0;
+
+	strbuf_addf(&#38;sb, &#34;%s/%s&#34;, gitdir, refs_check_dir);
+
+	iter = dir_iterator_begin(sb.buf, 0);
+
+	if (!iter) {
+		ret = error_errno(&#34;cannot open directory %s&#34;, sb.buf);
+		goto out;
+	}
+
+	while ((iter_status = dir_iterator_advance(iter)) == ITER_OK) {
+		if (S_ISDIR(iter-&gt;st.st_mode)) {
+			continue;
+		} else if (S_ISREG(iter-&gt;st.st_mode) ||
+			   S_ISLNK(iter-&gt;st.st_mode)) {
+			if (o-&gt;verbose)
+				fprintf_ln(stderr, &#34;Checking %s/%s&#34;,
+					   refs_check_dir, iter-&gt;relative_path);
+			for (size_t i = 0; fsck_refs_fns[i]; i++) {
+				if (fsck_refs_fns[i](o, gitdir, refs_check_dir, iter))
+					ret = -1;
+			}
+		} else {
+			ret = error(_(&#34;unexpected file type for &#39;%s&#39;&#34;),
+				    iter-&gt;basename);
+		}
+	}
+
+	if (iter_status != ITER_DONE)
+		ret = error(_(&#34;failed to iterate over &#39;%s&#39;&#34;), sb.buf);
+
+out:
+	strbuf_release(&#38;sb);
+	return ret;
+}
+
+static int files_fsck_refs(struct ref_store *ref_store,
+			   struct fsck_refs_options *o)
+{
+	int ret;
+	files_fsck_refs_fn fsck_refs_fns[]= {
+		NULL
+	};
+
+	if (o-&gt;verbose)
+		fprintf_ln(stderr, &#34;Checking references consistency&#34;);
+
+	ret = files_fsck_refs_dir(ref_store, o, &#34;refs&#34;, fsck_refs_fns);
+
+	return ret;
+}
+
</span> static int files_fsck(struct ref_store *ref_store,
 		      struct fsck_refs_options *o)
 {
<span
class="hunk">@@ -3409,7 +3482,9 @@ static int files_fsck(struct ref_store *ref_store,
</span> 	struct files_ref_store *refs =
 		files_downcast(ref_store, REF_STORE_READ, &#34;fsck&#34;);
 
<span
class="del">-	ret = refs-&gt;packed_ref_store-&gt;be-&gt;fsck(refs-&gt;packed_ref_store, o);
</span><span
class="add">+	ret = refs-&gt;packed_ref_store-&gt;be-&gt;fsck(refs-&gt;packed_ref_store, o)
+	    | files_fsck_refs(ref_store, o);
+
</span> 	return ret;
 }
 
-- 
2.45.2

</pre></div></content></entry><entry><author><name>shejialuo</name><email>shejialuo@gmail.com</email></author><title>[PATCH v3 4/7] builtin/fsck: add `git-refs verify` child process</title><updated>2024-06-18T08:18:34Z</updated><link
href="http://lore.kernel.org/git/ZnFC1rne3SBemacT@ArchLinux/"/><id>urn:uuid:5db0ba02-8d0b-f96d-1f35-dd38289da86a</id><thr:in-reply-to
ref="urn:uuid:296e3964-9ee9-6b3a-4238-4b7fabb59c77"
href="http://lore.kernel.org/git/20240612085349.710785-1-shejialuo@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Introduce a new function &#34;fsck_refs&#34; that initializes and runs a child
process to execute the &#34;git-refs verify&#34; command.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Karthik Nayak &lt;karthik.188@gmail.com&gt;
Signed-off-by: shejialuo &lt;shejialuo@gmail.com&gt;
---
 builtin/fsck.c | 17 +++++++++++++++++
 1 file <a href="http://lore.kernel.org/git/ZnFC1rne3SBemacT@ArchLinux/#related">changed</a>, 17 insertions(+)

<span
class="head">diff --git a/builtin/fsck.c b/builtin/fsck.c
index d13a226c2e..10d73f534f 100644
--- a/builtin/fsck.c
+++ b/builtin/fsck.c
</span><span
class="hunk">@@ -896,6 +896,21 @@ static int check_pack_rev_indexes(struct repository *r, int show_progress)
</span> 	return res;
 }
 
<span
class="add">+static void fsck_refs(void)
+{
+	struct child_process refs_verify = CHILD_PROCESS_INIT;
+	child_process_init(&#38;refs_verify);
+	refs_verify.git_cmd = 1;
+	strvec_pushl(&#38;refs_verify.args, &#34;refs&#34;, &#34;verify&#34;, NULL);
+	if (verbose)
+		strvec_push(&#38;refs_verify.args, &#34;--verbose&#34;);
+	if (check_strict)
+		strvec_push(&#38;refs_verify.args, &#34;--strict&#34;);
+
+	if (run_command(&#38;refs_verify))
+		errors_found |= ERROR_REFS;
+}
+
</span> static char const * const fsck_usage[] = {
 	N_(&#34;git fsck [--tags] [--root] [--unreachable] [--cache] [--no-reflogs]\n&#34;
 	   &#34;         [--[no-]full] [--strict] [--verbose] [--lost-found]\n&#34;
<span
class="hunk">@@ -1065,6 +1080,8 @@ int cmd_fsck(int argc, const char **argv, const char *prefix)
</span> 
 	check_connectivity();
 
<span
class="add">+	fsck_refs();
+
</span> 	if (the_repository-&gt;settings.core_commit_graph) {
 		struct child_process commit_graph_verify = CHILD_PROCESS_INIT;
 
-- 
2.45.2

</pre></div></content></entry><entry><author><name>shejialuo</name><email>shejialuo@gmail.com</email></author><title>[PATCH v3 3/7] builtin/refs: add verify subcommand</title><updated>2024-06-18T08:18:07Z</updated><link
href="http://lore.kernel.org/git/ZnFCu7kDjjoNr9dr@ArchLinux/"/><id>urn:uuid:7bd62e92-a1c5-8a1b-05bf-e818409d8197</id><thr:in-reply-to
ref="urn:uuid:296e3964-9ee9-6b3a-4238-4b7fabb59c77"
href="http://lore.kernel.org/git/20240612085349.710785-1-shejialuo@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Introduce a new subcommand &#34;verify&#34; in git-refs(1) to allow the user to
check the reference database consistency.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Karthik Nayak &lt;karthik.188@gmail.com&gt;
Signed-off-by: shejialuo &lt;shejialuo@gmail.com&gt;
---
 Documentation/git-refs.txt | 13 +++++++++++
 builtin/refs.c             | 45 ++++++++++++++++++++++++++++++++++++++
 2 files <a href="http://lore.kernel.org/git/ZnFCu7kDjjoNr9dr@ArchLinux/#related">changed</a>, 58 insertions(+)

<span
class="head">diff --git a/Documentation/git-refs.txt b/Documentation/git-refs.txt
index 5b99e04385..16b518ecce 100644
--- a/Documentation/git-refs.txt
+++ b/Documentation/git-refs.txt
</span><span
class="hunk">@@ -10,6 +10,7 @@ SYNOPSIS
</span> --------
 [verse]
 &#39;git refs migrate&#39; --ref-format=&lt;format&gt; [--dry-run]
<span
class="add">+&#39;git refs verify&#39; [--strict] [--verbose]
</span> 
 DESCRIPTION
 -----------
<span
class="hunk">@@ -22,6 +23,9 @@ COMMANDS
</span> migrate::
 	Migrate ref store between different formats.
 
<span
class="add">+verify::
+	Verify reference database consistency.
+
</span> OPTIONS
 -------
 
<span
class="hunk">@@ -39,6 +43,15 @@ include::ref-storage-format.txt[]
</span> 	can be used to double check that the migration works as expected before
 	performing the actual migration.
 
<span
class="add">+The following options are specific to &#39;git refs verify&#39;:
+
+--strict::
+	Enable more strict checking, every WARN severity for the `Fsck Messages`
+	be seen as ERROR.
+
+--verbose::
+	When verifying the reference database consistency, be chatty.
+
</span> KNOWN LIMITATIONS
 -----------------
 
<span
class="head">diff --git a/builtin/refs.c b/builtin/refs.c
index 46dcd150d4..82ed0d57c1 100644
--- a/builtin/refs.c
+++ b/builtin/refs.c
</span><span
class="hunk">@@ -1,4 +1,6 @@
</span> #include &#34;builtin.h&#34;
<span
class="add">+#include &#34;config.h&#34;
+#include &#34;fsck.h&#34;
</span> #include &#34;parse-options.h&#34;
 #include &#34;refs.h&#34;
 #include &#34;repository.h&#34;
<span
class="hunk">@@ -7,6 +9,9 @@
</span> #define REFS_MIGRATE_USAGE \
 	N_(&#34;git refs migrate --ref-format=&lt;format&gt; [--dry-run]&#34;)
 
<span
class="add">+#define REFS_VERIFY_USAGE \
+	N_(&#34;git refs verify [--strict] [--verbose]&#34;)
+
</span> static int cmd_refs_migrate(int argc, const char **argv, const char *prefix)
 {
 	const char * const migrate_usage[] = {
<span
class="hunk">@@ -58,15 +63,55 @@ static int cmd_refs_migrate(int argc, const char **argv, const char *prefix)
</span> 	return err;
 }
 
<span
class="add">+static int cmd_refs_verify(int argc, const char **argv, const char *prefix)
+{
+	const char * const verify_usage[] = {
+		REFS_VERIFY_USAGE,
+		NULL,
+	};
+	int ret = 0;
+	unsigned int verbose = 0, strict = 0;
+	struct fsck_refs_options fsck_refs_options = FSCK_REFS_OPTIONS_DEFAULT;
+	struct option options[] = {
+		OPT__VERBOSE(&#38;verbose, N_(&#34;be verbose&#34;)),
+		OPT_BOOL(0, &#34;strict&#34;, &#38;strict, N_(&#34;enable strict checking&#34;)),
+		OPT_END(),
+	};
+
+	argc = parse_options(argc, argv, prefix, options, verify_usage, 0);
+	if (argc)
+		usage(_(&#34;too many arguments&#34;));
+
+	if (verbose)
+		fsck_refs_options.verbose = 1;
+	if (strict)
+		fsck_refs_options.strict = 1;
+
+	git_config(git_fsck_refs_config, &#38;fsck_refs_options);
+	prepare_repo_settings(the_repository);
+
+	ret = refs_fsck(get_main_ref_store(the_repository), &#38;fsck_refs_options);
+
+	/*
+	 * Explicitly free the allocated array. This is necessary because
+	 * this program is executed as child process of git-fsck(1) and the
+	 * allocated array may not freed when git-fsck(1) aborts somewhere.
+	 */
+	free(fsck_refs_options.msg_type);
+	return ret;
+}
+
</span> int cmd_refs(int argc, const char **argv, const char *prefix)
 {
 	const char * const refs_usage[] = {
 		REFS_MIGRATE_USAGE,
<span
class="add">+		REFS_VERIFY_USAGE,
</span> 		NULL,
 	};
 	parse_opt_subcommand_fn *fn = NULL;
 	struct option opts[] = {
 		OPT_SUBCOMMAND(&#34;migrate&#34;, &#38;fn, cmd_refs_migrate),
<span
class="add">+		OPT_SUBCOMMAND(&#34;verify&#34;, &#38;fn, cmd_refs_verify),
</span> 		OPT_END(),
 	};
 
-- 
2.45.2

</pre></div></content></entry><entry><author><name>shejialuo</name><email>shejialuo@gmail.com</email></author><title>[PATCH v3 2/7] refs: set up ref consistency check infrastructure</title><updated>2024-06-18T08:17:17Z</updated><link
href="http://lore.kernel.org/git/ZnFCiYrvAypGLtcC@ArchLinux/"/><id>urn:uuid:6e681f0b-5a49-2295-4dfc-7987446cf50e</id><thr:in-reply-to
ref="urn:uuid:296e3964-9ee9-6b3a-4238-4b7fabb59c77"
href="http://lore.kernel.org/git/20240612085349.710785-1-shejialuo@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The interfaces defined in the `ref_storage_be` are carefully structured
in semantic. It&#39;s organized as the five parts:

1. The name and the initialization interfaces.
2. The ref transaction interfaces.
3. The ref internal interfaces (pack, rename and copy).
4. The ref filesystem interfaces.
5. The reflog related interfaces.

To keep consistent with the git-fsck(1), add a new interface named
&#34;fsck_refs_fn&#34; to the end of &#34;ref_storage_be&#34;. This semantic cannot be
grouped into any above five categories. Explicitly add blank line to
make it different from others.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Karthik Nayak &lt;karthik.188@gmail.com&gt;
Signed-off-by: shejialuo &lt;shejialuo@gmail.com&gt;
---
 refs.c                  |  5 +++++
 refs.h                  |  8 ++++++++
 refs/debug.c            | 11 +++++++++++
 refs/files-backend.c    | 15 ++++++++++++++-
 refs/packed-backend.c   |  8 ++++++++
 refs/refs-internal.h    |  6 ++++++
 refs/reftable-backend.c |  8 ++++++++
 7 files <a href="http://lore.kernel.org/git/ZnFCiYrvAypGLtcC@ArchLinux/#related">changed</a>, 60 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/refs.c b/refs.c
index f7c7765d23..0922439275 100644
--- a/refs.c
+++ b/refs.c
</span><span
class="hunk">@@ -316,6 +316,11 @@ int check_refname_format(const char *refname, int flags)
</span> 	return check_or_sanitize_refname(refname, flags, NULL);
 }
 
<span
class="add">+int refs_fsck(struct ref_store *refs, struct fsck_refs_options *o)
+{
+	return refs-&gt;be-&gt;fsck(refs, o);
+}
+
</span> void sanitize_refname_component(const char *refname, struct strbuf *out)
 {
 	if (check_or_sanitize_refname(refname, REFNAME_ALLOW_ONELEVEL, out))
<span
class="head">diff --git a/refs.h b/refs.h
index 76d25df4de..5a042695f5 100644
--- a/refs.h
+++ b/refs.h
</span><span
class="hunk">@@ -3,6 +3,7 @@
</span> 
 #include &#34;commit.h&#34;
 
<span
class="add">+struct fsck_refs_options;
</span> struct object_id;
 struct ref_store;
 struct repository;
<span
class="hunk">@@ -547,6 +548,13 @@ int refs_for_each_reflog(struct ref_store *refs, each_reflog_fn fn, void *cb_dat
</span>  */
 int check_refname_format(const char *refname, int flags);
 
<span
class="add">+/*
+ * Check the reference database for consistency. Return 0 if refs and
+ * reflogs are consistent, and non-zero otherwise. The errors will be
+ * written to stderr.
+ */
+int refs_fsck(struct ref_store *refs, struct fsck_refs_options *o);
+
</span> /*
  * Apply the rules from check_refname_format, but mutate the result until it
  * is acceptable, and place the result in &#34;out&#34;.
<span
class="head">diff --git a/refs/debug.c b/refs/debug.c
index 547d9245b9..6306c25fd3 100644
--- a/refs/debug.c
+++ b/refs/debug.c
</span><span
class="hunk">@@ -419,6 +419,15 @@ static int debug_reflog_expire(struct ref_store *ref_store, const char *refname,
</span> 	return res;
 }
 
<span
class="add">+static int debug_fsck(struct ref_store *ref_store,
+		      struct fsck_refs_options *o)
+{
+	struct debug_ref_store *drefs = (struct debug_ref_store *)ref_store;
+	int res = drefs-&gt;refs-&gt;be-&gt;fsck(drefs-&gt;refs, o);
+	trace_printf_key(&#38;trace_refs, &#34;fsck: %d\n&#34;, res);
+	return res;
+}
+
</span> struct ref_storage_be refs_be_debug = {
 	.name = &#34;debug&#34;,
 	.init = NULL,
<span
class="hunk">@@ -451,4 +460,6 @@ struct ref_storage_be refs_be_debug = {
</span> 	.create_reflog = debug_create_reflog,
 	.delete_reflog = debug_delete_reflog,
 	.reflog_expire = debug_reflog_expire,
<span
class="add">+
+	.fsck = debug_fsck,
</span> };
<span
class="head">diff --git a/refs/files-backend.c b/refs/files-backend.c
index cb752d32b6..e965345ad8 100644
--- a/refs/files-backend.c
+++ b/refs/files-backend.c
</span><span
class="hunk">@@ -3402,6 +3402,17 @@ static int files_ref_store_remove_on_disk(struct ref_store *ref_store,
</span> 	return ret;
 }
 
<span
class="add">+static int files_fsck(struct ref_store *ref_store,
+		      struct fsck_refs_options *o)
+{
+	int ret;
+	struct files_ref_store *refs =
+		files_downcast(ref_store, REF_STORE_READ, &#34;fsck&#34;);
+
+	ret = refs-&gt;packed_ref_store-&gt;be-&gt;fsck(refs-&gt;packed_ref_store, o);
+	return ret;
+}
+
</span> struct ref_storage_be refs_be_files = {
 	.name = &#34;files&#34;,
 	.init = files_ref_store_init,
<span
class="hunk">@@ -3428,5 +3439,7 @@ struct ref_storage_be refs_be_files = {
</span> 	.reflog_exists = files_reflog_exists,
 	.create_reflog = files_create_reflog,
 	.delete_reflog = files_delete_reflog,
<span
class="del">-	.reflog_expire = files_reflog_expire
</span><span
class="add">+	.reflog_expire = files_reflog_expire,
+
+	.fsck = files_fsck,
</span> };
<span
class="head">diff --git a/refs/packed-backend.c b/refs/packed-backend.c
index c4c1e36aa2..db152053f8 100644
--- a/refs/packed-backend.c
+++ b/refs/packed-backend.c
</span><span
class="hunk">@@ -1733,6 +1733,12 @@ static struct ref_iterator *packed_reflog_iterator_begin(struct ref_store *ref_s
</span> 	return empty_ref_iterator_begin();
 }
 
<span
class="add">+static int packed_fsck(struct ref_store *ref_store,
+		       struct fsck_refs_options *o)
+{
+	return 0;
+}
+
</span> struct ref_storage_be refs_be_packed = {
 	.name = &#34;packed&#34;,
 	.init = packed_ref_store_init,
<span
class="hunk">@@ -1760,4 +1766,6 @@ struct ref_storage_be refs_be_packed = {
</span> 	.create_reflog = NULL,
 	.delete_reflog = NULL,
 	.reflog_expire = NULL,
<span
class="add">+
+	.fsck = packed_fsck,
</span> };
<span
class="head">diff --git a/refs/refs-internal.h b/refs/refs-internal.h
index cbcb6f9c36..8f42f21e77 100644
--- a/refs/refs-internal.h
+++ b/refs/refs-internal.h
</span><span
class="hunk">@@ -4,6 +4,7 @@
</span> #include &#34;refs.h&#34;
 #include &#34;iterator.h&#34;
 
<span
class="add">+struct fsck_refs_options;
</span> struct ref_transaction;
 
 /*
<span
class="hunk">@@ -650,6 +651,9 @@ typedef int read_raw_ref_fn(struct ref_store *ref_store, const char *refname,
</span> typedef int read_symbolic_ref_fn(struct ref_store *ref_store, const char *refname,
 				 struct strbuf *referent);
 
<span
class="add">+typedef int fsck_fn(struct ref_store *ref_store,
+		    struct fsck_refs_options *o);
+
</span> struct ref_storage_be {
 	const char *name;
 	ref_store_init_fn *init;
<span
class="hunk">@@ -677,6 +681,8 @@ struct ref_storage_be {
</span> 	create_reflog_fn *create_reflog;
 	delete_reflog_fn *delete_reflog;
 	reflog_expire_fn *reflog_expire;
<span
class="add">+
+	fsck_fn *fsck;
</span> };
 
 extern struct ref_storage_be refs_be_files;
<span
class="head">diff --git a/refs/reftable-backend.c b/refs/reftable-backend.c
index e555be4671..7f606faa9e 100644
--- a/refs/reftable-backend.c
+++ b/refs/reftable-backend.c
</span><span
class="hunk">@@ -2242,6 +2242,12 @@ static int reftable_be_reflog_expire(struct ref_store *ref_store,
</span> 	return ret;
 }
 
<span
class="add">+static int reftable_be_fsck(struct ref_store *ref_store,
+			    struct fsck_refs_options *o)
+{
+	return 0;
+}
+
</span> struct ref_storage_be refs_be_reftable = {
 	.name = &#34;reftable&#34;,
 	.init = reftable_be_init,
<span
class="hunk">@@ -2269,4 +2275,6 @@ struct ref_storage_be refs_be_reftable = {
</span> 	.create_reflog = reftable_be_create_reflog,
 	.delete_reflog = reftable_be_delete_reflog,
 	.reflog_expire = reftable_be_reflog_expire,
<span
class="add">+
+	.fsck = reftable_be_fsck,
</span> };
-- 
2.45.2

</pre></div></content></entry><entry><author><name>shejialuo</name><email>shejialuo@gmail.com</email></author><title>[GSoC][PATCH v3 1/7] fsck: add refs check interfaces to interface with fsck error levels</title><updated>2024-06-18T08:15:18Z</updated><link
href="http://lore.kernel.org/git/ZnFCEYypdAyXMMlg@ArchLinux/"/><id>urn:uuid:3dd239b9-f245-7746-c59d-cf7a12672257</id><thr:in-reply-to
ref="urn:uuid:296e3964-9ee9-6b3a-4238-4b7fabb59c77"
href="http://lore.kernel.org/git/20240612085349.710785-1-shejialuo@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The git-fsck(1) focuses on object database consistency check. It relies
on the &#34;fsck_options&#34; to interact with fsck error levels. However,
&#34;fsck_options&#34; aims at checking the object database which makes it
unsuitable to change the semantics of it. Instead, create
&#34;fsck_refs_options&#34; structure to handle refs consistency check.

The &#34;git_fsck_config&#34; sets up the &#34;msg_type&#34; and &#34;skiplist&#34; member of
the &#34;fsck_options&#34;. For refs, we just need the &#34;msg_type&#34;. In order to
allow setting up more refs-specific options easily later, add a separate
function &#34;git_fsck_refs_config&#34; to initialize the refs-specific options.

Move the &#34;msg_type&#34; and &#34;strict&#34; member to the top of the &#34;fsck_options&#34;
which allows us to convert &#34;fsck_refs_options *&#34; to &#34;fsck_options *&#34; to
reuse the interfaces provided by &#34;fsck.h&#34; without changing the original
code.

The static function &#34;report&#34; provided by &#34;fsck.c&#34; aims at reporting the
problems related to object database which cannot be reused for refs.
Provide &#34;fsck_refs_report&#34; function to integrate the fsck error levels
into reference consistency check.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Karthik Nayak &lt;karthik.188@gmail.com&gt;
Signed-off-by: shejialuo &lt;shejialuo@gmail.com&gt;
---
 fsck.c | 69 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 fsck.h | 45 ++++++++++++++++++++++++++++++++++++--
 2 files <a href="http://lore.kernel.org/git/ZnFCEYypdAyXMMlg@ArchLinux/#related">changed</a>, 112 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/fsck.c b/fsck.c
index 8ef962199f..13528c646e 100644
--- a/fsck.c
+++ b/fsck.c
</span><span
class="hunk">@@ -1249,6 +1249,20 @@ int fsck_buffer(const struct object_id *oid, enum object_type type,
</span> 		      type);
 }
 
<span
class="add">+int fsck_refs_error_function(struct fsck_refs_options *o UNUSED,
+			     const char *name,
+			     enum fsck_msg_type msg_type,
+			     enum fsck_msg_id msg_id UNUSED,
+			     const char *message)
+{
+	if (msg_type == FSCK_WARN) {
+		warning(&#34;%s: %s&#34;, name, message);
+		return 0;
+	}
+	error(&#34;%s: %s&#34;, name, message);
+	return 1;
+}
+
</span> int fsck_error_function(struct fsck_options *o,
 			const struct object_id *oid,
 			enum object_type object_type UNUSED,
<span
class="hunk">@@ -1323,6 +1337,61 @@ int fsck_finish(struct fsck_options *options)
</span> 	return ret;
 }
 
<span
class="add">+int fsck_refs_report(struct fsck_refs_options *o,
+		     const char *name,
+		     enum fsck_msg_id msg_id,
+		     const char *fmt, ...)
+{
+	va_list ap;
+	struct strbuf sb = STRBUF_INIT;
+	enum fsck_msg_type msg_type =
+		fsck_msg_type(msg_id, (struct fsck_options*)o);
+	int ret = 0;
+
+	if (msg_type == FSCK_IGNORE)
+		return 0;
+
+	if (msg_type == FSCK_FATAL)
+		msg_type = FSCK_ERROR;
+	else if (msg_type == FSCK_INFO)
+		msg_type = FSCK_WARN;
+
+	prepare_msg_ids();
+	strbuf_addf(&#38;sb, &#34;%s: &#34;, msg_id_info[msg_id].camelcased);
+
+	va_start(ap, fmt);
+	strbuf_vaddf(&#38;sb, fmt, ap);
+	ret = o-&gt;error_func(o, name, msg_type, msg_id, sb.buf);
+	strbuf_release(&#38;sb);
+	va_end(ap);
+
+	return ret;
+}
+
+int git_fsck_refs_config(const char *var, const char *value,
+			 const struct config_context *ctx, void *cb)
+{
+	struct fsck_refs_options *options = cb;
+	const char *msg_id;
+
+	/*
+	 * We don&#39;t check the value of fsck.skiplist here, because it
+	 * is specific to object database, not reference database.
+	 */
+	if (strcmp(var, &#34;fsck.skiplist&#34;) == 0) {
+		return 0;
+	}
+
+	if (skip_prefix(var, &#34;fsck.&#34;, &#38;msg_id)) {
+		if (!value)
+			return config_error_nonbool(var);
+		fsck_set_msg_type((struct fsck_options*)options, msg_id, value);
+		return 0;
+	}
+
+	return git_default_config(var, value, ctx, cb);
+}
+
</span> int git_fsck_config(const char *var, const char *value,
 		    const struct config_context *ctx, void *cb)
 {
<span
class="head">diff --git a/fsck.h b/fsck.h
index 17fa2dda5d..6a38ac4a16 100644
--- a/fsck.h
+++ b/fsck.h
</span><span
class="hunk">@@ -96,6 +96,7 @@ enum fsck_msg_id {
</span> };
 #undef MSG_ID
 
<span
class="add">+struct fsck_refs_options;
</span> struct fsck_options;
 struct object;
 
<span
class="hunk">@@ -107,6 +108,21 @@ void fsck_set_msg_type(struct fsck_options *options,
</span> void fsck_set_msg_types(struct fsck_options *options, const char *values);
 int is_valid_msg_type(const char *msg_id, const char *msg_type);
 
<span
class="add">+/*
+ * callback function for fsck refs and reflogs.
+ */
+typedef int (*fsck_refs_error)(struct fsck_refs_options *o,
+			       const char *name,
+			       enum fsck_msg_type msg_type,
+			       enum fsck_msg_id msg_id,
+			       const char *message);
+
+int fsck_refs_error_function(struct fsck_refs_options *o,
+			     const char *name,
+			     enum fsck_msg_type msg_type,
+			     enum fsck_msg_id msg_id,
+			     const char *message);
+
</span> /*
  * callback function for fsck_walk
  * type is the expected type of the object or OBJ_ANY
<span
class="hunk">@@ -135,11 +151,28 @@ int fsck_error_cb_print_missing_gitmodules(struct fsck_options *o,
</span> 					   enum fsck_msg_id msg_id,
 					   const char *message);
 
<span
class="add">+struct fsck_refs_options {
+	enum fsck_msg_type *msg_type;
+	unsigned strict:1;
+
+	fsck_refs_error error_func;
+	unsigned verbose:1;
+};
+
+#define FSCK_REFS_OPTIONS_DEFAULT { \
+	.error_func = fsck_refs_error_function, \
+}
+
</span> struct fsck_options {
<span
class="add">+	/*
+	 * Reorder the fields to allow `fsck_ref_options` to use
+	 * the interfaces using `struct fsck_options`.
+	 */
+	enum fsck_msg_type *msg_type;
+	unsigned strict:1;
+
</span> 	fsck_walk_func walk;
 	fsck_error error_func;
<span
class="del">-	unsigned strict:1;
-	enum fsck_msg_type *msg_type;
</span> 	struct oidset skiplist;
 	struct oidset gitmodules_found;
 	struct oidset gitmodules_done;
<span
class="hunk">@@ -221,6 +254,12 @@ int fsck_tag_standalone(const struct object_id *oid, const char *buffer,
</span>  */
 int fsck_finish(struct fsck_options *options);
 
<span
class="add">+__attribute__((format (printf, 4, 5)))
+int fsck_refs_report(struct fsck_refs_options *o,
+		     const char *name,
+		     enum fsck_msg_id msg_id,
+		     const char *fmt, ...);
+
</span> /*
  * Subsystem for storing human-readable names for each object.
  *
<span
class="hunk">@@ -247,6 +286,8 @@ const char *fsck_describe_object(struct fsck_options *options,
</span> 				 const struct object_id *oid);
 
 struct key_value_info;
<span
class="add">+int git_fsck_refs_config(const char *var, const char *value,
+			 const struct config_context *ctx, void *cb);
</span> /*
  * git_config() callback for use by fsck-y tools that want to support
  * fsck.&lt;msg&gt; fsck.skipList etc.
-- 
2.45.2

</pre></div></content></entry><entry><author><name>shejialuo</name><email>shejialuo@gmail.com</email></author><title>[GSoC][PATCH v3 0/7] ref consistency check infra setup</title><updated>2024-06-18T08:14:06Z</updated><link
href="http://lore.kernel.org/git/ZnFByMI1lWUDSxLd@ArchLinux/"/><id>urn:uuid:e49509da-3075-1309-2e97-bd4e1e257796</id><thr:in-reply-to
ref="urn:uuid:296e3964-9ee9-6b3a-4238-4b7fabb59c77"
href="http://lore.kernel.org/git/20240612085349.710785-1-shejialuo@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This is the third version. Mainly focuses on the following problems:

1. Add &#34;escape&#34; check for symrefs and symbolic links.
2. Resolve the reviews.
3. Fix some errors in version 2.

shejialuo (7):
  fsck: add refs check interfaces to interface with fsck error levels
  refs: set up ref consistency check infrastructure
  builtin/refs: add verify subcommand
  builtin/fsck: add `git-refs verify` child process
  files-backend: add unified interface for refs scanning
  fsck: add ref name check for files backend
  fsck: add ref content check for files backend

 Documentation/fsck-msgids.txt |  12 ++
 Documentation/git-refs.txt    |  13 ++
 builtin/fsck.c                |  17 +++
 builtin/refs.c                |  45 ++++++
 fsck.c                        |  69 +++++++++
 fsck.h                        |  49 ++++++-
 refs.c                        |   7 +-
 refs.h                        |   8 ++
 refs/debug.c                  |  11 ++
 refs/files-backend.c          | 255 +++++++++++++++++++++++++++++++++-
 refs/packed-backend.c         |   8 ++
 refs/refs-internal.h          |  11 +-
 refs/reftable-backend.c       |   8 ++
 t/t0602-reffiles-fsck.sh      | 211 ++++++++++++++++++++++++++++
 14 files changed, 716 insertions(+), 8 deletions(-)
 create mode 100755 t/t0602-reffiles-fsck.sh

Range-diff against v2:
1:  a65de15dc7 ! 1:  b8d20c4be9 fsck: add refs check interfaces to interface with fsck error levels
    @@ fsck.h: int fsck_error_cb_print_missing_gitmodules(struct fsck_options *o,
     +struct fsck_refs_options {
     +	enum fsck_msg_type *msg_type;
     +	unsigned strict:1;
    ++
     +	fsck_refs_error error_func;
     +	unsigned verbose:1;
     +};
    @@ fsck.h: int fsck_error_cb_print_missing_gitmodules(struct fsck_options *o,
     +}
     +
      struct fsck_options {
    ++	/*
    ++	 * Reorder the fields to allow `fsck_ref_options` to use
    ++	 * the interfaces using `struct fsck_options`.
    ++	 */
     +	enum fsck_msg_type *msg_type;
     +	unsigned strict:1;
    ++
      	fsck_walk_func walk;
      	fsck_error error_func;
     -	unsigned strict:1;
2:  a87149069a ! 2:  c7ed95d6b4 refs: set up ref consistency check infrastructure
    @@ refs/debug.c: static int debug_reflog_expire(struct ref_store *ref_store, const
     +static int debug_fsck(struct ref_store *ref_store,
     +		      struct fsck_refs_options *o)
     +{
    -+	trace_printf_key(&#38;trace_refs, &#34;fsck\n&#34;);
    -+	return 0;
    ++	struct debug_ref_store *drefs = (struct debug_ref_store *)ref_store;
    ++	int res = drefs-&gt;refs-&gt;be-&gt;fsck(drefs-&gt;refs, o);
    ++	trace_printf_key(&#38;trace_refs, &#34;fsck: %d\n&#34;, res);
    ++	return res;
     +}
     +
      struct ref_storage_be refs_be_debug = {
3:  e1f1b77527 ! 3:  373f470fdc builtin/refs: add verify subcommand
    @@ Documentation/git-refs.txt: include::ref-storage-format.txt[]
      	can be used to double check that the migration works as expected before
      	performing the actual migration.
      
    ++The following options are specific to &#39;git refs verify&#39;:
    ++
     +--strict::
     +	Enable more strict checking, every WARN severity for the `Fsck Messages`
     +	be seen as ERROR.
4:  2b0ee79e78 = 4:  4f8ebea573 builtin/fsck: add `git-refs verify` child process
5:  6d23eaa1d1 ! 5:  6062b3b453 files-backend: add unified interface for refs scanning
    @@ refs/files-backend.c: static int files_ref_store_remove_on_disk(struct ref_store
      		      struct fsck_refs_options *o)
      {
     @@ refs/files-backend.c: static int files_fsck(struct ref_store *ref_store,
    + 	struct files_ref_store *refs =
      		files_downcast(ref_store, REF_STORE_READ, &#34;fsck&#34;);
      
    - 	ret = refs-&gt;packed_ref_store-&gt;be-&gt;fsck(refs-&gt;packed_ref_store, o);
    -+	ret = files_fsck_refs(ref_store, o);
    +-	ret = refs-&gt;packed_ref_store-&gt;be-&gt;fsck(refs-&gt;packed_ref_store, o);
    ++	ret = refs-&gt;packed_ref_store-&gt;be-&gt;fsck(refs-&gt;packed_ref_store, o)
    ++	    | files_fsck_refs(ref_store, o);
     +
      	return ret;
      }
6:  8c55ecdd88 = 6:  87a22f4c7f fsck: add ref name check for files backend
7:  aba5f50940 ! 7:  b945f61ef1 fsck: add ref content check for files backend
    @@ Commit message
         in the files backend. The new functionality ensures that symrefs, real
         symbolic link and regular refs are validated correctly.
     
    -    Add a new function &#34;files_fsck_symref&#34; to check whether the symrefs and
    -    symbolic link points to a valid object and a new function
    -    &#34;files_fsck_refs_content&#34; handles both regular refs and symbolic refs.
    +    In order to check the trailing content of the regular refs, add a new
    +    parameter `trailing` to `parse_loose_ref_contents`.
     
    -    In order to check the trailing content, add a new parameter
    -    &#34;trailing&#34; to &#34;parse_loose_ref_contents&#34; function.
    +    For symrefs, `parse_loose_ref_contents` will set the &#34;referent&#34;.
    +    However, symbolic link could be either absolute or relative. Use
    +    &#34;strbuf_add_real_path&#34; to read the symbolic link and convert the
    +    relative path to absolute path. Then use &#34;skip_prefix&#34; to make it align
    +    with symref &#34;referent&#34;.
    +
    +    Thus, the symrefs and symbolic links could share the same interface. Add
    +    a new function &#34;files_fsck_symref_target&#34; which aims at checking the
    +    following things:
    +
    +    1. whether the pointee is under the `refs/` directory.
    +    2. whether the pointee name is correct.
    +    3. whether the pointee path is a wrong type in filesystem.
     
         Last, add the following FSCK MESSAGEs:
     
    -    1. &#34;badRefSha(ERROR)&#34;: A ref has a bad sha.
    -    2. &#34;danglingSymre(WARN)&#34;: Found a dangling symref.
    +    1. &#34;badRefContent(ERROR)&#34;: A ref has a bad content
    +    2. &#34;badSymrefPointee(ERROR)&#34;: The pointee of a symref is bad.
         3. &#34;trailingRefContent(WARN)&#34;: A ref content has trailing contents.
     
         Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
    @@ Commit message
     
      ## Documentation/fsck-msgids.txt ##
     @@
    + `badParentSha1`::
    + 	(ERROR) A commit object has a bad parent sha1.
    + 
    ++`badRefContent`::
    ++	(ERROR) A ref has a bad content.
    ++
      `badRefName`::
      	(ERROR) A ref has a bad name.
      
    -+`badRefSha`::
    -+	(ERROR) A ref has a bad sha.
    ++`badSymrefPointee`::
    ++	(ERROR) The pointee of a symref is bad.
     +
      `badTagName`::
      	(INFO) A tag has an invalid format.
      
    -@@
    - `badType`::
    - 	(ERROR) Found an invalid object type.
    - 
    -+`danglingSymref`::
    -+	(WARN) Found a dangling symref.
    -+
    - `duplicateEntries`::
    - 	(ERROR) A tree contains duplicate file entries.
    - 
     @@
      `symlinkTargetMissing`::
      	(ERROR) Unable to read symbolic link target&#39;s blob.
    @@ fsck.h: enum fsck_msg_type {
      	FUNC(BAD_OBJECT_SHA1, ERROR) \
      	FUNC(BAD_PARENT_SHA1, ERROR) \
      	FUNC(BAD_REF_NAME, ERROR) \
    -+	FUNC(BAD_REF_SHA, ERROR) \
    ++	FUNC(BAD_REF_CONTENT, ERROR) \
    ++	FUNC(BAD_SYMREF_POINTEE, ERROR) \
      	FUNC(BAD_TIMEZONE, ERROR) \
      	FUNC(BAD_TREE, ERROR) \
      	FUNC(BAD_TREE_SHA1, ERROR) \
     @@ fsck.h: enum fsck_msg_type {
    - 	FUNC(SYMLINK_TARGET_BLOB, ERROR) \
    - 	/* warnings */ \
    - 	FUNC(EMPTY_NAME, WARN) \
    -+	FUNC(DANGLING_SYMREF, WARN) \
    - 	FUNC(FULL_PATHNAME, WARN) \
    - 	FUNC(HAS_DOT, WARN) \
      	FUNC(HAS_DOTDOT, WARN) \
      	FUNC(HAS_DOTGIT, WARN) \
      	FUNC(NULL_SHA1, WARN) \
    @@ refs.c: static int refs_read_special_head(struct ref_store *ref_store,
      	strbuf_release(&#38;full_path);
     
      ## refs/files-backend.c ##
    +@@
    + #include &#34;../git-compat-util.h&#34;
    ++#include &#34;../abspath.h&#34;
    + #include &#34;../copy.h&#34;
    + #include &#34;../environment.h&#34;
    + #include &#34;../gettext.h&#34;
     @@ refs/files-backend.c: static int read_ref_internal(struct ref_store *ref_store, const char *refname,
      	strbuf_rtrim(&#38;sb_contents);
      	buf = sb_contents.buf;
    @@ refs/files-backend.c: static int files_read_symbolic_ref(struct ref_store *ref_s
      int parse_loose_ref_contents(const char *buf, struct object_id *oid,
      			     struct strbuf *referent, unsigned int *type,
     -			     int *failure_errno)
    -+			     int *failure_errno, unsigned int *trailing)
    ++			     int *failure_errno, const char **trailing)
      {
      	const char *p;
      	if (skip_prefix(buf, &#34;ref:&#34;, &#38;buf)) {
    @@ refs/files-backend.c: int parse_loose_ref_contents(const char *buf, struct objec
      		return -1;
      	}
     +
    -+	if (trailing &#38;&#38; (*p != &#39;\0&#39; &#38;&#38; *p != &#39;\n&#39;))
    -+		*trailing = 1;
    ++	if (trailing)
    ++		*trailing = p;
     +
      	return 0;
      }
    @@ refs/files-backend.c: static int files_fsck_refs_name(struct fsck_refs_options *
      	return ret;
      }
      
    -+static int files_fsck_symref(struct fsck_refs_options *o,
    -+			     struct strbuf *refname,
    -+			     struct strbuf *path)
    ++/*
    ++ * Check the symref &#34;pointee_name&#34; and &#34;pointee_path&#34;. The caller should
    ++ * make sure that &#34;pointee_path&#34; is absolute. For symbolic ref, &#34;pointee_name&#34;
    ++ * would be the content after &#34;refs:&#34;. For symblic link, &#34;pointee_name&#34; would
    ++ * be the relative path agaignst &#34;gitdir&#34;.
    ++ */
    ++static int files_fsck_symref_target(struct fsck_refs_options *o,
    ++				    const char *refname,
    ++				    const char *pointee_name,
    ++				    const char *pointee_path)
     +{
    ++	const char *p = NULL;
     +	struct stat st;
     +	int ret = 0;
     +
    -+	if (lstat(path-&gt;buf, &#38;st) &lt; 0) {
    -+		ret = fsck_refs_report(o, refname-&gt;buf,
    -+				       FSCK_MSG_DANGLING_SYMREF,
    -+				       &#34;point to non-existent ref&#34;);
    ++	if (!skip_prefix(pointee_name, &#34;refs/&#34;, &#38;p)) {
    ++
    ++		ret = fsck_refs_report(o, refname,
    ++				       FSCK_MSG_BAD_SYMREF_POINTEE,
    ++				       &#34;point to target out of refs hierarchy&#34;);
     +		goto out;
     +	}
     +
    ++	if (check_refname_format(pointee_name, 0)) {
    ++		ret = fsck_refs_report(o, refname,
    ++				       FSCK_MSG_BAD_SYMREF_POINTEE,
    ++				       &#34;point to invalid refname&#34;);
    ++	}
    ++
    ++	if (lstat(pointee_path, &#38;st) &lt; 0)
    ++		goto out;
    ++
     +	if (!S_ISREG(st.st_mode) &#38;&#38; !S_ISLNK(st.st_mode)) {
    -+		ret = fsck_refs_report(o, refname-&gt;buf,
    -+				       FSCK_MSG_DANGLING_SYMREF,
    -+				       &#34;point to invalid object&#34;);
    ++		ret = fsck_refs_report(o, refname,
    ++				       FSCK_MSG_BAD_SYMREF_POINTEE,
    ++				       &#34;point to invalid target&#34;);
     +		goto out;
     +	}
     +out:
    @@ refs/files-backend.c: static int files_fsck_refs_name(struct fsck_refs_options *
     +				   const char *refs_check_dir,
     +				   struct dir_iterator *iter)
     +{
    -+	struct strbuf path = STRBUF_INIT,
    -+		      refname = STRBUF_INIT,
    ++	struct strbuf pointee_path = STRBUF_INIT,
     +		      ref_content = STRBUF_INIT,
    -+		      referent = STRBUF_INIT;
    -+	unsigned int trailing = 0;
    ++		      abs_gitdir = STRBUF_INIT,
    ++		      referent = STRBUF_INIT,
    ++		      refname = STRBUF_INIT;
    ++	const char *trailing = NULL;
     +	int failure_errno = 0;
     +	unsigned int type = 0;
     +	struct object_id oid;
     +	int ret = 0;
     +
    -+	strbuf_addbuf(&#38;path, &#38;iter-&gt;path);
     +	strbuf_addf(&#38;refname, &#34;%s/%s&#34;, refs_check_dir, iter-&gt;relative_path);
     +
     +	/*
    @@ refs/files-backend.c: static int files_fsck_refs_name(struct fsck_refs_options *
     +	 * of the destination object.
     +	 */
     +	if (S_ISLNK(iter-&gt;st.st_mode)) {
    -+		strbuf_strip_file_from_path(&#38;path);
    -+		ret = strbuf_readlink(&#38;ref_content,
    -+				      iter-&gt;path.buf, iter-&gt;st.st_size);
    -+		if (ret &lt; 0) {
    -+			ret = error_errno(_(&#34;could not read link &#39;%s&#39;&#34;),
    -+					  iter-&gt;path.buf);
    ++		const char *pointee_name = NULL;
    ++
    ++		strbuf_add_real_path(&#38;pointee_path, iter-&gt;path.buf);
    ++
    ++		strbuf_add_absolute_path(&#38;abs_gitdir, gitdir);
    ++		strbuf_normalize_path(&#38;abs_gitdir);
    ++		if (!is_dir_sep(abs_gitdir.buf[abs_gitdir.len - 1]))
    ++			strbuf_addch(&#38;abs_gitdir, &#39;/&#39;);
    ++
    ++		if (!skip_prefix(pointee_path.buf,
    ++				 abs_gitdir.buf, &#38;pointee_name)) {
    ++			ret = fsck_refs_report(o, refname.buf,
    ++					       FSCK_MSG_BAD_SYMREF_POINTEE,
    ++					       &#34;point to target outside gitdir&#34;);
     +			goto clean;
     +		}
    -+		strbuf_addbuf(&#38;path, &#38;ref_content);
    -+		strbuf_reset(&#38;ref_content);
     +
    -+		ret = files_fsck_symref(o, &#38;refname, &#38;path);
    ++		ret = files_fsck_symref_target(o, refname.buf, pointee_name,
    ++					       pointee_path.buf);
     +		goto clean;
     +	}
     +
    -+	if (strbuf_read_file(&#38;ref_content, path.buf, 0) &lt; 0) {
    ++	if (strbuf_read_file(&#38;ref_content, iter-&gt;path.buf, 0) &lt; 0) {
     +		ret = error_errno(_(&#34;%s/%s: unable to read the ref&#34;),
     +				  refs_check_dir, iter-&gt;relative_path);
     +		goto clean;
    @@ refs/files-backend.c: static int files_fsck_refs_name(struct fsck_refs_options *
     +				     &#38;referent, &#38;type,
     +				     &#38;failure_errno, &#38;trailing)) {
     +		ret = fsck_refs_report(o, refname.buf,
    -+				       FSCK_MSG_BAD_REF_SHA,
    ++				       FSCK_MSG_BAD_REF_CONTENT,
     +				       &#34;invalid ref content&#34;);
     +		goto clean;
     +	}
    @@ refs/files-backend.c: static int files_fsck_refs_name(struct fsck_refs_options *
     +	 * connectivity.
     +	 */
     +	if (referent.len &#38;&#38; (type &#38; REF_ISSYMREF)) {
    -+		strbuf_reset(&#38;path);
    -+		strbuf_addf(&#38;path, &#34;%s/%s&#34;, gitdir, referent.buf);
    -+
    -+		if (check_refname_format(referent.buf, 0)) {
    -+			ret = fsck_refs_report(o, refname.buf,
    -+					       FSCK_MSG_DANGLING_SYMREF,
    -+					       &#34;point to invalid refname&#34;);
    -+			goto clean;
    -+		}
    ++		strbuf_addf(&#38;pointee_path, &#34;%s/%s&#34;, gitdir, referent.buf);
    ++		strbuf_rtrim(&#38;referent);
     +
    -+		ret = files_fsck_symref(o, &#38;refname, &#38;path);
    ++		ret = files_fsck_symref_target(o, refname.buf, referent.buf,
    ++					       pointee_path.buf);
     +		goto clean;
     +	} else {
     +		/*
     +		 * Only regular refs could have a trailing garbage. Should
     +		 * be reported as a warning.
     +		 */
    -+		if (trailing) {
    ++		if (trailing &#38;&#38; (*trailing != &#39;\0&#39; &#38;&#38; *trailing != &#39;\n&#39;)) {
     +			ret = fsck_refs_report(o, refname.buf,
     +					       FSCK_MSG_TRAILING_REF_CONTENT,
     +					       &#34;trailing garbage in ref&#34;);
    @@ refs/files-backend.c: static int files_fsck_refs_name(struct fsck_refs_options *
     +	}
     +
     +clean:
    -+	strbuf_release(&#38;path);
    ++	strbuf_release(&#38;abs_gitdir);
    ++	strbuf_release(&#38;pointee_path);
     +	strbuf_release(&#38;refname);
     +	strbuf_release(&#38;ref_content);
     +	strbuf_release(&#38;referent);
    @@ refs/refs-internal.h: struct ref_store {
      /*
       * Parse contents of a loose ref file. *failure_errno maybe be set to EINVAL for
     - * invalid contents.
    -+ * invalid contents. Also trailing is set to 1 when there is any bytes after the
    -+ * hex.
    ++ * invalid contents. Also *trailing is set to the first character after the
    ++ * refname or NULL if the referent is not empty.
       */
      int parse_loose_ref_contents(const char *buf, struct object_id *oid,
      			     struct strbuf *referent, unsigned int *type,
     -			     int *failure_errno);
    -+			     int *failure_errno, unsigned int *trailing);
    ++			     int *failure_errno, const char **trailing);
      
      /*
       * Fill in the generic part of refs and add it to our collection of
    @@ t/t0602-reffiles-fsck.sh: test_expect_success &#39;ref name check should be adapted
     +		printf &#34;xfsazqfxcadas&#34; &gt; $tag_dir_prefix/tag-2-bad &#38;&#38;
     +		test_must_fail git refs verify 2&gt;err &#38;&#38;
     +		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
    -+		error: refs/tags/tag-2-bad: badRefSha: invalid ref content
    ++		error: refs/tags/tag-2-bad: badRefContent: invalid ref content
     +		EOF
     +		rm $tag_dir_prefix/tag-2-bad &#38;&#38;
     +		test_cmp expect err
    @@ t/t0602-reffiles-fsck.sh: test_expect_success &#39;ref name check should be adapted
     +		printf &#34;xfsazqfxcadas&#34; &gt; $branch_dir_prefix/a/b/branch-2-bad &#38;&#38;
     +		test_must_fail git refs verify 2&gt;err &#38;&#38;
     +		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
    -+		error: refs/heads/a/b/branch-2-bad: badRefSha: invalid ref content
    ++		error: refs/heads/a/b/branch-2-bad: badRefContent: invalid ref content
     +		EOF
     +		rm $branch_dir_prefix/a/b/branch-2-bad &#38;&#38;
     +		test_cmp expect err
    @@ t/t0602-reffiles-fsck.sh: test_expect_success &#39;ref name check should be adapted
     +	) &#38;&#38;
     +	(
     +		cd repo &#38;&#38;
    -+		printf &#34;ref: refs/heads/branch-3&#34; &gt; $branch_dir_prefix/branch-2-bad &#38;&#38;
    -+		git refs verify 2&gt;err &#38;&#38;
    ++		printf &#34;ref: refs/heads/.branch&#34; &gt; $branch_dir_prefix/branch-2-bad &#38;&#38;
    ++		test_must_fail git refs verify 2&gt;err &#38;&#38;
     +		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
    -+		warning: refs/heads/branch-2-bad: danglingSymref: point to non-existent ref
    ++		error: refs/heads/branch-2-bad: badSymrefPointee: point to invalid refname
     +		EOF
     +		rm $branch_dir_prefix/branch-2-bad &#38;&#38;
     +		test_cmp expect err
     +	) &#38;&#38;
     +	(
     +		cd repo &#38;&#38;
    -+		printf &#34;ref: refs/heads/.branch&#34; &gt; $branch_dir_prefix/branch-2-bad &#38;&#38;
    -+		git refs verify 2&gt;err &#38;&#38;
    ++		printf &#34;ref: refs/heads&#34; &gt; $branch_dir_prefix/branch-2-bad &#38;&#38;
    ++		test_must_fail git refs verify 2&gt;err &#38;&#38;
     +		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
    -+		warning: refs/heads/branch-2-bad: danglingSymref: point to invalid refname
    ++		error: refs/heads/branch-2-bad: badSymrefPointee: point to invalid target
     +		EOF
     +		rm $branch_dir_prefix/branch-2-bad &#38;&#38;
     +		test_cmp expect err
     +	) &#38;&#38;
     +	(
     +		cd repo &#38;&#38;
    -+		printf &#34;ref: refs/heads&#34; &gt; $branch_dir_prefix/branch-2-bad &#38;&#38;
    -+		git refs verify 2&gt;err &#38;&#38;
    ++		printf &#34;ref: logs/maint-v2.45&#34; &gt; $branch_dir_prefix/branch-2-bad &#38;&#38;
    ++		test_must_fail git refs verify 2&gt;err &#38;&#38;
     +		cat &gt;expect &lt;&lt;-EOF &#38;&#38;
    -+		warning: refs/heads/branch-2-bad: danglingSymref: point to invalid object
    ++		error: refs/heads/branch-2-bad: badSymrefPointee: point to target out of refs hierarchy
     +		EOF
     +		rm $branch_dir_prefix/branch-2-bad &#38;&#38;
     +		test_cmp expect err
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Kyle Lippincott via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH] attr: fix msan issue in read_attr_from_index</title><updated>2024-06-17T20:00:28Z</updated><link
href="http://lore.kernel.org/git/pull.1747.git.1718654424683.gitgitgadget@gmail.com/"/><id>urn:uuid:30b09c1b-ba8f-3e2e-151f-917e05e326cf</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Kyle Lippincott &lt;spectral@google.com&gt;

Memory sanitizer (msan) is detecting a use of an uninitialized variable
(`size`) in `read_attr_from_index`:

    ==2268==WARNING: MemorySanitizer: use-of-uninitialized-value
    #0 0x5651f3416504 in read_attr_from_index git/attr.c:868:11
    #1 0x5651f3415530 in read_attr git/attr.c
    #2 0x5651f3413d74 in bootstrap_attr_stack git/attr.c:968:6
    #3 0x5651f3413d74 in prepare_attr_stack git/attr.c:1004:2
    #4 0x5651f3413d74 in collect_some_attrs git/attr.c:1199:2
    #5 0x5651f3413144 in git_check_attr git/attr.c:1345:2
    #6 0x5651f34728da in convert_attrs git/convert.c:1320:2
    #7 0x5651f3473425 in would_convert_to_git_filter_fd git/convert.c:1373:2
    #8 0x5651f357a35e in index_fd git/object-file.c:2630:34
    #9 0x5651f357aa15 in index_path git/object-file.c:2657:7
    #10 0x5651f35db9d9 in add_to_index git/read-cache.c:766:7
    #11 0x5651f35dc170 in add_file_to_index git/read-cache.c:799:9
    #12 0x5651f321f9b2 in add_files git/builtin/add.c:346:7
    #13 0x5651f321f9b2 in cmd_add git/builtin/add.c:565:18
    #14 0x5651f321d327 in run_builtin git/git.c:474:11
    #15 0x5651f321bc9e in handle_builtin git/git.c:729:3
    #16 0x5651f321a792 in run_argv git/git.c:793:4
    #17 0x5651f321a792 in cmd_main git/git.c:928:19
    #18 0x5651f33dde1f in main git/common-main.c:62:11

The issue exists because `size` is an output parameter from
`read_blob_data_from_index`, but it&#39;s only modified if
`read_blob_data_from_index` returns non-NULL. The read of `size` when
calling `read_attr_from_buf` unconditionally may read from an
uninitialized value. `read_attr_from_buf` checks that `buf` is non-NULL
before reading from `size`, but by then it&#39;s already too late: the
uninitialized read will have happened already. Furthermore, there&#39;s no
guarantee that the compiler won&#39;t reorder things so that it checks
`size` before checking `!buf`.

Make the call to `read_attr_from_buf` conditional on `buf` being
non-NULL, ensuring that `size` is not read if it&#39;s never set.

Signed-off-by: Kyle Lippincott &lt;spectral@google.com&gt;
---
    attr: fix msan issue in read_attr_from_index

Published-As: <a
href="https://github.com/gitgitgadget/git/releases/tag/pr-1747%2Fspectral54%2Fmsan-attr-v1">https://github.com/gitgitgadget/git/releases/tag/pr-1747%2Fspectral54%2Fmsan-attr-v1</a>
Fetch-It-Via: git fetch <a
href="https://github.com/gitgitgadget/git">https://github.com/gitgitgadget/git</a> pr-1747/spectral54/msan-attr-v1
Pull-Request: <a
href="https://github.com/gitgitgadget/git/pull/1747">https://github.com/gitgitgadget/git/pull/1747</a>

 attr.c | 3 ++-
 1 file <a href="http://lore.kernel.org/git/pull.1747.git.1718654424683.gitgitgadget@gmail.com/#related">changed</a>, 2 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/attr.c b/attr.c
index 300f994ba6e..a2e0775f7e5 100644
--- a/attr.c
+++ b/attr.c
</span><span
class="hunk">@@ -865,7 +865,8 @@ static struct attr_stack *read_attr_from_index(struct index_state *istate,
</span> 		stack = read_attr_from_blob(istate, &#38;istate-&gt;cache[sparse_dir_pos]-&gt;oid, relative_path, flags);
 	} else {
 		buf = read_blob_data_from_index(istate, path, &#38;size);
<span
class="del">-		stack = read_attr_from_buf(buf, size, path, flags);
</span><span
class="add">+		if (buf)
+			stack = read_attr_from_buf(buf, size, path, flags);
</span> 	}
 	return stack;
 }

base-commit: 8d94cfb54504f2ec9edc7ca3eb5c29a3dd3675ae
-- 
gitgitgadget
</pre></div></content></entry><entry><author><name>Xing Xin via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v7 3/3] unbundle: extend object verification for fetches</title><updated>2024-06-17T13:55:43Z</updated><link
href="http://lore.kernel.org/git/2f15099bbb9fed4919e829274b7683ace9094d15.1718632536.git.gitgitgadget@gmail.com/"/><id>urn:uuid:ec9c9459-788d-3d8f-64cd-9c5ad7a20546</id><thr:in-reply-to
ref="urn:uuid:a88ab440-4a6d-0645-abb8-1c780348e756"
href="http://lore.kernel.org/git/pull.1730.v7.git.1718632535.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Xing Xin &lt;xingxin.xx@bytedance.com&gt;

The existing fetch.fsckObjects and transfer.fsckObjects configurations
were not fully applied to bundle-involved fetches, including direct
bundle fetches and bundle-uri enabled fetches. Furthermore, there was no
object verification support for unbundle.

This commit extends object verification support in `bundle.c:unbundle`
by adding the `VERIFY_BUNDLE_FSCK` option to `verify_bundle_flags`. When
this option is enabled, we append the `--fsck-objects` flag to
`git-index-pack`.

The `VERIFY_BUNDLE_FSCK` option is now used by bundle-involved fetches,
where we use `fetch-pack.c:fetch_pack_fsck_objects` to determine whether
to enable this option for `bundle.c:unbundle`, specifically in:

- `transport.c:fetch_refs_from_bundle` for direct bundle fetches.
- `bundle-uri.c:unbundle_from_file` for bundle-uri enabled fetches.

This addition ensures a consistent logic for object verification during
fetches. Tests have been added to confirm functionality in the scenarios
mentioned above.

Reviewed-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Signed-off-by: Xing Xin &lt;xingxin.xx@bytedance.com&gt;
---
 bundle-uri.c                |  3 ++-
 bundle.c                    |  3 +++
 bundle.h                    |  1 +
 t/t5558-clone-bundle-uri.sh | 33 ++++++++++++++++++++++++++++++++-
 t/t5607-clone-bundle.sh     | 33 +++++++++++++++++++++++++++++++++
 transport.c                 |  3 ++-
 6 files <a href="http://lore.kernel.org/git/2f15099bbb9fed4919e829274b7683ace9094d15.1718632536.git.gitgitgadget@gmail.com/#related">changed</a>, 73 insertions(+), 3 deletions(-)

<span
class="head">diff --git a/bundle-uri.c b/bundle-uri.c
index 65666a11d9c..ed9b49fdbc1 100644
--- a/bundle-uri.c
+++ b/bundle-uri.c
</span><span
class="hunk">@@ -9,6 +9,7 @@
</span> #include &#34;hashmap.h&#34;
 #include &#34;pkt-line.h&#34;
 #include &#34;config.h&#34;
<span
class="add">+#include &#34;fetch-pack.h&#34;
</span> #include &#34;remote.h&#34;
 
 static struct {
<span
class="hunk">@@ -373,7 +374,7 @@ static int unbundle_from_file(struct repository *r, const char *file)
</span> 	 * the prerequisite commits.
 	 */
 	if ((result = unbundle(r, &#38;header, bundle_fd, NULL,
<span
class="del">-			       VERIFY_BUNDLE_QUIET)))
</span><span
class="add">+			       VERIFY_BUNDLE_QUIET | (fetch_pack_fsck_objects() ? VERIFY_BUNDLE_FSCK : 0))))
</span> 		return 1;
 
 	/*
<span
class="head">diff --git a/bundle.c b/bundle.c
index 95367c2d0a0..f124a2a5626 100644
--- a/bundle.c
+++ b/bundle.c
</span><span
class="hunk">@@ -625,6 +625,9 @@ int unbundle(struct repository *r, struct bundle_header *header,
</span> 	if (header-&gt;filter.choice)
 		strvec_push(&#38;ip.args, &#34;--promisor=from-bundle&#34;);
 
<span
class="add">+	if (flags &#38; VERIFY_BUNDLE_FSCK)
+		strvec_push(&#38;ip.args, &#34;--fsck-objects&#34;);
+
</span> 	if (extra_index_pack_args) {
 		strvec_pushv(&#38;ip.args, extra_index_pack_args-&gt;v);
 		strvec_clear(extra_index_pack_args);
<span
class="head">diff --git a/bundle.h b/bundle.h
index 021adbdcbb3..5ccc9a061a4 100644
--- a/bundle.h
+++ b/bundle.h
</span><span
class="hunk">@@ -33,6 +33,7 @@ int create_bundle(struct repository *r, const char *path,
</span> enum verify_bundle_flags {
 	VERIFY_BUNDLE_VERBOSE = (1 &lt;&lt; 0),
 	VERIFY_BUNDLE_QUIET = (1 &lt;&lt; 1),
<span
class="add">+	VERIFY_BUNDLE_FSCK = (1 &lt;&lt; 2),
</span> };
 
 int verify_bundle(struct repository *r, struct bundle_header *header,
<span
class="head">diff --git a/t/t5558-clone-bundle-uri.sh b/t/t5558-clone-bundle-uri.sh
index 2dcdd238a90..38a25d08d0a 100755
--- a/t/t5558-clone-bundle-uri.sh
+++ b/t/t5558-clone-bundle-uri.sh
</span><span
class="hunk">@@ -34,7 +34,21 @@ test_expect_success &#39;create bundle&#39; &#39;
</span> 		sed -e &#34;/^$/q&#34; -e &#34;s/$(git rev-parse A) /$(git rev-parse B) /&#34; \
 			&lt;A.bundle &gt;bad-header.bundle &#38;&#38;
 		convert_bundle_to_pack \
<span
class="del">-			&lt;A.bundle &gt;&gt;bad-header.bundle
</span><span
class="add">+			&lt;A.bundle &gt;&gt;bad-header.bundle &#38;&#38;
+
+		cat &gt;data &lt;&lt;-EOF &#38;&#38;
+		tree $(git rev-parse HEAD^{tree})
+		parent $(git rev-parse HEAD)
+		author A U Thor
+		committer A U Thor
+
+		commit: this is a commit with bad emails
+
+		EOF
+		git hash-object --literally -t commit -w --stdin &lt;data &gt;commit &#38;&#38;
+		git branch bad $(cat commit) &#38;&#38;
+		git bundle create bad-object.bundle bad &#38;&#38;
+		git update-ref -d refs/heads/bad
</span> 	)
 &#39;
 
<span
class="hunk">@@ -56,6 +70,23 @@ test_expect_success &#39;clone with bundle that has bad header&#39; &#39;
</span> 	! grep &#34;refs/bundles/&#34; refs
 &#39;
 
<span
class="add">+test_expect_success &#39;clone with bundle that has bad object&#39; &#39;
+	# Unbundle succeeds if no fsckObjects confugured.
+	git clone --bundle-uri=&#34;clone-from/bad-object.bundle&#34; \
+		clone-from clone-bad-object-no-fsck &#38;&#38;
+	git -C clone-bad-object-no-fsck for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
+	grep &#34;refs/bundles/&#34; refs &gt;actual &#38;&#38;
+	test_write_lines refs/bundles/bad &gt;expect &#38;&#38;
+	test_cmp expect actual &#38;&#38;
+
+	# Unbundle fails with fsckObjects set true, but clone can still proceed.
+	git -c fetch.fsckObjects=true clone --bundle-uri=&#34;clone-from/bad-object.bundle&#34; \
+		clone-from clone-bad-object-fsck 2&gt;err &#38;&#38;
+	test_grep &#34;missingEmail&#34; err &#38;&#38;
+	git -C clone-bad-object-fsck for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
+	! grep &#34;refs/bundles/&#34; refs
+&#39;
+
</span> test_expect_success &#39;clone with path bundle and non-default hash&#39; &#39;
 	test_when_finished &#34;rm -rf clone-path-non-default-hash&#34; &#38;&#38;
 	GIT_DEFAULT_HASH=sha256 git clone --bundle-uri=&#34;clone-from/B.bundle&#34; \
<span
class="head">diff --git a/t/t5607-clone-bundle.sh b/t/t5607-clone-bundle.sh
index 0d1e92d9963..5182efc0b45 100755
--- a/t/t5607-clone-bundle.sh
+++ b/t/t5607-clone-bundle.sh
</span><span
class="hunk">@@ -138,6 +138,39 @@ test_expect_success &#39;fetch SHA-1 from bundle&#39; &#39;
</span> 	git fetch --no-tags foo/tip.bundle &#34;$(cat hash)&#34;
 &#39;
 
<span
class="add">+test_expect_success &#39;clone bundle with different fsckObjects configurations&#39; &#39;
+	test_create_repo bundle-fsck &#38;&#38;
+	(
+		cd bundle-fsck &#38;&#38;
+		test_commit first &#38;&#38;
+		cat &gt;data &lt;&lt;-EOF &#38;&#38;
+		tree $(git rev-parse HEAD^{tree})
+		parent $(git rev-parse HEAD)
+		author A U Thor
+		committer A U Thor
+
+		commit: this is a commit with bad emails
+
+		EOF
+		git hash-object --literally -t commit -w --stdin &lt;data &gt;commit &#38;&#38;
+		git branch bad $(cat commit) &#38;&#38;
+		git bundle create bad.bundle bad
+	) &#38;&#38;
+
+	git clone bundle-fsck/bad.bundle bundle-no-fsck &#38;&#38;
+
+	git -c fetch.fsckObjects=false -c transfer.fsckObjects=true \
+		clone bundle-fsck/bad.bundle bundle-fetch-no-fsck &#38;&#38;
+
+	test_must_fail git -c fetch.fsckObjects=true \
+		clone bundle-fsck/bad.bundle bundle-fetch-fsck 2&gt;err &#38;&#38;
+	test_grep &#34;missingEmail&#34; err &#38;&#38;
+
+	test_must_fail git -c transfer.fsckObjects=true \
+		clone bundle-fsck/bad.bundle bundle-transfer-fsck 2&gt;err &#38;&#38;
+	test_grep &#34;missingEmail&#34; err
+&#39;
+
</span> test_expect_success &#39;git bundle uses expected default format&#39; &#39;
 	git bundle create bundle HEAD^.. &#38;&#38;
 	cat &gt;expect &lt;&lt;-EOF &#38;&#38;
<span
class="head">diff --git a/transport.c b/transport.c
index 0ad04b77fd2..a93c4171f7b 100644
--- a/transport.c
+++ b/transport.c
</span><span
class="hunk">@@ -184,7 +184,8 @@ static int fetch_refs_from_bundle(struct transport *transport,
</span> 	if (!data-&gt;get_refs_from_bundle_called)
 		get_refs_from_bundle_inner(transport);
 	ret = unbundle(the_repository, &#38;data-&gt;header, data-&gt;fd,
<span
class="del">-		       &#38;extra_index_pack_args, 0);
</span><span
class="add">+		       &#38;extra_index_pack_args,
+		       fetch_pack_fsck_objects() ? VERIFY_BUNDLE_FSCK : 0);
</span> 	transport-&gt;hash_algo = data-&gt;header.hash_algo;
 	return ret;
 }
-- 
gitgitgadget
</pre></div></content></entry><entry><author><name>Xing Xin via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v7 2/3] fetch-pack: expose fsckObjects configuration logic</title><updated>2024-06-17T13:55:42Z</updated><link
href="http://lore.kernel.org/git/3dc0d9dd22f64f79f7cddc453c43701f73f0e133.1718632536.git.gitgitgadget@gmail.com/"/><id>urn:uuid:98ffc288-e388-5895-1b96-277aa9af9790</id><thr:in-reply-to
ref="urn:uuid:a88ab440-4a6d-0645-abb8-1c780348e756"
href="http://lore.kernel.org/git/pull.1730.v7.git.1718632535.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Xing Xin &lt;xingxin.xx@bytedance.com&gt;

Currently, we can use &#34;transfer.fsckObjects&#34; and the more specific
&#34;fetch.fsckObjects&#34; to control checks for broken objects in received
packs during fetches. However, these configurations were only
acknowledged by `fetch-pack.c:get_pack` and did not take effect in
direct bundle fetches and fetches with _bundle-uri_ enabled.

This commit exposes the fetch-then-transfer configuration logic by
adding a new function `fetch_pack_fsck_objects` in fetch-pack.h. This
new function is used to replace the assignment for `fsck_objects` in
`fetch-pack.c:get_pack`. In the next commit, it will also be used by
`bundle.c:unbundle` to better fit fetching scenarios.

Helped-by: Junio C Hamano &lt;gitster@pobox.com&gt;
Helped-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Signed-off-by: Xing Xin &lt;xingxin.xx@bytedance.com&gt;
---
 fetch-pack.c | 17 +++++++++++------
 fetch-pack.h |  5 +++++
 2 files <a href="http://lore.kernel.org/git/3dc0d9dd22f64f79f7cddc453c43701f73f0e133.1718632536.git.gitgitgadget@gmail.com/#related">changed</a>, 16 insertions(+), 6 deletions(-)

<span
class="head">diff --git a/fetch-pack.c b/fetch-pack.c
index 7d2aef21add..3acff2baf09 100644
--- a/fetch-pack.c
+++ b/fetch-pack.c
</span><span
class="hunk">@@ -954,12 +954,7 @@ static int get_pack(struct fetch_pack_args *args,
</span> 		strvec_push(&#38;cmd.args, alternate_shallow_file);
 	}
 
<span
class="del">-	if (fetch_fsck_objects &gt;= 0
-	    ? fetch_fsck_objects
-	    : transfer_fsck_objects &gt;= 0
-	    ? transfer_fsck_objects
-	    : 0)
-		fsck_objects = 1;
</span><span
class="add">+	fsck_objects = fetch_pack_fsck_objects();
</span> 
 	if (do_keep || args-&gt;from_promisor || index_pack_args || fsck_objects) {
 		if (pack_lockfiles || fsck_objects)
<span
class="hunk">@@ -2046,6 +2041,16 @@ static const struct object_id *iterate_ref_map(void *cb_data)
</span> 	return &#38;ref-&gt;old_oid;
 }
 
<span
class="add">+int fetch_pack_fsck_objects(void)
+{
+	fetch_pack_setup();
+	if (fetch_fsck_objects &gt;= 0)
+		return fetch_fsck_objects;
+	if (transfer_fsck_objects &gt;= 0)
+		return transfer_fsck_objects;
+	return 0;
+}
+
</span> struct ref *fetch_pack(struct fetch_pack_args *args,
 		       int fd[],
 		       const struct ref *ref,
<span
class="head">diff --git a/fetch-pack.h b/fetch-pack.h
index 6775d265175..b5c579cdae2 100644
--- a/fetch-pack.h
+++ b/fetch-pack.h
</span><span
class="hunk">@@ -101,4 +101,9 @@ void negotiate_using_fetch(const struct oid_array *negotiation_tips,
</span>  */
 int report_unmatched_refs(struct ref **sought, int nr_sought);
 
<span
class="add">+/*
+ * Return true if checks for broken objects in received pack are required.
+ */
+int fetch_pack_fsck_objects(void);
+
</span> #endif
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Xing Xin via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v7 1/3] bundle-uri: verify oid before writing refs</title><updated>2024-06-17T13:55:40Z</updated><link
href="http://lore.kernel.org/git/fc9f44fda0032ab1e5ee0c9bcc2886ddb8e17722.1718632536.git.gitgitgadget@gmail.com/"/><id>urn:uuid:af7aea62-1195-5574-88fe-b27c5c1a21f0</id><thr:in-reply-to
ref="urn:uuid:a88ab440-4a6d-0645-abb8-1c780348e756"
href="http://lore.kernel.org/git/pull.1730.v7.git.1718632535.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Xing Xin &lt;xingxin.xx@bytedance.com&gt;

When using the bundle-uri mechanism with a bundle list containing
multiple interrelated bundles, we encountered a bug where tips from
downloaded bundles were not discovered, thus resulting in rather slow
clones. This was particularly problematic when employing the
&#34;creationTokens&#34; heuristic.

To reproduce this issue, consider a repository with a single branch
&#34;main&#34; pointing to commit &#34;A&#34;. Firstly, create a base bundle with:

  git bundle create base.bundle main

Then, add a new commit &#34;B&#34; on top of &#34;A&#34;, and create an incremental
bundle for &#34;main&#34;:

  git bundle create incr.bundle A..main

Now, generate a bundle list with the following content:

  [bundle]
      version = 1
      mode = all
      heuristic = creationToken

  [bundle &#34;base&#34;]
      uri = base.bundle
      creationToken = 1

  [bundle &#34;incr&#34;]
      uri = incr.bundle
      creationToken = 2

A fresh clone with the bundle list above should result in a reference
&#34;refs/bundles/main&#34; pointing to &#34;B&#34; in the new repository. However, git
would still download everything from the server, as if it had fetched
nothing locally.

So why the &#34;refs/bundles/main&#34; is not discovered? After some digging I
found that:

1. Bundles in bundle list are downloaded to local files via
   `bundle-uri.c:download_bundle_list` or via
   `bundle-uri.c:fetch_bundles_by_token` for the &#34;creationToken&#34;
   heuristic.
2. Each bundle is unbundled via `bundle-uri.c:unbundle_from_file`, which
   is called by `bundle-uri.c:unbundle_all_bundles` or called within
   `bundle-uri.c:fetch_bundles_by_token` for the &#34;creationToken&#34;
   heuristic.
3. To get all prerequisites of the bundle, the bundle header is read
   inside `bundle-uri.c:unbundle_from_file` to by calling
   `bundle.c:read_bundle_header`.
4. Then it calls `bundle.c:unbundle`, which calls
   `bundle.c:verify_bundle` to ensure the repository contains all the
   prerequisites.
5. `bundle.c:verify_bundle` calls `parse_object`, which eventually
   invokes `packfile.c:prepare_packed_git` or
   `packfile.c:reprepare_packed_git`, filling
   `raw_object_store-&gt;packed_git` and setting `packed_git_initialized`.
6. If `bundle.c:unbundle` succeeds, it writes refs via
   `refs.c:refs_update_ref` with `REF_SKIP_OID_VERIFICATION` set. Here
   bundle refs which can target arbitrary objects are written to the
   repository.
7. Finally, in `fetch-pack.c:do_fetch_pack_v2`, the functions
   `fetch-pack.c:mark_complete_and_common_ref` and
   `fetch-pack.c:mark_tips` are called with `OBJECT_INFO_QUICK` set to
   find local tips for negotiation. The `OBJECT_INFO_QUICK` flag
   prevents `packfile.c:reprepare_packed_git` from being called,
   resulting in failures to parse OIDs that reside only in the latest
   bundle.

In the example above, when unbunding &#34;incr.bundle&#34;, &#34;base.pack&#34; is added
to `packed_git` due to prerequisites verification. However, &#34;B&#34; cannot
be found for negotiation because it exists in &#34;incr.pack&#34;, which is not
included in `packed_git`.

Fix the bug by removing `REF_SKIP_OID_VERIFICATION` flag when writing
bundle refs. When `refs.c:refs_update_ref` is called to write the
corresponding bundle refs, it triggers `refs.c:ref_transaction_commit`.
This, in turn, invokes `refs.c:ref_transaction_prepare`, which calls
`transaction_prepare` of the refs storage backend. For files backend, it
is `files-backend.c:files_transaction_prepare`, and for reftable
backend, it is `reftable-backend.c:reftable_be_transaction_prepare`.
Both functions eventually call `object.c:parse_object`, which can invoke
`packfile.c:reprepare_packed_git` to refresh `packed_git`. This ensures
that bundle refs point to valid objects and that all tips from bundle
refs are correctly parsed during subsequent negotiations.

A set of negotiation-related tests for cloning with bundle-uri has been
included to demonstrate that downloaded bundles are utilized to
accelerate fetching.

Additionally, another test has been added to show that bundles with
incorrect headers, where refs point to non-existent objects, do not
result in any bundle refs being created in the repository.

Reviewed-by: Karthik Nayak &lt;karthik.188@gmail.com&gt;
Reviewed-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Signed-off-by: Xing Xin &lt;xingxin.xx@bytedance.com&gt;
---
 bundle-uri.c                |   3 +-
 t/t5558-clone-bundle-uri.sh | 150 +++++++++++++++++++++++++++++++++++-
 2 files <a href="http://lore.kernel.org/git/fc9f44fda0032ab1e5ee0c9bcc2886ddb8e17722.1718632536.git.gitgitgadget@gmail.com/#related">changed</a>, 147 insertions(+), 6 deletions(-)

<span
class="head">diff --git a/bundle-uri.c b/bundle-uri.c
index 91b3319a5c1..65666a11d9c 100644
--- a/bundle-uri.c
+++ b/bundle-uri.c
</span><span
class="hunk">@@ -400,8 +400,7 @@ static int unbundle_from_file(struct repository *r, const char *file)
</span> 		refs_update_ref(get_main_ref_store(the_repository),
 				&#34;fetched bundle&#34;, bundle_ref.buf, oid,
 				has_old ? &#38;old_oid : NULL,
<span
class="del">-				REF_SKIP_OID_VERIFICATION,
-				UPDATE_REFS_MSG_ON_ERR);
</span><span
class="add">+				0, UPDATE_REFS_MSG_ON_ERR);
</span> 	}
 
 	bundle_header_release(&#38;header);
<span
class="head">diff --git a/t/t5558-clone-bundle-uri.sh b/t/t5558-clone-bundle-uri.sh
index 1ca5f745e73..2dcdd238a90 100755
--- a/t/t5558-clone-bundle-uri.sh
+++ b/t/t5558-clone-bundle-uri.sh
</span><span
class="hunk">@@ -3,6 +3,7 @@
</span> test_description=&#39;test fetching bundles with --bundle-uri&#39;
 
 . ./test-lib.sh
<span
class="add">+. &#34;$TEST_DIRECTORY&#34;/lib-bundle.sh
</span> 
 test_expect_success &#39;fail to clone from non-existent file&#39; &#39;
 	test_when_finished rm -rf test &#38;&#38;
<span
class="hunk">@@ -19,10 +20,22 @@ test_expect_success &#39;fail to clone from non-bundle file&#39; &#39;
</span> 
 test_expect_success &#39;create bundle&#39; &#39;
 	git init clone-from &#38;&#38;
<span
class="del">-	git -C clone-from checkout -b topic &#38;&#38;
-	test_commit -C clone-from A &#38;&#38;
-	test_commit -C clone-from B &#38;&#38;
-	git -C clone-from bundle create B.bundle topic
</span><span
class="add">+	(
+		cd clone-from &#38;&#38;
+		git checkout -b topic &#38;&#38;
+
+		test_commit A &#38;&#38;
+		git bundle create A.bundle topic &#38;&#38;
+
+		test_commit B &#38;&#38;
+		git bundle create B.bundle topic &#38;&#38;
+
+		# Create a bundle with reference pointing to non-existent object.
+		sed -e &#34;/^$/q&#34; -e &#34;s/$(git rev-parse A) /$(git rev-parse B) /&#34; \
+			&lt;A.bundle &gt;bad-header.bundle &#38;&#38;
+		convert_bundle_to_pack \
+			&lt;A.bundle &gt;&gt;bad-header.bundle
+	)
</span> &#39;
 
 test_expect_success &#39;clone with path bundle&#39; &#39;
<span
class="hunk">@@ -33,6 +46,16 @@ test_expect_success &#39;clone with path bundle&#39; &#39;
</span> 	test_cmp expect actual
 &#39;
 
<span
class="add">+test_expect_success &#39;clone with bundle that has bad header&#39; &#39;
+	# Write bundle ref fails, but clone can still proceed.
+	git clone --bundle-uri=&#34;clone-from/bad-header.bundle&#34; \
+		clone-from clone-bad-header 2&gt;err &#38;&#38;
+	commit_b=$(git -C clone-from rev-parse B) &#38;&#38;
+	test_grep &#34;trying to write ref &#39;\&#39;&#39;refs/bundles/topic&#39;\&#39;&#39; with nonexistent object $commit_b&#34; err &#38;&#38;
+	git -C clone-bad-header for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
+	! grep &#34;refs/bundles/&#34; refs
+&#39;
+
</span> test_expect_success &#39;clone with path bundle and non-default hash&#39; &#39;
 	test_when_finished &#34;rm -rf clone-path-non-default-hash&#34; &#38;&#38;
 	GIT_DEFAULT_HASH=sha256 git clone --bundle-uri=&#34;clone-from/B.bundle&#34; \
<span
class="hunk">@@ -259,6 +282,125 @@ test_expect_success &#39;clone bundle list (file, any mode, all failures)&#39; &#39;
</span> 	! grep &#34;refs/bundles/&#34; refs
 &#39;
 
<span
class="add">+test_expect_success &#39;negotiation: bundle with part of wanted commits&#39; &#39;
+	test_when_finished &#34;rm -f trace*.txt&#34; &#38;&#38;
+	GIT_TRACE_PACKET=&#34;$(pwd)/trace-packet.txt&#34; \
+	git clone --no-local --bundle-uri=&#34;clone-from/A.bundle&#34; \
+		clone-from nego-bundle-part &#38;&#38;
+	git -C nego-bundle-part for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
+	grep &#34;refs/bundles/&#34; refs &gt;actual &#38;&#38;
+	test_write_lines refs/bundles/topic &gt;expect &#38;&#38;
+	test_cmp expect actual &#38;&#38;
+	# Ensure that refs/bundles/topic are sent as &#34;have&#34;.
+	test_grep &#34;clone&gt; have $(git -C clone-from rev-parse A)&#34; trace-packet.txt
+&#39;
+
+test_expect_success &#39;negotiation: bundle with all wanted commits&#39; &#39;
+	test_when_finished &#34;rm -f trace*.txt&#34; &#38;&#38;
+	GIT_TRACE_PACKET=&#34;$(pwd)/trace-packet.txt&#34; \
+	git clone --no-local --single-branch --branch=topic --no-tags \
+		--bundle-uri=&#34;clone-from/B.bundle&#34; \
+		clone-from nego-bundle-all &#38;&#38;
+	git -C nego-bundle-all for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
+	grep &#34;refs/bundles/&#34; refs &gt;actual &#38;&#38;
+	test_write_lines refs/bundles/topic &gt;expect &#38;&#38;
+	test_cmp expect actual &#38;&#38;
+	# We already have all needed commits so no &#34;want&#34; needed.
+	! grep &#34;clone&gt; want &#34; trace-packet.txt
+&#39;
+
+test_expect_success &#39;negotiation: bundle list (no heuristic)&#39; &#39;
+	test_when_finished &#34;rm -f trace*.txt&#34; &#38;&#38;
+	cat &gt;bundle-list &lt;&lt;-EOF &#38;&#38;
+	[bundle]
+		version = 1
+		mode = all
+
+	[bundle &#34;bundle-1&#34;]
+		uri = file://$(pwd)/clone-from/bundle-1.bundle
+
+	[bundle &#34;bundle-2&#34;]
+		uri = file://$(pwd)/clone-from/bundle-2.bundle
+	EOF
+
+	GIT_TRACE_PACKET=&#34;$(pwd)/trace-packet.txt&#34; \
+	git clone --no-local --bundle-uri=&#34;file://$(pwd)/bundle-list&#34; \
+		clone-from nego-bundle-list-no-heuristic &#38;&#38;
+
+	git -C nego-bundle-list-no-heuristic for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
+	grep &#34;refs/bundles/&#34; refs &gt;actual &#38;&#38;
+	cat &gt;expect &lt;&lt;-\EOF &#38;&#38;
+	refs/bundles/base
+	refs/bundles/left
+	EOF
+	test_cmp expect actual &#38;&#38;
+	test_grep &#34;clone&gt; have $(git -C nego-bundle-list-no-heuristic rev-parse refs/bundles/left)&#34; trace-packet.txt
+&#39;
+
+test_expect_success &#39;negotiation: bundle list (creationToken)&#39; &#39;
+	test_when_finished &#34;rm -f trace*.txt&#34; &#38;&#38;
+	cat &gt;bundle-list &lt;&lt;-EOF &#38;&#38;
+	[bundle]
+		version = 1
+		mode = all
+		heuristic = creationToken
+
+	[bundle &#34;bundle-1&#34;]
+		uri = file://$(pwd)/clone-from/bundle-1.bundle
+		creationToken = 1
+
+	[bundle &#34;bundle-2&#34;]
+		uri = file://$(pwd)/clone-from/bundle-2.bundle
+		creationToken = 2
+	EOF
+
+	GIT_TRACE_PACKET=&#34;$(pwd)/trace-packet.txt&#34; \
+	git clone --no-local --bundle-uri=&#34;file://$(pwd)/bundle-list&#34; \
+		clone-from nego-bundle-list-heuristic &#38;&#38;
+
+	git -C nego-bundle-list-heuristic for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
+	grep &#34;refs/bundles/&#34; refs &gt;actual &#38;&#38;
+	cat &gt;expect &lt;&lt;-\EOF &#38;&#38;
+	refs/bundles/base
+	refs/bundles/left
+	EOF
+	test_cmp expect actual &#38;&#38;
+	test_grep &#34;clone&gt; have $(git -C nego-bundle-list-heuristic rev-parse refs/bundles/left)&#34; trace-packet.txt
+&#39;
+
+test_expect_success &#39;negotiation: bundle list with all wanted commits&#39; &#39;
+	test_when_finished &#34;rm -f trace*.txt&#34; &#38;&#38;
+	cat &gt;bundle-list &lt;&lt;-EOF &#38;&#38;
+	[bundle]
+		version = 1
+		mode = all
+		heuristic = creationToken
+
+	[bundle &#34;bundle-1&#34;]
+		uri = file://$(pwd)/clone-from/bundle-1.bundle
+		creationToken = 1
+
+	[bundle &#34;bundle-2&#34;]
+		uri = file://$(pwd)/clone-from/bundle-2.bundle
+		creationToken = 2
+	EOF
+
+	GIT_TRACE_PACKET=&#34;$(pwd)/trace-packet.txt&#34; \
+	git clone --no-local --single-branch --branch=left --no-tags \
+		--bundle-uri=&#34;file://$(pwd)/bundle-list&#34; \
+		clone-from nego-bundle-list-all &#38;&#38;
+
+	git -C nego-bundle-list-all for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
+	grep &#34;refs/bundles/&#34; refs &gt;actual &#38;&#38;
+	cat &gt;expect &lt;&lt;-\EOF &#38;&#38;
+	refs/bundles/base
+	refs/bundles/left
+	EOF
+	test_cmp expect actual &#38;&#38;
+	# We already have all needed commits so no &#34;want&#34; needed.
+	! grep &#34;clone&gt; want &#34; trace-packet.txt
+&#39;
+
</span> #########################################################################
 # HTTP tests begin here
 
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>blanet via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v7 0/3] object checking related additions and fixes for bundles in fetches</title><updated>2024-06-17T13:55:40Z</updated><link
href="http://lore.kernel.org/git/pull.1730.v7.git.1718632535.gitgitgadget@gmail.com/"/><id>urn:uuid:a88ab440-4a6d-0645-abb8-1c780348e756</id><thr:in-reply-to
ref="urn:uuid:db64910f-9725-3df2-93a1-4a5e13cd0441"
href="http://lore.kernel.org/git/pull.1730.v6.git.1718109943.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">While attempting to fix a reference negotiation bug in bundle-uri, we
identified that the fetch process lacks some crucial object validation
checks when processing bundles. The primary issues are:

 1. In the bundle-uri scenario, object IDs were not validated before writing
    bundle references. This was the root cause of the original negotiation
    bug in bundle-uri and could lead to potential repository corruption.
 2. The existing &#34;fetch.fsckObjects&#34; and &#34;transfer.fsckObjects&#34;
    configurations were not applied when directly fetching bundles or
    fetching with bundle-uri enabled. In fact, there were no object
    validation supports for unbundle.

The first patch addresses the bundle-uri negotiation issue by removing the
REF_SKIP_OID_VERIFICATION flag when writing bundle references.

Patches 2 through 3 extend verify_bundle_flags for bundle.c:unbundle to add
support for object validation (fsck) in fetch scenarios, mainly following
the suggestions from Junio and Patrick on the mailing list.

Xing Xin (3):
  bundle-uri: verify oid before writing refs
  fetch-pack: expose fsckObjects configuration logic
  unbundle: extend object verification for fetches

 bundle-uri.c                |   6 +-
 bundle.c                    |   3 +
 bundle.h                    |   1 +
 fetch-pack.c                |  17 ++--
 fetch-pack.h                |   5 +
 t/t5558-clone-bundle-uri.sh | 181 +++++++++++++++++++++++++++++++++++-
 t/t5607-clone-bundle.sh     |  33 +++++++
 transport.c                 |   3 +-
 8 files changed, 235 insertions(+), 14 deletions(-)


base-commit: b9cfe4845cb2562584837bc0101c0ab76490a239
Published-As: <a
href="https://github.com/gitgitgadget/git/releases/tag/pr-1730%2Fblanet%2Fxx%2Fbundle-uri-bug-using-bundle-list-v7">https://github.com/gitgitgadget/git/releases/tag/pr-1730%2Fblanet%2Fxx%2Fbundle-uri-bug-using-bundle-list-v7</a>
Fetch-It-Via: git fetch <a
href="https://github.com/gitgitgadget/git">https://github.com/gitgitgadget/git</a> pr-1730/blanet/xx/bundle-uri-bug-using-bundle-list-v7
Pull-Request: <a
href="https://github.com/gitgitgadget/git/pull/1730">https://github.com/gitgitgadget/git/pull/1730</a>

Range-diff vs v6:

 1:  e958a3ab20c ! 1:  fc9f44fda00 bundle-uri: verify oid before writing refs
     @@ Commit message
          be found for negotiation because it exists in &#34;incr.pack&#34;, which is not
          included in `packed_git`.
      
     -    This commit fixes the bug by removing `REF_SKIP_OID_VERIFICATION` flag
     -    when writing bundle refs. When `refs.c:refs_update_ref` is called to to
     -    write the corresponding bundle refs, it triggers
     -    `refs.c:ref_transaction_commit`.  This, in turn, invokes
     -    `refs.c:ref_transaction_prepare`, which calls `transaction_prepare` of
     -    the refs storage backend. For files backend, this function is
     -    `files-backend.c:files_transaction_prepare`, and for reftable backend,
     -    it is `reftable-backend.c:reftable_be_transaction_prepare`. Both
     -    functions eventually call `object.c:parse_object`, which can invoke
     +    Fix the bug by removing `REF_SKIP_OID_VERIFICATION` flag when writing
     +    bundle refs. When `refs.c:refs_update_ref` is called to write the
     +    corresponding bundle refs, it triggers `refs.c:ref_transaction_commit`.
     +    This, in turn, invokes `refs.c:ref_transaction_prepare`, which calls
     +    `transaction_prepare` of the refs storage backend. For files backend, it
     +    is `files-backend.c:files_transaction_prepare`, and for reftable
     +    backend, it is `reftable-backend.c:reftable_be_transaction_prepare`.
     +    Both functions eventually call `object.c:parse_object`, which can invoke
          `packfile.c:reprepare_packed_git` to refresh `packed_git`. This ensures
          that bundle refs point to valid objects and that all tips from bundle
          refs are correctly parsed during subsequent negotiations.
      
     -    A test has been added to demonstrate that bundles with incorrect
     -    headers, where refs point to non-existent objects, do not result in any
     -    bundle refs being created in the repository. Additionally, a set of
     -    negotiation-related tests for fetching with bundle-uri has been
     -    included.
     +    A set of negotiation-related tests for cloning with bundle-uri has been
     +    included to demonstrate that downloaded bundles are utilized to
     +    accelerate fetching.
     +
     +    Additionally, another test has been added to show that bundles with
     +    incorrect headers, where refs point to non-existent objects, do not
     +    result in any bundle refs being created in the repository.
      
          Reviewed-by: Karthik Nayak &lt;karthik.188@gmail.com&gt;
          Reviewed-by: Patrick Steinhardt &lt;ps@pks.im&gt;
     @@ bundle-uri.c: static int unbundle_from_file(struct repository *r, const char *fi
       	bundle_header_release(&#38;header);
      
       ## t/t5558-clone-bundle-uri.sh ##
     +@@
     + test_description=&#39;test fetching bundles with --bundle-uri&#39;
     + 
     + . ./test-lib.sh
     ++. &#34;$TEST_DIRECTORY&#34;/lib-bundle.sh
     + 
     + test_expect_success &#39;fail to clone from non-existent file&#39; &#39;
     + 	test_when_finished rm -rf test &#38;&#38;
      @@ t/t5558-clone-bundle-uri.sh: test_expect_success &#39;fail to clone from non-bundle file&#39; &#39;
       
       test_expect_success &#39;create bundle&#39; &#39;
     @@ t/t5558-clone-bundle-uri.sh: test_expect_success &#39;fail to clone from non-bundle
      +		git bundle create B.bundle topic &#38;&#38;
      +
      +		# Create a bundle with reference pointing to non-existent object.
     -+		sed &#34;s/$(git rev-parse A)/$(git rev-parse B)/&#34; &lt;A.bundle &gt;bad-header.bundle
     ++		sed -e &#34;/^$/q&#34; -e &#34;s/$(git rev-parse A) /$(git rev-parse B) /&#34; \
     ++			&lt;A.bundle &gt;bad-header.bundle &#38;&#38;
     ++		convert_bundle_to_pack \
     ++			&lt;A.bundle &gt;&gt;bad-header.bundle
      +	)
       &#39;
       
     @@ t/t5558-clone-bundle-uri.sh: test_expect_success &#39;clone with path bundle&#39; &#39;
       &#39;
       
      +test_expect_success &#39;clone with bundle that has bad header&#39; &#39;
     ++	# Write bundle ref fails, but clone can still proceed.
      +	git clone --bundle-uri=&#34;clone-from/bad-header.bundle&#34; \
      +		clone-from clone-bad-header 2&gt;err &#38;&#38;
     -+	# Write bundle ref fails, but clone can still proceed.
      +	commit_b=$(git -C clone-from rev-parse B) &#38;&#38;
      +	test_grep &#34;trying to write ref &#39;\&#39;&#39;refs/bundles/topic&#39;\&#39;&#39; with nonexistent object $commit_b&#34; err &#38;&#38;
      +	git -C clone-bad-header for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
     @@ t/t5558-clone-bundle-uri.sh: test_expect_success &#39;clone bundle list (file, any m
       	! grep &#34;refs/bundles/&#34; refs
       &#39;
       
     -+#########################################################################
     -+# Clone negotiation related tests begin here
     -+
      +test_expect_success &#39;negotiation: bundle with part of wanted commits&#39; &#39;
     -+	test_when_finished rm -rf trace*.txt &#38;&#38;
     ++	test_when_finished &#34;rm -f trace*.txt&#34; &#38;&#38;
      +	GIT_TRACE_PACKET=&#34;$(pwd)/trace-packet.txt&#34; \
      +	git clone --no-local --bundle-uri=&#34;clone-from/A.bundle&#34; \
      +		clone-from nego-bundle-part &#38;&#38;
      +	git -C nego-bundle-part for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
      +	grep &#34;refs/bundles/&#34; refs &gt;actual &#38;&#38;
     -+	cat &gt;expect &lt;&lt;-\EOF &#38;&#38;
     -+	refs/bundles/topic
     -+	EOF
     ++	test_write_lines refs/bundles/topic &gt;expect &#38;&#38;
      +	test_cmp expect actual &#38;&#38;
      +	# Ensure that refs/bundles/topic are sent as &#34;have&#34;.
     -+	grep &#34;clone&gt; have $(git -C clone-from rev-parse A)&#34; trace-packet.txt
     ++	test_grep &#34;clone&gt; have $(git -C clone-from rev-parse A)&#34; trace-packet.txt
      +&#39;
      +
      +test_expect_success &#39;negotiation: bundle with all wanted commits&#39; &#39;
     -+	test_when_finished rm -rf trace*.txt &#38;&#38;
     ++	test_when_finished &#34;rm -f trace*.txt&#34; &#38;&#38;
      +	GIT_TRACE_PACKET=&#34;$(pwd)/trace-packet.txt&#34; \
      +	git clone --no-local --single-branch --branch=topic --no-tags \
      +		--bundle-uri=&#34;clone-from/B.bundle&#34; \
      +		clone-from nego-bundle-all &#38;&#38;
      +	git -C nego-bundle-all for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
      +	grep &#34;refs/bundles/&#34; refs &gt;actual &#38;&#38;
     -+	cat &gt;expect &lt;&lt;-\EOF &#38;&#38;
     -+	refs/bundles/topic
     -+	EOF
     ++	test_write_lines refs/bundles/topic &gt;expect &#38;&#38;
      +	test_cmp expect actual &#38;&#38;
      +	# We already have all needed commits so no &#34;want&#34; needed.
      +	! grep &#34;clone&gt; want &#34; trace-packet.txt
      +&#39;
      +
      +test_expect_success &#39;negotiation: bundle list (no heuristic)&#39; &#39;
     -+	test_when_finished rm -f trace*.txt &#38;&#38;
     ++	test_when_finished &#34;rm -f trace*.txt&#34; &#38;&#38;
      +	cat &gt;bundle-list &lt;&lt;-EOF &#38;&#38;
      +	[bundle]
      +		version = 1
     @@ t/t5558-clone-bundle-uri.sh: test_expect_success &#39;clone bundle list (file, any m
      +	refs/bundles/left
      +	EOF
      +	test_cmp expect actual &#38;&#38;
     -+	grep &#34;clone&gt; have $(git -C nego-bundle-list-no-heuristic rev-parse refs/bundles/left)&#34; trace-packet.txt
     ++	test_grep &#34;clone&gt; have $(git -C nego-bundle-list-no-heuristic rev-parse refs/bundles/left)&#34; trace-packet.txt
      +&#39;
      +
      +test_expect_success &#39;negotiation: bundle list (creationToken)&#39; &#39;
     -+	test_when_finished rm -f trace*.txt &#38;&#38;
     ++	test_when_finished &#34;rm -f trace*.txt&#34; &#38;&#38;
      +	cat &gt;bundle-list &lt;&lt;-EOF &#38;&#38;
      +	[bundle]
      +		version = 1
     @@ t/t5558-clone-bundle-uri.sh: test_expect_success &#39;clone bundle list (file, any m
      +	refs/bundles/left
      +	EOF
      +	test_cmp expect actual &#38;&#38;
     -+	grep &#34;clone&gt; have $(git -C nego-bundle-list-heuristic rev-parse refs/bundles/left)&#34; trace-packet.txt
     ++	test_grep &#34;clone&gt; have $(git -C nego-bundle-list-heuristic rev-parse refs/bundles/left)&#34; trace-packet.txt
      +&#39;
      +
      +test_expect_success &#39;negotiation: bundle list with all wanted commits&#39; &#39;
     -+	test_when_finished rm -f trace*.txt &#38;&#38;
     ++	test_when_finished &#34;rm -f trace*.txt&#34; &#38;&#38;
      +	cat &gt;bundle-list &lt;&lt;-EOF &#38;&#38;
      +	[bundle]
      +		version = 1
 2:  d21c236b8de = 2:  3dc0d9dd22f fetch-pack: expose fsckObjects configuration logic
 3:  53395e8c08a ! 3:  2f15099bbb9 unbundle: support object verification for fetches
     @@ Metadata
      Author: Xing Xin &lt;xingxin.xx@bytedance.com&gt;
      
       ## Commit message ##
     -    unbundle: support object verification for fetches
     +    unbundle: extend object verification for fetches
      
     -    This commit extends object verification support for fetches in
     -    `bundle.c:unbundle` by adding the `VERIFY_BUNDLE_FSCK_FOLLOW_FETCH`
     -    option to `verify_bundle_flags`. When this option is enabled,
     -    `bundle.c:unbundle` invokes `fetch-pack.c:fetch_pack_fsck_objects` to
     -    determine whether to append the &#34;--fsck-objects&#34; flag to
     -    &#34;git-index-pack&#34;.
     +    The existing fetch.fsckObjects and transfer.fsckObjects configurations
     +    were not fully applied to bundle-involved fetches, including direct
     +    bundle fetches and bundle-uri enabled fetches. Furthermore, there was no
     +    object verification support for unbundle.
      
     -    `VERIFY_BUNDLE_FSCK_FOLLOW_FETCH` is now passed to `unbundle` in the
     -    fetching process, including:
     +    This commit extends object verification support in `bundle.c:unbundle`
     +    by adding the `VERIFY_BUNDLE_FSCK` option to `verify_bundle_flags`. When
     +    this option is enabled, we append the `--fsck-objects` flag to
     +    `git-index-pack`.
     +
     +    The `VERIFY_BUNDLE_FSCK` option is now used by bundle-involved fetches,
     +    where we use `fetch-pack.c:fetch_pack_fsck_objects` to determine whether
     +    to enable this option for `bundle.c:unbundle`, specifically in:
      
          - `transport.c:fetch_refs_from_bundle` for direct bundle fetches.
          - `bundle-uri.c:unbundle_from_file` for bundle-uri enabled fetches.
      
          This addition ensures a consistent logic for object verification during
     -    fetch operations. Tests have been added to confirm functionality in the
     -    scenarios mentioned above.
     +    fetches. Tests have been added to confirm functionality in the scenarios
     +    mentioned above.
      
          Reviewed-by: Patrick Steinhardt &lt;ps@pks.im&gt;
          Signed-off-by: Xing Xin &lt;xingxin.xx@bytedance.com&gt;
      
       ## bundle-uri.c ##
     +@@
     + #include &#34;hashmap.h&#34;
     + #include &#34;pkt-line.h&#34;
     + #include &#34;config.h&#34;
     ++#include &#34;fetch-pack.h&#34;
     + #include &#34;remote.h&#34;
     + 
     + static struct {
      @@ bundle-uri.c: static int unbundle_from_file(struct repository *r, const char *file)
       	 * the prerequisite commits.
       	 */
       	if ((result = unbundle(r, &#38;header, bundle_fd, NULL,
      -			       VERIFY_BUNDLE_QUIET)))
     -+			       VERIFY_BUNDLE_QUIET | VERIFY_BUNDLE_FSCK_FOLLOW_FETCH)))
     ++			       VERIFY_BUNDLE_QUIET | (fetch_pack_fsck_objects() ? VERIFY_BUNDLE_FSCK : 0))))
       		return 1;
       
       	/*
      
       ## bundle.c ##
     -@@
     - #include &#34;list-objects-filter-options.h&#34;
     - #include &#34;connected.h&#34;
     - #include &#34;write-or-die.h&#34;
     -+#include &#34;fetch-pack.h&#34;
     - 
     - static const char v2_bundle_signature[] = &#34;# v2 git bundle\n&#34;;
     - static const char v3_bundle_signature[] = &#34;# v3 git bundle\n&#34;;
      @@ bundle.c: int unbundle(struct repository *r, struct bundle_header *header,
       	if (header-&gt;filter.choice)
       		strvec_push(&#38;ip.args, &#34;--promisor=from-bundle&#34;);
       
     -+	if (flags &#38; VERIFY_BUNDLE_FSCK_FOLLOW_FETCH)
     -+		if (fetch_pack_fsck_objects())
     -+			strvec_push(&#38;ip.args, &#34;--fsck-objects&#34;);
     ++	if (flags &#38; VERIFY_BUNDLE_FSCK)
     ++		strvec_push(&#38;ip.args, &#34;--fsck-objects&#34;);
      +
       	if (extra_index_pack_args) {
       		strvec_pushv(&#38;ip.args, extra_index_pack_args-&gt;v);
     @@ bundle.h: int create_bundle(struct repository *r, const char *path,
       enum verify_bundle_flags {
       	VERIFY_BUNDLE_VERBOSE = (1 &lt;&lt; 0),
       	VERIFY_BUNDLE_QUIET = (1 &lt;&lt; 1),
     -+	VERIFY_BUNDLE_FSCK_FOLLOW_FETCH = (1 &lt;&lt; 2),
     ++	VERIFY_BUNDLE_FSCK = (1 &lt;&lt; 2),
       };
       
       int verify_bundle(struct repository *r, struct bundle_header *header,
      
       ## t/t5558-clone-bundle-uri.sh ##
      @@ t/t5558-clone-bundle-uri.sh: test_expect_success &#39;create bundle&#39; &#39;
     - 		git bundle create B.bundle topic &#38;&#38;
     - 
     - 		# Create a bundle with reference pointing to non-existent object.
     --		sed &#34;s/$(git rev-parse A)/$(git rev-parse B)/&#34; &lt;A.bundle &gt;bad-header.bundle
     -+		sed &#34;s/$(git rev-parse A)/$(git rev-parse B)/&#34; &lt;A.bundle &gt;bad-header.bundle &#38;&#38;
     + 		sed -e &#34;/^$/q&#34; -e &#34;s/$(git rev-parse A) /$(git rev-parse B) /&#34; \
     + 			&lt;A.bundle &gt;bad-header.bundle &#38;&#38;
     + 		convert_bundle_to_pack \
     +-			&lt;A.bundle &gt;&gt;bad-header.bundle
     ++			&lt;A.bundle &gt;&gt;bad-header.bundle &#38;&#38;
      +
      +		cat &gt;data &lt;&lt;-EOF &#38;&#38;
      +		tree $(git rev-parse HEAD^{tree})
     @@ t/t5558-clone-bundle-uri.sh: test_expect_success &#39;clone with bundle that has bad
      +		clone-from clone-bad-object-no-fsck &#38;&#38;
      +	git -C clone-bad-object-no-fsck for-each-ref --format=&#34;%(refname)&#34; &gt;refs &#38;&#38;
      +	grep &#34;refs/bundles/&#34; refs &gt;actual &#38;&#38;
     -+	cat &gt;expect &lt;&lt;-\EOF &#38;&#38;
     -+	refs/bundles/bad
     -+	EOF
     ++	test_write_lines refs/bundles/bad &gt;expect &#38;&#38;
      +	test_cmp expect actual &#38;&#38;
      +
      +	# Unbundle fails with fsckObjects set true, but clone can still proceed.
     @@ transport.c: static int fetch_refs_from_bundle(struct transport *transport,
       		get_refs_from_bundle_inner(transport);
       	ret = unbundle(the_repository, &#38;data-&gt;header, data-&gt;fd,
      -		       &#38;extra_index_pack_args, 0);
     -+		       &#38;extra_index_pack_args, VERIFY_BUNDLE_FSCK_FOLLOW_FETCH);
     ++		       &#38;extra_index_pack_args,
     ++		       fetch_pack_fsck_objects() ? VERIFY_BUNDLE_FSCK : 0);
       	transport-&gt;hash_algo = data-&gt;header.hash_algo;
       	return ret;
       }

-- 
gitgitgadget
</pre></div></content></entry><entry><author><name>dark0dave via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH] submodule: allow gitsubmodules to be pointed at tags</title><updated>2024-06-17T12:01:51Z</updated><link
href="http://lore.kernel.org/git/pull.1703.git.git.1718625706679.gitgitgadget@gmail.com/"/><id>urn:uuid:ce71a430-014f-345d-e7a9-90f3d5e026a0</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: dark0dave &lt;dark0dave@mykolab.com&gt;

Intent: Enable git submodules to point at tags,
effectively freezing them

Context: There is a large repo with 50+ submodules, the goal is
to have some submodules update to HEAD but others to remain fixed.
The update command does this by recursing through
directories. This is very useful, however if an update is run,
all the submodules are updated to HEAD.

The goals:
- Be able to create a submodule from a fixed tag (complete)
- Be able to run git submodule update, with a flag to either update
or keep the submodule pointed at the supplied tag (complete)

Example:

git submodule add changes

git submodule add --tag v34.3
<a
href="https://github.com/Gibberlings3/SwordCoastStratagems.git">https://github.com/Gibberlings3/SwordCoastStratagems.git</a>
cat .gitmodules
[submodule &#34;SwordCoastStratagems&#34;]
  path = SwordCoastStratagems
  url = <a
href="https://github.com/Gibberlings3/SwordCoastStratagems.git">https://github.com/Gibberlings3/SwordCoastStratagems.git</a>
  tag = v34.3

git submodule update changes

git submodule update  --remote -f --checkout

No changes as we are fixed to the tag

git submodule update --remote -f --checkout --no-single-tag
Submodule path &#39;SwordCoastStratagems&#39;: checked out
&#39;77426a2e14dbe584af811f922a6da3a48d74c074&#39;

Checks out to HEAD of remote

CC: Revi Ewer &lt;revi.ewer@example.com&gt;,
Ill Takalook &lt;ill.takalook@example.net&gt;

Signed-off-by: dark0dave &lt;dark0dave@mykolab.com&gt;
---
    submodule: allow gitsubmodules to be pointed at tags @dark0dave
    
    I want to enable users freezing their submodules to a tag.
    
    Example:
    
    
    Add
    ===
    
    git submodule add changes
    
    git submodule add --tag v34.3 <a
href="https://github.com/Gibberlings3/SwordCoastStratagems.git">https://github.com/Gibberlings3/SwordCoastStratagems.git</a>
    cat .gitmodules
    [submodule &#34;SwordCoastStratagems&#34;]
      path = SwordCoastStratagems
      url = <a
href="https://github.com/Gibberlings3/SwordCoastStratagems.git">https://github.com/Gibberlings3/SwordCoastStratagems.git</a>
      tag = v34.3
    
    
    
    Update
    ======
    
    git submodule update changes
    
    
    Single tag
    ==========
    
    git submodule update  --remote -f --checkout
    $
    
    
    No changes as we are fixed to the tag
    
    
    No Single tag
    =============
    
    git submodule update --remote -f --checkout --no-single-tag
    Submodule path &#39;SwordCoastStratagems&#39;: checked out &#39;77426a2e14dbe584af811f922a6da3a48d74c074&#39;
    
    
    Checks out to HEAD of remote

Published-As: <a
href="https://github.com/gitgitgadget/git/releases/tag/pr-git-1703%2Fdark0dave%2Fmaster-v1">https://github.com/gitgitgadget/git/releases/tag/pr-git-1703%2Fdark0dave%2Fmaster-v1</a>
Fetch-It-Via: git fetch <a
href="https://github.com/gitgitgadget/git">https://github.com/gitgitgadget/git</a> pr-git-1703/dark0dave/master-v1
Pull-Request: <a
href="https://github.com/git/git/pull/1703">https://github.com/git/git/pull/1703</a>

 builtin/submodule--helper.c            | 119 +++++++++++++++++++++++--
 contrib/completion/git-completion.bash |   8 +-
 git-submodule.sh                       |  59 +++++++++++-
 submodule-config.c                     |  14 +++
 submodule-config.h                     |   1 +
 5 files <a href="http://lore.kernel.org/git/pull.1703.git.git.1718625706679.gitgitgadget@gmail.com/#related">changed</a>, 189 insertions(+), 12 deletions(-)

<span
class="head">diff --git a/builtin/submodule--helper.c b/builtin/submodule--helper.c
index 880ab4456ee..e7f150230e9 100644
--- a/builtin/submodule--helper.c
+++ b/builtin/submodule--helper.c
</span><span
class="hunk">@@ -1541,9 +1541,11 @@ struct module_clone_data {
</span> 	unsigned int dissociate: 1;
 	unsigned int require_init: 1;
 	int single_branch;
<span
class="add">+	int single_tag;
</span> };
 #define MODULE_CLONE_DATA_INIT { \
 	.single_branch = -1, \
<span
class="add">+	.single_tag = -1, \
</span> }
 
 struct submodule_alternate_setup {
<span
class="hunk">@@ -1754,6 +1756,10 @@ static int clone_submodule(const struct module_clone_data *clone_data,
</span> 			strvec_push(&#38;cp.args, clone_data-&gt;single_branch ?
 				    &#34;--single-branch&#34; :
 				    &#34;--no-single-branch&#34;);
<span
class="add">+		if (clone_data-&gt;single_tag &gt;= 0)
+			strvec_push(&#38;cp.args, clone_data-&gt;single_tag ?
+				    &#34;--single-branch&#34; :
+				    &#34;--no-single-branch&#34;);
</span> 
 		strvec_push(&#38;cp.args, &#34;--&#34;);
 		strvec_push(&#38;cp.args, clone_data-&gt;url);
<span
class="hunk">@@ -1981,6 +1987,7 @@ struct update_data {
</span> 	int depth;
 	int max_jobs;
 	int single_branch;
<span
class="add">+	int single_tag;
</span> 	int recommend_shallow;
 	unsigned int require_init;
 	unsigned int force;
<span
class="hunk">@@ -2004,6 +2011,7 @@ struct update_data {
</span> 	.recommend_shallow = -1, \
 	.references = STRING_LIST_INIT_DUP, \
 	.single_branch = -1, \
<span
class="add">+	.single_tag = -1, \
</span> 	.max_jobs = 1, \
 }
 
<span
class="hunk">@@ -2151,6 +2159,10 @@ static int prepare_to_clone_next_submodule(const struct cache_entry *ce,
</span> 		strvec_push(&#38;child-&gt;args, suc-&gt;update_data-&gt;single_branch ?
 					      &#34;--single-branch&#34; :
 					      &#34;--no-single-branch&#34;);
<span
class="add">+	if (suc-&gt;update_data-&gt;single_tag &gt;= 0)
+		strvec_push(&#38;child-&gt;args, suc-&gt;update_data-&gt;single_tag ?
+					      &#34;--single-tag&#34; :
+					      &#34;--no-single-tag&#34;);
</span> 
 cleanup:
 	free(displaypath);
<span
class="hunk">@@ -2297,6 +2309,7 @@ static int fetch_in_submodule(const char *module_path, int depth, int quiet,
</span> 	cp.dir = module_path;
 
 	strvec_push(&#38;cp.args, &#34;fetch&#34;);
<span
class="add">+
</span> 	if (quiet)
 		strvec_push(&#38;cp.args, &#34;--quiet&#34;);
 	if (depth)
<span
class="hunk">@@ -2434,6 +2447,30 @@ static int run_update_procedure(const struct update_data *ud)
</span> 	return run_update_command(ud, subforce);
 }
 
<span
class="add">+static int remote_submodule_tag(const char *path, const char **tag)
+{
+	const struct submodule *sub;
+	char *key;
+	*tag = NULL;
+
+	sub = submodule_from_path(the_repository, null_oid(), path);
+	if (!sub)
+		return die_message(_(&#34;could not initialize submodule at path &#39;%s&#39;&#34;),
+				   path);
+
+	key = xstrfmt(&#34;submodule.%s.tag&#34;, sub-&gt;name);
+	if (repo_config_get_string_tmp(the_repository, key, tag))
+		*tag = sub-&gt;tag;
+	free(key);
+
+	if (!*tag) {
+		/* No tag found */
+		return 1;
+	}
+
+	return 0;
+}
+
</span> static int remote_submodule_branch(const char *path, const char **branch)
 {
 	const struct submodule *sub;
<span
class="hunk">@@ -2579,6 +2616,10 @@ static void update_data_to_args(const struct update_data *update_data,
</span> 		strvec_push(args, update_data-&gt;single_branch ?
 				    &#34;--single-branch&#34; :
 				    &#34;--no-single-branch&#34;);
<span
class="add">+	if (update_data-&gt;single_tag &gt;= 0)
+		strvec_push(args, update_data-&gt;single_tag ?
+				    &#34;--single-branch&#34; :
+				    &#34;--no-single-branch&#34;);
</span> }
 
 static int update_submodule(struct update_data *update_data)
<span
class="hunk">@@ -2606,16 +2647,22 @@ static int update_submodule(struct update_data *update_data)
</span> 	if (update_data-&gt;remote) {
 		char *remote_name;
 		const char *branch;
<span
class="add">+		const char *tag;
</span> 		char *remote_ref;
 		int code;
 
 		code = get_default_remote_submodule(update_data-&gt;sm_path, &#38;remote_name);
 		if (code)
 			return code;
<span
class="del">-		code = remote_submodule_branch(update_data-&gt;sm_path, &#38;branch);
-		if (code)
-			return code;
-		remote_ref = xstrfmt(&#34;refs/remotes/%s/%s&#34;, remote_name, branch);
</span><span
class="add">+		code = remote_submodule_tag(update_data-&gt;sm_path, &#38;tag);
+		if (!code &#38;&#38; update_data-&gt;single_tag) {
+				remote_ref = xstrfmt(&#34;refs/tags/%s&#34;, tag);
+		} else {
+			code = remote_submodule_branch(update_data-&gt;sm_path, &#38;branch);
+			if (code)
+				return code;
+			remote_ref = xstrfmt(&#34;refs/remotes/%s/%s&#34;, remote_name, branch);
+		}
</span> 
 		free(remote_name);
 
<span
class="hunk">@@ -2781,6 +2828,8 @@ static int module_update(int argc, const char **argv, const char *prefix)
</span> 			   N_(&#34;disallow cloning into non-empty directory, implies --init&#34;)),
 		OPT_BOOL(0, &#34;single-branch&#34;, &#38;opt.single_branch,
 			 N_(&#34;clone only one branch, HEAD or --branch&#34;)),
<span
class="add">+		OPT_BOOL(0, &#34;single-tag&#34;, &#38;opt.single_tag,
+			 N_(&#34;clone only one tag, --tag&#34;)),
</span> 		OPT_PARSE_LIST_OBJECTS_FILTER(&#38;filter_options),
 		OPT_END()
 	};
<span
class="hunk">@@ -2790,7 +2839,7 @@ static int module_update(int argc, const char **argv, const char *prefix)
</span> 		&#34; [-N|--no-fetch] [-f|--force]&#34;
 		&#34; [--checkout|--merge|--rebase]&#34;
 		&#34; [--[no-]recommend-shallow] [--reference &lt;repository&gt;]&#34;
<span
class="del">-		&#34; [--recursive] [--[no-]single-branch] [--] [&lt;path&gt;...]&#34;),
</span><span
class="add">+		&#34; [--recursive] [--[no-]single-branch] [--[no-]single-tag] [--] [&lt;path&gt;...]&#34;),
</span> 		NULL
 	};
 
<span
class="hunk">@@ -3058,6 +3107,52 @@ static int module_set_branch(int argc, const char **argv, const char *prefix)
</span> 	return !!ret;
 }
 
<span
class="add">+
+static int module_set_tag(int argc, const char **argv, const char *prefix)
+{
+	int ret;
+	const char *opt_tag = NULL;
+	const char *path;
+	char *config_name;
+	struct option options[] = {
+		/*
+		 * We accept the `quiet` option for uniformity across subcommands,
+		 * though there is nothing to make less verbose in this subcommand.
+		 */
+		OPT_NOOP_NOARG(&#39;q&#39;, &#34;quiet&#34;),
+
+		OPT_STRING(&#39;t&#39;, &#34;tag&#34;, &#38;opt_tag, N_(&#34;tag&#34;),
+			N_(&#34;set the tracking tag&#34;)),
+		OPT_END()
+	};
+
+	const char *const usage[] = {
+		N_(&#34;git submodule set-tag [-q|--quiet] (-t|--tag) &lt;tag&gt; &lt;path&gt;&#34;),
+		NULL
+	};
+	const struct submodule *sub;
+
+	argc = parse_options(argc, argv, prefix, options, usage, 0);
+
+	if (!opt_tag)
+		die(_(&#34;--tag required&#34;));
+
+	if (argc != 1 || !(path = argv[0]))
+		usage_with_options(usage, options);
+
+	sub = submodule_from_path(the_repository, null_oid(), path);
+
+	if (!sub)
+		die(_(&#34;no submodule mapping found in .gitmodules for path &#39;%s&#39;&#34;),
+		    path);
+
+	config_name = xstrfmt(&#34;submodule.%s.tag&#34;, sub-&gt;tag);
+	ret = config_set_in_gitmodules_file_gently(config_name, opt_tag);
+
+	free(config_name);
+	return !!ret;
+}
+
</span> static int module_create_branch(int argc, const char **argv, const char *prefix)
 {
 	enum branch_track track;
<span
class="hunk">@@ -3098,6 +3193,7 @@ static int module_create_branch(int argc, const char **argv, const char *prefix)
</span> struct add_data {
 	const char *prefix;
 	const char *branch;
<span
class="add">+	const char *tag;
</span> 	const char *reference_path;
 	char *sm_path;
 	const char *sm_name;
<span
class="hunk">@@ -3219,7 +3315,9 @@ static int add_submodule(const struct add_data *add_data)
</span> 		 */
 		strvec_pushl(&#38;cp.args, &#34;checkout&#34;, &#34;-f&#34;, &#34;-q&#34;, NULL);
 
<span
class="del">-		if (add_data-&gt;branch) {
</span><span
class="add">+		if (add_data-&gt;tag) {
+			strvec_pushf(&#38;cp.args, &#34;%s&#34;, add_data-&gt;tag);
+		} else if (add_data-&gt;branch) {
</span> 			strvec_pushl(&#38;cp.args, &#34;-B&#34;, add_data-&gt;branch, NULL);
 			strvec_pushf(&#38;cp.args, &#34;origin/%s&#34;, add_data-&gt;branch);
 		}
<span
class="hunk">@@ -3272,7 +3370,11 @@ static void configure_added_submodule(struct add_data *add_data)
</span> 	    config_submodule_in_gitmodules(add_data-&gt;sm_name, &#34;url&#34;, add_data-&gt;repo))
 		die(_(&#34;Failed to register submodule &#39;%s&#39;&#34;), add_data-&gt;sm_path);
 
<span
class="del">-	if (add_data-&gt;branch) {
</span><span
class="add">+	if (add_data-&gt;tag) {
+		if (config_submodule_in_gitmodules(add_data-&gt;sm_name,
+						&#34;tag&#34;, add_data-&gt;tag))
+			die(_(&#34;Failed to register submodule &#39;%s&#39;&#34;), add_data-&gt;sm_path);
+	} else if (add_data-&gt;branch) {
</span> 		if (config_submodule_in_gitmodules(add_data-&gt;sm_name,
 						   &#34;branch&#34;, add_data-&gt;branch))
 			die(_(&#34;Failed to register submodule &#39;%s&#39;&#34;), add_data-&gt;sm_path);
<span
class="hunk">@@ -3371,6 +3473,8 @@ static int module_add(int argc, const char **argv, const char *prefix)
</span> 	struct option options[] = {
 		OPT_STRING(&#39;b&#39;, &#34;branch&#34;, &#38;add_data.branch, N_(&#34;branch&#34;),
 			   N_(&#34;branch of repository to add as submodule&#34;)),
<span
class="add">+		OPT_STRING(&#39;t&#39;, &#34;tag&#34;, &#38;add_data.tag, N_(&#34;tag&#34;),
+			   N_(&#34;tag of repository to add as submodule&#34;)),
</span> 		OPT__FORCE(&#38;force, N_(&#34;allow adding an otherwise ignored submodule path&#34;),
 			   PARSE_OPT_NOCOMPLETE),
 		OPT__QUIET(&#38;quiet, N_(&#34;print only error messages&#34;)),
<span
class="hunk">@@ -3506,6 +3610,7 @@ int cmd_submodule__helper(int argc, const char **argv, const char *prefix)
</span> 		OPT_SUBCOMMAND(&#34;set-url&#34;, &#38;fn, module_set_url),
 		OPT_SUBCOMMAND(&#34;set-branch&#34;, &#38;fn, module_set_branch),
 		OPT_SUBCOMMAND(&#34;create-branch&#34;, &#38;fn, module_create_branch),
<span
class="add">+		OPT_SUBCOMMAND(&#34;set-tag&#34;, &#38;fn, module_set_tag),
</span> 		OPT_END()
 	};
 	argc = parse_options(argc, argv, prefix, options, usage, 0);
<span
class="head">diff --git a/contrib/completion/git-completion.bash b/contrib/completion/git-completion.bash
index 60a22d619a8..5e087bc443a 100644
--- a/contrib/completion/git-completion.bash
+++ b/contrib/completion/git-completion.bash
</span><span
class="hunk">@@ -3057,6 +3057,9 @@ _git_remote ()
</span> 	set-head,--*)
 		__gitcomp_builtin remote_set-head
 		;;
<span
class="add">+	set-tag,--*)
+		__gitcomp_builtin remote_set-tag
+		;;
</span> 	set-branches,--*)
 		__gitcomp_builtin remote_set-branches
 		;;
<span
class="hunk">@@ -3471,7 +3474,7 @@ _git_submodule ()
</span> {
 	__git_has_doubledash &#38;&#38; return
 
<span
class="del">-	local subcommands=&#34;add status init deinit update set-branch set-url summary foreach sync absorbgitdirs&#34;
</span><span
class="add">+	local subcommands=&#34;add status init deinit update set-branch set-tag set-url summary foreach sync absorbgitdirs&#34;
</span> 	local subcommand=&#34;$(__git_find_on_cmdline &#34;$subcommands&#34;)&#34;
 	if [ -z &#34;$subcommand&#34; ]; then
 		case &#34;$cur&#34; in
<span
class="hunk">@@ -3502,6 +3505,9 @@ _git_submodule ()
</span> 			--force --rebase --merge --reference --depth --recursive --jobs
 		&#34;
 		;;
<span
class="add">+	set-tag,--*)
+		__gitcomp &#34;--tag&#34;
+		;;
</span> 	set-branch,--*)
 		__gitcomp &#34;--default --branch&#34;
 		;;
<span
class="head">diff --git a/git-submodule.sh b/git-submodule.sh
index 7f9582d9234..bbb17244d73 100755
--- a/git-submodule.sh
+++ b/git-submodule.sh
</span><span
class="hunk">@@ -6,12 +6,13 @@
</span> 
 dashless=$(basename &#34;$0&#34; | sed -e &#39;s/-/ /&#39;)
 USAGE=&#34;[--quiet] [--cached]
<span
class="del">-   or: $dashless [--quiet] add [-b &lt;branch&gt;] [-f|--force] [--name &lt;name&gt;] [--reference &lt;repository&gt;] [--] &lt;repository&gt; [&lt;path&gt;]
</span><span
class="add">+   or: $dashless [--quiet] add [-b &lt;branch&gt;] [-t &lt;tag&gt;] [-f|--force] [--name &lt;name&gt;] [--reference &lt;repository&gt;] [--] &lt;repository&gt; [&lt;path&gt;]
</span>    or: $dashless [--quiet] status [--cached] [--recursive] [--] [&lt;path&gt;...]
    or: $dashless [--quiet] init [--] [&lt;path&gt;...]
    or: $dashless [--quiet] deinit [-f|--force] (--all| [--] &lt;path&gt;...)
<span
class="del">-   or: $dashless [--quiet] update [--init [--filter=&lt;filter-spec&gt;]] [--remote] [-N|--no-fetch] [-f|--force] [--checkout|--merge|--rebase] [--[no-]recommend-shallow] [--reference &lt;repository&gt;] [--recursive] [--[no-]single-branch] [--] [&lt;path&gt;...]
</span><span
class="add">+   or: $dashless [--quiet] update [--init [--filter=&lt;filter-spec&gt;]] [--remote] [-N|--no-fetch] [-f|--force] [--checkout|--merge|--rebase] [--[no-]recommend-shallow] [--reference &lt;repository&gt;] [--recursive] [--[no-]single-branch] [--[no-]single-tag] [--] [&lt;path&gt;...]
</span>    or: $dashless [--quiet] set-branch (--default|--branch &lt;branch&gt;) [--] &lt;path&gt;
<span
class="add">+   or: $dashless [--quiet] set-tag (--tag &lt;tag&gt;) [--] &lt;path&gt;
</span>    or: $dashless [--quiet] set-url [--] &lt;path&gt; &lt;newurl&gt;
    or: $dashless [--quiet] summary [--cached|--files] [--summary-limit &lt;n&gt;] [commit] [--] [&lt;path&gt;...]
    or: $dashless [--quiet] foreach [--recursive] &lt;command&gt;
<span
class="hunk">@@ -49,6 +50,7 @@ depth=
</span> progress=
 dissociate=
 single_branch=
<span
class="add">+single_tag=
</span> jobs=
 recommend_shallow=
 filter=
<span
class="hunk">@@ -77,6 +79,11 @@ cmd_add()
</span> 			branch=$2
 			shift
 			;;
<span
class="add">+		-t | --tag)
+			case &#34;$2&#34; in &#39;&#39;) usage ;; esac
+			tag=$2
+			shift
+			;;
</span> 		-f | --force)
 			force=$1
 			;;
<span
class="hunk">@@ -129,7 +136,7 @@ cmd_add()
</span> 		usage
 	fi
 
<span
class="del">-	git ${wt_prefix:+-C &#34;$wt_prefix&#34;} submodule--helper add ${quiet:+--quiet} ${force:+--force} ${progress:+&#34;--progress&#34;} ${branch:+--branch &#34;$branch&#34;} ${reference_path:+--reference &#34;$reference_path&#34;} ${dissociate:+--dissociate} ${custom_name:+--name &#34;$custom_name&#34;} ${depth:+&#34;$depth&#34;} -- &#34;$@&#34;
</span><span
class="add">+	git ${wt_prefix:+-C &#34;$wt_prefix&#34;} submodule--helper add ${quiet:+--quiet} ${force:+--force} ${progress:+&#34;--progress&#34;} ${branch:+--branch &#34;$branch&#34;}  ${tag:+--tag &#34;$tag&#34;} ${reference_path:+--reference &#34;$reference_path&#34;} ${dissociate:+--dissociate} ${custom_name:+--name &#34;$custom_name&#34;} ${depth:+&#34;$depth&#34;} -- &#34;$@&#34;
</span> }
 
 #
<span
class="hunk">@@ -316,6 +323,12 @@ cmd_update()
</span> 		--no-single-branch)
 			single_branch=&#34;--no-single-branch&#34;
 			;;
<span
class="add">+		--single-tag)
+			single_tag=&#34;--single-tag&#34;
+			;;
+		--no-single-tag)
+			single_tag=&#34;--no-single-tag&#34;
+			;;
</span> 		--filter)
 			case &#34;$2&#34; in &#39;&#39;) usage ;; esac
 			filter=&#34;--filter=$2&#34;
<span
class="hunk">@@ -355,6 +368,7 @@ cmd_update()
</span> 		${require_init:+--require-init} \
 		${dissociate:+&#34;--dissociate&#34;} \
 		$single_branch \
<span
class="add">+		$single_tag \
</span> 		$recommend_shallow \
 		$jobs \
 		$filter \
<span
class="hunk">@@ -402,6 +416,43 @@ cmd_set_branch() {
</span> 	git ${wt_prefix:+-C &#34;$wt_prefix&#34;} submodule--helper set-branch ${quiet:+--quiet} ${branch:+--branch &#34;$branch&#34;} ${default:+--default} -- &#34;$@&#34;
 }
 
<span
class="add">+#
+# Configures a submodule&#39;s default tag
+#
+# $@ = requested path
+#
+cmd_set_tag() {
+	default=
+	tag=
+
+	while test $# -ne 0
+	do
+		case &#34;$1&#34; in
+		-q|--quiet)
+			# we don&#39;t do anything with this but we need to accept it
+			;;
+		-t|--tag)
+			case &#34;$2&#34; in &#39;&#39;) usage ;; esac
+			tag=$2
+			shift
+			;;
+		--)
+			shift
+			break
+			;;
+		-*)
+			usage
+			;;
+		*)
+			break
+			;;
+		esac
+		shift
+	done
+
+	git ${wt_prefix:+-C &#34;$wt_prefix&#34;} submodule--helper set-tag ${quiet:+--quiet} ${tag:+--tag &#34;$tag&#34;} -- &#34;$@&#34;
+}
+
</span> #
 # Configures a submodule&#39;s remote url
 #
<span
class="hunk">@@ -571,7 +622,7 @@ cmd_absorbgitdirs()
</span> while test $# != 0 &#38;&#38; test -z &#34;$command&#34;
 do
 	case &#34;$1&#34; in
<span
class="del">-	add | foreach | init | deinit | update | set-branch | set-url | status | summary | sync | absorbgitdirs)
</span><span
class="add">+	add | foreach | init | deinit | update | set-branch | set-tag | set-url | status | summary | sync | absorbgitdirs)
</span> 		command=$1
 		;;
 	-q|--quiet)
<span
class="head">diff --git a/submodule-config.c b/submodule-config.c
index ec45ea67b95..a258406cced 100644
--- a/submodule-config.c
+++ b/submodule-config.c
</span><span
class="hunk">@@ -93,6 +93,7 @@ static void free_one_config(struct submodule_entry *entry)
</span> 	free((void *) entry-&gt;config-&gt;branch);
 	free((void *) entry-&gt;config-&gt;url);
 	free((void *) entry-&gt;config-&gt;ignore);
<span
class="add">+	free((void *) entry-&gt;config-&gt;tag);
</span> 	free((void *) entry-&gt;config-&gt;update_strategy.command);
 	free(entry-&gt;config);
 }
<span
class="hunk">@@ -415,6 +416,7 @@ static struct submodule *lookup_or_create_by_name(struct submodule_cache *cache,
</span> 	submodule-&gt;fetch_recurse = RECURSE_SUBMODULES_NONE;
 	submodule-&gt;ignore = NULL;
 	submodule-&gt;branch = NULL;
<span
class="add">+	submodule-&gt;tag = NULL;
</span> 	submodule-&gt;recommend_shallow = -1;
 
 	oidcpy(&#38;submodule-&gt;gitmodules_oid, gitmodules_oid);
<span
class="hunk">@@ -660,6 +662,8 @@ static int parse_config(const char *var, const char *value,
</span> 	} else if (!strcmp(item.buf, &#34;branch&#34;)) {
 		if (!value)
 			ret = config_error_nonbool(var);
<span
class="add">+		else if (submodule-&gt;branch &#38;&#38; submodule-&gt;tag)
+			die(_(&#34;can not specify both tag and branch &#39;%s&#39;&#34;), var);
</span> 		else if (!me-&gt;overwrite &#38;&#38; submodule-&gt;branch)
 			warn_multiple_config(me-&gt;treeish_name, submodule-&gt;name,
 					     &#34;branch&#34;);
<span
class="hunk">@@ -667,6 +671,16 @@ static int parse_config(const char *var, const char *value,
</span> 			free((void *)submodule-&gt;branch);
 			submodule-&gt;branch = xstrdup(value);
 		}
<span
class="add">+	} else if (!strcmp(item.buf, &#34;tag&#34;)) {
+		if (!value)
+			ret = config_error_nonbool(var);
+		else if (!me-&gt;overwrite &#38;&#38; submodule-&gt;tag)
+			warn_multiple_config(me-&gt;treeish_name, submodule-&gt;name,
+					     &#34;tag&#34;);
+		else {
+			free((void *)submodule-&gt;tag);
+			submodule-&gt;tag = xstrdup(value);
+		}
</span> 	}
 
 	strbuf_release(&#38;name);
<span
class="head">diff --git a/submodule-config.h b/submodule-config.h
index b6133af71b0..522683cc130 100644
--- a/submodule-config.h
+++ b/submodule-config.h
</span><span
class="hunk">@@ -38,6 +38,7 @@ struct submodule {
</span> 	enum submodule_recurse_mode fetch_recurse;
 	const char *ignore;
 	const char *branch;
<span
class="add">+	const char *tag;
</span> 	struct submodule_update_strategy update_strategy;
 	/* the object id of the responsible .gitmodules file */
 	struct object_id gitmodules_oid;

base-commit: d63586cb314731c851f28e14fc8012988467e2da
-- 
gitgitgadget
</pre></div></content></entry><entry><author><name>Eric Wong</name><email>e@80x24.org</email></author><title
type="html">[PATCH 2/2] t9700: ensure cat-file info isn&#39;t buffered by default</title><updated>2024-06-17T10:43:41Z</updated><link
href="http://lore.kernel.org/git/20240617104326.3522535-3-e@80x24.org/"/><id>urn:uuid:7d183d08-c359-7de7-fc32-e256896ce661</id><thr:in-reply-to
ref="urn:uuid:5d235a12-857e-b8f7-14d9-af8aa4747e4f"
href="http://lore.kernel.org/git/20240617104326.3522535-1-e@80x24.org/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">While working on buffering changes to `git cat-file&#39; in a
separate patch, I inadvertently made the output of --batch-check
and the `info&#39; command of --batch-command buffered by default.

Buffering by default breaks some 3rd-party Perl scripts using
cat-file, but this breakage was not detected anywhere in our
test suite.  The easiest place to test this behavior is with
Git.pm, since (AFAIK) other equivalent way to test this behavior
from Bourne shell and/or awk would require racy sleeps,
non-portable FIFOs or tedious C code.

Signed-off-by: Eric Wong &lt;e@80x24.org&gt;
---
 t/t9700/test.pl | 14 ++++++++++++++
 1 file <a href="http://lore.kernel.org/git/20240617104326.3522535-3-e@80x24.org/#related">changed</a>, 14 insertions(+)

<span
class="head">diff --git a/t/t9700/test.pl b/t/t9700/test.pl
index d8e85482ab..94a2e2c09d 100755
--- a/t/t9700/test.pl
+++ b/t/t9700/test.pl
</span><span
class="hunk">@@ -154,6 +154,20 @@ sub adjust_dirsep {
</span> 		     &#34;abc\&#34;\\ \x07\x08\x09\x0a\x0b\x0c\x0d\x01 &#34;,
 		     &#39;unquote escape sequences&#39;);
 
<span
class="add">+# ensure --batch-check is unbuffered by default
+my ($pid, $in, $out, $ctx) = $r-&gt;command_bidi_pipe(qw(cat-file --batch-check));
+print $out $file1hash, &#34;\n&#34; or die $!;
+my $info = &lt;$in&gt;;
+is $info, &#34;$file1hash blob 15\n&#34;, &#39;command_bidi_pipe w/ --batch-check&#39;;
+$r-&gt;command_close_bidi_pipe($pid, $in, $out, $ctx);
+
+# ditto with `info&#39; with --batch-command
+($pid, $in, $out, $ctx) = $r-&gt;command_bidi_pipe(qw(cat-file --batch-command));
+print $out &#39;info &#39;, $file1hash, &#34;\n&#34; or die $!;
+$info = &lt;$in&gt;;
+is $info, &#34;$file1hash blob 15\n&#34;, &#39;command_bidi_pipe w/ --batch-command=info&#39;;
+$r-&gt;command_close_bidi_pipe($pid, $in, $out, $ctx);
+
</span> printf &#34;1..%d\n&#34;, Test::More-&gt;builder-&gt;current_test;
 
 my $is_passing = eval { Test::More-&gt;is_passing };
</pre></div></content></entry><entry><author><name>Eric Wong</name><email>e@80x24.org</email></author><title>[PATCH 1/2] Git.pm: use array in command_bidi_pipe example</title><updated>2024-06-17T10:43:34Z</updated><link
href="http://lore.kernel.org/git/20240617104326.3522535-2-e@80x24.org/"/><id>urn:uuid:0b9cf364-64cd-b8be-b3f5-d5b00b97201e</id><thr:in-reply-to
ref="urn:uuid:5d235a12-857e-b8f7-14d9-af8aa4747e4f"
href="http://lore.kernel.org/git/20240617104326.3522535-1-e@80x24.org/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">command_bidi_pipe takes the git command and optional arguments as an
array, not a string.  Make sure the documentation example is usable
code.

Signed-off-by: Eric Wong &lt;e@80x24.org&gt;
---
 perl/Git.pm | 4 ++--
 1 file <a href="http://lore.kernel.org/git/20240617104326.3522535-2-e@80x24.org/#related">changed</a>, 2 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/perl/Git.pm b/perl/Git.pm
index 03bf570bf4..aebfe0c6e0 100644
--- a/perl/Git.pm
+++ b/perl/Git.pm
</span><span
class="hunk">@@ -418,7 +418,7 @@ sub command_bidi_pipe {
</span> and it is the fourth value returned by C&lt;command_bidi_pipe()&gt;.  The call idiom
 is:
 
<span
class="del">-	my ($pid, $in, $out, $ctx) = $r-&gt;command_bidi_pipe(&#39;cat-file --batch-check&#39;);
</span><span
class="add">+	my ($pid, $in, $out, $ctx) = $r-&gt;command_bidi_pipe(qw(cat-file --batch-check));
</span> 	print $out &#34;000000000\n&#34;;
 	while (&lt;$in&gt;) { ... }
 	$r-&gt;command_close_bidi_pipe($pid, $in, $out, $ctx);
<span
class="hunk">@@ -431,7 +431,7 @@ sub command_bidi_pipe {
</span> calling this function.  This may be useful in a query-response type of
 commands where caller first writes a query and later reads response, eg:
 
<span
class="del">-	my ($pid, $in, $out, $ctx) = $r-&gt;command_bidi_pipe(&#39;cat-file --batch-check&#39;);
</span><span
class="add">+	my ($pid, $in, $out, $ctx) = $r-&gt;command_bidi_pipe(qw(cat-file --batch-check));
</span> 	print $out &#34;000000000\n&#34;;
 	close $out;
 	while (&lt;$in&gt;) { ... }
</pre></div></content></entry><entry><author><name>Eric Wong</name><email>e@80x24.org</email></author><title>[PATCH 0/2] cat-file related doc and test</title><updated>2024-06-17T10:43:27Z</updated><link
href="http://lore.kernel.org/git/20240617104326.3522535-1-e@80x24.org/"/><id>urn:uuid:5d235a12-857e-b8f7-14d9-af8aa4747e4f</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">I was working on reducing syscalls required for cat-file --batch
(and readers) in a different patch, but noticed a bug in my
yet-to-be-published patch wasn&#39;t detected in our test suite,
only via 3rd-party Perl code.

Then I noticed Git.pm documentation was wrong..., so fixes
are in reverse order.

Eric Wong (2):
  Git.pm: use array in command_bidi_pipe example
  t9700: ensure cat-file info isn&#39;t buffered by default

 perl/Git.pm     |  4 ++--
 t/t9700/test.pl | 14 ++++++++++++++
 2 files changed, 16 insertions(+), 2 deletions(-)
</pre></div></content></entry><entry><author><name>Miguel &#193;ngel Pastor Olivar via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH 0/2] Symlink resolutions: limits and return modes</title><updated>2024-06-17T09:04:09Z</updated><link
href="http://lore.kernel.org/git/pull.1751.git.1718615028.gitgitgadget@gmail.com/"/><id>urn:uuid:efaef144-dd73-a9f4-a5de-0428b863bc4b</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">It can be useful to limit the number of symlink resolutions performed while
looking for a tree entry. The goal is to provide the ability to resolve up
to a particular depth, instead of reaching the end of the link chain.

In addition, I would like to extend the symlink resolution process and
provide the ability to return the object found at the designated depth
instead of returning an error.

The current code already provides a limit to the maximum number of
resolutions that can be performed, and something similar to this is returned
to the caller:

loop SP &lt;size&gt; LF
&lt;object&gt; LF


With these patches, we are looking to return the actual information of the
object where the resolution stopped. Something similar to:

&lt;oid&gt; blob &lt;size&gt;\nndata\n


Miguel &#193;ngel Pastor Olivar (2):
  cat-file: configurable number of symlink resolutions
  cat-file: configurable &#34;best effort mode&#34; for symlink resolution

 Documentation/config/core.txt | 19 +++++++++++++++
 config.c                      | 18 ++++++++++++++
 environment.c                 |  3 +++
 environment.h                 |  8 ++++++
 t/t1006-cat-file.sh           | 46 +++++++++++++++++++++++++++++++++++
 tree-walk.c                   | 18 +++++++++++++-
 6 files changed, 111 insertions(+), 1 deletion(-)


base-commit: d63586cb314731c851f28e14fc8012988467e2da
Published-As: <a
href="https://github.com/gitgitgadget/git/releases/tag/pr-1751%2Fmigue%2Fmigue%2Ffollow-symlinks-max-depth-v1">https://github.com/gitgitgadget/git/releases/tag/pr-1751%2Fmigue%2Fmigue%2Ffollow-symlinks-max-depth-v1</a>
Fetch-It-Via: git fetch <a
href="https://github.com/gitgitgadget/git">https://github.com/gitgitgadget/git</a> pr-1751/migue/migue/follow-symlinks-max-depth-v1
Pull-Request: <a
href="https://github.com/gitgitgadget/git/pull/1751">https://github.com/gitgitgadget/git/pull/1751</a>
-- 
gitgitgadget
</pre></div></content></entry><entry><author><name>Miguel &#193;ngel Pastor Olivar via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title
type="html">[PATCH 2/2] cat-file: configurable &#34;best effort mode&#34; for symlink resolution</title><updated>2024-06-17T09:03:53Z</updated><link
href="http://lore.kernel.org/git/5de72c45e767c4d704503c8cd5c8e6dce4ea04d6.1718615028.git.gitgitgadget@gmail.com/"/><id>urn:uuid:80067f03-8741-d28a-3ac5-517080eafa7d</id><thr:in-reply-to
ref="urn:uuid:efaef144-dd73-a9f4-a5de-0428b863bc4b"
href="http://lore.kernel.org/git/pull.1751.git.1718615028.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: =?UTF-8?q?Miguel=20=C3=81ngel=20Pastor=20Olivar?= &lt;migue@github.com&gt;

This patch introduces a new &#34;best effort mode&#34; where the object found at
resolution step N is returned. If we&#39;ve reached the end of the chain, the
returned object will be the file at the end of the chain, however, if, after
n resolutions we haven&#39;t reached the end of the chain, the returned object
will represent a symlink

The goal is to extend the symlink resolution process and provide the ability
to return the object found at the designated depth instead of returning an
error.

The current code already provides a limit to the maximum number of
resolutions that can be performed and something similar to this is returned
back to the caller:

loop SP &lt;size&gt; LF &lt;object&gt; LF

With the new config setting we are looking to return the actual information
of the object where the resolution stopped. Something similar to:

&lt;oid&gt; blob &lt;size&gt;\ndata\n

Signed-off-by: Miguel &#193;ngel Pastor Olivar &lt;migue@github.com&gt;
---
 Documentation/config/core.txt | 16 +++++++++++++++-
 config.c                      | 13 +++++++++++++
 environment.c                 |  2 ++
 environment.h                 |  7 +++++++
 t/t1006-cat-file.sh           | 29 +++++++++++++++++++++++++++++
 tree-walk.c                   | 11 +++++++++++
 6 files <a href="http://lore.kernel.org/git/5de72c45e767c4d704503c8cd5c8e6dce4ea04d6.1718615028.git.gitgitgadget@gmail.com/#related">changed</a>, 77 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/Documentation/config/core.txt b/Documentation/config/core.txt
index ca2d1eede52..706f316c89e 100644
--- a/Documentation/config/core.txt
+++ b/Documentation/config/core.txt
</span><span
class="hunk">@@ -761,4 +761,18 @@ core.maxTreeDepth::
</span> core.maxSymlinkDepth::
 	The maximum number of symlinks Git is willing to resolve while
 	looking for a tree entry.
<span
class="del">-	The default is GET_TREE_ENTRY_FOLLOW_SYMLINKS_MAX_LINKS.
</span>\ No newline at end of file
<span
class="add">+	The default is GET_TREE_ENTRY_FOLLOW_SYMLINKS_MAX_LINKS.
+
+core.symlinkResolutionMode::
+	The result returned by the symlink resolution process when
+	core.maxSymlinkDepth is reached. When set to &#34;error&#34;
+	`
+	loop SP &lt;size&gt; LF
+	&lt;object&gt; LF
+	` is returned.
+	If `best-effort` is set, the resolution process will return
+	something like:
+	`
+	&lt;oid&gt; blob &lt;size&gt; 120000\nname\n
+	`
+	The default is &#34;error&#34;.
</span>\ No newline at end of file
<span
class="head">diff --git a/config.c b/config.c
index d69e9a3ae6b..fa753565e68 100644
--- a/config.c
+++ b/config.c
</span><span
class="hunk">@@ -1687,6 +1687,19 @@ static int git_default_core_config(const char *var, const char *value,
</span> 		return 0;
 	}
 
<span
class="add">+	if (!strcmp(var, &#34;core.symlinkresolutionmode&#34;)) {
+		if (!value)
+			symlink_resolution_mode = SYMLINK_RESOLUTION_MODE_ERROR;
+		if (!strcmp(value, &#34;error&#34;))
+			symlink_resolution_mode = SYMLINK_RESOLUTION_MODE_ERROR;
+		else if (!strcmp(value, &#34;best-effort&#34;))
+			symlink_resolution_mode =
+				SYMLINK_RESOLUTION_MODE_BEST_EFFORT;
+		else
+			warning(_(&#34;ignoring unknown core.symlinkresolutionmode value &#39;%s&#39;&#34;),
+				value);
+	}
+
</span> 	/* Add other config variables here and to Documentation/config.txt. */
 	return platform_core_config(var, value, ctx, cb);
 }
<span
class="head">diff --git a/environment.c b/environment.c
index 6d7a5001eb1..a497331f2bc 100644
--- a/environment.c
+++ b/environment.c
</span><span
class="hunk">@@ -96,6 +96,8 @@ int max_allowed_tree_depth =
</span> 	2048;
 #endif
 int max_symlink_depth = -1;
<span
class="add">+enum symlink_resolution_mode symlink_resolution_mode =
+	SYMLINK_RESOLUTION_MODE_ERROR;
</span> 
 #ifndef PROTECT_HFS_DEFAULT
 #define PROTECT_HFS_DEFAULT 0
<span
class="head">diff --git a/environment.h b/environment.h
index ea39c2887b1..5a6eebb061b 100644
--- a/environment.h
+++ b/environment.h
</span><span
class="hunk">@@ -143,6 +143,13 @@ extern unsigned long pack_size_limit_cfg;
</span> extern int max_allowed_tree_depth;
 extern int max_symlink_depth;
 
<span
class="add">+enum symlink_resolution_mode {
+	SYMLINK_RESOLUTION_MODE_ERROR = 0,
+	SYMLINK_RESOLUTION_MODE_BEST_EFFORT
+};
+
+extern enum symlink_resolution_mode symlink_resolution_mode;
+
</span> /*
  * Accessors for the core.sharedrepository config which lazy-load the value
  * from the config (if not already set). The &#34;reset&#34; function can be
<span
class="head">diff --git a/t/t1006-cat-file.sh b/t/t1006-cat-file.sh
index fd7ab1d1eff..c1d807a0d7f 100755
--- a/t/t1006-cat-file.sh
+++ b/t/t1006-cat-file.sh
</span><span
class="hunk">@@ -1113,6 +1113,35 @@ test_expect_success &#39;git cat-file --batch --follow-symlink stop resolving symlin
</span> 	test_cmp expect actual
 &#39;
 
<span
class="add">+test_expect_success &#39;git cat-file --batch --follow-symlink stop resolving symlink at designated depth with error mode config&#39; &#39;
+	printf &#34;loop 22\nHEAD:link-to-symlink-3\n&#34;&gt;expect &#38;&#38;
+	printf &#39;HEAD:link-to-symlink-3&#39; | git -c core.maxsymlinkdepth=1 -c core.symlinkresolutionmode=error cat-file --batch=&#34;%(objectname) %(objecttype) %(objectsize)&#34; --follow-symlinks &gt; actual &#38;&#38;
+	test_cmp expect actual &#38;&#38;
+	printf &#39;HEAD:link-to-symlink-3&#39; | git -c core.maxsymlinkdepth=2 -c core.symlinkresolutionmode=error cat-file --batch=&#34;%(objectname) %(objecttype) %(objectsize)&#34; --follow-symlinks &gt; actual &#38;&#38;
+	test_cmp expect actual &#38;&#38;
+	printf &#39;HEAD:link-to-symlink-3&#39; | git -c core.maxsymlinkdepth=3 -c core.symlinkresolutionmode=error cat-file --batch=&#34;%(objectname) %(objecttype) %(objectsize)&#34; --follow-symlinks &gt; actual &#38;&#38;
+	test_cmp expect actual &#38;&#38;
+	oid=$(git rev-parse HEAD:morx) &#38;&#38;
+	printf &#34;${oid} blob 11\nHello World\n&#34; &gt;expect &#38;&#38;
+	printf &#39;HEAD:link-to-symlink-3&#39; | git -c core.maxsymlinkdepth=4 cat-file --batch=&#34;%(objectname) %(objecttype) %(objectsize)&#34; --follow-symlinks &gt; actual &#38;&#38;
+	test_cmp expect actual
+&#39;
+
+test_expect_success &#39;git cat-file --batch --follow-symlink return object info at designated depth&#39; &#39;
+	oid=$(git rev-parse HEAD:link-to-symlink-1) &#38;&#38;
+	printf &#34;${oid} blob 13\nsame-dir-link\n&#34; &gt;expect &#38;&#38;
+	printf &#39;HEAD:link-to-symlink-1&#39; | git -c core.maxsymlinkdepth=1  -c core.symlinkresolutionmode=best-effort cat-file --batch=&#34;%(objectname) %(objecttype) %(objectsize)&#34; --follow-symlinks &gt;actual &#38;&#38;
+	test_cmp expect actual &#38;&#38;
+	oid=$(git rev-parse HEAD:same-dir-link) &#38;&#38;
+	printf &#34;${oid} blob 4\nmorx\n&#34; &gt; expect &#38;&#38;
+	printf &#39;HEAD:link-to-symlink-1&#39; | git -c core.maxsymlinkdepth=2  -c core.symlinkresolutionmode=best-effort cat-file --batch=&#34;%(objectname) %(objecttype) %(objectsize)&#34; --follow-symlinks &gt;actual &#38;&#38;
+	test_cmp expect actual &#38;&#38;
+	oid=$(git rev-parse HEAD:morx) &#38;&#38;
+	printf &#34;${oid} blob 11\nHello World\n&#34; &gt; expect &#38;&#38;
+	printf &#39;HEAD:link-to-symlink-1&#39; | git -c core.maxsymlinkdepth=3  -c core.symlinkresolutionmode=best-effort cat-file --batch=&#34;%(objectname) %(objecttype) %(objectsize)&#34; --follow-symlinks &gt;actual &#38;&#38;
+	test_cmp expect actual
+&#39;
+
</span> test_expect_success &#39;cat-file --batch-all-objects shows all objects&#39; &#39;
 	# make new repos so we know the full set of objects; we will
 	# also make sure that there are some packed and some loose
<span
class="head">diff --git a/tree-walk.c b/tree-walk.c
index 3ec2302309e..ee861fd6351 100644
--- a/tree-walk.c
+++ b/tree-walk.c
</span><span
class="hunk">@@ -821,6 +821,17 @@ enum get_oid_result get_tree_entry_follow_symlinks(struct repository *r,
</span> 			contents_start = contents;
 
 			parent = &#38;parents[parents_nr - 1];
<span
class="add">+
+			if (follows_remaining == 0 &#38;&#38;
+			    symlink_resolution_mode ==
+				    SYMLINK_RESOLUTION_MODE_BEST_EFFORT) {
+				strbuf_addstr(result_path, contents);
+				oidcpy(result, &#38;current_tree_oid);
+				free(contents);
+				retval = FOUND;
+				goto done;
+			}
+
</span> 			init_tree_desc(&#38;t, &#38;parent-&gt;oid, parent-&gt;tree, parent-&gt;size);
 			strbuf_splice(&#38;namebuf, 0, len,
 				      contents_start, link_len);
-- 
gitgitgadget
</pre></div></content></entry><entry><author><name>Miguel &#193;ngel Pastor Olivar via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH 1/2] cat-file: configurable number of symlink resolutions</title><updated>2024-06-17T09:03:52Z</updated><link
href="http://lore.kernel.org/git/cbf38c7281de33289f622c9926c75744323311af.1718615028.git.gitgitgadget@gmail.com/"/><id>urn:uuid:77abd85b-d13c-434a-e946-22c4660c7e59</id><thr:in-reply-to
ref="urn:uuid:efaef144-dd73-a9f4-a5de-0428b863bc4b"
href="http://lore.kernel.org/git/pull.1751.git.1718615028.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: =?UTF-8?q?Miguel=20=C3=81ngel=20Pastor=20Olivar?= &lt;migue@github.com&gt;

Sometimes, it can be useful to limit the number of symlink resolutions
performed while looking for a tree entry.

The goal is to provide the ability to resolve up to a particular depth,
instead of reaching the end of the link chain.

The current code already provides a limit to the maximum number of
resolutions that can be performed
(GET_TREE_ENTRY_FOLLOW_SYMLINKS_MAX_LINKS). This patch introduces a new
config setting to make the previous property configurable. No logical
changes are introduced in this patch

Signed-off-by: Miguel &#193;ngel Pastor Olivar &lt;migue@github.com&gt;
---
 Documentation/config/core.txt |  5 +++++
 config.c                      |  5 +++++
 environment.c                 |  1 +
 environment.h                 |  1 +
 t/t1006-cat-file.sh           | 17 +++++++++++++++++
 tree-walk.c                   |  7 ++++++-
 6 files <a href="http://lore.kernel.org/git/cbf38c7281de33289f622c9926c75744323311af.1718615028.git.gitgitgadget@gmail.com/#related">changed</a>, 35 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/Documentation/config/core.txt b/Documentation/config/core.txt
index 93d65e1dfd2..ca2d1eede52 100644
--- a/Documentation/config/core.txt
+++ b/Documentation/config/core.txt
</span><span
class="hunk">@@ -757,3 +757,8 @@ core.maxTreeDepth::
</span> 	tree (e.g., &#34;a/b/cde/f&#34; has a depth of 4). This is a fail-safe
 	to allow Git to abort cleanly, and should not generally need to
 	be adjusted. The default is 4096.
<span
class="add">+
+core.maxSymlinkDepth::
+	The maximum number of symlinks Git is willing to resolve while
+	looking for a tree entry.
+	The default is GET_TREE_ENTRY_FOLLOW_SYMLINKS_MAX_LINKS.
</span>\ No newline at end of file
<span
class="head">diff --git a/config.c b/config.c
index abce05b7744..d69e9a3ae6b 100644
--- a/config.c
+++ b/config.c
</span><span
class="hunk">@@ -1682,6 +1682,11 @@ static int git_default_core_config(const char *var, const char *value,
</span> 		return 0;
 	}
 
<span
class="add">+	if (!strcmp(var, &#34;core.maxsymlinkdepth&#34;)) {
+		max_symlink_depth = git_config_int(var, value, ctx-&gt;kvi);
+		return 0;
+	}
+
</span> 	/* Add other config variables here and to Documentation/config.txt. */
 	return platform_core_config(var, value, ctx, cb);
 }
<span
class="head">diff --git a/environment.c b/environment.c
index 701d5151354..6d7a5001eb1 100644
--- a/environment.c
+++ b/environment.c
</span><span
class="hunk">@@ -95,6 +95,7 @@ int max_allowed_tree_depth =
</span> #else
 	2048;
 #endif
<span
class="add">+int max_symlink_depth = -1;
</span> 
 #ifndef PROTECT_HFS_DEFAULT
 #define PROTECT_HFS_DEFAULT 0
<span
class="head">diff --git a/environment.h b/environment.h
index e9f01d4d11c..ea39c2887b1 100644
--- a/environment.h
+++ b/environment.h
</span><span
class="hunk">@@ -141,6 +141,7 @@ extern size_t delta_base_cache_limit;
</span> extern unsigned long big_file_threshold;
 extern unsigned long pack_size_limit_cfg;
 extern int max_allowed_tree_depth;
<span
class="add">+extern int max_symlink_depth;
</span> 
 /*
  * Accessors for the core.sharedrepository config which lazy-load the value
<span
class="head">diff --git a/t/t1006-cat-file.sh b/t/t1006-cat-file.sh
index e12b2219721..fd7ab1d1eff 100755
--- a/t/t1006-cat-file.sh
+++ b/t/t1006-cat-file.sh
</span><span
class="hunk">@@ -878,6 +878,9 @@ test_expect_success &#39;cat-file -t and -s on corrupt loose object&#39; &#39;
</span> test_expect_success &#39;prep for symlink tests&#39; &#39;
 	echo_without_newline &#34;$hello_content&#34; &gt;morx &#38;&#38;
 	test_ln_s_add morx same-dir-link &#38;&#38;
<span
class="add">+	test_ln_s_add same-dir-link link-to-symlink-1 &#38;&#38;
+	test_ln_s_add link-to-symlink-1 link-to-symlink-2 &#38;&#38;
+	test_ln_s_add link-to-symlink-2 link-to-symlink-3 &#38;&#38;
</span> 	test_ln_s_add dir link-to-dir &#38;&#38;
 	test_ln_s_add ../fleem out-of-repo-link &#38;&#38;
 	test_ln_s_add .. out-of-repo-link-dir &#38;&#38;
<span
class="hunk">@@ -1096,6 +1099,20 @@ test_expect_success &#39;git cat-file --batch --follow-symlink returns correct sha a
</span> 	test_cmp expect actual
 &#39;
 
<span
class="add">+test_expect_success &#39;git cat-file --batch --follow-symlink stop resolving symlinks&#39; &#39;
+	printf &#34;loop 22\nHEAD:link-to-symlink-3\n&#34;&gt;expect &#38;&#38;
+	printf &#39;HEAD:link-to-symlink-3&#39; | git -c core.maxsymlinkdepth=1 cat-file --batch=&#34;%(objectname) %(objecttype) %(objectsize)&#34; --follow-symlinks &gt; actual &#38;&#38;
+	test_cmp expect actual &#38;&#38;
+	printf &#39;HEAD:link-to-symlink-3&#39; | git -c core.maxsymlinkdepth=2 cat-file --batch=&#34;%(objectname) %(objecttype) %(objectsize)&#34; --follow-symlinks &gt; actual &#38;&#38;
+	test_cmp expect actual &#38;&#38;
+	printf &#39;HEAD:link-to-symlink-3&#39; | git -c core.maxsymlinkdepth=3 cat-file --batch=&#34;%(objectname) %(objecttype) %(objectsize)&#34; --follow-symlinks &gt; actual &#38;&#38;
+	test_cmp expect actual &#38;&#38;
+	oid=$(git rev-parse HEAD:morx) &#38;&#38;
+	printf &#34;${oid} blob 11\nHello World\n&#34; &gt;expect &#38;&#38;
+	printf &#39;HEAD:link-to-symlink-3&#39; | git -c core.maxsymlinkdepth=4 cat-file --batch=&#34;%(objectname) %(objecttype) %(objectsize)&#34; --follow-symlinks &gt; actual &#38;&#38;
+	test_cmp expect actual
+&#39;
+
</span> test_expect_success &#39;cat-file --batch-all-objects shows all objects&#39; &#39;
 	# make new repos so we know the full set of objects; we will
 	# also make sure that there are some packed and some loose
<span
class="head">diff --git a/tree-walk.c b/tree-walk.c
index 6565d9ad993..3ec2302309e 100644
--- a/tree-walk.c
+++ b/tree-walk.c
</span><span
class="hunk">@@ -664,7 +664,12 @@ enum get_oid_result get_tree_entry_follow_symlinks(struct repository *r,
</span> 	struct object_id current_tree_oid;
 	struct strbuf namebuf = STRBUF_INIT;
 	struct tree_desc t;
<span
class="del">-	int follows_remaining = GET_TREE_ENTRY_FOLLOW_SYMLINKS_MAX_LINKS;
</span><span
class="add">+	int follows_remaining =
+		max_symlink_depth &gt; -1 &#38;&#38;
+				max_symlink_depth &lt;=
+					GET_TREE_ENTRY_FOLLOW_SYMLINKS_MAX_LINKS ?
+			max_symlink_depth :
+			GET_TREE_ENTRY_FOLLOW_SYMLINKS_MAX_LINKS;
</span> 
 	init_tree_desc(&#38;t, NULL, NULL, 0UL);
 	strbuf_addstr(&#38;namebuf, name);
-- 
gitgitgadget

</pre></div></content></entry><entry><author><name>Kyle Zhao via GitGitGadget</name><email>gitgitgadget@gmail.com</email></author><title>[PATCH v6] merge: avoid write merge state when unable to write index</title><updated>2024-06-17T03:08:41Z</updated><link
href="http://lore.kernel.org/git/pull.1731.v6.git.1718593717745.gitgitgadget@gmail.com/"/><id>urn:uuid:1dcaa427-2506-a99b-c308-9a10dd5a56d3</id><thr:in-reply-to
ref="urn:uuid:941700d4-5402-a788-03e7-afef2bf35dea"
href="http://lore.kernel.org/git/pull.1731.v5.git.1718173639942.gitgitgadget@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Kyle Zhao &lt;kylezhao@tencent.com&gt;

Writing the merge state after the index write fails is meaningless and
could potentially cause Git to lose changes.

Signed-off-by: Kyle Zhao &lt;kylezhao@tencent.com&gt;
---
    merge: avoid write merge state when unable to write index
    
    In some of our monorepos, code is sometimes lost after merging.
    
    After investigation, we discovered the problem.
    
    This happens if we perform &#34;git pull&#34; or &#34;git merge&#34; when another git
    process is writing to the index, especially in a monorepo (because its
    index will be larger).
    
    How to reproduce:
    
    git init demo
    cd demo
    touch 1.txt &#38;&#38; git add . &#38;&#38; git commit -m &#34;1&#34;
    git checkout -b source-branch
    touch 2.txt &#38;&#38; git add . &#38;&#38; git commit -m &#34;2&#34;
    git checkout master
    echo &#34;1&#34; &gt;&gt; 1.txt &#38;&#38; git add . &#38;&#38; git commit -m &#34;3&#34;
    # another git process runnning
    touch .git/index.lock
    git merge source-branch
    # another git process finished
    rm .git/index.lock
    git commit -m &#34;4&#34;
    
    
    Then the modifications from the source branch are lost.
    
    Regards, Kyle

Published-As: <a
href="https://github.com/gitgitgadget/git/releases/tag/pr-1731%2Fkeyu98%2Fkz%2Ffix-merge-when-index-lock-exists-v6">https://github.com/gitgitgadget/git/releases/tag/pr-1731%2Fkeyu98%2Fkz%2Ffix-merge-when-index-lock-exists-v6</a>
Fetch-It-Via: git fetch <a
href="https://github.com/gitgitgadget/git">https://github.com/gitgitgadget/git</a> pr-1731/keyu98/kz/fix-merge-when-index-lock-exists-v6
Pull-Request: <a
href="https://github.com/gitgitgadget/git/pull/1731">https://github.com/gitgitgadget/git/pull/1731</a>

Range-diff vs v5:

 1:  a5156088514 ! 1:  24150cd814a merge: avoid write merge state when unable to write index
     @@ Metadata
       ## Commit message ##
          merge: avoid write merge state when unable to write index
      
     -    When running a merge while the index is locked (presumably by another
     -    process), the merge state is written, the index is not updated, and then
     -    the merge fails. This might cause unexpected results.
     -
     -    E.g., if another running process is &#34;git commit&#34;, MERGE_HEAD and other
     -    state files we write on our side will be taken into account by them and
     -    cause them to record a merge, even though they may have been trying to
     -    record something entirely different.
     +    Writing the merge state after the index write fails is meaningless and
     +    could potentially cause Git to lose changes.
      
          Signed-off-by: Kyle Zhao &lt;kylezhao@tencent.com&gt;
      


 builtin/merge.c  |  2 +-
 t/t7600-merge.sh | 10 ++++++++++
 2 files <a href="http://lore.kernel.org/git/pull.1731.v6.git.1718593717745.gitgitgadget@gmail.com/#related">changed</a>, 11 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/builtin/merge.c b/builtin/merge.c
index daed2d4e1e2..03c405fa5df 100644
--- a/builtin/merge.c
+++ b/builtin/merge.c
</span><span
class="hunk">@@ -701,7 +701,7 @@ static int try_merge_strategy(const char *strategy, struct commit_list *common,
</span> 	if (repo_refresh_and_write_index(the_repository, REFRESH_QUIET,
 					 SKIP_IF_UNCHANGED, 0, NULL, NULL,
 					 NULL) &lt; 0)
<span
class="del">-		return error(_(&#34;Unable to write index.&#34;));
</span><span
class="add">+		die(_(&#34;Unable to write index.&#34;));
</span> 
 	if (!strcmp(strategy, &#34;recursive&#34;) || !strcmp(strategy, &#34;subtree&#34;) ||
 	    !strcmp(strategy, &#34;ort&#34;)) {
<span
class="head">diff --git a/t/t7600-merge.sh b/t/t7600-merge.sh
index e5ff073099a..ef54cff4faa 100755
--- a/t/t7600-merge.sh
+++ b/t/t7600-merge.sh
</span><span
class="hunk">@@ -236,6 +236,16 @@ test_expect_success &#39;merge c1 with c2&#39; &#39;
</span> 	verify_parents $c1 $c2
 &#39;
 
<span
class="add">+test_expect_success &#39;merge c1 with c2 when index.lock exists&#39; &#39;
+	test_when_finished rm .git/index.lock &#38;&#38;
+	git reset --hard c1 &#38;&#38;
+	&gt;.git/index.lock &#38;&#38;
+	test_must_fail git merge c2 &#38;&#38;
+	test_path_is_missing .git/MERGE_HEAD &#38;&#38;
+	test_path_is_missing .git/MERGE_MODE &#38;&#38;
+	test_path_is_missing .git/MERGE_MSG
+&#39;
+
</span> test_expect_success &#39;merge --squash c3 with c7&#39; &#39;
 	git reset --hard c3 &#38;&#38;
 	test_must_fail git merge --squash c7 &#38;&#38;

base-commit: d63586cb314731c851f28e14fc8012988467e2da
-- 
gitgitgadget
</pre></div></content></entry><entry><author><name>Serhii Tereshchenko</name><email>serg.partizan@gmail.com</email></author><title>[PATCH] Fix default font scaling</title><updated>2024-06-15T08:54:00Z</updated><link
href="http://lore.kernel.org/git/20240615085345.47278-1-serg.partizan@gmail.com/"/><id>urn:uuid:f041ed79-1a8b-bb8a-fb22-964e525f04e3</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This fixes font scaling for default fonts, where we don&#39;t set font
sizes explicitly.

Without this, on 4k monitor with text-scaling-factor configured in Gnome,
labels, buttons and settings are using very small font sizes. (Probably,
not just Gnome but anything that sets custom DPI).

Screenshots here: <a
href="https://twiukraine.com/@partizan/112619567918546426">https://twiukraine.com/@partizan/112619567918546426</a>

Signed-off-by: Serhii Tereshchenko &lt;serg.partizan@gmail.com&gt;
---
 git-gui.sh | 10 ++++++++++
 1 file <a href="http://lore.kernel.org/git/20240615085345.47278-1-serg.partizan@gmail.com/#related">changed</a>, 10 insertions(+)

<span
class="head">diff --git a/git-gui.sh b/git-gui.sh
index 8bc8892..23dd82d 100755
--- a/git-gui.sh
+++ b/git-gui.sh
</span><span
class="hunk">@@ -810,6 +810,16 @@ if {[is_Windows]} {
</span> ## config defaults
 
 set cursor_ptr arrow
<span
class="add">+
+# For whatever reason, Tk does not apply font scaling to default fonts,
+# but applies font scaling when setting size explicitly.
+# Default -size 10 is still 10, when you look at it with `font actual ...`,
+# but explicitl -size 10 becomes 10 * scale factor.
+# So, we need to configure fonts to use their default font sizes, but scaled.
+foreach font_name [font names] {
+	font configure $font_name -size [font actual $font_name -size]
+}
+
</span> font create font_ui
 if {[lsearch -exact [font names] TkDefaultFont] != -1} {
 	eval [linsert [font actual TkDefaultFont] 0 font configure font_ui]
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Taylor Blau</name><email>me@ttaylorr.com</email></author><title>[PATCH v2 2/2] pack-bitmap.c: ensure pseudo-merge offset reads are bounded</title><updated>2024-06-14T19:24:01Z</updated><link
href="http://lore.kernel.org/git/8abd564e7cbea8a3a165db86354d10a3f966d50f.1718392943.git.me@ttaylorr.com/"/><id>urn:uuid:4d373539-569a-5467-526a-68ab39ec3219</id><thr:in-reply-to
ref="urn:uuid:27af4bed-736c-db6b-5878-1527a05f85c2"
href="http://lore.kernel.org/git/cover.1718392943.git.me@ttaylorr.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">After reading the pseudo-merge extension&#39;s metadata table, we allocate
an array to store information about each pseudo-merge, including its
byte offset within the .bitmap file itself.

This is done like so:

    pseudo_merge_ofs = index_end - 24 -
            (index-&gt;pseudo_merges.nr * sizeof(uint64_t));
    for (i = 0; i &lt; index-&gt;pseudo_merges.nr; i++) {
            index-&gt;pseudo_merges.v[i].at = get_be64(pseudo_merge_ofs);
            pseudo_merge_ofs += sizeof(uint64_t);
    }

But if the pseudo-merge table is corrupt, we&#39;ll keep calling get_be64()
past the end of the pseudo-merge extension, potentially reading off the
end of the mmap&#39;d region.

Prevent this by ensuring that we have at least `table_size - 24` many
bytes available to read (adding 24 to the left-hand side of our
inequality to account for the length of the metadata component).

This is sufficient to prevent us from reading off the end of the
pseudo-merge extension, and ensures that all of the get_be64() calls
below are in bounds.

Helped-by: Jeff King &lt;peff@peff.net&gt;
Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
---
 pack-bitmap.c | 5 +++++
 1 file <a href="http://lore.kernel.org/git/8abd564e7cbea8a3a165db86354d10a3f966d50f.1718392943.git.me@ttaylorr.com/#related">changed</a>, 5 insertions(+)

<span
class="head">diff --git a/pack-bitmap.c b/pack-bitmap.c
index 70230e2647..ae13d7ee3b 100644
--- a/pack-bitmap.c
+++ b/pack-bitmap.c
</span><span
class="hunk">@@ -238,6 +238,11 @@ static int load_bitmap_header(struct bitmap_index *index)
</span> 				index-&gt;pseudo_merges.commits_nr = get_be32(index_end - 20);
 				index-&gt;pseudo_merges.nr = get_be32(index_end - 24);
 
<span
class="add">+				if (st_add(st_mult(index-&gt;pseudo_merges.nr,
+						   sizeof(uint64_t)),
+					   24) &gt; table_size)
+					return error(_(&#34;corrupted bitmap index file, pseudo-merge table too short&#34;));
+
</span> 				CALLOC_ARRAY(index-&gt;pseudo_merges.v,
 					     index-&gt;pseudo_merges.nr);
 
-- 
2.45.0.33.g0a16399d14.dirty
</pre></div></content></entry><entry><author><name>Taylor Blau</name><email>me@ttaylorr.com</email></author><title>[PATCH v2 1/2] Documentation/technical/bitmap-format.txt: add missing position table</title><updated>2024-06-14T19:23:57Z</updated><link
href="http://lore.kernel.org/git/a71ec05e5dc0c8c40e1cce14a7c5fe946437a24d.1718392943.git.me@ttaylorr.com/"/><id>urn:uuid:b137cabc-6733-87ac-564f-411aba16f15d</id><thr:in-reply-to
ref="urn:uuid:27af4bed-736c-db6b-5878-1527a05f85c2"
href="http://lore.kernel.org/git/cover.1718392943.git.me@ttaylorr.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">While investigating a benign Coverity warning on the new pseudo-merge
implementation, I was struggling to understand the (paraphrased) below:

    ofs = index_end - 24 - (index-&gt;pseudo_merges.nr * sizeof(uint64_t));
    for (i = 0; i &lt; index-&gt;pseudo_merges.nr; i++) {
            index-&gt;pseudo_merges.v[i].at = get_be64(ofs);
            ofs += sizeof(uint64_t);
    }

, in pack-bitmap.c::load_bitmap_header(). Looking at the documentation,
the diagram describing the on-disk format (prior to this patch)
suggested that the optional extended lookup table immediately preceded
the trailing metadata portion.

If that were the case, that would make the above code from
load_bitmap_header() incorrect, as we&#39;d be blindly reading into the
extended offset table.

But later on in the documentation there is a description of the
pseudo-merge position table as immediately preceding the trailing
metadata portion of the extension. And indeed, we do write the position
table in pack-bitmap-write.c:

    /* write positions for all pseudo merges */
    for (i = 0; i &lt; writer-&gt;pseudo_merges_nr; i++)
            hashwrite_be64(f, pseudo_merge_ofs[i]);

    hashwrite_be32(f, writer-&gt;pseudo_merges_nr);
    hashwrite_be32(f, kh_size(writer-&gt;pseudo_merge_commits));
    hashwrite_be64(f, table_start - start);
    hashwrite_be64(f, hashfile_total(f) - start + sizeof(uint64_t));

So this is purely a case of the diagram being out of sync with the
textual description and actual implementation of the format
specification.

Add the missing component back to the format diagram to avoid further
confusion in this area.

Signed-off-by: Taylor Blau &lt;me@ttaylorr.com&gt;
---
 Documentation/technical/bitmap-format.txt | 9 +++++++++
 1 file <a href="http://lore.kernel.org/git/a71ec05e5dc0c8c40e1cce14a7c5fe946437a24d.1718392943.git.me@ttaylorr.com/#related">changed</a>, 9 insertions(+)

<span
class="head">diff --git a/Documentation/technical/bitmap-format.txt b/Documentation/technical/bitmap-format.txt
index ee7775a258..bfb0ec7beb 100644
--- a/Documentation/technical/bitmap-format.txt
+++ b/Documentation/technical/bitmap-format.txt
</span><span
class="hunk">@@ -312,6 +312,15 @@ the end of a `.bitmap` file. The format is as follows:
</span> |                                           |
 +-------------------------------------------+
 |                                           |
<span
class="add">+|  Pseudo-merge position table              |
+|  +----+----------+----------+----------+  |
+|  | N  | Offset 1 |   ....   | Offset N |  |
+|  +----+----------+----------+----------+  |
+|  |    |  8 bytes |   ....   |  8 bytes |  |
+|  +----+----------+----------+----------+  |
+|                                           |
++-------------------------------------------+
+|                                           |
</span> |  Pseudo-merge Metadata                    |
 |  +-----------------------------------+    |
 |  | # pseudo-merges (4 bytes)         |    |
-- 
2.45.0.33.g0a16399d14.dirty

</pre></div></content></entry><entry><author><name>Taylor Blau</name><email>me@ttaylorr.com</email></author><title>[PATCH v2 0/2] pseudo-merge: various small fixes</title><updated>2024-06-14T19:23:55Z</updated><link
href="http://lore.kernel.org/git/cover.1718392943.git.me@ttaylorr.com/"/><id>urn:uuid:27af4bed-736c-db6b-5878-1527a05f85c2</id><thr:in-reply-to
ref="urn:uuid:38f4d113-0f4f-0bdc-7bb1-fd4f6bc5e650"
href="http://lore.kernel.org/git/a71ec05e5dc0c8c40e1cce14a7c5fe946437a24d.1717699237.git.me@ttaylorr.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Here is a small reroll of a couple of patches I wrote to fix various
small issues with the tb/pseudo-merge-reachability-bitmaps topic.

The only change since last time is replacing:

    if (st_mult(index-&gt;pseudo_merges.nr, sizeof(uint64_t)) &gt; table_size - 24)

with:

    if (st_add(st_mult(index-&gt;pseudo_merges.nr, sizeof(uint64_t)), 24) &gt; table_size)

based on helpful review from Junio. For convenience, a range-diff is
below. Thanks in advance for any final review on this topic :-).

Taylor Blau (2):
  Documentation/technical/bitmap-format.txt: add missing position table
  pack-bitmap.c: ensure pseudo-merge offset reads are bounded

 Documentation/technical/bitmap-format.txt | 9 +++++++++
 pack-bitmap.c                             | 5 +++++
 2 files changed, 14 insertions(+)

Range-diff against v1:
-:  ---------- &gt; 1:  a71ec05e5d Documentation/technical/bitmap-format.txt: add missing position table
1:  0a16399d14 ! 2:  8abd564e7c pack-bitmap.c: ensure pseudo-merge offset reads are bounded
    @@ Commit message
         end of the mmap&#39;d region.

         Prevent this by ensuring that we have at least `table_size - 24` many
    -    bytes available to read (subtracting 24 as the length of the metadata
    -    component).
    +    bytes available to read (adding 24 to the left-hand side of our
    +    inequality to account for the length of the metadata component).

         This is sufficient to prevent us from reading off the end of the
         pseudo-merge extension, and ensures that all of the get_be64() calls
    @@ pack-bitmap.c: static int load_bitmap_header(struct bitmap_index *index)
      				index-&gt;pseudo_merges.commits_nr = get_be32(index_end - 20);
      				index-&gt;pseudo_merges.nr = get_be32(index_end - 24);

    -+				if (st_mult(index-&gt;pseudo_merges.nr, sizeof(uint64_t)) &gt; table_size - 24)
    ++				if (st_add(st_mult(index-&gt;pseudo_merges.nr,
    ++						   sizeof(uint64_t)),
    ++					   24) &gt; table_size)
     +					return error(_(&#34;corrupted bitmap index file, pseudo-merge table too short&#34;));
     +
      				CALLOC_ARRAY(index-&gt;pseudo_merges.v,

base-commit: 0b7500dc66ffcb6b1ccc3332715936a59c6b5ce4
--
2.45.0.33.g0a16399d14.dirty
</pre></div></content></entry><entry><author><name>Junio C Hamano</name><email>gitster@pobox.com</email></author><title>[PATCH] archive: document that --add-virtual-file takes full path</title><updated>2024-06-14T18:41:00Z</updated><link
href="http://lore.kernel.org/git/xmqq5xubfjuu.fsf_-_@gitster.g/"/><id>urn:uuid:5d119f92-1e59-7f5c-6bd3-aba49495d043</id><thr:in-reply-to
ref="urn:uuid:2cb7c9c8-b39f-0957-57bf-84f4053e40ca"
href="http://lore.kernel.org/git/xmqqh6dvflea.fsf@gitster.g/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Junio C Hamano &lt;gitster@pobox.com&gt; writes:

<span
class="q">&gt; Ren&#233; Scharfe &lt;l.s.r@web.de&gt; writes:
&gt;
&gt;&gt; I&#39;m not sure I have an opinion on that topic, yet.  Fixing the
&gt;&gt; documentation is certainly easier.  Adding the prefix to the path of
&gt;&gt; virtual files as well is a breaking change.  I feel that the easier
&gt;&gt; route should at least be mentioned in the commit message and why it
&gt;&gt; was not taken.
&gt;
&gt; It has been a few weeks since this discussion stalled.  Let me make
&gt; an executive decision on the direction here---let&#39;s keep the behaviour
&gt; and align the documentation so that we won&#39;t break existing users.
&gt;
&gt; Thanks.
</span>
So here is to re-ignite the discussion.

----- &gt;8 -----
Subject: [PATCH] archive: document that --add-virtual-file takes full path

Tom Scogland noticed that `--add-virtual-file` option uses the path
specified as its value as-is, without prepending any value given to
the `--prefix` option like `--add-file` does.

The behaviour has always been that way since the option was
introduced, but the documentation has always been wrong and said
that it would use the value of `--prefix` just like `--add-file`
does.

We could modify the behaviour to make it literally work like the
documentation said, but it would break existing scripts the users
use.

Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
---
 Documentation/git-archive.txt | 10 ++++++----
 1 file <a href="http://lore.kernel.org/git/xmqq5xubfjuu.fsf_-_@gitster.g/#related">changed</a>, 6 insertions(+), 4 deletions(-)

<span
class="head">diff --git a/Documentation/git-archive.txt b/Documentation/git-archive.txt
index 98526f2beb..a0e3fe7996 100644
--- a/Documentation/git-archive.txt
+++ b/Documentation/git-archive.txt
</span><span
class="hunk">@@ -53,7 +53,7 @@ OPTIONS
</span> --prefix=&lt;prefix&gt;/::
 	Prepend &lt;prefix&gt;/ to paths in the archive.  Can be repeated; its
 	rightmost value is used for all tracked files.  See below which
<span
class="del">-	value gets used by `--add-file` and `--add-virtual-file`.
</span><span
class="add">+	value gets used by `--add-file`.
</span> 
 -o &lt;file&gt;::
 --output=&lt;file&gt;::
<span
class="hunk">@@ -67,9 +67,7 @@ OPTIONS
</span> 
 --add-virtual-file=&lt;path&gt;:&lt;content&gt;::
 	Add the specified contents to the archive.  Can be repeated to add
<span
class="del">-	multiple files.  The path of the file in the archive is built
-	by concatenating the value of the last `--prefix` option (if any)
-	before this `--add-virtual-file` and `&lt;path&gt;`.
</span><span
class="add">+	multiple files.
</span> +
 The `&lt;path&gt;` argument can start and end with a literal double-quote
 character; the contained file name is interpreted as a C-style string,
<span
class="hunk">@@ -81,6 +79,10 @@ if the path begins or ends with a double-quote character.
</span> The file mode is limited to a regular file, and the option may be
 subject to platform-dependent command-line limits. For non-trivial
 cases, write an untracked file and use `--add-file` instead.
<span
class="add">++
+Note that unlike `--add-file` the path created in the archive is not
+affected by the `--prefix` option, as a full `&lt;path&gt;` can be given as
+the value of the option.
</span> 
 --worktree-attributes::
 	Look for attributes in .gitattributes files in the working tree
-- 
2.45.2-683-g09b5b61c39

</pre></div></content></entry><entry><author><name>Jeff King</name><email>peff@peff.net</email></author><title>[PATCH 11/11] remote: drop checks for zero-url case</title><updated>2024-06-14T10:42:04Z</updated><link
href="http://lore.kernel.org/git/20240614104203.GK222445@coredump.intra.peff.net/"/><id>urn:uuid:5741ef31-3f33-5a49-b4c2-5aeafa4a374d</id><thr:in-reply-to
ref="urn:uuid:d67e1264-d284-4105-e0d9-849c435b0ca4"
href="http://lore.kernel.org/git/20240614102439.GA222287@coredump.intra.peff.net/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Now that the previous commit removed the possibility that a &#34;struct
remote&#34; will ever have zero url fields, we can drop a number of
redundant checks and untriggerable code paths.

Signed-off-by: Jeff King &lt;peff@peff.net&gt;
---
Note for reviewers: the hunk in builtin/push.c is funny. The original
code was:

  if (url-&gt;nr) {
	for (i = 0; i &lt; url-&gt;nr; i++) {
		do this
	}
  } else {
    do that
  }

And I removed the &#34;do that&#34; part along with the if/else to become:

  for (i = 0; i &lt; url-&gt;nr; i++) {
	do this
  }


But because &#34;this&#34; and &#34;that&#34; were so similar, and because the
indentation of &#34;this&#34; in the loop was now the same of the old &#34;that&#34;,
the diff makes it look like I dropped the first half of the conditional.

 builtin/archive.c          |  2 --
 builtin/ls-remote.c        |  2 --
 builtin/push.c             | 13 ++-----------
 builtin/remote.c           | 13 +++----------
 t/helper/test-bundle-uri.c |  2 --
 transport.c                | 17 +++++++----------
 6 files <a href="http://lore.kernel.org/git/20240614104203.GK222445@coredump.intra.peff.net/#related">changed</a>, 12 insertions(+), 37 deletions(-)

<span
class="head">diff --git a/builtin/archive.c b/builtin/archive.c
index 0d9aff7e6f..7234607aaa 100644
--- a/builtin/archive.c
+++ b/builtin/archive.c
</span><span
class="hunk">@@ -31,8 +31,6 @@ static int run_remote_archiver(int argc, const char **argv,
</span> 	struct packet_reader reader;
 
 	_remote = remote_get(remote);
<span
class="del">-	if (!_remote-&gt;url.nr)
-		die(_(&#34;git archive: Remote with no URL&#34;));
</span> 	transport = transport_get(_remote, _remote-&gt;url.v[0]);
 	transport_connect(transport, &#34;git-upload-archive&#34;, exec, fd);
 
<span
class="head">diff --git a/builtin/ls-remote.c b/builtin/ls-remote.c
index 4c04dbbf19..8f3a64d838 100644
--- a/builtin/ls-remote.c
+++ b/builtin/ls-remote.c
</span><span
class="hunk">@@ -109,8 +109,6 @@ int cmd_ls_remote(int argc, const char **argv, const char *prefix)
</span> 			die(&#34;bad repository &#39;%s&#39;&#34;, dest);
 		die(&#34;No remote configured to list refs from.&#34;);
 	}
<span
class="del">-	if (!remote-&gt;url.nr)
-		die(&#34;remote %s has no configured URL&#34;, dest);
</span> 
 	if (get_url) {
 		printf(&#34;%s\n&#34;, remote-&gt;url.v[0]);
<span
class="head">diff --git a/builtin/push.c b/builtin/push.c
index 00d99af1a8..8260c6e46a 100644
--- a/builtin/push.c
+++ b/builtin/push.c
</span><span
class="hunk">@@ -438,18 +438,9 @@ static int do_push(int flags,
</span> 	}
 	errs = 0;
 	url = push_url_of_remote(remote);
<span
class="del">-	if (url-&gt;nr) {
-		for (i = 0; i &lt; url-&gt;nr; i++) {
-			struct transport *transport =
-				transport_get(remote, url-&gt;v[i]);
-			if (flags &#38; TRANSPORT_PUSH_OPTIONS)
-				transport-&gt;push_options = push_options;
-			if (push_with_options(transport, push_refspec, flags))
-				errs++;
-		}
-	} else {
</span><span
class="add">+	for (i = 0; i &lt; url-&gt;nr; i++) {
</span> 		struct transport *transport =
<span
class="del">-			transport_get(remote, NULL);
</span><span
class="add">+			transport_get(remote, url-&gt;v[i]);
</span> 		if (flags &#38; TRANSPORT_PUSH_OPTIONS)
 			transport-&gt;push_options = push_options;
 		if (push_with_options(transport, push_refspec, flags))
<span
class="head">diff --git a/builtin/remote.c b/builtin/remote.c
index 06c09ed060..c5c94d4dbd 100644
--- a/builtin/remote.c
+++ b/builtin/remote.c
</span><span
class="hunk">@@ -1002,8 +1002,7 @@ static int get_remote_ref_states(const char *name,
</span> 		struct transport *transport;
 		const struct ref *remote_refs;
 
<span
class="del">-		transport = transport_get(states-&gt;remote, states-&gt;remote-&gt;url.nr &gt; 0 ?
-			states-&gt;remote-&gt;url.v[0] : NULL);
</span><span
class="add">+		transport = transport_get(states-&gt;remote, states-&gt;remote-&gt;url.v[0]);
</span> 		remote_refs = transport_get_remote_refs(transport, NULL);
 
 		states-&gt;queried = 1;
<span
class="hunk">@@ -1294,8 +1293,7 @@ static int show(int argc, const char **argv, const char *prefix)
</span> 		get_remote_ref_states(*argv, &#38;info.states, query_flag);
 
 		printf_ln(_(&#34;* remote %s&#34;), *argv);
<span
class="del">-		printf_ln(_(&#34;  Fetch URL: %s&#34;), info.states.remote-&gt;url.nr &gt; 0 ?
-		       info.states.remote-&gt;url.v[0] : _(&#34;(no URL)&#34;));
</span><span
class="add">+		printf_ln(_(&#34;  Fetch URL: %s&#34;), info.states.remote-&gt;url.v[0]);
</span> 		url = push_url_of_remote(info.states.remote);
 		for (i = 0; i &lt; url-&gt;nr; i++)
 			/*
<span
class="hunk">@@ -1440,10 +1438,7 @@ static int prune_remote(const char *remote, int dry_run)
</span> 	}
 
 	printf_ln(_(&#34;Pruning %s&#34;), remote);
<span
class="del">-	printf_ln(_(&#34;URL: %s&#34;),
-		  states.remote-&gt;url.nr
-		  ? states.remote-&gt;url.v[0]
-		  : _(&#34;(no URL)&#34;));
</span><span
class="add">+	printf_ln(_(&#34;URL: %s&#34;), states.remote-&gt;url.v[0]);
</span> 
 	for_each_string_list_item(item, &#38;states.stale)
 		string_list_append(&#38;refs_to_prune, item-&gt;util);
<span
class="hunk">@@ -1632,8 +1627,6 @@ static int get_url(int argc, const char **argv, const char *prefix)
</span> 	}
 
 	url = push_mode ? push_url_of_remote(remote) : &#38;remote-&gt;url;
<span
class="del">-	if (!url-&gt;nr)
-		die(_(&#34;no URLs configured for remote &#39;%s&#39;&#34;), remotename);
</span> 
 	if (all_mode) {
 		for (i = 0; i &lt; url-&gt;nr; i++)
<span
class="head">diff --git a/t/helper/test-bundle-uri.c b/t/helper/test-bundle-uri.c
index 3285dd962e..0c5fa723d8 100644
--- a/t/helper/test-bundle-uri.c
+++ b/t/helper/test-bundle-uri.c
</span><span
class="hunk">@@ -88,8 +88,6 @@ static int cmd_ls_remote(int argc, const char **argv)
</span> 			die(_(&#34;bad repository &#39;%s&#39;&#34;), dest);
 		die(_(&#34;no remote configured to get bundle URIs from&#34;));
 	}
<span
class="del">-	if (!remote-&gt;url.nr)
-		die(_(&#34;remote &#39;%s&#39; has no configured URL&#34;), dest);
</span> 
 	transport = transport_get(remote, NULL);
 	if (transport_get_remote_bundle_uri(transport) &lt; 0) {
<span
class="head">diff --git a/transport.c b/transport.c
index eba92eb7e0..a324045240 100644
--- a/transport.c
+++ b/transport.c
</span><span
class="hunk">@@ -1112,6 +1112,7 @@ static struct transport_vtable builtin_smart_vtable = {
</span> struct transport *transport_get(struct remote *remote, const char *url)
 {
 	const char *helper;
<span
class="add">+	const char *p;
</span> 	struct transport *ret = xcalloc(1, sizeof(*ret));
 
 	ret-&gt;progress = isatty(2);
<span
class="hunk">@@ -1127,19 +1128,15 @@ struct transport *transport_get(struct remote *remote, const char *url)
</span> 	ret-&gt;remote = remote;
 	helper = remote-&gt;foreign_vcs;
 
<span
class="del">-	if (!url &#38;&#38; remote-&gt;url.nr)
</span><span
class="add">+	if (!url)
</span> 		url = remote-&gt;url.v[0];
 	ret-&gt;url = url;
 
<span
class="del">-	/* maybe it is a foreign URL? */
-	if (url) {
-		const char *p = url;
-
-		while (is_urlschemechar(p == url, *p))
-			p++;
-		if (starts_with(p, &#34;::&#34;))
-			helper = xstrndup(url, p - url);
-	}
</span><span
class="add">+	p = url;
+	while (is_urlschemechar(p == url, *p))
+		p++;
+	if (starts_with(p, &#34;::&#34;))
+		helper = xstrndup(url, p - url);
</span> 
 	if (helper) {
 		transport_helper_init(ret, helper);
-- 
2.45.2.937.g0bcb3c087a
</pre></div></content></entry><entry><author><name>Jeff King</name><email>peff@peff.net</email></author><title>[PATCH 10/11] remote: always require at least one url in a remote</title><updated>2024-06-14T10:37:12Z</updated><link
href="http://lore.kernel.org/git/20240614103711.GJ222445@coredump.intra.peff.net/"/><id>urn:uuid:6128baa6-7b90-8add-a4a7-00939e9aa96a</id><thr:in-reply-to
ref="urn:uuid:d67e1264-d284-4105-e0d9-849c435b0ca4"
href="http://lore.kernel.org/git/20240614102439.GA222287@coredump.intra.peff.net/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">When we return a struct from remote_get(), the result _almost_ always
has at least one url. In remotes_remote_get_1(), we do this:

        if (name_given &#38;&#38; !valid_remote(ret))
                add_url_alias(remote_state, ret, name);
        if (!valid_remote(ret))
                return NULL;

So if the remote doesn&#39;t have a url, we give it one based on the name
(this is how unconfigured urls are used as remotes). And if that doesn&#39;t
work, we return NULL.

But there&#39;s a catch: valid_remote() checks that we have at least one url
_unless_ the remote.*.vcs field is set. This comes from c578f51d52 (Add
a config option for remotes to specify a foreign vcs, 2009-11-18), and
the whole idea was to support remote helpers that don&#39;t have their own
url.

However, that mode has been broken since 25d5cc488a (Pass unknown
protocols to external protocol handlers, 2009-12-09)! That commit
unconditionally looks at the url in get_helper(), causing a segfault
with something like:

  git -c remote.foo.vcs=bar fetch foo

We could fix that now, of course. But given that it has been broken for
almost 15 years and nobody noticed, there&#39;s a better option. This weird
&#34;there might not be a url&#34; special case requires checks all over the
code base, and it&#39;s not clear if there are other similar segfaults
lurking. It would be nice if we could drop that special case.

So instead, let&#39;s let the &#34;the remote name is the url&#34; code kick in. If
you have &#34;remote.foo.vcs&#34;, then your url (unless otherwise configured)
is &#34;foo&#34;. This does have a visible effect compared to what 25d5cc488a
was trying to do. The idea back then is that for a remote without a url,
we&#39;d run:

   # only one command-line option!
   git-remote-bar foo

whereas with our default url, now we&#39;ll run:

  git-remote-bar foo foo

Again, in practice nobody can be relying on this because it has been
segfaulting for 15 years. We should consider just removing this &#34;vcs&#34;
config option entirely, but that would be a user-visible breakage. So by
fixing it this way, we can keep things working that have been working,
and simplify away one special case inside our code.

This fixes the segfault from 25d5cc488a (demonstrated by the test), and
we can build further cleanups on top.

Signed-off-by: Jeff King &lt;peff@peff.net&gt;
---
 remote.c                  | 2 +-
 t/t5801-remote-helpers.sh | 2 +-
 2 files <a href="http://lore.kernel.org/git/20240614103711.GJ222445@coredump.intra.peff.net/#related">changed</a>, 2 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/remote.c b/remote.c
index b7262964fb..5fa046c8f8 100644
--- a/remote.c
+++ b/remote.c
</span><span
class="hunk">@@ -32,7 +32,7 @@ struct counted_string {
</span> 
 static int valid_remote(const struct remote *remote)
 {
<span
class="del">-	return (!!remote-&gt;url.nr) || (!!remote-&gt;foreign_vcs);
</span><span
class="add">+	return !!remote-&gt;url.nr;
</span> }
 
 static char *alias_url(const char *url, struct rewrites *r)
<span
class="head">diff --git a/t/t5801-remote-helpers.sh b/t/t5801-remote-helpers.sh
index 7c8c4359aa..20f43f7b7d 100755
--- a/t/t5801-remote-helpers.sh
+++ b/t/t5801-remote-helpers.sh
</span><span
class="hunk">@@ -53,7 +53,7 @@ test_expect_success &#39;fetch with configured remote.*.vcs&#39; &#39;
</span> 	test_grep remote-testgit vcs-fetch.trace
 &#39;
 
<span
class="del">-test_expect_failure &#39;vcs remote with no url&#39; &#39;
</span><span
class="add">+test_expect_success &#39;vcs remote with no url&#39; &#39;
</span> 	NOURL_UPSTREAM=$PWD/server &#38;&#38;
 	export NOURL_UPSTREAM &#38;&#38;
 	git init vcs-nourl &#38;&#38;
-- 
2.45.2.937.g0bcb3c087a

</pre></div></content></entry><entry><author><name>Jeff King</name><email>peff@peff.net</email></author><title>[PATCH 09/11] t5801: test remote.*.vcs config</title><updated>2024-06-14T10:34:55Z</updated><link
href="http://lore.kernel.org/git/20240614103454.GI222445@coredump.intra.peff.net/"/><id>urn:uuid:db01e2b0-603e-3f43-ea5d-ad5a26fe7e44</id><thr:in-reply-to
ref="urn:uuid:d67e1264-d284-4105-e0d9-849c435b0ca4"
href="http://lore.kernel.org/git/20240614102439.GA222287@coredump.intra.peff.net/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The usual way to trigger a remote helper is to use the &#34;::&#34; syntax from:
87422439d1 (Allow specifying the remote helper in the url, 2009-11-18).
Doing:

  git config remote.origin.url hg::<a
href="https://example.com/repo">https://example.com/repo</a>

will run &#34;git-remote-hg origin <a
href="https://example.com/repo">https://example.com/repo</a>&#34;. Or you can
use the fallback handling from 25d5cc488a (Pass unknown protocols to
external protocol handlers, 2009-12-09):

  git config remote.origin.url &#34;foo://bar&#34;

which will run &#34;git-remote-foo origin foo://bar&#34;.

But there&#39;s a third way, from c578f51d52 (Add a config option for
remotes to specify a foreign vcs, 2009-11-18):

  git config remote.origin.vcs foo
  git config remote.origin.url bar

which will run &#34;git-remote-foo origin bar&#34;. This is mostly redundant
with the other methods, except that it is supposed to allow you to run
without a URL at all. So:

  git config remote.origin.vcs foo

would run &#34;git-remote-foo origin&#34; with no extra URL parameter (under the
assumption that the helper somehow knows how to access the remote repo).
However, this mode has been broken since 25d5cc488a, shortly after it
was added! That commit taught the transport code to always look at the
URL string to parse off the &#34;foo::&#34; bits, meaning it would always
segfault in the no-url case. You can see that with:

  git -c remote.foo.vcs=bar fetch foo

Nobody seems to have noticed in the almost 15 years since, so presumably
it&#39;s not a well-used feature. And without that, arguably the whole
remote.*.vcs feature could be removed entirely, as it isn&#39;t offering
anything you couldn&#39;t do with the &#34;helper::&#34; syntax. But it _does_ work
if you have a URL, and it has been advertised in the documentation for
all that time. So we shouldn&#39;t just remove it without warning.

Likewise, even if we were going to deprecate it, we should avoid
breaking it in the meantime. Since there are no tests for it at all,
let&#39;s add a few basic ones:

  - this syntax doesn&#39;t work well with &#34;git clone&#34; (another point
    against it versus &#34;helper::&#34;). But we can use &#34;clone -c&#34; to set up
    the config manually, passing the URL as usual to clone. This does
    work, though note that I had to use --no-local in the test to avoid
    broken interactions between the local code and the helper. In the
    real world this would be a non-issue, since the remote URL would
    generally not also be a local Git repo!

  - likewise, we should be able to set up the config manually and fetch
    into a repository. This also works.

  - we can simulate a vcs that has no URL support by stuffing the remote
    path into another environment variable. This should work, but
    doesn&#39;t (it hits the segfault mentioned above).

In the first two cases, I took the extra step of checking GIT_TRACE
output to confirm that we actually ran the helper (since the URL is a
valid Git repo, the clone/fetch would appear to work even if we
didn&#39;t use the helper at all!).

Signed-off-by: Jeff King &lt;peff@peff.net&gt;
---
I have no real problem with deprecating this, and it might be a nice
thing to clean up in the long run. But it seemed like less work to just
fix it in the next patch, so I did that. ;)

 t/t5801-remote-helpers.sh | 23 +++++++++++++++++++++++
 t/t5801/git-remote-nourl  |  3 +++
 2 files <a href="http://lore.kernel.org/git/20240614103454.GI222445@coredump.intra.peff.net/#related">changed</a>, 26 insertions(+)
 create mode 100755 t/t5801/git-remote-nourl

<span
class="head">diff --git a/t/t5801-remote-helpers.sh b/t/t5801-remote-helpers.sh
index 4e0a77f985..7c8c4359aa 100755
--- a/t/t5801-remote-helpers.sh
+++ b/t/t5801-remote-helpers.sh
</span><span
class="hunk">@@ -38,6 +38,29 @@ test_expect_success &#39;cloning from local repo&#39; &#39;
</span> 	test_cmp server/file local/file
 &#39;
 
<span
class="add">+test_expect_success &#39;clone with remote.*.vcs config&#39; &#39;
+	GIT_TRACE=$PWD/vcs-clone.trace \
+	git clone --no-local -c remote.origin.vcs=testgit &#34;$PWD/server&#34; vcs-clone &#38;&#38;
+	test_grep remote-testgit vcs-clone.trace
+&#39;
+
+test_expect_success &#39;fetch with configured remote.*.vcs&#39; &#39;
+	git init vcs-fetch &#38;&#38;
+	git -C vcs-fetch config remote.origin.vcs testgit &#38;&#38;
+	git -C vcs-fetch config remote.origin.url &#34;$PWD/server&#34; &#38;&#38;
+	GIT_TRACE=$PWD/vcs-fetch.trace \
+	git -C vcs-fetch fetch origin &#38;&#38;
+	test_grep remote-testgit vcs-fetch.trace
+&#39;
+
+test_expect_failure &#39;vcs remote with no url&#39; &#39;
+	NOURL_UPSTREAM=$PWD/server &#38;&#38;
+	export NOURL_UPSTREAM &#38;&#38;
+	git init vcs-nourl &#38;&#38;
+	git -C vcs-nourl config remote.origin.vcs nourl &#38;&#38;
+	git -C vcs-nourl fetch origin
+&#39;
+
</span> test_expect_success &#39;create new commit on remote&#39; &#39;
 	(cd server &#38;&#38;
 	 echo content &gt;&gt;file &#38;&#38;
<span
class="head">diff --git a/t/t5801/git-remote-nourl b/t/t5801/git-remote-nourl
new file mode 100755
index 0000000000..09be6013c5
--- /dev/null
+++ b/t/t5801/git-remote-nourl
</span><span
class="hunk">@@ -0,0 +1,3 @@
</span><span
class="add">+#!/bin/sh
+
+exec git-remote-testgit &#34;$1&#34; &#34;$NOURL_UPSTREAM&#34;
</span>-- 
2.45.2.937.g0bcb3c087a

</pre></div></content></entry><entry><author><name>Jeff King</name><email>peff@peff.net</email></author><title>[PATCH 08/11] t5801: make remote-testgit GIT_DIR setup more robust</title><updated>2024-06-14T10:31:33Z</updated><link
href="http://lore.kernel.org/git/20240614103131.GH222445@coredump.intra.peff.net/"/><id>urn:uuid:5f57b188-e010-8bf3-0e82-31b8c6ca2b04</id><thr:in-reply-to
ref="urn:uuid:d67e1264-d284-4105-e0d9-849c435b0ca4"
href="http://lore.kernel.org/git/20240614102439.GA222287@coredump.intra.peff.net/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Our tests use a fake helper that just imports from an existing Git
repository. We&#39;re fed the path to that repo on the command line, and
derive the GIT_DIR by tacking on &#34;/.git&#34;.

This is wrong if the path is a bare repository, but that&#39;s OK since this
is just a limited test. But it&#39;s also wrong if the transport code feeds
us the actual .git directory itself (i.e., we expect &#34;/path/to/repo&#34; but
it gives us &#34;/path/to/repo/.git&#34;). None of the current tests do that,
but let&#39;s future-proof ourselves against adding a test that does.

We can instead ask &#34;rev-parse&#34; to set our GIT_DIR. Note that we have to
first unset other git variables from our environment. Coming into this
script, we&#39;ll have GIT_DIR set to the fetching repository, and we need
to &#34;switch&#34; to the remote one.

Signed-off-by: Jeff King &lt;peff@peff.net&gt;
---
 t/t5801/git-remote-testgit | 3 ++-
 1 file <a href="http://lore.kernel.org/git/20240614103131.GH222445@coredump.intra.peff.net/#related">changed</a>, 2 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/t/t5801/git-remote-testgit b/t/t5801/git-remote-testgit
index c5b10f5775..f8b476499f 100755
--- a/t/t5801/git-remote-testgit
+++ b/t/t5801/git-remote-testgit
</span><span
class="hunk">@@ -26,7 +26,8 @@ then
</span> 	t_refspec=&#34;&#34;
 fi
 
<span
class="del">-GIT_DIR=&#34;$url/.git&#34;
</span><span
class="add">+unset $(git rev-parse --local-env-vars)
+GIT_DIR=$(git -C &#34;$url&#34; rev-parse --absolute-git-dir)
</span> export GIT_DIR
 
 force=
-- 
2.45.2.937.g0bcb3c087a

</pre></div></content></entry><entry><author><name>Jeff King</name><email>peff@peff.net</email></author><title>[PATCH 07/11] remote: allow resetting url list</title><updated>2024-06-14T10:31:24Z</updated><link
href="http://lore.kernel.org/git/20240614103122.GG222445@coredump.intra.peff.net/"/><id>urn:uuid:04dd5825-bd96-1f50-bcb4-01ff49f89ddd</id><thr:in-reply-to
ref="urn:uuid:d67e1264-d284-4105-e0d9-849c435b0ca4"
href="http://lore.kernel.org/git/20240614102439.GA222287@coredump.intra.peff.net/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Because remote.*.url is treated as a multi-valued key, there is no way
to override previous config. So for example if you have
remote.origin.url set to some wrong value, doing:

  git -c remote.origin.url=right fetch

would not work. It would append &#34;right&#34; to the list, which means we&#39;d
still fetch from &#34;wrong&#34; (since subsequent values are used only as push
urls).

Let&#39;s provide a mechanism to reset the list, like we do for other
multi-valued keys (e.g., credential.helper, http.extraheaders, and
merge.suppressDest all use this &#34;empty string means reset&#34; pattern).

Reported-by: Mathew George &lt;mathewegeorge@gmail.com&gt;
Signed-off-by: Jeff King &lt;peff@peff.net&gt;
---
By the way, I think the nearby remote.*.fetch and remote.*.push could
learn the same trick. I left that out of this series, mostly because it
was getting long. But also because I had trouble imagining how a one-off
refspec change would be useful. We can revisit it on top if we want.

 Documentation/config/remote.txt |  5 ++++-
 remote.c                        | 10 +++++++--
 t/t5505-remote.sh               | 36 +++++++++++++++++++++++++++++++++
 3 files <a href="http://lore.kernel.org/git/20240614103122.GG222445@coredump.intra.peff.net/#related">changed</a>, 48 insertions(+), 3 deletions(-)

<span
class="head">diff --git a/Documentation/config/remote.txt b/Documentation/config/remote.txt
index eef0bf4f62..8efc53e836 100644
--- a/Documentation/config/remote.txt
+++ b/Documentation/config/remote.txt
</span><span
class="hunk">@@ -8,13 +8,16 @@ remote.&lt;name&gt;.url::
</span> 	linkgit:git-push[1]. A configured remote can have multiple URLs;
 	in this case the first is used for fetching, and all are used
 	for pushing (assuming no `remote.&lt;name&gt;.pushurl` is defined).
<span
class="add">+	Setting this key to the empty string clears the list of urls,
+	allowing you to override earlier config.
</span> 
 remote.&lt;name&gt;.pushurl::
 	The push URL of a remote repository.  See linkgit:git-push[1].
 	If a `pushurl` option is present in a configured remote, it
 	is used for pushing instead of `remote.&lt;name&gt;.url`. A configured
 	remote can have multiple push URLs; in this case a push goes to
<span
class="del">-	all of them.
</span><span
class="add">+	all of them. Setting this key to the empty string clears the
+	list of urls, allowing you to override earlier config.
</span> 
 remote.&lt;name&gt;.proxy::
 	For remotes that require curl (http, https and ftp), the URL to
<span
class="head">diff --git a/remote.c b/remote.c
index 9417d83e51..b7262964fb 100644
--- a/remote.c
+++ b/remote.c
</span><span
class="hunk">@@ -63,12 +63,18 @@ static char *alias_url(const char *url, struct rewrites *r)
</span> 
 static void add_url(struct remote *remote, const char *url)
 {
<span
class="del">-	strvec_push(&#38;remote-&gt;url, url);
</span><span
class="add">+	if (*url)
+		strvec_push(&#38;remote-&gt;url, url);
+	else
+		strvec_clear(&#38;remote-&gt;url);
</span> }
 
 static void add_pushurl(struct remote *remote, const char *pushurl)
 {
<span
class="del">-	strvec_push(&#38;remote-&gt;pushurl, pushurl);
</span><span
class="add">+	if (*pushurl)
+		strvec_push(&#38;remote-&gt;pushurl, pushurl);
+	else
+		strvec_clear(&#38;remote-&gt;pushurl);
</span> }
 
 static void add_pushurl_alias(struct remote_state *remote_state,
<span
class="head">diff --git a/t/t5505-remote.sh b/t/t5505-remote.sh
index 7789ff12c4..08424e878e 100755
--- a/t/t5505-remote.sh
+++ b/t/t5505-remote.sh
</span><span
class="hunk">@@ -1492,4 +1492,40 @@ test_expect_success &#39;refs/remotes/* &lt;src&gt; refspec and unqualified &lt;dst&gt; DWIM and
</span> 	)
 &#39;
 
<span
class="add">+test_expect_success &#39;empty config clears remote.*.url list&#39; &#39;
+	test_when_finished &#34;git config --remove-section remote.multi&#34; &#38;&#38;
+	git config --add remote.multi.url wrong-one &#38;&#38;
+	git config --add remote.multi.url wrong-two &#38;&#38;
+	git -c remote.multi.url= \
+	    -c remote.multi.url=right-one \
+	    -c remote.multi.url=right-two \
+	    remote show -n multi &gt;actual.raw &#38;&#38;
+	grep URL actual.raw &gt;actual &#38;&#38;
+	cat &gt;expect &lt;&lt;-\EOF &#38;&#38;
+	  Fetch URL: right-one
+	  Push  URL: right-one
+	  Push  URL: right-two
+	EOF
+	test_cmp expect actual
+&#39;
+
+test_expect_success &#39;empty config clears remote.*.pushurl list&#39; &#39;
+	test_when_finished &#34;git config --remove-section remote.multi&#34; &#38;&#38;
+	git config --add remote.multi.url right &#38;&#38;
+	git config --add remote.multi.url will-be-ignored &#38;&#38;
+	git config --add remote.multi.pushurl wrong-push-one &#38;&#38;
+	git config --add remote.multi.pushurl wrong-push-two &#38;&#38;
+	git -c remote.multi.pushurl= \
+	    -c remote.multi.pushurl=right-push-one \
+	    -c remote.multi.pushurl=right-push-two \
+	    remote show -n multi &gt;actual.raw &#38;&#38;
+	grep URL actual.raw &gt;actual &#38;&#38;
+	cat &gt;expect &lt;&lt;-\EOF &#38;&#38;
+	  Fetch URL: right
+	  Push  URL: right-push-one
+	  Push  URL: right-push-two
+	EOF
+	test_cmp expect actual
+&#39;
+
</span> test_done
-- 
2.45.2.937.g0bcb3c087a

</pre></div></content></entry><entry><author><name>Jeff King</name><email>peff@peff.net</email></author><title>[PATCH 06/11] config: document remote.*.url/pushurl interaction</title><updated>2024-06-14T10:30:06Z</updated><link
href="http://lore.kernel.org/git/20240614103005.GF222445@coredump.intra.peff.net/"/><id>urn:uuid:9045caef-1942-4fff-b142-9073e08d5c0f</id><thr:in-reply-to
ref="urn:uuid:d67e1264-d284-4105-e0d9-849c435b0ca4"
href="http://lore.kernel.org/git/20240614102439.GA222287@coredump.intra.peff.net/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The documentation for these keys gives a very terse definition and
points you to the fetch/push manpages. But from reading those pages it
was not at all obvious to me that:

  - these are keys that can be defined multiple times with meaningful
    behavior (especially remote.*.url)

  - the way that pushurl overrides url (the git-push page does mention
    that &#34;pushurl defaults to url&#34;, but it is not immediately clear what
    a multi-valued url would do in that situation).

Let&#39;s try to summarize the current behavior.

Signed-off-by: Jeff King &lt;peff@peff.net&gt;
---
 Documentation/config/remote.txt | 8 +++++++-
 1 file <a href="http://lore.kernel.org/git/20240614103005.GF222445@coredump.intra.peff.net/#related">changed</a>, 7 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/Documentation/config/remote.txt b/Documentation/config/remote.txt
index 0678b4bcfe..eef0bf4f62 100644
--- a/Documentation/config/remote.txt
+++ b/Documentation/config/remote.txt
</span><span
class="hunk">@@ -5,10 +5,16 @@ remote.pushDefault::
</span> 
 remote.&lt;name&gt;.url::
 	The URL of a remote repository.  See linkgit:git-fetch[1] or
<span
class="del">-	linkgit:git-push[1].
</span><span
class="add">+	linkgit:git-push[1]. A configured remote can have multiple URLs;
+	in this case the first is used for fetching, and all are used
+	for pushing (assuming no `remote.&lt;name&gt;.pushurl` is defined).
</span> 
 remote.&lt;name&gt;.pushurl::
 	The push URL of a remote repository.  See linkgit:git-push[1].
<span
class="add">+	If a `pushurl` option is present in a configured remote, it
+	is used for pushing instead of `remote.&lt;name&gt;.url`. A configured
+	remote can have multiple push URLs; in this case a push goes to
+	all of them.
</span> 
 remote.&lt;name&gt;.proxy::
 	For remotes that require curl (http, https and ftp), the URL to
-- 
2.45.2.937.g0bcb3c087a

</pre></div></content></entry><entry><author><name>Jeff King</name><email>peff@peff.net</email></author><title>[PATCH 05/11] remote: simplify url/pushurl selection</title><updated>2024-06-14T10:29:11Z</updated><link
href="http://lore.kernel.org/git/20240614102909.GE222445@coredump.intra.peff.net/"/><id>urn:uuid:e976545b-1c00-da37-314c-ce21e7b6feff</id><thr:in-reply-to
ref="urn:uuid:d67e1264-d284-4105-e0d9-849c435b0ca4"
href="http://lore.kernel.org/git/20240614102439.GA222287@coredump.intra.peff.net/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">When we want to know the push urls for a remote, there is some simple
logic:

  - if the user configured any remote.*.pushurl keys, then those make
    the complete set of push urls

  - otherwise we push to all urls in remote.*.url

Many spots implement this with a level of indirection, assigning to a
local url/url_nr pair. But since both arrays are now strvecs, we can
just use a pointer to select the appropriate strvec, shortening the code
a bit.

Even though this is now a one-liner, since it is application logic that
is present in so many places, it&#39;s worth abstracting a helper function.
In fact, we already have such a function, but it&#39;s local to
builtin/push.c. So we&#39;ll just make it available everywhere via remote.h.

There are two spots to pay special attention to here:

  1. in builtin/remote.c&#39;s get_url(), we are selecting first based on
     push_mode and then falling back to &#34;url&#34; when we&#39;re in push_mode
     but no pushurl is defined. The updated code makes that much more
     clear, compared to the original which had an &#34;else&#34; fall-through.

  2. likewise in that file&#39;s set_url(), we _only_ respect push_mode,
     sine the point is that we are adding to pushurl in that case
     (whether it is empty or not). And thus it does not use our helper
     function.

Signed-off-by: Jeff King &lt;peff@peff.net&gt;
---
 builtin/push.c   | 21 ++++-----------
 builtin/remote.c | 69 ++++++++++++++----------------------------------
 remote.c         |  5 ++++
 remote.h         |  1 +
 4 files <a href="http://lore.kernel.org/git/20240614102909.GE222445@coredump.intra.peff.net/#related">changed</a>, 31 insertions(+), 65 deletions(-)

<span
class="head">diff --git a/builtin/push.c b/builtin/push.c
index 61b5d3afdd..00d99af1a8 100644
--- a/builtin/push.c
+++ b/builtin/push.c
</span><span
class="hunk">@@ -141,16 +141,6 @@ static void set_refspecs(const char **refs, int nr, const char *repo)
</span> 	free_refs(local_refs);
 }
 
<span
class="del">-static int push_url_of_remote(struct remote *remote, const char ***url_p)
-{
-	if (remote-&gt;pushurl.nr) {
-		*url_p = remote-&gt;pushurl.v;
-		return remote-&gt;pushurl.nr;
-	}
-	*url_p = remote-&gt;url.v;
-	return remote-&gt;url.nr;
-}
-
</span> static NORETURN void die_push_simple(struct branch *branch,
 				     struct remote *remote)
 {
<span
class="hunk">@@ -434,8 +424,7 @@ static int do_push(int flags,
</span> 		   struct remote *remote)
 {
 	int i, errs;
<span
class="del">-	const char **url;
-	int url_nr;
</span><span
class="add">+	struct strvec *url;
</span> 	struct refspec *push_refspec = &#38;rs;
 
 	if (push_options-&gt;nr)
<span
class="hunk">@@ -448,11 +437,11 @@ static int do_push(int flags,
</span> 			setup_default_push_refspecs(&#38;flags, remote);
 	}
 	errs = 0;
<span
class="del">-	url_nr = push_url_of_remote(remote, &#38;url);
-	if (url_nr) {
-		for (i = 0; i &lt; url_nr; i++) {
</span><span
class="add">+	url = push_url_of_remote(remote);
+	if (url-&gt;nr) {
+		for (i = 0; i &lt; url-&gt;nr; i++) {
</span> 			struct transport *transport =
<span
class="del">-				transport_get(remote, url[i]);
</span><span
class="add">+				transport_get(remote, url-&gt;v[i]);
</span> 			if (flags &#38; TRANSPORT_PUSH_OPTIONS)
 				transport-&gt;push_options = push_options;
 			if (push_with_options(transport, push_refspec, flags))
<span
class="head">diff --git a/builtin/remote.c b/builtin/remote.c
index ee6a33ff11..06c09ed060 100644
--- a/builtin/remote.c
+++ b/builtin/remote.c
</span><span
class="hunk">@@ -1213,8 +1213,8 @@ static int get_one_entry(struct remote *remote, void *priv)
</span> {
 	struct string_list *list = priv;
 	struct strbuf remote_info_buf = STRBUF_INIT;
<span
class="del">-	const char **url;
-	int i, url_nr;
</span><span
class="add">+	struct strvec *url;
+	int i;
</span> 
 	if (remote-&gt;url.nr &gt; 0) {
 		struct strbuf promisor_config = STRBUF_INIT;
<span
class="hunk">@@ -1230,16 +1230,10 @@ static int get_one_entry(struct remote *remote, void *priv)
</span> 				strbuf_detach(&#38;remote_info_buf, NULL);
 	} else
 		string_list_append(list, remote-&gt;name)-&gt;util = NULL;
<span
class="del">-	if (remote-&gt;pushurl.nr) {
-		url = remote-&gt;pushurl.v;
-		url_nr = remote-&gt;pushurl.nr;
-	} else {
-		url = remote-&gt;url.v;
-		url_nr = remote-&gt;url.nr;
-	}
-	for (i = 0; i &lt; url_nr; i++)
</span><span
class="add">+	url = push_url_of_remote(remote);
+	for (i = 0; i &lt; url-&gt;nr; i++)
</span> 	{
<span
class="del">-		strbuf_addf(&#38;remote_info_buf, &#34;%s (push)&#34;, url[i]);
</span><span
class="add">+		strbuf_addf(&#38;remote_info_buf, &#34;%s (push)&#34;, url-&gt;v[i]);
</span> 		string_list_append(list, remote-&gt;name)-&gt;util =
 				strbuf_detach(&#38;remote_info_buf, NULL);
 	}
<span
class="hunk">@@ -1295,28 +1289,21 @@ static int show(int argc, const char **argv, const char *prefix)
</span> 
 	for (; argc; argc--, argv++) {
 		int i;
<span
class="del">-		const char **url;
-		int url_nr;
</span><span
class="add">+		struct strvec *url;
</span> 
 		get_remote_ref_states(*argv, &#38;info.states, query_flag);
 
 		printf_ln(_(&#34;* remote %s&#34;), *argv);
 		printf_ln(_(&#34;  Fetch URL: %s&#34;), info.states.remote-&gt;url.nr &gt; 0 ?
 		       info.states.remote-&gt;url.v[0] : _(&#34;(no URL)&#34;));
<span
class="del">-		if (info.states.remote-&gt;pushurl.nr) {
-			url = info.states.remote-&gt;pushurl.v;
-			url_nr = info.states.remote-&gt;pushurl.nr;
-		} else {
-			url = info.states.remote-&gt;url.v;
-			url_nr = info.states.remote-&gt;url.nr;
-		}
-		for (i = 0; i &lt; url_nr; i++)
</span><span
class="add">+		url = push_url_of_remote(info.states.remote);
+		for (i = 0; i &lt; url-&gt;nr; i++)
</span> 			/*
 			 * TRANSLATORS: the colon &#39;:&#39; should align
 			 * with the one in &#34; Fetch URL: %s&#34;
 			 * translation.
 			 */
<span
class="del">-			printf_ln(_(&#34;  Push  URL: %s&#34;), url[i]);
</span><span
class="add">+			printf_ln(_(&#34;  Push  URL: %s&#34;), url-&gt;v[i]);
</span> 		if (!i)
 			printf_ln(_(&#34;  Push  URL: %s&#34;), _(&#34;(no URL)&#34;));
 		if (no_query)
<span
class="hunk">@@ -1622,8 +1609,7 @@ static int get_url(int argc, const char **argv, const char *prefix)
</span> 	int i, push_mode = 0, all_mode = 0;
 	const char *remotename = NULL;
 	struct remote *remote;
<span
class="del">-	const char **url;
-	int url_nr;
</span><span
class="add">+	struct strvec *url;
</span> 	struct option options[] = {
 		OPT_BOOL(&#39;\0&#39;, &#34;push&#34;, &#38;push_mode,
 			 N_(&#34;query push URLs rather than fetch URLs&#34;)),
<span
class="hunk">@@ -1645,27 +1631,15 @@ static int get_url(int argc, const char **argv, const char *prefix)
</span> 		exit(2);
 	}
 
<span
class="del">-	url_nr = 0;
-	if (push_mode) {
-		url = remote-&gt;pushurl.v;
-		url_nr = remote-&gt;pushurl.nr;
-	}
-	/* else fetch mode */
-
-	/* Use the fetch URL when no push URLs were found or requested. */
-	if (!url_nr) {
-		url = remote-&gt;url.v;
-		url_nr = remote-&gt;url.nr;
-	}
-
-	if (!url_nr)
</span><span
class="add">+	url = push_mode ? push_url_of_remote(remote) : &#38;remote-&gt;url;
+	if (!url-&gt;nr)
</span> 		die(_(&#34;no URLs configured for remote &#39;%s&#39;&#34;), remotename);
 
 	if (all_mode) {
<span
class="del">-		for (i = 0; i &lt; url_nr; i++)
-			printf_ln(&#34;%s&#34;, url[i]);
</span><span
class="add">+		for (i = 0; i &lt; url-&gt;nr; i++)
+			printf_ln(&#34;%s&#34;, url-&gt;v[i]);
</span> 	} else {
<span
class="del">-		printf_ln(&#34;%s&#34;, *url);
</span><span
class="add">+		printf_ln(&#34;%s&#34;, url-&gt;v[0]);
</span> 	}
 
 	return 0;
<span
class="hunk">@@ -1680,8 +1654,7 @@ static int set_url(int argc, const char **argv, const char *prefix)
</span> 	const char *oldurl = NULL;
 	struct remote *remote;
 	regex_t old_regex;
<span
class="del">-	const char **urlset;
-	int urlset_nr;
</span><span
class="add">+	struct strvec *urlset;
</span> 	struct strbuf name_buf = STRBUF_INIT;
 	struct option options[] = {
 		OPT_BOOL(&#39;\0&#39;, &#34;push&#34;, &#38;push_mode,
<span
class="hunk">@@ -1718,12 +1691,10 @@ static int set_url(int argc, const char **argv, const char *prefix)
</span> 
 	if (push_mode) {
 		strbuf_addf(&#38;name_buf, &#34;remote.%s.pushurl&#34;, remotename);
<span
class="del">-		urlset = remote-&gt;pushurl.v;
-		urlset_nr = remote-&gt;pushurl.nr;
</span><span
class="add">+		urlset = &#38;remote-&gt;pushurl;
</span> 	} else {
 		strbuf_addf(&#38;name_buf, &#34;remote.%s.url&#34;, remotename);
<span
class="del">-		urlset = remote-&gt;url.v;
-		urlset_nr = remote-&gt;url.nr;
</span><span
class="add">+		urlset = &#38;remote-&gt;url;
</span> 	}
 
 	/* Special cases that add new entry. */
<span
class="hunk">@@ -1740,8 +1711,8 @@ static int set_url(int argc, const char **argv, const char *prefix)
</span> 	if (regcomp(&#38;old_regex, oldurl, REG_EXTENDED))
 		die(_(&#34;Invalid old URL pattern: %s&#34;), oldurl);
 
<span
class="del">-	for (i = 0; i &lt; urlset_nr; i++)
-		if (!regexec(&#38;old_regex, urlset[i], 0, NULL, 0))
</span><span
class="add">+	for (i = 0; i &lt; urlset-&gt;nr; i++)
+		if (!regexec(&#38;old_regex, urlset-&gt;v[i], 0, NULL, 0))
</span> 			matches++;
 		else
 			negative_matches++;
<span
class="head">diff --git a/remote.c b/remote.c
index 76a3e41c73..9417d83e51 100644
--- a/remote.c
+++ b/remote.c
</span><span
class="hunk">@@ -827,6 +827,11 @@ int remote_has_url(struct remote *remote, const char *url)
</span> 	return 0;
 }
 
<span
class="add">+struct strvec *push_url_of_remote(struct remote *remote)
+{
+	return remote-&gt;pushurl.nr ? &#38;remote-&gt;pushurl : &#38;remote-&gt;url;
+}
+
</span> static int match_name_with_pattern(const char *key, const char *name,
 				   const char *value, char **result)
 {
<span
class="head">diff --git a/remote.h b/remote.h
index 84dc91cca0..034f9d6660 100644
--- a/remote.h
+++ b/remote.h
</span><span
class="hunk">@@ -123,6 +123,7 @@ typedef int each_remote_fn(struct remote *remote, void *priv);
</span> int for_each_remote(each_remote_fn fn, void *priv);
 
 int remote_has_url(struct remote *remote, const char *url);
<span
class="add">+struct strvec *push_url_of_remote(struct remote *remote);
</span> 
 struct ref_push_report {
 	const char *ref_name;
-- 
2.45.2.937.g0bcb3c087a

</pre></div></content></entry><entry><author><name>Jeff King</name><email>peff@peff.net</email></author><title>[PATCH 04/11] remote: use strvecs to store remote url/pushurl</title><updated>2024-06-14T10:28:02Z</updated><link
href="http://lore.kernel.org/git/20240614102801.GD222445@coredump.intra.peff.net/"/><id>urn:uuid:237455f1-f4ff-63da-f82a-606b785115c2</id><thr:in-reply-to
ref="urn:uuid:d67e1264-d284-4105-e0d9-849c435b0ca4"
href="http://lore.kernel.org/git/20240614102439.GA222287@coredump.intra.peff.net/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Now that the url/pushurl fields of &#34;struct remote&#34; own their strings, we
can switch from bare arrays to strvecs. This has a few advantages:

  - push/clear are now one-liners

  - likewise the free+assigns in alias_all_urls() can use
    strvec_replace()

  - we now use size_t for storage, avoiding possible overflow

  - this will enable some further cleanups in future patches

There&#39;s quite a bit of fallout in the code that reads these fields, as
it tends to access these arrays directly. But it&#39;s mostly a mechanical
replacement of &#34;url_nr&#34; with &#34;url.nr&#34;, and &#34;url[i]&#34; with &#34;url.v[i]&#34;,
with a few variations (e.g. &#34;*url&#34; could become &#34;*url.v&#34;, but I used
&#34;url.v[0]&#34; for consistency).

Signed-off-by: Jeff King &lt;peff@peff.net&gt;
---
 builtin/archive.c          |  4 +--
 builtin/clone.c            |  4 +--
 builtin/ls-remote.c        |  6 ++--
 builtin/push.c             | 10 +++----
 builtin/remote.c           | 56 +++++++++++++++++++-------------------
 remote-curl.c              |  2 +-
 remote.c                   | 52 ++++++++++++++---------------------
 remote.h                   | 12 ++------
 t/helper/test-bundle-uri.c |  2 +-
 transport.c                |  4 +--
 10 files <a href="http://lore.kernel.org/git/20240614102801.GD222445@coredump.intra.peff.net/#related">changed</a>, 68 insertions(+), 84 deletions(-)

<span
class="head">diff --git a/builtin/archive.c b/builtin/archive.c
index f35560042e..0d9aff7e6f 100644
--- a/builtin/archive.c
+++ b/builtin/archive.c
</span><span
class="hunk">@@ -31,9 +31,9 @@ static int run_remote_archiver(int argc, const char **argv,
</span> 	struct packet_reader reader;
 
 	_remote = remote_get(remote);
<span
class="del">-	if (!_remote-&gt;url_nr)
</span><span
class="add">+	if (!_remote-&gt;url.nr)
</span> 		die(_(&#34;git archive: Remote with no URL&#34;));
<span
class="del">-	transport = transport_get(_remote, _remote-&gt;url[0]);
</span><span
class="add">+	transport = transport_get(_remote, _remote-&gt;url.v[0]);
</span> 	transport_connect(transport, &#34;git-upload-archive&#34;, exec, fd);
 
 	/*
<span
class="head">diff --git a/builtin/clone.c b/builtin/clone.c
index 730b3efae6..d3b70b49b0 100644
--- a/builtin/clone.c
+++ b/builtin/clone.c
</span><span
class="hunk">@@ -1290,7 +1290,7 @@ int cmd_clone(int argc, const char **argv, const char *prefix)
</span> 	refspec_appendf(&#38;remote-&gt;fetch, &#34;+%s*:%s*&#34;, src_ref_prefix,
 			branch_top.buf);
 
<span
class="del">-	path = get_repo_path(remote-&gt;url[0], &#38;is_bundle);
</span><span
class="add">+	path = get_repo_path(remote-&gt;url.v[0], &#38;is_bundle);
</span> 	is_local = option_local != 0 &#38;&#38; path &#38;&#38; !is_bundle;
 	if (is_local) {
 		if (option_depth)
<span
class="hunk">@@ -1312,7 +1312,7 @@ int cmd_clone(int argc, const char **argv, const char *prefix)
</span> 	if (option_local &gt; 0 &#38;&#38; !is_local)
 		warning(_(&#34;--local is ignored&#34;));
 
<span
class="del">-	transport = transport_get(remote, path ? path : remote-&gt;url[0]);
</span><span
class="add">+	transport = transport_get(remote, path ? path : remote-&gt;url.v[0]);
</span> 	transport_set_verbosity(transport, option_verbosity, option_progress);
 	transport-&gt;family = family;
 	transport-&gt;cloning = 1;
<span
class="head">diff --git a/builtin/ls-remote.c b/builtin/ls-remote.c
index e8d65ebbdc..4c04dbbf19 100644
--- a/builtin/ls-remote.c
+++ b/builtin/ls-remote.c
</span><span
class="hunk">@@ -109,11 +109,11 @@ int cmd_ls_remote(int argc, const char **argv, const char *prefix)
</span> 			die(&#34;bad repository &#39;%s&#39;&#34;, dest);
 		die(&#34;No remote configured to list refs from.&#34;);
 	}
<span
class="del">-	if (!remote-&gt;url_nr)
</span><span
class="add">+	if (!remote-&gt;url.nr)
</span> 		die(&#34;remote %s has no configured URL&#34;, dest);
 
 	if (get_url) {
<span
class="del">-		printf(&#34;%s\n&#34;, *remote-&gt;url);
</span><span
class="add">+		printf(&#34;%s\n&#34;, remote-&gt;url.v[0]);
</span> 		return 0;
 	}
 
<span
class="hunk">@@ -130,7 +130,7 @@ int cmd_ls_remote(int argc, const char **argv, const char *prefix)
</span> 	}
 
 	if (!dest &#38;&#38; !quiet)
<span
class="del">-		fprintf(stderr, &#34;From %s\n&#34;, *remote-&gt;url);
</span><span
class="add">+		fprintf(stderr, &#34;From %s\n&#34;, remote-&gt;url.v[0]);
</span> 	for ( ; ref; ref = ref-&gt;next) {
 		struct ref_array_item *item;
 		if (!check_ref_type(ref, flags))
<span
class="head">diff --git a/builtin/push.c b/builtin/push.c
index 2fbb31c3ad..61b5d3afdd 100644
--- a/builtin/push.c
+++ b/builtin/push.c
</span><span
class="hunk">@@ -143,12 +143,12 @@ static void set_refspecs(const char **refs, int nr, const char *repo)
</span> 
 static int push_url_of_remote(struct remote *remote, const char ***url_p)
 {
<span
class="del">-	if (remote-&gt;pushurl_nr) {
-		*url_p = remote-&gt;pushurl;
-		return remote-&gt;pushurl_nr;
</span><span
class="add">+	if (remote-&gt;pushurl.nr) {
+		*url_p = remote-&gt;pushurl.v;
+		return remote-&gt;pushurl.nr;
</span> 	}
<span
class="del">-	*url_p = remote-&gt;url;
-	return remote-&gt;url_nr;
</span><span
class="add">+	*url_p = remote-&gt;url.v;
+	return remote-&gt;url.nr;
</span> }
 
 static NORETURN void die_push_simple(struct branch *branch,
<span
class="head">diff --git a/builtin/remote.c b/builtin/remote.c
index 447ef1d3c9..ee6a33ff11 100644
--- a/builtin/remote.c
+++ b/builtin/remote.c
</span><span
class="hunk">@@ -619,8 +619,8 @@ static int migrate_file(struct remote *remote)
</span> 	int i;
 
 	strbuf_addf(&#38;buf, &#34;remote.%s.url&#34;, remote-&gt;name);
<span
class="del">-	for (i = 0; i &lt; remote-&gt;url_nr; i++)
-		git_config_set_multivar(buf.buf, remote-&gt;url[i], &#34;^$&#34;, 0);
</span><span
class="add">+	for (i = 0; i &lt; remote-&gt;url.nr; i++)
+		git_config_set_multivar(buf.buf, remote-&gt;url.v[i], &#34;^$&#34;, 0);
</span> 	strbuf_reset(&#38;buf);
 	strbuf_addf(&#38;buf, &#34;remote.%s.push&#34;, remote-&gt;name);
 	for (i = 0; i &lt; remote-&gt;push.raw_nr; i++)
<span
class="hunk">@@ -1002,8 +1002,8 @@ static int get_remote_ref_states(const char *name,
</span> 		struct transport *transport;
 		const struct ref *remote_refs;
 
<span
class="del">-		transport = transport_get(states-&gt;remote, states-&gt;remote-&gt;url_nr &gt; 0 ?
-			states-&gt;remote-&gt;url[0] : NULL);
</span><span
class="add">+		transport = transport_get(states-&gt;remote, states-&gt;remote-&gt;url.nr &gt; 0 ?
+			states-&gt;remote-&gt;url.v[0] : NULL);
</span> 		remote_refs = transport_get_remote_refs(transport, NULL);
 
 		states-&gt;queried = 1;
<span
class="hunk">@@ -1216,12 +1216,12 @@ static int get_one_entry(struct remote *remote, void *priv)
</span> 	const char **url;
 	int i, url_nr;
 
<span
class="del">-	if (remote-&gt;url_nr &gt; 0) {
</span><span
class="add">+	if (remote-&gt;url.nr &gt; 0) {
</span> 		struct strbuf promisor_config = STRBUF_INIT;
 		const char *partial_clone_filter = NULL;
 
 		strbuf_addf(&#38;promisor_config, &#34;remote.%s.partialclonefilter&#34;, remote-&gt;name);
<span
class="del">-		strbuf_addf(&#38;remote_info_buf, &#34;%s (fetch)&#34;, remote-&gt;url[0]);
</span><span
class="add">+		strbuf_addf(&#38;remote_info_buf, &#34;%s (fetch)&#34;, remote-&gt;url.v[0]);
</span> 		if (!git_config_get_string_tmp(promisor_config.buf, &#38;partial_clone_filter))
 			strbuf_addf(&#38;remote_info_buf, &#34; [%s]&#34;, partial_clone_filter);
 
<span
class="hunk">@@ -1230,12 +1230,12 @@ static int get_one_entry(struct remote *remote, void *priv)
</span> 				strbuf_detach(&#38;remote_info_buf, NULL);
 	} else
 		string_list_append(list, remote-&gt;name)-&gt;util = NULL;
<span
class="del">-	if (remote-&gt;pushurl_nr) {
-		url = remote-&gt;pushurl;
-		url_nr = remote-&gt;pushurl_nr;
</span><span
class="add">+	if (remote-&gt;pushurl.nr) {
+		url = remote-&gt;pushurl.v;
+		url_nr = remote-&gt;pushurl.nr;
</span> 	} else {
<span
class="del">-		url = remote-&gt;url;
-		url_nr = remote-&gt;url_nr;
</span><span
class="add">+		url = remote-&gt;url.v;
+		url_nr = remote-&gt;url.nr;
</span> 	}
 	for (i = 0; i &lt; url_nr; i++)
 	{
<span
class="hunk">@@ -1301,14 +1301,14 @@ static int show(int argc, const char **argv, const char *prefix)
</span> 		get_remote_ref_states(*argv, &#38;info.states, query_flag);
 
 		printf_ln(_(&#34;* remote %s&#34;), *argv);
<span
class="del">-		printf_ln(_(&#34;  Fetch URL: %s&#34;), info.states.remote-&gt;url_nr &gt; 0 ?
-		       info.states.remote-&gt;url[0] : _(&#34;(no URL)&#34;));
-		if (info.states.remote-&gt;pushurl_nr) {
-			url = info.states.remote-&gt;pushurl;
-			url_nr = info.states.remote-&gt;pushurl_nr;
</span><span
class="add">+		printf_ln(_(&#34;  Fetch URL: %s&#34;), info.states.remote-&gt;url.nr &gt; 0 ?
+		       info.states.remote-&gt;url.v[0] : _(&#34;(no URL)&#34;));
+		if (info.states.remote-&gt;pushurl.nr) {
+			url = info.states.remote-&gt;pushurl.v;
+			url_nr = info.states.remote-&gt;pushurl.nr;
</span> 		} else {
<span
class="del">-			url = info.states.remote-&gt;url;
-			url_nr = info.states.remote-&gt;url_nr;
</span><span
class="add">+			url = info.states.remote-&gt;url.v;
+			url_nr = info.states.remote-&gt;url.nr;
</span> 		}
 		for (i = 0; i &lt; url_nr; i++)
 			/*
<span
class="hunk">@@ -1454,8 +1454,8 @@ static int prune_remote(const char *remote, int dry_run)
</span> 
 	printf_ln(_(&#34;Pruning %s&#34;), remote);
 	printf_ln(_(&#34;URL: %s&#34;),
<span
class="del">-		  states.remote-&gt;url_nr
-		  ? states.remote-&gt;url[0]
</span><span
class="add">+		  states.remote-&gt;url.nr
+		  ? states.remote-&gt;url.v[0]
</span> 		  : _(&#34;(no URL)&#34;));
 
 	for_each_string_list_item(item, &#38;states.stale)
<span
class="hunk">@@ -1647,15 +1647,15 @@ static int get_url(int argc, const char **argv, const char *prefix)
</span> 
 	url_nr = 0;
 	if (push_mode) {
<span
class="del">-		url = remote-&gt;pushurl;
-		url_nr = remote-&gt;pushurl_nr;
</span><span
class="add">+		url = remote-&gt;pushurl.v;
+		url_nr = remote-&gt;pushurl.nr;
</span> 	}
 	/* else fetch mode */
 
 	/* Use the fetch URL when no push URLs were found or requested. */
 	if (!url_nr) {
<span
class="del">-		url = remote-&gt;url;
-		url_nr = remote-&gt;url_nr;
</span><span
class="add">+		url = remote-&gt;url.v;
+		url_nr = remote-&gt;url.nr;
</span> 	}
 
 	if (!url_nr)
<span
class="hunk">@@ -1718,12 +1718,12 @@ static int set_url(int argc, const char **argv, const char *prefix)
</span> 
 	if (push_mode) {
 		strbuf_addf(&#38;name_buf, &#34;remote.%s.pushurl&#34;, remotename);
<span
class="del">-		urlset = remote-&gt;pushurl;
-		urlset_nr = remote-&gt;pushurl_nr;
</span><span
class="add">+		urlset = remote-&gt;pushurl.v;
+		urlset_nr = remote-&gt;pushurl.nr;
</span> 	} else {
 		strbuf_addf(&#38;name_buf, &#34;remote.%s.url&#34;, remotename);
<span
class="del">-		urlset = remote-&gt;url;
-		urlset_nr = remote-&gt;url_nr;
</span><span
class="add">+		urlset = remote-&gt;url.v;
+		urlset_nr = remote-&gt;url.nr;
</span> 	}
 
 	/* Special cases that add new entry. */
<span
class="head">diff --git a/remote-curl.c b/remote-curl.c
index 6008d7e87c..22957c16db 100644
--- a/remote-curl.c
+++ b/remote-curl.c
</span><span
class="hunk">@@ -1574,7 +1574,7 @@ int cmd_main(int argc, const char **argv)
</span> 	if (argc &gt; 2) {
 		end_url_with_slash(&#38;url, argv[2]);
 	} else {
<span
class="del">-		end_url_with_slash(&#38;url, remote-&gt;url[0]);
</span><span
class="add">+		end_url_with_slash(&#38;url, remote-&gt;url.v[0]);
</span> 	}
 
 	http_init(remote, url.buf, 0);
<span
class="head">diff --git a/remote.c b/remote.c
index f7c846865f..76a3e41c73 100644
--- a/remote.c
+++ b/remote.c
</span><span
class="hunk">@@ -32,7 +32,7 @@ struct counted_string {
</span> 
 static int valid_remote(const struct remote *remote)
 {
<span
class="del">-	return (!!remote-&gt;url) || (!!remote-&gt;foreign_vcs);
</span><span
class="add">+	return (!!remote-&gt;url.nr) || (!!remote-&gt;foreign_vcs);
</span> }
 
 static char *alias_url(const char *url, struct rewrites *r)
<span
class="hunk">@@ -63,14 +63,12 @@ static char *alias_url(const char *url, struct rewrites *r)
</span> 
 static void add_url(struct remote *remote, const char *url)
 {
<span
class="del">-	ALLOC_GROW(remote-&gt;url, remote-&gt;url_nr + 1, remote-&gt;url_alloc);
-	remote-&gt;url[remote-&gt;url_nr++] = xstrdup(url);
</span><span
class="add">+	strvec_push(&#38;remote-&gt;url, url);
</span> }
 
 static void add_pushurl(struct remote *remote, const char *pushurl)
 {
<span
class="del">-	ALLOC_GROW(remote-&gt;pushurl, remote-&gt;pushurl_nr + 1, remote-&gt;pushurl_alloc);
-	remote-&gt;pushurl[remote-&gt;pushurl_nr++] = xstrdup(pushurl);
</span><span
class="add">+	strvec_push(&#38;remote-&gt;pushurl, pushurl);
</span> }
 
 static void add_pushurl_alias(struct remote_state *remote_state,
<span
class="hunk">@@ -150,18 +148,12 @@ static struct remote *make_remote(struct remote_state *remote_state,
</span> 
 static void remote_clear(struct remote *remote)
 {
<span
class="del">-	int i;
-
</span> 	free((char *)remote-&gt;name);
 	free((char *)remote-&gt;foreign_vcs);
 
<span
class="del">-	for (i = 0; i &lt; remote-&gt;url_nr; i++)
-		free((char *)remote-&gt;url[i]);
-	FREE_AND_NULL(remote-&gt;url);
</span><span
class="add">+	strvec_clear(&#38;remote-&gt;url);
+	strvec_clear(&#38;remote-&gt;pushurl);
</span> 
<span
class="del">-	for (i = 0; i &lt; remote-&gt;pushurl_nr; i++)
-		free((char *)remote-&gt;pushurl[i]);
-	FREE_AND_NULL(remote-&gt;pushurl);
</span> 	free((char *)remote-&gt;receivepack);
 	free((char *)remote-&gt;uploadpack);
 	FREE_AND_NULL(remote-&gt;http_proxy);
<span
class="hunk">@@ -493,27 +485,25 @@ static void alias_all_urls(struct remote_state *remote_state)
</span> 		int add_pushurl_aliases;
 		if (!remote_state-&gt;remotes[i])
 			continue;
<span
class="del">-		for (j = 0; j &lt; remote_state-&gt;remotes[i]-&gt;pushurl_nr; j++) {
-			char *alias = alias_url(remote_state-&gt;remotes[i]-&gt;pushurl[j],
</span><span
class="add">+		for (j = 0; j &lt; remote_state-&gt;remotes[i]-&gt;pushurl.nr; j++) {
+			char *alias = alias_url(remote_state-&gt;remotes[i]-&gt;pushurl.v[j],
</span> 						&#38;remote_state-&gt;rewrites);
<span
class="del">-			if (alias) {
-				free((char *)remote_state-&gt;remotes[i]-&gt;pushurl[j]);
-				remote_state-&gt;remotes[i]-&gt;pushurl[j] = alias;
-			}
</span><span
class="add">+			if (alias)
+				strvec_replace(&#38;remote_state-&gt;remotes[i]-&gt;pushurl,
+					       j, alias);
</span> 		}
<span
class="del">-		add_pushurl_aliases = remote_state-&gt;remotes[i]-&gt;pushurl_nr == 0;
-		for (j = 0; j &lt; remote_state-&gt;remotes[i]-&gt;url_nr; j++) {
</span><span
class="add">+		add_pushurl_aliases = remote_state-&gt;remotes[i]-&gt;pushurl.nr == 0;
+		for (j = 0; j &lt; remote_state-&gt;remotes[i]-&gt;url.nr; j++) {
</span> 			char *alias;
 			if (add_pushurl_aliases)
 				add_pushurl_alias(
 					remote_state, remote_state-&gt;remotes[i],
<span
class="del">-					remote_state-&gt;remotes[i]-&gt;url[j]);
-			alias = alias_url(remote_state-&gt;remotes[i]-&gt;url[j],
</span><span
class="add">+					remote_state-&gt;remotes[i]-&gt;url.v[j]);
+			alias = alias_url(remote_state-&gt;remotes[i]-&gt;url.v[j],
</span> 					  &#38;remote_state-&gt;rewrites);
<span
class="del">-			if (alias) {
-				free((char *)remote_state-&gt;remotes[i]-&gt;url[j]);
-				remote_state-&gt;remotes[i]-&gt;url[j] = alias;
-			}
</span><span
class="add">+			if (alias)
+				strvec_replace(&#38;remote_state-&gt;remotes[i]-&gt;url,
+					       j, alias);
</span> 		}
 	}
 }
<span
class="hunk">@@ -653,10 +643,10 @@ static void validate_remote_url(struct remote *remote)
</span> 	else
 		die(_(&#34;unrecognized value transfer.credentialsInUrl: &#39;%s&#39;&#34;), value);
 
<span
class="del">-	for (i = 0; i &lt; remote-&gt;url_nr; i++) {
</span><span
class="add">+	for (i = 0; i &lt; remote-&gt;url.nr; i++) {
</span> 		struct url_info url_info = { 0 };
 
<span
class="del">-		if (!url_normalize(remote-&gt;url[i], &#38;url_info) ||
</span><span
class="add">+		if (!url_normalize(remote-&gt;url.v[i], &#38;url_info) ||
</span> 		    !url_info.passwd_off)
 			goto loop_cleanup;
 
<span
class="hunk">@@ -830,8 +820,8 @@ struct ref *ref_remove_duplicates(struct ref *ref_map)
</span> int remote_has_url(struct remote *remote, const char *url)
 {
 	int i;
<span
class="del">-	for (i = 0; i &lt; remote-&gt;url_nr; i++) {
-		if (!strcmp(remote-&gt;url[i], url))
</span><span
class="add">+	for (i = 0; i &lt; remote-&gt;url.nr; i++) {
+		if (!strcmp(remote-&gt;url.v[i], url))
</span> 			return 1;
 	}
 	return 0;
<span
class="head">diff --git a/remote.h b/remote.h
index e8c6655e42..84dc91cca0 100644
--- a/remote.h
+++ b/remote.h
</span><span
class="hunk">@@ -4,6 +4,7 @@
</span> #include &#34;hash-ll.h&#34;
 #include &#34;hashmap.h&#34;
 #include &#34;refspec.h&#34;
<span
class="add">+#include &#34;strvec.h&#34;
</span> 
 struct option;
 struct transport_ls_refs_options;
<span
class="hunk">@@ -68,16 +69,9 @@ struct remote {
</span> 	char *foreign_vcs;
 
 	/* An array of all of the url_nr URLs configured for the remote */
<span
class="del">-	const char **url;
-
-	int url_nr;
-	int url_alloc;
-
</span><span
class="add">+	struct strvec url;
</span> 	/* An array of all of the pushurl_nr push URLs configured for the remote */
<span
class="del">-	const char **pushurl;
-
-	int pushurl_nr;
-	int pushurl_alloc;
</span><span
class="add">+	struct strvec pushurl;
</span> 
 	struct refspec push;
 
<span
class="head">diff --git a/t/helper/test-bundle-uri.c b/t/helper/test-bundle-uri.c
index 09dc78733c..3285dd962e 100644
--- a/t/helper/test-bundle-uri.c
+++ b/t/helper/test-bundle-uri.c
</span><span
class="hunk">@@ -88,7 +88,7 @@ static int cmd_ls_remote(int argc, const char **argv)
</span> 			die(_(&#34;bad repository &#39;%s&#39;&#34;), dest);
 		die(_(&#34;no remote configured to get bundle URIs from&#34;));
 	}
<span
class="del">-	if (!remote-&gt;url_nr)
</span><span
class="add">+	if (!remote-&gt;url.nr)
</span> 		die(_(&#34;remote &#39;%s&#39; has no configured URL&#34;), dest);
 
 	transport = transport_get(remote, NULL);
<span
class="head">diff --git a/transport.c b/transport.c
index 83ddea8fbc..eba92eb7e0 100644
--- a/transport.c
+++ b/transport.c
</span><span
class="hunk">@@ -1127,8 +1127,8 @@ struct transport *transport_get(struct remote *remote, const char *url)
</span> 	ret-&gt;remote = remote;
 	helper = remote-&gt;foreign_vcs;
 
<span
class="del">-	if (!url &#38;&#38; remote-&gt;url)
-		url = remote-&gt;url[0];
</span><span
class="add">+	if (!url &#38;&#38; remote-&gt;url.nr)
+		url = remote-&gt;url.v[0];
</span> 	ret-&gt;url = url;
 
 	/* maybe it is a foreign URL? */
-- 
2.45.2.937.g0bcb3c087a

</pre></div></content></entry><entry><author><name>Jeff King</name><email>peff@peff.net</email></author><title>[PATCH 03/11] remote: transfer ownership of memory in add_url(), etc</title><updated>2024-06-14T10:27:23Z</updated><link
href="http://lore.kernel.org/git/20240614102722.GC222445@coredump.intra.peff.net/"/><id>urn:uuid:ab934b3f-1c9f-be4e-6e42-b7863155a2a4</id><thr:in-reply-to
ref="urn:uuid:d67e1264-d284-4105-e0d9-849c435b0ca4"
href="http://lore.kernel.org/git/20240614102439.GA222287@coredump.intra.peff.net/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Many of the internal functions in remote.c take const strings and store
them forever in instances of &#34;struct remote&#34;. Since the functions are
internal and callers are aware of the convention, this seems to mostly
work and not cause leaks. But there are some issues:

  - it&#39;s impossible to clear any of the arrays, because the data
    dependencies between them are too muddled (if you free() a string,
    it might also be referenced from another array, causing a
    user-after-free; but if you don&#39;t, that might be the last reference,
    causing a leak).

    This is mostly of interest for further refactoring and features, but
    there&#39;s at least one spot that&#39;s already a problem. In alias_all_urls(),
    we replace elements of remote-&gt;url and remote-&gt;pushurl with their
    aliased forms, dropping references to the original.

  - sometimes strings from outside callers make their way in. For
    example, calling remote_get(&#34;foo&#34;) when there is no configured &#34;foo&#34;
    remote will create a remote struct with the single url &#34;foo&#34;. But
    we&#39;ll do so by holding on to the string passed to remote_get()
    forever.

    In practice I think this works out because we&#39;d usually pass in a
    string that lasts the length of the program (a string literal, or
    argv reference, or other data structure allocated in the main
    function). But it&#39;s a rather subtle requirement.

Instead, let&#39;s have remote-&gt;url and remote-&gt;pushurl own their string
memory. They&#39;ll copy the const strings that are passed in, and callers
can stop making their own copies. Likewise, when we overwrite an entry,
we can free the memory it points to, fixing the leak mentioned above.

We&#39;ll leave the struct members as &#34;const&#34; since they are visible to the
outside world, and shouldn&#39;t usually be touched. This requires casting
on free() for now, but we&#39;ll clean that further in a future patch.

Signed-off-by: Jeff King &lt;peff@peff.net&gt;
---
Since now we&#39;ll always allocate, I don&#39;t think it&#39;s possible for this to
introduce any memory corruption issues. It _might_ introduce a leak, but
I think I fixed all of the callers.

 remote.c | 33 +++++++++++++++++++--------------
 1 file <a href="http://lore.kernel.org/git/20240614102722.GC222445@coredump.intra.peff.net/#related">changed</a>, 19 insertions(+), 14 deletions(-)

<span
class="head">diff --git a/remote.c b/remote.c
index fd9d58f820..f7c846865f 100644
--- a/remote.c
+++ b/remote.c
</span><span
class="hunk">@@ -64,13 +64,13 @@ static char *alias_url(const char *url, struct rewrites *r)
</span> static void add_url(struct remote *remote, const char *url)
 {
 	ALLOC_GROW(remote-&gt;url, remote-&gt;url_nr + 1, remote-&gt;url_alloc);
<span
class="del">-	remote-&gt;url[remote-&gt;url_nr++] = url;
</span><span
class="add">+	remote-&gt;url[remote-&gt;url_nr++] = xstrdup(url);
</span> }
 
 static void add_pushurl(struct remote *remote, const char *pushurl)
 {
 	ALLOC_GROW(remote-&gt;pushurl, remote-&gt;pushurl_nr + 1, remote-&gt;pushurl_alloc);
<span
class="del">-	remote-&gt;pushurl[remote-&gt;pushurl_nr++] = pushurl;
</span><span
class="add">+	remote-&gt;pushurl[remote-&gt;pushurl_nr++] = xstrdup(pushurl);
</span> }
 
 static void add_pushurl_alias(struct remote_state *remote_state,
<span
class="hunk">@@ -79,6 +79,7 @@ static void add_pushurl_alias(struct remote_state *remote_state,
</span> 	char *alias = alias_url(url, &#38;remote_state-&gt;rewrites_push);
 	if (alias)
 		add_pushurl(remote, alias);
<span
class="add">+	free(alias);
</span> }
 
 static void add_url_alias(struct remote_state *remote_state,
<span
class="hunk">@@ -87,6 +88,7 @@ static void add_url_alias(struct remote_state *remote_state,
</span> 	char *alias = alias_url(url, &#38;remote_state-&gt;rewrites);
 	add_url(remote, alias ? alias : url);
 	add_pushurl_alias(remote_state, remote, url);
<span
class="add">+	free(alias);
</span> }
 
 struct remotes_hash_key {
<span
class="hunk">@@ -293,7 +295,7 @@ static void read_remotes_file(struct remote_state *remote_state,
</span> 
 		if (skip_prefix(buf.buf, &#34;URL:&#34;, &#38;v))
 			add_url_alias(remote_state, remote,
<span
class="del">-				      xstrdup(skip_spaces(v)));
</span><span
class="add">+				      skip_spaces(v));
</span> 		else if (skip_prefix(buf.buf, &#34;Push:&#34;, &#38;v))
 			refspec_append(&#38;remote-&gt;push, skip_spaces(v));
 		else if (skip_prefix(buf.buf, &#34;Pull:&#34;, &#38;v))
<span
class="hunk">@@ -336,7 +338,7 @@ static void read_branches_file(struct remote_state *remote_state,
</span> 	else
 		frag = to_free = repo_default_branch_name(the_repository, 0);
 
<span
class="del">-	add_url_alias(remote_state, remote, strbuf_detach(&#38;buf, NULL));
</span><span
class="add">+	add_url_alias(remote_state, remote, buf.buf);
</span> 	refspec_appendf(&#38;remote-&gt;fetch, &#34;refs/heads/%s:refs/heads/%s&#34;,
 			frag, remote-&gt;name);
 
<span
class="hunk">@@ -347,6 +349,7 @@ static void read_branches_file(struct remote_state *remote_state,
</span> 	refspec_appendf(&#38;remote-&gt;push, &#34;HEAD:refs/heads/%s&#34;, frag);
 	remote-&gt;fetch_tags = 1; /* always auto-follow */
 
<span
class="add">+	strbuf_release(&#38;buf);
</span> 	free(to_free);
 }
 
<span
class="hunk">@@ -431,15 +434,13 @@ static int handle_config(const char *key, const char *value,
</span> 	else if (!strcmp(subkey, &#34;prunetags&#34;))
 		remote-&gt;prune_tags = git_config_bool(key, value);
 	else if (!strcmp(subkey, &#34;url&#34;)) {
<span
class="del">-		char *v;
-		if (git_config_string(&#38;v, key, value))
-			return -1;
-		add_url(remote, v);
</span><span
class="add">+		if (!value)
+			return config_error_nonbool(key);
+		add_url(remote, value);
</span> 	} else if (!strcmp(subkey, &#34;pushurl&#34;)) {
<span
class="del">-		char *v;
-		if (git_config_string(&#38;v, key, value))
-			return -1;
-		add_pushurl(remote, v);
</span><span
class="add">+		if (!value)
+			return config_error_nonbool(key);
+		add_pushurl(remote, value);
</span> 	} else if (!strcmp(subkey, &#34;push&#34;)) {
 		char *v;
 		if (git_config_string(&#38;v, key, value))
<span
class="hunk">@@ -495,8 +496,10 @@ static void alias_all_urls(struct remote_state *remote_state)
</span> 		for (j = 0; j &lt; remote_state-&gt;remotes[i]-&gt;pushurl_nr; j++) {
 			char *alias = alias_url(remote_state-&gt;remotes[i]-&gt;pushurl[j],
 						&#38;remote_state-&gt;rewrites);
<span
class="del">-			if (alias)
</span><span
class="add">+			if (alias) {
+				free((char *)remote_state-&gt;remotes[i]-&gt;pushurl[j]);
</span> 				remote_state-&gt;remotes[i]-&gt;pushurl[j] = alias;
<span
class="add">+			}
</span> 		}
 		add_pushurl_aliases = remote_state-&gt;remotes[i]-&gt;pushurl_nr == 0;
 		for (j = 0; j &lt; remote_state-&gt;remotes[i]-&gt;url_nr; j++) {
<span
class="hunk">@@ -507,8 +510,10 @@ static void alias_all_urls(struct remote_state *remote_state)
</span> 					remote_state-&gt;remotes[i]-&gt;url[j]);
 			alias = alias_url(remote_state-&gt;remotes[i]-&gt;url[j],
 					  &#38;remote_state-&gt;rewrites);
<span
class="del">-			if (alias)
</span><span
class="add">+			if (alias) {
+				free((char *)remote_state-&gt;remotes[i]-&gt;url[j]);
</span> 				remote_state-&gt;remotes[i]-&gt;url[j] = alias;
<span
class="add">+			}
</span> 		}
 	}
 }
-- 
2.45.2.937.g0bcb3c087a

</pre></div></content></entry><entry><author><name>Jeff King</name><email>peff@peff.net</email></author><title>[PATCH 02/11] remote: refactor alias_url() memory ownership</title><updated>2024-06-14T10:26:18Z</updated><link
href="http://lore.kernel.org/git/20240614102616.GB222445@coredump.intra.peff.net/"/><id>urn:uuid:7855bdba-fc1b-ae10-8ad6-f66d623beb0e</id><thr:in-reply-to
ref="urn:uuid:d67e1264-d284-4105-e0d9-849c435b0ca4"
href="http://lore.kernel.org/git/20240614102439.GA222287@coredump.intra.peff.net/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The alias_url() function may return either a newly allocated string
(which the caller must take ownership of), or the original const &#34;url&#34;
parameter that was passed in.

This often works OK because callers are generally passing in a &#34;url&#34;
that they expect to retain ownership of anyway. So whether we got back
the original or a new string, we&#39;re always interested in storing it
forever. But I suspect there are some possible leaks here (e.g.,
add_url_alias() may end up discarding the original &#34;url&#34;).

Whether there are active leaks or not, this is a confusing setup that
makes further refactoring of memory ownership harder. So instead of
returning the original string, return NULL, forcing callers to decide
what to do with it explicitly. We can then build further cleanups on top
of that.

Signed-off-by: Jeff King &lt;peff@peff.net&gt;
---
Just to be clear, I think there&#39;s probably still a leak in
add_url_alias() even after this patch. It&#39;s just a step on the way to
fixing.

 remote.c | 26 +++++++++++++++-----------
 1 file <a href="http://lore.kernel.org/git/20240614102616.GB222445@coredump.intra.peff.net/#related">changed</a>, 15 insertions(+), 11 deletions(-)

<span
class="head">diff --git a/remote.c b/remote.c
index dcb5492c85..fd9d58f820 100644
--- a/remote.c
+++ b/remote.c
</span><span
class="hunk">@@ -35,7 +35,7 @@ static int valid_remote(const struct remote *remote)
</span> 	return (!!remote-&gt;url) || (!!remote-&gt;foreign_vcs);
 }
 
<span
class="del">-static const char *alias_url(const char *url, struct rewrites *r)
</span><span
class="add">+static char *alias_url(const char *url, struct rewrites *r)
</span> {
 	int i, j;
 	struct counted_string *longest;
<span
class="hunk">@@ -56,7 +56,7 @@ static const char *alias_url(const char *url, struct rewrites *r)
</span> 		}
 	}
 	if (!longest)
<span
class="del">-		return url;
</span><span
class="add">+		return NULL;
</span> 
 	return xstrfmt(&#34;%s%s&#34;, r-&gt;rewrite[longest_i]-&gt;base, url + longest-&gt;len);
 }
<span
class="hunk">@@ -76,15 +76,16 @@ static void add_pushurl(struct remote *remote, const char *pushurl)
</span> static void add_pushurl_alias(struct remote_state *remote_state,
 			      struct remote *remote, const char *url)
 {
<span
class="del">-	const char *pushurl = alias_url(url, &#38;remote_state-&gt;rewrites_push);
-	if (pushurl != url)
-		add_pushurl(remote, pushurl);
</span><span
class="add">+	char *alias = alias_url(url, &#38;remote_state-&gt;rewrites_push);
+	if (alias)
+		add_pushurl(remote, alias);
</span> }
 
 static void add_url_alias(struct remote_state *remote_state,
 			  struct remote *remote, const char *url)
 {
<span
class="del">-	add_url(remote, alias_url(url, &#38;remote_state-&gt;rewrites));
</span><span
class="add">+	char *alias = alias_url(url, &#38;remote_state-&gt;rewrites);
+	add_url(remote, alias ? alias : url);
</span> 	add_pushurl_alias(remote_state, remote, url);
 }
 
<span
class="hunk">@@ -492,19 +493,22 @@ static void alias_all_urls(struct remote_state *remote_state)
</span> 		if (!remote_state-&gt;remotes[i])
 			continue;
 		for (j = 0; j &lt; remote_state-&gt;remotes[i]-&gt;pushurl_nr; j++) {
<span
class="del">-			remote_state-&gt;remotes[i]-&gt;pushurl[j] =
-				alias_url(remote_state-&gt;remotes[i]-&gt;pushurl[j],
-					  &#38;remote_state-&gt;rewrites);
</span><span
class="add">+			char *alias = alias_url(remote_state-&gt;remotes[i]-&gt;pushurl[j],
+						&#38;remote_state-&gt;rewrites);
+			if (alias)
+				remote_state-&gt;remotes[i]-&gt;pushurl[j] = alias;
</span> 		}
 		add_pushurl_aliases = remote_state-&gt;remotes[i]-&gt;pushurl_nr == 0;
 		for (j = 0; j &lt; remote_state-&gt;remotes[i]-&gt;url_nr; j++) {
<span
class="add">+			char *alias;
</span> 			if (add_pushurl_aliases)
 				add_pushurl_alias(
 					remote_state, remote_state-&gt;remotes[i],
 					remote_state-&gt;remotes[i]-&gt;url[j]);
<span
class="del">-			remote_state-&gt;remotes[i]-&gt;url[j] =
-				alias_url(remote_state-&gt;remotes[i]-&gt;url[j],
</span><span
class="add">+			alias = alias_url(remote_state-&gt;remotes[i]-&gt;url[j],
</span> 					  &#38;remote_state-&gt;rewrites);
<span
class="add">+			if (alias)
+				remote_state-&gt;remotes[i]-&gt;url[j] = alias;
</span> 		}
 	}
 }
-- 
2.45.2.937.g0bcb3c087a

</pre></div></content></entry><entry><author><name>Jeff King</name><email>peff@peff.net</email></author><title>[PATCH 01/11] archive: fix check for missing url</title><updated>2024-06-14T10:25:26Z</updated><link
href="http://lore.kernel.org/git/20240614102525.GA222445@coredump.intra.peff.net/"/><id>urn:uuid:5ef3d132-6257-4272-5d8e-2012475bc146</id><thr:in-reply-to
ref="urn:uuid:d67e1264-d284-4105-e0d9-849c435b0ca4"
href="http://lore.kernel.org/git/20240614102439.GA222287@coredump.intra.peff.net/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Running &#34;git archive --remote&#34; checks that we have at least one url for
the remote. It does so by looking at remote.url[0], but that won&#39;t work;
if we have no url at all, then remote.url will be NULL, and we&#39;ll
segfault.

Check url_nr instead, which is a more direct way of asking what we
want.

You can trigger the segfault like this:

  git -c remote.foo.vcs=bar archive --remote=foo

but I didn&#39;t bother adding a test. This is the tip of the iceberg for
no-url remotes, and a later patch will improve that situation. I just
wanted to clean up this bug so it didn&#39;t make further refactoring of
this code more confusing.

Signed-off-by: Jeff King &lt;peff@peff.net&gt;
---
This code actually goes away in patch 10, but it&#39;s possible we&#39;d want to
take a different approach there. So I preferred to fix this up front
anyway.

 builtin/archive.c | 2 +-
 1 file <a href="http://lore.kernel.org/git/20240614102525.GA222445@coredump.intra.peff.net/#related">changed</a>, 1 insertion(+), 1 deletion(-)

<span
class="head">diff --git a/builtin/archive.c b/builtin/archive.c
index 15ee1ec7bb..f35560042e 100644
--- a/builtin/archive.c
+++ b/builtin/archive.c
</span><span
class="hunk">@@ -31,7 +31,7 @@ static int run_remote_archiver(int argc, const char **argv,
</span> 	struct packet_reader reader;
 
 	_remote = remote_get(remote);
<span
class="del">-	if (!_remote-&gt;url[0])
</span><span
class="add">+	if (!_remote-&gt;url_nr)
</span> 		die(_(&#34;git archive: Remote with no URL&#34;));
 	transport = transport_get(_remote, _remote-&gt;url[0]);
 	transport_connect(transport, &#34;git-upload-archive&#34;, exec, fd);
-- 
2.45.2.937.g0bcb3c087a

</pre></div></content></entry><entry><author><name>Jeff King</name><email>peff@peff.net</email></author><title>[PATCH 0/11] allow overriding remote.*.url</title><updated>2024-06-14T10:24:46Z</updated><link
href="http://lore.kernel.org/git/20240614102439.GA222287@coredump.intra.peff.net/"/><id>urn:uuid:d67e1264-d284-4105-e0d9-849c435b0ca4</id><thr:in-reply-to
ref="urn:uuid:d5bebd5f-b9cf-3ef0-857b-2500a680b30f"
href="http://lore.kernel.org/git/20240613102409.GE817573@coredump.intra.peff.net/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">On Thu, Jun 13, 2024 at 06:24:09AM -0400, Jeff King wrote:

<span
class="q">&gt; &gt; I was expecting (with excitement) a mess, but the above is as clean
&gt; &gt; as we can make the idea, I would say.  Lack of documentation and
&gt; &gt; tests do count as incompleteness though of course.
&gt; 
&gt; Yeah, and we should probably do the same for pushurl. And I think there
&gt; could be some cleanup of the memory ownership handling of add_url().
</span>
So as always with this crufty 2009-era code, there turned out to be some
subtleties. ;)

The good news is that I think dealing with them left the code in a
better place. It&#39;s easier to reason about, and a few possible leaks have
been plugged (I don&#39;t know if they were triggered in the test suite or
not; if so they weren&#39;t enough to tip any scripts over to being
leak-free).

We can split the series into segments:

  [01/11]: archive: fix check for missing url

    A nearby trivial bugfix.

  [02/11]: remote: refactor alias_url() memory ownership
  [03/11]: remote: transfer ownership of memory in add_url(), etc
  [04/11]: remote: use strvecs to store remote url/pushurl
  [05/11]: remote: simplify url/pushurl selection

    Fixing memory handling weirdness, which is a necessary prereq for
    the &#34;reset&#34; operation to avoid leaking. The switch to using a strvec
    isn&#39;t strictly necessary, but it does make the code (including the
    later patch 7) simpler.

  [06/11]: config: document remote.*.url/pushurl interaction
  [07/11]: remote: allow resetting url list

    The actual change is in patch 7 here, but it was hard to add new
    docs to the rather anemic existing ones. Hence patch 6.

  [08/11]: t5801: make remote-testgit GIT_DIR setup more robust
  [09/11]: t5801: test remote.*.vcs config
  [10/11]: remote: always require at least one url in a remote
  [11/11]: remote: drop checks for zero-url case

    This is a related cleanup I found while working in the area.
    Arguably it could be a separate topic, though it does depend
    textually on what came before.

 Documentation/config/remote.txt | 11 +++-
 builtin/archive.c               |  4 +-
 builtin/clone.c                 |  4 +-
 builtin/ls-remote.c             |  6 +--
 builtin/push.c                  | 28 ++--------
 builtin/remote.c                | 88 +++++++++---------------------
 remote-curl.c                   |  2 +-
 remote.c                        | 94 ++++++++++++++++++---------------
 remote.h                        | 13 ++---
 t/helper/test-bundle-uri.c      |  2 -
 t/t5505-remote.sh               | 36 +++++++++++++
 t/t5801-remote-helpers.sh       | 23 ++++++++
 t/t5801/git-remote-nourl        |  3 ++
 t/t5801/git-remote-testgit      |  3 +-
 transport.c                     | 19 +++----
 15 files changed, 174 insertions(+), 162 deletions(-)
 create mode 100755 t/t5801/git-remote-nourl

-Peff
</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH v4 7/7] t-reftable-pq: add tests for merged_iter_pqueue_top()</title><updated>2024-06-14T09:52:23Z</updated><link
href="http://lore.kernel.org/git/20240614095136.12052-8-chandrapratap3519@gmail.com/"/><id>urn:uuid:9ce727d2-1e18-da47-a2ba-e3dcd259df95</id><thr:in-reply-to
ref="urn:uuid:a0dd6a58-7766-45de-568a-44df0caec4c5"
href="http://lore.kernel.org/git/20240614095136.12052-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">merged_iter_pqueue_top() as defined by reftable/pq.{c, h} returns
the element at the top of a priority-queue&#39;s heap without removing
it. Since there are no tests for this function in the existing
setup, add tests for the same.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-pq.c | 49 ++++++++++++++++++++++++++++++++++++
 1 file <a href="http://lore.kernel.org/git/20240614095136.12052-8-chandrapratap3519@gmail.com/#related">changed</a>, 49 insertions(+)

<span
class="head">diff --git a/t/unit-tests/t-reftable-pq.c b/t/unit-tests/t-reftable-pq.c
index e114a8cb0f..0e93cc97b1 100644
--- a/t/unit-tests/t-reftable-pq.c
+++ b/t/unit-tests/t-reftable-pq.c
</span><span
class="hunk">@@ -18,6 +18,11 @@ static void merged_iter_pqueue_check(const struct merged_iter_pqueue *pq)
</span> 	}
 }
 
<span
class="add">+static int pq_entry_equal(struct pq_entry *a, struct pq_entry *b)
+{
+	return !reftable_record_cmp(a-&gt;rec, b-&gt;rec) &#38;&#38; (a-&gt;index == b-&gt;index);
+}
+
</span> static void test_pq_record(void)
 {
 	struct merged_iter_pqueue pq = { 0 };
<span
class="hunk">@@ -45,9 +50,11 @@ static void test_pq_record(void)
</span> 	} while (i != 1);
 
 	while (!merged_iter_pqueue_is_empty(pq)) {
<span
class="add">+		struct pq_entry top = merged_iter_pqueue_top(pq);
</span> 		struct pq_entry e = merged_iter_pqueue_remove(&#38;pq);
 		merged_iter_pqueue_check(&#38;pq);
 
<span
class="add">+		check(pq_entry_equal(&#38;top, &#38;e));
</span> 		check(reftable_record_type(e.rec) == BLOCK_TYPE_REF);
 		if (last)
 			check_int(strcmp(last, e.rec-&gt;u.ref.refname), &lt;, 0);
<span
class="hunk">@@ -82,9 +89,11 @@ static void test_pq_index(void)
</span> 	}
 
 	for (i = N - 1; !merged_iter_pqueue_is_empty(pq); i--) {
<span
class="add">+		struct pq_entry top = merged_iter_pqueue_top(pq);
</span> 		struct pq_entry e = merged_iter_pqueue_remove(&#38;pq);
 		merged_iter_pqueue_check(&#38;pq);
 
<span
class="add">+		check(pq_entry_equal(&#38;top, &#38;e));
</span> 		check(reftable_record_type(e.rec) == BLOCK_TYPE_REF);
 		check_int(e.index, ==, i);
 		if (last)
<span
class="hunk">@@ -97,10 +106,50 @@ static void test_pq_index(void)
</span> 	merged_iter_pqueue_release(&#38;pq);
 }
 
<span
class="add">+static void test_merged_iter_pqueue_top(void)
+{
+	struct merged_iter_pqueue pq = { 0 };
+	struct reftable_record recs[14];
+	size_t N = ARRAY_SIZE(recs), i;
+
+	for (i = 0; i &lt; N; i++) {
+		reftable_record_init(&#38;recs[i], BLOCK_TYPE_REF);
+		recs[i].u.ref.refname = xstrdup(&#34;refs/heads/master&#34;);
+	}
+
+	for (i = 0; i &lt; N; i++) {
+		struct pq_entry e = {
+			.rec = &#38;recs[i],
+			.index = i,
+		};
+
+		merged_iter_pqueue_add(&#38;pq, &#38;e);
+		merged_iter_pqueue_check(&#38;pq);
+	}
+
+	for (i = N - 1; !merged_iter_pqueue_is_empty(pq); i--) {
+		struct pq_entry top = merged_iter_pqueue_top(pq);
+		struct pq_entry e = merged_iter_pqueue_remove(&#38;pq);
+
+		merged_iter_pqueue_check(&#38;pq);
+		check(pq_entry_equal(&#38;top, &#38;e));
+		check(reftable_record_equal(top.rec, &#38;recs[i], GIT_SHA1_RAWSZ));
+		for (size_t j = 0; i &lt; pq.len; j++) {
+			check(pq_less(&#38;top, &#38;pq.heap[j]));
+			check_int(top.index, &gt;, j);
+		}
+	}
+
+	for (i = 0; i &lt; N; i++)
+		reftable_record_release(&#38;recs[i]);
+	merged_iter_pqueue_release(&#38;pq);
+}
+
</span> int cmd_main(int argc, const char *argv[])
 {
 	TEST(test_pq_record(), &#34;pq works with record-based comparison&#34;);
 	TEST(test_pq_index(), &#34;pq works with index-based comparison&#34;);
<span
class="add">+	TEST(test_merged_iter_pqueue_top(), &#34;merged_iter_pqueue_top works&#34;);
</span> 
 	return test_done();
 }
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH v4 6/7] t-reftable-pq: add test for index based comparison</title><updated>2024-06-14T09:52:20Z</updated><link
href="http://lore.kernel.org/git/20240614095136.12052-7-chandrapratap3519@gmail.com/"/><id>urn:uuid:b152a9dc-443b-3903-805b-b3eb4bd3c0a0</id><thr:in-reply-to
ref="urn:uuid:a0dd6a58-7766-45de-568a-44df0caec4c5"
href="http://lore.kernel.org/git/20240614095136.12052-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">When comparing two entries, the priority queue as defined by
reftable/pq.{c, h} first compares the entries on the basis of
their ref-record&#39;s keys. If the keys turn out to be equal, the
comparison is then made on the basis of their update indices
(which are never equal).

In the current testing setup, only the case for comparison on
the basis of ref-record&#39;s keys is exercised. Add a test for
index-based comparison as well. Rename the existing test to
reflect its nature of only testing record-based comparison.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-pq.c | 43 ++++++++++++++++++++++++++++++++++--
 1 file <a href="http://lore.kernel.org/git/20240614095136.12052-7-chandrapratap3519@gmail.com/#related">changed</a>, 41 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/t/unit-tests/t-reftable-pq.c b/t/unit-tests/t-reftable-pq.c
index 774c4194e5..e114a8cb0f 100644
--- a/t/unit-tests/t-reftable-pq.c
+++ b/t/unit-tests/t-reftable-pq.c
</span><span
class="hunk">@@ -18,7 +18,7 @@ static void merged_iter_pqueue_check(const struct merged_iter_pqueue *pq)
</span> 	}
 }
 
<span
class="del">-static void test_pq(void)
</span><span
class="add">+static void test_pq_record(void)
</span> {
 	struct merged_iter_pqueue pq = { 0 };
 	struct reftable_record recs[54];
<span
class="hunk">@@ -59,9 +59,48 @@ static void test_pq(void)
</span> 	merged_iter_pqueue_release(&#38;pq);
 }
 
<span
class="add">+static void test_pq_index(void)
+{
+	struct merged_iter_pqueue pq = { 0 };
+	struct reftable_record recs[14];
+	char *last = NULL;
+	size_t N = ARRAY_SIZE(recs), i;
+
+	for (i = 0; i &lt; N; i++) {
+		reftable_record_init(&#38;recs[i], BLOCK_TYPE_REF);
+		recs[i].u.ref.refname = xstrdup(&#34;refs/heads/master&#34;);
+	}
+
+	for (i = 0; i &lt; N; i++) {
+		struct pq_entry e = {
+			.rec = &#38;recs[i],
+			.index = i,
+		};
+
+		merged_iter_pqueue_add(&#38;pq, &#38;e);
+		merged_iter_pqueue_check(&#38;pq);
+	}
+
+	for (i = N - 1; !merged_iter_pqueue_is_empty(pq); i--) {
+		struct pq_entry e = merged_iter_pqueue_remove(&#38;pq);
+		merged_iter_pqueue_check(&#38;pq);
+
+		check(reftable_record_type(e.rec) == BLOCK_TYPE_REF);
+		check_int(e.index, ==, i);
+		if (last)
+			check_str(last, e.rec-&gt;u.ref.refname);
+		last = e.rec-&gt;u.ref.refname;
+	}
+
+	for (i = 0; i &lt; N; i++)
+		reftable_record_release(&#38;recs[i]);
+	merged_iter_pqueue_release(&#38;pq);
+}
+
</span> int cmd_main(int argc, const char *argv[])
 {
<span
class="del">-	TEST(test_pq(), &#34;pq works&#34;);
</span><span
class="add">+	TEST(test_pq_record(), &#34;pq works with record-based comparison&#34;);
+	TEST(test_pq_index(), &#34;pq works with index-based comparison&#34;);
</span> 
 	return test_done();
 }
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH v4 5/7] t-reftable-pq: make merged_iter_pqueue_check() callable by reference</title><updated>2024-06-14T09:52:17Z</updated><link
href="http://lore.kernel.org/git/20240614095136.12052-6-chandrapratap3519@gmail.com/"/><id>urn:uuid:98fd8f0a-ae9e-3623-0575-5f82b44d074c</id><thr:in-reply-to
ref="urn:uuid:a0dd6a58-7766-45de-568a-44df0caec4c5"
href="http://lore.kernel.org/git/20240614095136.12052-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">merged_iter_pqueue_check() checks the validity of a priority queue
represented by a merged_iter_pqueue struct by asserting the
parent-child relation in the struct&#39;s heap. Explicity passing a
struct to this function means a copy of the entire struct is created,
which is inefficient.

Make the function accept a pointer to the struct instead. This is
safe to do since the function doesn&#39;t modify the struct in any way.
Make the function parameter &#39;const&#39; to assert immutability.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 t/unit-tests/t-reftable-pq.c | 10 +++++-----
 1 file <a href="http://lore.kernel.org/git/20240614095136.12052-6-chandrapratap3519@gmail.com/#related">changed</a>, 5 insertions(+), 5 deletions(-)

<span
class="head">diff --git a/t/unit-tests/t-reftable-pq.c b/t/unit-tests/t-reftable-pq.c
index 7d151f8582..774c4194e5 100644
--- a/t/unit-tests/t-reftable-pq.c
+++ b/t/unit-tests/t-reftable-pq.c
</span><span
class="hunk">@@ -10,11 +10,11 @@ license that can be found in the LICENSE file or at
</span> #include &#34;reftable/constants.h&#34;
 #include &#34;reftable/pq.h&#34;
 
<span
class="del">-static void merged_iter_pqueue_check(struct merged_iter_pqueue pq)
</span><span
class="add">+static void merged_iter_pqueue_check(const struct merged_iter_pqueue *pq)
</span> {
<span
class="del">-	for (size_t i = 1; i &lt; pq.len; i++) {
</span><span
class="add">+	for (size_t i = 1; i &lt; pq-&gt;len; i++) {
</span> 		size_t parent = (i - 1) / 2;
<span
class="del">-		check(pq_less(&#38;pq.heap[parent], &#38;pq.heap[i]));
</span><span
class="add">+		check(pq_less(&#38;pq-&gt;heap[parent], &#38;pq-&gt;heap[i]));
</span> 	}
 }
 
<span
class="hunk">@@ -40,13 +40,13 @@ static void test_pq(void)
</span> 		};
 
 		merged_iter_pqueue_add(&#38;pq, &#38;e);
<span
class="del">-		merged_iter_pqueue_check(pq);
</span><span
class="add">+		merged_iter_pqueue_check(&#38;pq);
</span> 		i = (i * 7) % N;
 	} while (i != 1);
 
 	while (!merged_iter_pqueue_is_empty(pq)) {
 		struct pq_entry e = merged_iter_pqueue_remove(&#38;pq);
<span
class="del">-		merged_iter_pqueue_check(pq);
</span><span
class="add">+		merged_iter_pqueue_check(&#38;pq);
</span> 
 		check(reftable_record_type(e.rec) == BLOCK_TYPE_REF);
 		if (last)
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH v4 4/7] t-reftable-pq: make merged_iter_pqueue_check() static</title><updated>2024-06-14T09:52:13Z</updated><link
href="http://lore.kernel.org/git/20240614095136.12052-5-chandrapratap3519@gmail.com/"/><id>urn:uuid:bcd4f656-d02c-87bd-443c-e00cc510ec2d</id><thr:in-reply-to
ref="urn:uuid:a0dd6a58-7766-45de-568a-44df0caec4c5"
href="http://lore.kernel.org/git/20240614095136.12052-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">merged_iter_pqueue_check() is a function previously defined in
reftable/pq_test.c (now t/unit-tests/t-reftable-pq.c) and used in
the testing of a priority queue as defined by reftable/pq.{c, h}.
As such, this function is only called by reftable/pq_test.c and it
makes little sense to expose it to non-testing code via reftable/pq.h.

Hence, make this function static and remove its prototype from
reftable/pq.h.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 reftable/pq.h                | 1 -
 t/unit-tests/t-reftable-pq.c | 2 +-
 2 files <a href="http://lore.kernel.org/git/20240614095136.12052-5-chandrapratap3519@gmail.com/#related">changed</a>, 1 insertion(+), 2 deletions(-)

<span
class="head">diff --git a/reftable/pq.h b/reftable/pq.h
index f796c23179..707bd26767 100644
--- a/reftable/pq.h
+++ b/reftable/pq.h
</span><span
class="hunk">@@ -22,7 +22,6 @@ struct merged_iter_pqueue {
</span> 	size_t cap;
 };
 
<span
class="del">-void merged_iter_pqueue_check(struct merged_iter_pqueue pq);
</span> struct pq_entry merged_iter_pqueue_remove(struct merged_iter_pqueue *pq);
 void merged_iter_pqueue_add(struct merged_iter_pqueue *pq, const struct pq_entry *e);
 void merged_iter_pqueue_release(struct merged_iter_pqueue *pq);
<span
class="head">diff --git a/t/unit-tests/t-reftable-pq.c b/t/unit-tests/t-reftable-pq.c
index a47a9473f3..7d151f8582 100644
--- a/t/unit-tests/t-reftable-pq.c
+++ b/t/unit-tests/t-reftable-pq.c
</span><span
class="hunk">@@ -10,7 +10,7 @@ license that can be found in the LICENSE file or at
</span> #include &#34;reftable/constants.h&#34;
 #include &#34;reftable/pq.h&#34;
 
<span
class="del">-void merged_iter_pqueue_check(struct merged_iter_pqueue pq)
</span><span
class="add">+static void merged_iter_pqueue_check(struct merged_iter_pqueue pq)
</span> {
 	for (size_t i = 1; i &lt; pq.len; i++) {
 		size_t parent = (i - 1) / 2;
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH v4 3/7] t: move reftable/pq_test.c to the unit testing framework</title><updated>2024-06-14T09:52:11Z</updated><link
href="http://lore.kernel.org/git/20240614095136.12052-4-chandrapratap3519@gmail.com/"/><id>urn:uuid:5ed07cf8-0625-8f7b-d394-04d466f9c721</id><thr:in-reply-to
ref="urn:uuid:a0dd6a58-7766-45de-568a-44df0caec4c5"
href="http://lore.kernel.org/git/20240614095136.12052-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">reftable/pq_test.c exercises a priority queue defined by
reftable/pq.{c, h}. Migrate reftable/pq_test.c to the unit
testing framework. Migration involves refactoring the tests
to use the unit testing framework instead of reftable&#39;s test
framework.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 Makefile                                      |  2 +-
 t/helper/test-reftable.c                      |  1 -
 .../pq_test.c =&gt; t/unit-tests/t-reftable-pq.c | 37 ++++++++-----------
 3 files <a href="http://lore.kernel.org/git/20240614095136.12052-4-chandrapratap3519@gmail.com/#related">changed</a>, 16 insertions(+), 24 deletions(-)
 rename reftable/pq_test.c =&gt; t/unit-tests/t-reftable-pq.c (62%)

<span
class="head">diff --git a/Makefile b/Makefile
index 59d98ba688..1cabe4cc69 100644
--- a/Makefile
+++ b/Makefile
</span><span
class="hunk">@@ -1336,6 +1336,7 @@ THIRD_PARTY_SOURCES += sha1dc/%
</span> UNIT_TEST_PROGRAMS += t-ctype
 UNIT_TEST_PROGRAMS += t-mem-pool
 UNIT_TEST_PROGRAMS += t-prio-queue
<span
class="add">+UNIT_TEST_PROGRAMS += t-reftable-pq
</span> UNIT_TEST_PROGRAMS += t-strbuf
 UNIT_TEST_PROGRAMS += t-strcmp-offset
 UNIT_TEST_PROGRAMS += t-trailer
<span
class="hunk">@@ -2675,7 +2676,6 @@ REFTABLE_TEST_OBJS += reftable/basics_test.o
</span> REFTABLE_TEST_OBJS += reftable/block_test.o
 REFTABLE_TEST_OBJS += reftable/dump.o
 REFTABLE_TEST_OBJS += reftable/merged_test.o
<span
class="del">-REFTABLE_TEST_OBJS += reftable/pq_test.o
</span> REFTABLE_TEST_OBJS += reftable/record_test.o
 REFTABLE_TEST_OBJS += reftable/readwrite_test.o
 REFTABLE_TEST_OBJS += reftable/stack_test.o
<span
class="head">diff --git a/t/helper/test-reftable.c b/t/helper/test-reftable.c
index bae731669c..86a2b0f91a 100644
--- a/t/helper/test-reftable.c
+++ b/t/helper/test-reftable.c
</span><span
class="hunk">@@ -9,7 +9,6 @@ int cmd__reftable(int argc, const char **argv)
</span> 	record_test_main(argc, argv);
 	block_test_main(argc, argv);
 	tree_test_main(argc, argv);
<span
class="del">-	pq_test_main(argc, argv);
</span> 	readwrite_test_main(argc, argv);
 	merged_test_main(argc, argv);
 	stack_test_main(argc, argv);
<span
class="head">diff --git a/reftable/pq_test.c b/t/unit-tests/t-reftable-pq.c
similarity index 62%
rename from reftable/pq_test.c
rename to t/unit-tests/t-reftable-pq.c
index b7d3c80cc7..a47a9473f3 100644
--- a/reftable/pq_test.c
+++ b/t/unit-tests/t-reftable-pq.c
</span><span
class="hunk">@@ -6,35 +6,28 @@ license that can be found in the LICENSE file or at
</span> <a
href="https://developers.google.com/open-source/licenses/bsd">https://developers.google.com/open-source/licenses/bsd</a>
 */
 
<span
class="del">-#include &#34;system.h&#34;
-
-#include &#34;basics.h&#34;
-#include &#34;constants.h&#34;
-#include &#34;pq.h&#34;
-#include &#34;record.h&#34;
-#include &#34;reftable-tests.h&#34;
-#include &#34;test_framework.h&#34;
</span><span
class="add">+#include &#34;test-lib.h&#34;
+#include &#34;reftable/constants.h&#34;
+#include &#34;reftable/pq.h&#34;
</span> 
 void merged_iter_pqueue_check(struct merged_iter_pqueue pq)
 {
<span
class="del">-	int i;
-	for (i = 1; i &lt; pq.len; i++) {
-		int parent = (i - 1) / 2;
-
-		EXPECT(pq_less(&#38;pq.heap[parent], &#38;pq.heap[i]));
</span><span
class="add">+	for (size_t i = 1; i &lt; pq.len; i++) {
+		size_t parent = (i - 1) / 2;
+		check(pq_less(&#38;pq.heap[parent], &#38;pq.heap[i]));
</span> 	}
 }
 
 static void test_pq(void)
 {
<span
class="del">-	struct merged_iter_pqueue pq = { NULL };
</span><span
class="add">+	struct merged_iter_pqueue pq = { 0 };
</span> 	struct reftable_record recs[54];
<span
class="del">-	int N = ARRAY_SIZE(recs) - 1, i;
</span><span
class="add">+	size_t N = ARRAY_SIZE(recs) - 1, i;
</span> 	char *last = NULL;
 
 	for (i = 0; i &lt; N; i++) {
 		struct strbuf refname = STRBUF_INIT;
<span
class="del">-		strbuf_addf(&#38;refname, &#34;%02d&#34;, i);
</span><span
class="add">+		strbuf_addf(&#38;refname, &#34;%02&#34;PRIuMAX, (uintmax_t)i);
</span> 
 		reftable_record_init(&#38;recs[i], BLOCK_TYPE_REF);
 		recs[i].u.ref.refname = strbuf_detach(&#38;refname, NULL);
<span
class="hunk">@@ -48,7 +41,6 @@ static void test_pq(void)
</span> 
 		merged_iter_pqueue_add(&#38;pq, &#38;e);
 		merged_iter_pqueue_check(pq);
<span
class="del">-
</span> 		i = (i * 7) % N;
 	} while (i != 1);
 
<span
class="hunk">@@ -56,9 +48,9 @@ static void test_pq(void)
</span> 		struct pq_entry e = merged_iter_pqueue_remove(&#38;pq);
 		merged_iter_pqueue_check(pq);
 
<span
class="del">-		EXPECT(reftable_record_type(e.rec) == BLOCK_TYPE_REF);
</span><span
class="add">+		check(reftable_record_type(e.rec) == BLOCK_TYPE_REF);
</span> 		if (last)
<span
class="del">-			EXPECT(strcmp(last, e.rec-&gt;u.ref.refname) &lt; 0);
</span><span
class="add">+			check_int(strcmp(last, e.rec-&gt;u.ref.refname), &lt;, 0);
</span> 		last = e.rec-&gt;u.ref.refname;
 	}
 
<span
class="hunk">@@ -67,8 +59,9 @@ static void test_pq(void)
</span> 	merged_iter_pqueue_release(&#38;pq);
 }
 
<span
class="del">-int pq_test_main(int argc, const char *argv[])
</span><span
class="add">+int cmd_main(int argc, const char *argv[])
</span> {
<span
class="del">-	RUN_TEST(test_pq);
-	return 0;
</span><span
class="add">+	TEST(test_pq(), &#34;pq works&#34;);
+
+	return test_done();
</span> }
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title
type="html">[PATCH v4 2/7] reftable: change the type of array indices to &#39;size_t&#39; in reftable/pq.c</title><updated>2024-06-14T09:52:07Z</updated><link
href="http://lore.kernel.org/git/20240614095136.12052-3-chandrapratap3519@gmail.com/"/><id>urn:uuid:eae2c495-1357-a938-6818-fe8c03b438d6</id><thr:in-reply-to
ref="urn:uuid:a0dd6a58-7766-45de-568a-44df0caec4c5"
href="http://lore.kernel.org/git/20240614095136.12052-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The variables &#39;i&#39;, &#39;j&#39;, &#39;k&#39; and &#39;min&#39; are used as indices for
&#39;pq-&gt;heap&#39;, which is an array. Additionally, &#39;pq-&gt;len&#39; is of
type &#39;size_t&#39; and is often used to assign values to these
variables. Hence, change the type of these variables from &#39;int&#39;
to &#39;size_t&#39;.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 reftable/pq.c | 12 ++++++------
 1 file <a href="http://lore.kernel.org/git/20240614095136.12052-3-chandrapratap3519@gmail.com/#related">changed</a>, 6 insertions(+), 6 deletions(-)

<span
class="head">diff --git a/reftable/pq.c b/reftable/pq.c
index 1a180c5fa6..2b5b7d1c0e 100644
--- a/reftable/pq.c
+++ b/reftable/pq.c
</span><span
class="hunk">@@ -22,15 +22,15 @@ int pq_less(struct pq_entry *a, struct pq_entry *b)
</span> 
 struct pq_entry merged_iter_pqueue_remove(struct merged_iter_pqueue *pq)
 {
<span
class="del">-	int i = 0;
</span><span
class="add">+	size_t i = 0;
</span> 	struct pq_entry e = pq-&gt;heap[0];
 	pq-&gt;heap[0] = pq-&gt;heap[pq-&gt;len - 1];
 	pq-&gt;len--;
 
 	while (i &lt; pq-&gt;len) {
<span
class="del">-		int min = i;
-		int j = 2 * i + 1;
-		int k = 2 * i + 2;
</span><span
class="add">+		size_t min = i;
+		size_t j = 2 * i + 1;
+		size_t k = 2 * i + 2;
</span> 		if (j &lt; pq-&gt;len &#38;&#38; pq_less(&#38;pq-&gt;heap[j], &#38;pq-&gt;heap[i]))
 			min = j;
 		if (k &lt; pq-&gt;len &#38;&#38; pq_less(&#38;pq-&gt;heap[k], &#38;pq-&gt;heap[min]))
<span
class="hunk">@@ -46,14 +46,14 @@ struct pq_entry merged_iter_pqueue_remove(struct merged_iter_pqueue *pq)
</span> 
 void merged_iter_pqueue_add(struct merged_iter_pqueue *pq, const struct pq_entry *e)
 {
<span
class="del">-	int i = 0;
</span><span
class="add">+	size_t i = 0;
</span> 
 	REFTABLE_ALLOC_GROW(pq-&gt;heap, pq-&gt;len + 1, pq-&gt;cap);
 	pq-&gt;heap[pq-&gt;len++] = *e;
 
 	i = pq-&gt;len - 1;
 	while (i &gt; 0) {
<span
class="del">-		int j = (i - 1) / 2;
</span><span
class="add">+		size_t j = (i - 1) / 2;
</span> 		if (pq_less(&#38;pq-&gt;heap[j], &#38;pq-&gt;heap[i]))
 			break;
 		SWAP(pq-&gt;heap[j], pq-&gt;heap[i]);
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[PATCH v4 1/7] reftable: remove unncessary curly braces in reftable/pq.c</title><updated>2024-06-14T09:52:05Z</updated><link
href="http://lore.kernel.org/git/20240614095136.12052-2-chandrapratap3519@gmail.com/"/><id>urn:uuid:23179678-860b-c3ec-1c3c-127c82e84289</id><thr:in-reply-to
ref="urn:uuid:a0dd6a58-7766-45de-568a-44df0caec4c5"
href="http://lore.kernel.org/git/20240614095136.12052-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">According to Documentation/CodingGuidelines, control-flow statements
with a single line as their body must omit curly braces. Make
reftable/pq.c conform to this guideline. Besides that, remove
unnecessary newlines and variable assignment.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
---
 reftable/pq.c | 17 ++++-------------
 1 file <a href="http://lore.kernel.org/git/20240614095136.12052-2-chandrapratap3519@gmail.com/#related">changed</a>, 4 insertions(+), 13 deletions(-)

<span
class="head">diff --git a/reftable/pq.c b/reftable/pq.c
index 7fb45d8c60..1a180c5fa6 100644
--- a/reftable/pq.c
+++ b/reftable/pq.c
</span><span
class="hunk">@@ -27,22 +27,16 @@ struct pq_entry merged_iter_pqueue_remove(struct merged_iter_pqueue *pq)
</span> 	pq-&gt;heap[0] = pq-&gt;heap[pq-&gt;len - 1];
 	pq-&gt;len--;
 
<span
class="del">-	i = 0;
</span> 	while (i &lt; pq-&gt;len) {
 		int min = i;
 		int j = 2 * i + 1;
 		int k = 2 * i + 2;
<span
class="del">-		if (j &lt; pq-&gt;len &#38;&#38; pq_less(&#38;pq-&gt;heap[j], &#38;pq-&gt;heap[i])) {
</span><span
class="add">+		if (j &lt; pq-&gt;len &#38;&#38; pq_less(&#38;pq-&gt;heap[j], &#38;pq-&gt;heap[i]))
</span> 			min = j;
<span
class="del">-		}
-		if (k &lt; pq-&gt;len &#38;&#38; pq_less(&#38;pq-&gt;heap[k], &#38;pq-&gt;heap[min])) {
</span><span
class="add">+		if (k &lt; pq-&gt;len &#38;&#38; pq_less(&#38;pq-&gt;heap[k], &#38;pq-&gt;heap[min]))
</span> 			min = k;
<span
class="del">-		}
-
-		if (min == i) {
</span><span
class="add">+		if (min == i)
</span> 			break;
<span
class="del">-		}
-
</span> 		SWAP(pq-&gt;heap[i], pq-&gt;heap[min]);
 		i = min;
 	}
<span
class="hunk">@@ -60,12 +54,9 @@ void merged_iter_pqueue_add(struct merged_iter_pqueue *pq, const struct pq_entry
</span> 	i = pq-&gt;len - 1;
 	while (i &gt; 0) {
 		int j = (i - 1) / 2;
<span
class="del">-		if (pq_less(&#38;pq-&gt;heap[j], &#38;pq-&gt;heap[i])) {
</span><span
class="add">+		if (pq_less(&#38;pq-&gt;heap[j], &#38;pq-&gt;heap[i]))
</span> 			break;
<span
class="del">-		}
-
</span> 		SWAP(pq-&gt;heap[j], pq-&gt;heap[i]);
<span
class="del">-
</span> 		i = j;
 	}
 }
-- 
2.45.2.404.g9eaef5822c

</pre></div></content></entry><entry><author><name>Chandra Pratap</name><email>chandrapratap3519@gmail.com</email></author><title>[GSoC][PATCH v4 0/7] t: port reftable/pq_test.c to the unit testing framework</title><updated>2024-06-14T09:52:02Z</updated><link
href="http://lore.kernel.org/git/20240614095136.12052-1-chandrapratap3519@gmail.com/"/><id>urn:uuid:a0dd6a58-7766-45de-568a-44df0caec4c5</id><thr:in-reply-to
ref="urn:uuid:68f84dc9-42e2-2469-8efe-86e4367099c2"
href="http://lore.kernel.org/git/20240611083157.9876-1-chandrapratap3519@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">In the recent codebase update (commit 8bf6fbd, 2023-12-09), a new unit
testing framework written entirely in C was introduced to the Git project
aimed at simplifying testing and reducing test run times.
Currently, tests for the reftable refs-backend are performed by a custom
testing framework defined by reftable/test_framework.{c, h}. Port
reftable/pq_test.c to the unit testing framework and improve upon
the ported test.

The first two patches in the series are preparatory cleanup, the third patch
moves the test to the unit testing framework, and the rest of the patches
improve upon the ported test.

Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;

---
Changes in v4:
- Add a commit message for the second patch

CI/PR for v4: <a
href="https://github.com/gitgitgadget/git/pull/1745">https://github.com/gitgitgadget/git/pull/1745</a>

Chandra Pratap(7):
reftable: remove unncessary curly braces in reftable/pq.c
reftable: change the type of array indices to &#39;size_t&#39; in
t: move reftable/pq_test.c to the unit testing framework
t-reftable-pq: make merged_iter_pqueue_check() static
t-reftable-pq: make merged_iter_pqueue_check() callable
t-reftable-pq: add test for index based comparison
t-reftable-pq: add tests for merged_iter_pqueue_top()

Makefile                     |   2 +-
reftable/pq.c                |  29 +++--------
reftable/pq.h                |   1 -
reftable/pq_test.c           |  74 ----------------------------
t/helper/test-reftable.c     |   1 -
t/unit-tests/t-reftable-pq.c | 155 +++++++++++++++++++++++++++++++++++++++++++++
6 files changed, 166 insertions(+), 96 deletions(-)

Range-diff against v3:
1:  3c333e7770 ! 1:  1873fb02ce reftable: change the type of array indices to &#39;size_t&#39; in reftable/pq.c
    @@ Metadata
      ## Commit message ##
         reftable: change the type of array indices to &#39;size_t&#39; in reftable/pq.c
     
    +    The variables &#39;i&#39;, &#39;j&#39;, &#39;k&#39; and &#39;min&#39; are used as indices for
    +    &#39;pq-&gt;heap&#39;, which is an array. Additionally, &#39;pq-&gt;len&#39; is of
    +    type &#39;size_t&#39; and is often used to assign values to these
    +    variables. Hence, change the type of these variables from &#39;int&#39;
    +    to &#39;size_t&#39;.
    +
         Mentored-by: Patrick Steinhardt &lt;ps@pks.im&gt;
         Mentored-by: Christian Couder &lt;chriscool@tuxfamily.org&gt;
         Signed-off-by: Chandra Pratap &lt;chandrapratap3519@gmail.com&gt;
2:  bf547f705a = 2:  3cccf8266a t: move reftable/pq_test.c to the unit testing framework
3:  7dd3a2b27f = 3:  4b63849694 t-reftable-pq: make merged_iter_pqueue_check() static
4:  c803e7adfc = 4:  3698a7189f t-reftable-pq: make merged_iter_pqueue_check() callable by reference
5:  0b03f3567d = 5:  d58c8f709e t-reftable-pq: add test for index based comparison
6:  0cdfa6221e = 6:  69521f0ff7 t-reftable-pq: add tests for merged_iter_pqueue_top()
</pre></div></content></entry><entry><author><name>Patrick Steinhardt</name><email>ps@pks.im</email></author><title>[PATCH v3 20/20] hex: guard declarations with `USE_THE_REPOSITORY_VARIABLE`</title><updated>2024-06-14T06:51:19Z</updated><link
href="http://lore.kernel.org/git/436ffc05701845e1e3bb19ea46d017d5b9b4114f.1718347699.git.ps@pks.im/"/><id>urn:uuid:9155a154-3ec1-cb3c-e5cf-f3bc5b1956f1</id><thr:in-reply-to
ref="urn:uuid:b9b5e391-3f8e-442b-ad2e-4edc34a3728d"
href="http://lore.kernel.org/git/cover.1718347699.git.ps@pks.im/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap"><a
href="http://lore.kernel.org/git/436ffc05701845e1e3bb19ea46d017d5b9b4114f.1718347699.git.ps@pks.im/1-a.txt">[-- Attachment #1: Type: text/plain, Size: 2848 bytes --]</a>

Guard declarations of functions that implicitly use `the_repository`
with `USE_THE_REPOSITORY_VARIABLE` such that callers don&#39;t accidentally
rely on that global variable.

Signed-off-by: Patrick Steinhardt &lt;ps@pks.im&gt;
---
 hex.h | 26 ++++++++++++++++----------
 1 file <a href="http://lore.kernel.org/git/436ffc05701845e1e3bb19ea46d017d5b9b4114f.1718347699.git.ps@pks.im/#related">changed</a>, 16 insertions(+), 10 deletions(-)

<span
class="head">diff --git a/hex.h b/hex.h
index 9809667f33..e9ccb54065 100644
--- a/hex.h
+++ b/hex.h
</span><span
class="hunk">@@ -13,10 +13,6 @@
</span>  * input, so it is safe to pass this function an arbitrary
  * null-terminated string.
  */
<span
class="del">-int get_hash_hex(const char *hex, unsigned char *hash);
-int get_oid_hex(const char *hex, struct object_id *oid);
-
-/* Like get_oid_hex, but for an arbitrary hash algorithm. */
</span> int get_oid_hex_algop(const char *hex, struct object_id *oid, const struct git_hash_algo *algop);
 
 /*
<span
class="hunk">@@ -35,7 +31,6 @@ int get_oid_hex_algop(const char *hex, struct object_id *oid, const struct git_h
</span> char *hash_to_hex_algop_r(char *buffer, const unsigned char *hash, const struct git_hash_algo *);
 char *oid_to_hex_r(char *out, const struct object_id *oid);
 char *hash_to_hex_algop(const unsigned char *hash, const struct git_hash_algo *);	/* static buffer result! */
<span
class="del">-char *hash_to_hex(const unsigned char *hash);						/* same static buffer */
</span> char *oid_to_hex(const struct object_id *oid);						/* same static buffer */
 
 /*
<span
class="hunk">@@ -45,13 +40,9 @@ char *oid_to_hex(const struct object_id *oid);						/* same static buffer */
</span>  * other invalid character.  end is only updated on success; otherwise, it is
  * unmodified.
  */
<span
class="del">-int parse_oid_hex(const char *hex, struct object_id *oid, const char **end);
-
-/* Like parse_oid_hex, but for an arbitrary hash algorithm. */
</span> int parse_oid_hex_algop(const char *hex, struct object_id *oid, const char **end,
 			const struct git_hash_algo *algo);
 
<span
class="del">-
</span> /*
  * These functions work like get_oid_hex and parse_oid_hex, but they will parse
  * a hex value for any algorithm. The algorithm is detected based on the length
<span
class="hunk">@@ -61,4 +52,19 @@ int parse_oid_hex_algop(const char *hex, struct object_id *oid, const char **end
</span> int get_oid_hex_any(const char *hex, struct object_id *oid);
 int parse_oid_hex_any(const char *hex, struct object_id *oid, const char **end);
 
<span
class="del">-#endif
</span><span
class="add">+#ifdef USE_THE_REPOSITORY_VARIABLE
+
+/* Like get_oid_hex_algop, but for `the_hash_algo`. */
+int get_hash_hex(const char *hex, unsigned char *hash);
+int get_oid_hex(const char *hex, struct object_id *oid);
+
+/* Like parse_oid_hex_algop, but uses `the_hash_algo`. */
+int parse_oid_hex(const char *hex, struct object_id *oid, const char **end);
+
+/*
+ * Same as `hash_to_hex_algop()`, but uses `the_hash_algo`.
+ */
+char *hash_to_hex(const unsigned char *hash);
+
+#endif /* USE_THE_REPOSITORY_VARIABLE */
+#endif /* HEX_H */
</span>-- 
2.45.2.457.g8d94cfb545.dirty


<a
href="http://lore.kernel.org/git/436ffc05701845e1e3bb19ea46d017d5b9b4114f.1718347699.git.ps@pks.im/2-signature.asc">[-- Attachment #2: signature.asc --]
[-- Type: application/pgp-signature, Size: 833 bytes --]</a>
</pre></div></content></entry><entry><author><name>Patrick Steinhardt</name><email>ps@pks.im</email></author><title
type="html">[PATCH v3 19/20] t/helper: remove dependency on `the_repository` in &#34;proc-receive&#34;</title><updated>2024-06-14T06:51:15Z</updated><link
href="http://lore.kernel.org/git/5de7a01af54267fa65e6b3269abe80b1c5301919.1718347699.git.ps@pks.im/"/><id>urn:uuid:9de1796c-295b-268d-0385-71e13c4d91fa</id><thr:in-reply-to
ref="urn:uuid:b9b5e391-3f8e-442b-ad2e-4edc34a3728d"
href="http://lore.kernel.org/git/cover.1718347699.git.ps@pks.im/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap"><a
href="http://lore.kernel.org/git/5de7a01af54267fa65e6b3269abe80b1c5301919.1718347699.git.ps@pks.im/1-a.txt">[-- Attachment #1: Type: text/plain, Size: 2061 bytes --]</a>

The &#34;proc-receive&#34; test helper implicitly relies on `the_repository` via
`parse_oid_hex()`. This isn&#39;t necessary though, and in fact the whole
command does not depend on `the_repository` at all.

Stop setting up `the_repository` and use `parse_oid_hex_any()` to parse
object IDs.

Signed-off-by: Patrick Steinhardt &lt;ps@pks.im&gt;
---
 t/helper/test-proc-receive.c | 9 +++------
 1 file <a href="http://lore.kernel.org/git/5de7a01af54267fa65e6b3269abe80b1c5301919.1718347699.git.ps@pks.im/#related">changed</a>, 3 insertions(+), 6 deletions(-)

<span
class="head">diff --git a/t/helper/test-proc-receive.c b/t/helper/test-proc-receive.c
index f30022d222..29361c7aab 100644
--- a/t/helper/test-proc-receive.c
+++ b/t/helper/test-proc-receive.c
</span><span
class="hunk">@@ -3,8 +3,8 @@
</span> #include &#34;hex.h&#34;
 #include &#34;parse-options.h&#34;
 #include &#34;pkt-line.h&#34;
<span
class="del">-#include &#34;setup.h&#34;
</span> #include &#34;sigchain.h&#34;
<span
class="add">+#include &#34;string-list.h&#34;
</span> 
 static const char *proc_receive_usage[] = {
 	&#34;test-tool proc-receive [&lt;options&gt;]&#34;,
<span
class="hunk">@@ -92,9 +92,9 @@ static void proc_receive_read_commands(struct packet_reader *reader,
</span> 		if (die_read_commands)
 			die(&#34;die with the --die-read-commands option&#34;);
 
<span
class="del">-		if (parse_oid_hex(reader-&gt;line, &#38;old_oid, &#38;p) ||
</span><span
class="add">+		if (parse_oid_hex_any(reader-&gt;line, &#38;old_oid, &#38;p) == GIT_HASH_UNKNOWN ||
</span> 		    *p++ != &#39; &#39; ||
<span
class="del">-		    parse_oid_hex(p, &#38;new_oid, &#38;p) ||
</span><span
class="add">+		    parse_oid_hex_any(p, &#38;new_oid, &#38;p) == GIT_HASH_UNKNOWN ||
</span> 		    *p++ != &#39; &#39;)
 			die(&#34;protocol error: expected &#39;old new ref&#39;, got &#39;%s&#39;&#34;,
 			    reader-&gt;line);
<span
class="hunk">@@ -128,7 +128,6 @@ static void proc_receive_read_push_options(struct packet_reader *reader,
</span> 
 int cmd__proc_receive(int argc, const char **argv)
 {
<span
class="del">-	int nongit_ok = 0;
</span> 	struct packet_reader reader;
 	struct command *commands = NULL;
 	struct string_list push_options = STRING_LIST_INIT_DUP;
<span
class="hunk">@@ -154,8 +153,6 @@ int cmd__proc_receive(int argc, const char **argv)
</span> 		OPT_END()
 	};
 
<span
class="del">-	setup_git_directory_gently(&#38;nongit_ok);
-
</span> 	argc = parse_options(argc, argv, &#34;test-tools&#34;, options, proc_receive_usage, 0);
 	if (argc &gt; 0)
 		usage_msg_opt(&#34;Too many arguments.&#34;, proc_receive_usage, options);
-- 
2.45.2.457.g8d94cfb545.dirty


<a
href="http://lore.kernel.org/git/5de7a01af54267fa65e6b3269abe80b1c5301919.1718347699.git.ps@pks.im/2-signature.asc">[-- Attachment #2: signature.asc --]
[-- Type: application/pgp-signature, Size: 833 bytes --]</a>
</pre></div></content></entry></feed>