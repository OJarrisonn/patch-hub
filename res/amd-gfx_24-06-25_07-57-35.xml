<?xml version="1.0" encoding="us-ascii"?>
<feed
xmlns="http://www.w3.org/2005/Atom"
xmlns:thr="http://purl.org/syndication/thread/1.0"><title>((s:patch OR s:rfc) AND NOT s:re:) - search results</title><link
rel="alternate"
type="text/html"
href="http://lore.kernel.org/amd-gfx/?q=((s:patch+OR+s:rfc)+AND+NOT+s:re:)"/><link
rel="self"
href="http://lore.kernel.org/amd-gfx/?q=((s:patch+OR+s:rfc)+AND+NOT+s:re:)&amp;x=A"/><id>urn:uuid:bf2c134e-36a8-00bb-7d77-16c3a7814731</id><updated>2024-06-25T07:07:22Z</updated><entry><author><name>Mario Limonciello</name><email>mario.limonciello@amd.com</email></author><title>[PATCH 2/2] Documentation/amdgpu: Add Ryzen 9000 series processors</title><updated>2024-06-24T19:15:48Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624191525.63787-2-mario.limonciello@amd.com/"/><id>urn:uuid:d3f03119-4857-fa21-fa81-04704aafb6fc</id><thr:in-reply-to
ref="urn:uuid:90e817b2-5fe3-7bdf-147c-da1d3c0bee1f"
href="http://lore.kernel.org/amd-gfx/20240624191525.63787-1-mario.limonciello@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">These have been announced so add them to the table.

Link: <a
href="https://www.amd.com/en/products/processors/desktops/ryzen/9000-series/amd-ryzen-9-9950x.html">https://www.amd.com/en/products/processors/desktops/ryzen/9000-series/amd-ryzen-9-9950x.html</a>
Signed-off-by: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
---
 Documentation/gpu/amdgpu/apu-asic-info-table.csv | 1 +
 1 file <a href="http://lore.kernel.org/amd-gfx/20240624191525.63787-2-mario.limonciello@amd.com/#related">changed</a>, 1 insertion(+)

<span
class="head">diff --git a/Documentation/gpu/amdgpu/apu-asic-info-table.csv b/Documentation/gpu/amdgpu/apu-asic-info-table.csv
index 61140ba32793..5dd4b8762d19 100644
--- a/Documentation/gpu/amdgpu/apu-asic-info-table.csv
+++ b/Documentation/gpu/amdgpu/apu-asic-info-table.csv
</span><span
class="hunk">@@ -7,6 +7,7 @@ SteamDeck, VANGOGH, DCN 3.0.1, 10.3.1, VCN 3.1.0, 5.2.1, 11.5.0
</span> Ryzen 5000 series / Ryzen 7x30 series, GREEN SARDINE / Cezanne / Barcelo / Barcelo-R, DCN 2.1, 9.3, VCN 2.2, 4.1.1, 12.0.1
 Ryzen 6000 series / Ryzen 7x35 series / Ryzen 7x36 series, YELLOW CARP / Rembrandt / Rembrandt-R, 3.1.2, 10.3.3, VCN 3.1.1, 5.2.3, 13.0.3
 Ryzen 7000 series (AM5), Raphael, 3.1.5, 10.3.6, 3.1.2, 5.2.6, 13.0.5
<span
class="add">+Ryzen 9000 series (AM5), Granite Ridge, 3.1.5, 10.3.6, 3.1.2, 5.2.6, 13.0.5
</span> Ryzen 7x45 series (FL1), Dragon Range, 3.1.5, 10.3.6, 3.1.2, 5.2.6, 13.0.5
 Ryzen 7x20 series, Mendocino, 3.1.6, 10.3.7, 3.1.1, 5.2.7, 13.0.8
 Ryzen 7x40 series, Phoenix, 3.1.4, 11.0.1 / 11.0.4, 4.0.2, 6.0.1, 13.0.4 / 13.0.11
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Mario Limonciello</name><email>mario.limonciello@amd.com</email></author><title>[PATCH 1/2] Documentation/amdgpu: Add Ryzen AI 300 series processors</title><updated>2024-06-24T19:15:45Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624191525.63787-1-mario.limonciello@amd.com/"/><id>urn:uuid:90e817b2-5fe3-7bdf-147c-da1d3c0bee1f</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">These have been announced so add them to the table.

Link: <a
href="https://www.amd.com/en/products/processors/laptop/ryzen/300-series/amd-ryzen-ai-9-hx-370.html">https://www.amd.com/en/products/processors/laptop/ryzen/300-series/amd-ryzen-ai-9-hx-370.html</a>
Signed-off-by: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
---
 Documentation/gpu/amdgpu/apu-asic-info-table.csv | 1 +
 1 file <a href="http://lore.kernel.org/amd-gfx/20240624191525.63787-1-mario.limonciello@amd.com/#related">changed</a>, 1 insertion(+)

<span
class="head">diff --git a/Documentation/gpu/amdgpu/apu-asic-info-table.csv b/Documentation/gpu/amdgpu/apu-asic-info-table.csv
index 18868abe2a91..61140ba32793 100644
--- a/Documentation/gpu/amdgpu/apu-asic-info-table.csv
+++ b/Documentation/gpu/amdgpu/apu-asic-info-table.csv
</span><span
class="hunk">@@ -11,3 +11,4 @@ Ryzen 7x45 series (FL1), Dragon Range, 3.1.5, 10.3.6, 3.1.2, 5.2.6, 13.0.5
</span> Ryzen 7x20 series, Mendocino, 3.1.6, 10.3.7, 3.1.1, 5.2.7, 13.0.8
 Ryzen 7x40 series, Phoenix, 3.1.4, 11.0.1 / 11.0.4, 4.0.2, 6.0.1, 13.0.4 / 13.0.11
 Ryzen 8x40 series, Hawk Point, 3.1.4, 11.0.1 / 11.0.4, 4.0.2, 6.0.1, 13.0.4 / 13.0.11
<span
class="add">+Ryzen AI 300 series, Strix Point, 3.5.0, 11.5.0, 4.0.5, 6.1.0, 14.0.0
</span>-- 
2.34.1

</pre></div></content></entry><entry><author><name>Sonny Jiang</name><email>sonny.jiang@amd.com</email></author><title>[PATCH] drm/amdgpu/jpeg5: Add support for DPG mode</title><updated>2024-06-24T17:58:50Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624175820.1508394-1-sonny.jiang@amd.com/"/><id>urn:uuid:6d9ca998-4cd5-2533-47c0-9af68859fa98</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Sonny Jiang &lt;sonjiang@amd.com&gt;

Add DPG support for JPEG 5.0

Signed-off-by: Sonny Jiang &lt;sonjiang@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_jpeg.h |  31 +++++
 drivers/gpu/drm/amd/amdgpu/jpeg_v5_0_0.c | 159 ++++++++++++++++++++---
 drivers/gpu/drm/amd/amdgpu/jpeg_v5_0_0.h |   6 +
 drivers/gpu/drm/amd/amdgpu/soc24.c       |   1 +
 4 files <a href="http://lore.kernel.org/amd-gfx/20240624175820.1508394-1-sonny.jiang@amd.com/#related">changed</a>, 180 insertions(+), 17 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_jpeg.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_jpeg.h
index aea31d61d991..f9cdd873ac9b 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_jpeg.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_jpeg.h
</span><span
class="hunk">@@ -60,6 +60,37 @@
</span> 		RREG32_SOC15(JPEG, inst_idx, mmUVD_DPG_LMA_DATA);				\
 	})
 
<span
class="add">+#define WREG32_SOC24_JPEG_DPG_MODE(inst_idx, offset, value, indirect)		\
+	do {									\
+		WREG32_SOC15(JPEG, GET_INST(JPEG, inst_idx),			\
+			     regUVD_DPG_LMA_DATA, value);			\
+		WREG32_SOC15(JPEG, GET_INST(JPEG, inst_idx),			\
+			     regUVD_DPG_LMA_MASK, 0xFFFFFFFF);			\
+		WREG32_SOC15(							\
+			JPEG, GET_INST(JPEG, inst_idx),				\
+			regUVD_DPG_LMA_CTL,					\
+			(UVD_DPG_LMA_CTL__READ_WRITE_MASK |			\
+			 offset &lt;&lt; UVD_DPG_LMA_CTL__READ_WRITE_ADDR__SHIFT |	\
+			 indirect &lt;&lt; UVD_DPG_LMA_CTL__SRAM_SEL__SHIFT));	\
+	} while (0)
+
+#define RREG32_SOC24_JPEG_DPG_MODE(inst_idx, offset, mask_en)			\
+	do {									\
+		WREG32_SOC15(JPEG, GET_INST(JPEG, inst_idx),			\
+			regUVD_DPG_LMA_MASK, 0xFFFFFFFF);			\
+		WREG32_SOC15(JPEG, GET_INST(JPEG, inst_idx),			\
+			regUVD_DPG_LMA_CTL,					\
+			(UVD_DPG_LMA_CTL__MASK_EN_MASK |			\
+			offset &lt;&lt; UVD_DPG_LMA_CTL__READ_WRITE_ADDR__SHIFT));	\
+		RREG32_SOC15(JPEG, inst_idx, regUVD_DPG_LMA_DATA);		\
+	} while (0)
+
+#define ADD_SOC24_JPEG_TO_DPG_SRAM(inst_idx, offset, value, indirect)		\
+	do {									\
+		*adev-&gt;jpeg.inst[inst_idx].dpg_sram_curr_addr++ = offset;	\
+		*adev-&gt;jpeg.inst[inst_idx].dpg_sram_curr_addr++ = value;	\
+	} while (0)
+
</span> struct amdgpu_jpeg_reg{
 	unsigned jpeg_pitch[AMDGPU_MAX_JPEG_RINGS];
 };
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/jpeg_v5_0_0.c b/drivers/gpu/drm/amd/amdgpu/jpeg_v5_0_0.c
index e766b9463759..d694a276498a 100644
--- a/drivers/gpu/drm/amd/amdgpu/jpeg_v5_0_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/jpeg_v5_0_0.c
</span><span
class="hunk">@@ -31,6 +31,7 @@
</span> #include &#34;vcn/vcn_5_0_0_offset.h&#34;
 #include &#34;vcn/vcn_5_0_0_sh_mask.h&#34;
 #include &#34;ivsrcid/vcn/irqsrcs_vcn_4_0.h&#34;
<span
class="add">+#include &#34;jpeg_v5_0_0.h&#34;
</span> 
 static void jpeg_v5_0_0_set_dec_ring_funcs(struct amdgpu_device *adev);
 static void jpeg_v5_0_0_set_irq_funcs(struct amdgpu_device *adev);
<span
class="hunk">@@ -137,6 +138,10 @@ static int jpeg_v5_0_0_hw_init(void *handle)
</span> 	adev-&gt;nbio.funcs-&gt;vcn_doorbell_range(adev, ring-&gt;use_doorbell,
 			(adev-&gt;doorbell_index.vcn.vcn_ring0_1 &lt;&lt; 1), 0);
 
<span
class="add">+	/* Skip ring test because pause DPG is not implemented. */
+	if (adev-&gt;pg_flags &#38; AMD_PG_SUPPORT_JPEG_DPG)
+		return 0;
+
</span> 	r = amdgpu_ring_test_helper(ring);
 	if (r)
 		return r;
<span
class="hunk">@@ -235,7 +240,7 @@ static void jpeg_v5_0_0_enable_clock_gating(struct amdgpu_device *adev)
</span> 	WREG32_SOC15(JPEG, 0, regJPEG_CGC_GATE, data);
 }
 
<span
class="del">-static int jpeg_v5_0_0_disable_static_power_gating(struct amdgpu_device *adev)
</span><span
class="add">+static int jpeg_v5_0_0_disable_power_gating(struct amdgpu_device *adev)
</span> {
 	uint32_t data = 0;
 
<span
class="hunk">@@ -248,14 +253,10 @@ static int jpeg_v5_0_0_disable_static_power_gating(struct amdgpu_device *adev)
</span> 	WREG32_P(SOC15_REG_OFFSET(JPEG, 0, regUVD_JPEG_POWER_STATUS), 0,
 		~UVD_JPEG_POWER_STATUS__JPEG_POWER_STATUS_MASK);
 
<span
class="del">-	/* keep the JPEG in static PG mode */
-	WREG32_P(SOC15_REG_OFFSET(JPEG, 0, regUVD_JPEG_POWER_STATUS), 0,
-		~UVD_JPEG_POWER_STATUS__JPEG_PG_MODE_MASK);
-
</span> 	return 0;
 }
 
<span
class="del">-static int jpeg_v5_0_0_enable_static_power_gating(struct amdgpu_device *adev)
</span><span
class="add">+static int jpeg_v5_0_0_enable_power_gating(struct amdgpu_device *adev)
</span> {
 	/* enable anti hang mechanism */
 	WREG32_P(SOC15_REG_OFFSET(JPEG, 0, regUVD_JPEG_POWER_STATUS),
<span
class="hunk">@@ -273,6 +274,121 @@ static int jpeg_v5_0_0_enable_static_power_gating(struct amdgpu_device *adev)
</span> 	return 0;
 }
 
<span
class="add">+static void jpeg_engine_5_0_0_dpg_clock_gating_mode(struct amdgpu_device *adev,
+	       int inst_idx, uint8_t indirect)
+{
+	uint32_t data = 0;
+
+	// JPEG disable CGC
+	if (adev-&gt;cg_flags &#38; AMD_CG_SUPPORT_JPEG_MGCG)
+		data = 1 &lt;&lt; JPEG_CGC_CTRL__DYN_CLOCK_MODE__SHIFT;
+	else
+		data = 0 &lt;&lt; JPEG_CGC_CTRL__DYN_CLOCK_MODE__SHIFT;
+
+	data |= 1 &lt;&lt; JPEG_CGC_CTRL__CLK_GATE_DLY_TIMER__SHIFT;
+	data |= 4 &lt;&lt; JPEG_CGC_CTRL__CLK_OFF_DELAY__SHIFT;
+
+	if (indirect) {
+		ADD_SOC24_JPEG_TO_DPG_SRAM(inst_idx, vcnipJPEG_CGC_CTRL, data, indirect);
+
+		// Turn on All JPEG clocks
+		data = 0;
+		ADD_SOC24_JPEG_TO_DPG_SRAM(inst_idx, vcnipJPEG_CGC_GATE, data, indirect);
+	} else {
+		WREG32_SOC24_JPEG_DPG_MODE(inst_idx, vcnipJPEG_CGC_CTRL, data, indirect);
+
+		// Turn on All JPEG clocks
+		data = 0;
+		WREG32_SOC24_JPEG_DPG_MODE(inst_idx, vcnipJPEG_CGC_GATE, data, indirect);
+	}
+}
+
+/**
+ * jpeg_v5_0_0_start_dpg_mode - Jpeg start with dpg mode
+ *
+ * @adev: amdgpu_device pointer
+ * @inst_idx: instance number index
+ * @indirect: indirectly write sram
+ *
+ * Start JPEG block with dpg mode
+ */
+static int jpeg_v5_0_0_start_dpg_mode(struct amdgpu_device *adev, int inst_idx, bool indirect)
+{
+	struct amdgpu_ring *ring = adev-&gt;jpeg.inst[inst_idx].ring_dec;
+	uint32_t reg_data = 0;
+
+	jpeg_v5_0_0_enable_power_gating(adev);
+
+	// enable dynamic power gating mode
+	reg_data = RREG32_SOC15(JPEG, inst_idx, regUVD_JPEG_POWER_STATUS);
+	reg_data |= UVD_JPEG_POWER_STATUS__JPEG_PG_MODE_MASK;
+	WREG32_SOC15(JPEG, inst_idx, regUVD_JPEG_POWER_STATUS, reg_data);
+
+	if (indirect)
+		adev-&gt;jpeg.inst[inst_idx].dpg_sram_curr_addr =
+			(uint32_t *)adev-&gt;jpeg.inst[inst_idx].dpg_sram_cpu_addr;
+
+	jpeg_engine_5_0_0_dpg_clock_gating_mode(adev, inst_idx, indirect);
+
+	/* MJPEG global tiling registers */
+	if (indirect)
+		ADD_SOC24_JPEG_TO_DPG_SRAM(inst_idx, vcnipJPEG_DEC_GFX10_ADDR_CONFIG,
+			adev-&gt;gfx.config.gb_addr_config, indirect);
+	else
+		WREG32_SOC24_JPEG_DPG_MODE(inst_idx, vcnipJPEG_DEC_GFX10_ADDR_CONFIG,
+			adev-&gt;gfx.config.gb_addr_config, 1);
+
+	/* enable System Interrupt for JRBC */
+	if (indirect)
+		ADD_SOC24_JPEG_TO_DPG_SRAM(inst_idx, vcnipJPEG_SYS_INT_EN,
+			JPEG_SYS_INT_EN__DJRBC0_MASK, indirect);
+	else
+		WREG32_SOC24_JPEG_DPG_MODE(inst_idx, vcnipJPEG_SYS_INT_EN,
+			JPEG_SYS_INT_EN__DJRBC0_MASK, 1);
+
+	if (indirect) {
+		/* add nop to workaround PSP size check */
+		ADD_SOC24_JPEG_TO_DPG_SRAM(inst_idx, vcnipUVD_NO_OP, 0, indirect);
+
+		amdgpu_jpeg_psp_update_sram(adev, inst_idx, 0);
+	}
+
+	WREG32_SOC15(VCN, 0, regVCN_JPEG_DB_CTRL,
+		ring-&gt;doorbell_index &lt;&lt; VCN_JPEG_DB_CTRL__OFFSET__SHIFT |
+		VCN_JPEG_DB_CTRL__EN_MASK);
+
+	WREG32_SOC15(JPEG, inst_idx, regUVD_LMI_JRBC_RB_VMID, 0);
+	WREG32_SOC15(JPEG, inst_idx, regUVD_JRBC_RB_CNTL, (0x00000001L | 0x00000002L));
+	WREG32_SOC15(JPEG, inst_idx, regUVD_LMI_JRBC_RB_64BIT_BAR_LOW,
+		lower_32_bits(ring-&gt;gpu_addr));
+	WREG32_SOC15(JPEG, inst_idx, regUVD_LMI_JRBC_RB_64BIT_BAR_HIGH,
+		upper_32_bits(ring-&gt;gpu_addr));
+	WREG32_SOC15(JPEG, inst_idx, regUVD_JRBC_RB_RPTR, 0);
+	WREG32_SOC15(JPEG, inst_idx, regUVD_JRBC_RB_WPTR, 0);
+	WREG32_SOC15(JPEG, inst_idx, regUVD_JRBC_RB_CNTL, 0x00000002L);
+	WREG32_SOC15(JPEG, inst_idx, regUVD_JRBC_RB_SIZE, ring-&gt;ring_size / 4);
+	ring-&gt;wptr = RREG32_SOC15(JPEG, inst_idx, regUVD_JRBC_RB_WPTR);
+
+	return 0;
+}
+
+/**
+ * jpeg_v5_0_0_stop_dpg_mode - Jpeg stop with dpg mode
+ *
+ * @adev: amdgpu_device pointer
+ * @inst_idx: instance number index
+ *
+ * Stop JPEG block with dpg mode
+ */
+static void jpeg_v5_0_0_stop_dpg_mode(struct amdgpu_device *adev, int inst_idx)
+{
+	uint32_t reg_data = 0;
+
+	reg_data = RREG32_SOC15(JPEG, inst_idx, regUVD_JPEG_POWER_STATUS);
+	reg_data &#38;= ~UVD_JPEG_POWER_STATUS__JPEG_PG_MODE_MASK;
+	WREG32_SOC15(JPEG, inst_idx, regUVD_JPEG_POWER_STATUS, reg_data);
+}
+
</span> /**
  * jpeg_v5_0_0_start - start JPEG block
  *
<span
class="hunk">@@ -288,8 +404,13 @@ static int jpeg_v5_0_0_start(struct amdgpu_device *adev)
</span> 	if (adev-&gt;pm.dpm_enabled)
 		amdgpu_dpm_enable_jpeg(adev, true);
 
<span
class="add">+	if (adev-&gt;pg_flags &#38; AMD_PG_SUPPORT_JPEG_DPG) {
+		r = jpeg_v5_0_0_start_dpg_mode(adev, 0, adev-&gt;jpeg.indirect_sram);
+		return r;
+	}
+
</span> 	/* disable power gating */
<span
class="del">-	r = jpeg_v5_0_0_disable_static_power_gating(adev);
</span><span
class="add">+	r = jpeg_v5_0_0_disable_power_gating(adev);
</span> 	if (r)
 		return r;
 
<span
class="hunk">@@ -300,7 +421,6 @@ static int jpeg_v5_0_0_start(struct amdgpu_device *adev)
</span> 	WREG32_SOC15(JPEG, 0, regJPEG_DEC_GFX10_ADDR_CONFIG,
 		adev-&gt;gfx.config.gb_addr_config);
 
<span
class="del">-
</span> 	/* enable JMI channel */
 	WREG32_P(SOC15_REG_OFFSET(JPEG, 0, regUVD_JMI_CNTL), 0,
 		~UVD_JMI_CNTL__SOFT_RESET_MASK);
<span
class="hunk">@@ -340,17 +460,22 @@ static int jpeg_v5_0_0_stop(struct amdgpu_device *adev)
</span> {
 	int r;
 
<span
class="del">-	/* reset JMI */
-	WREG32_P(SOC15_REG_OFFSET(JPEG, 0, regUVD_JMI_CNTL),
-		UVD_JMI_CNTL__SOFT_RESET_MASK,
-		~UVD_JMI_CNTL__SOFT_RESET_MASK);
</span><span
class="add">+	if (adev-&gt;pg_flags &#38; AMD_PG_SUPPORT_JPEG_DPG) {
+		jpeg_v5_0_0_stop_dpg_mode(adev, 0);
+	} else {
</span> 
<span
class="del">-	jpeg_v5_0_0_enable_clock_gating(adev);
</span><span
class="add">+		/* reset JMI */
+		WREG32_P(SOC15_REG_OFFSET(JPEG, 0, regUVD_JMI_CNTL),
+			UVD_JMI_CNTL__SOFT_RESET_MASK,
+			~UVD_JMI_CNTL__SOFT_RESET_MASK);
</span> 
<span
class="del">-	/* enable power gating */
-	r = jpeg_v5_0_0_enable_static_power_gating(adev);
-	if (r)
-		return r;
</span><span
class="add">+		jpeg_v5_0_0_enable_clock_gating(adev);
+
+		/* enable power gating */
+		r = jpeg_v5_0_0_enable_power_gating(adev);
+		if (r)
+			return r;
+	}
</span> 
 	if (adev-&gt;pm.dpm_enabled)
 		amdgpu_dpm_enable_jpeg(adev, false);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/jpeg_v5_0_0.h b/drivers/gpu/drm/amd/amdgpu/jpeg_v5_0_0.h
index bd348336b215..5abb96159814 100644
--- a/drivers/gpu/drm/amd/amdgpu/jpeg_v5_0_0.h
+++ b/drivers/gpu/drm/amd/amdgpu/jpeg_v5_0_0.h
</span><span
class="hunk">@@ -24,6 +24,12 @@
</span> #ifndef __JPEG_V5_0_0_H__
 #define __JPEG_V5_0_0_H__
 
<span
class="add">+#define vcnipJPEG_CGC_GATE                                 0x4160
+#define vcnipJPEG_CGC_CTRL                                 0x4161
+#define vcnipJPEG_SYS_INT_EN                               0x4141
+#define vcnipUVD_NO_OP                                     0x0029
+#define vcnipJPEG_DEC_GFX10_ADDR_CONFIG                    0x404A
+
</span> extern const struct amdgpu_ip_block_version jpeg_v5_0_0_ip_block;
 
 #endif /* __JPEG_V5_0_0_H__ */
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/soc24.c b/drivers/gpu/drm/amd/amdgpu/soc24.c
index a15673e2dc99..d27fb4ea6612 100644
--- a/drivers/gpu/drm/amd/amdgpu/soc24.c
+++ b/drivers/gpu/drm/amd/amdgpu/soc24.c
</span><span
class="hunk">@@ -428,6 +428,7 @@ static int soc24_common_early_init(void *handle)
</span> 
 		adev-&gt;pg_flags = AMD_PG_SUPPORT_VCN |
 			AMD_PG_SUPPORT_JPEG |
<span
class="add">+			AMD_PG_SUPPORT_JPEG_DPG |
</span> 			AMD_PG_SUPPORT_VCN_DPG;
 		adev-&gt;external_rev_id = adev-&gt;rev_id + 0x50;
 		break;
-- 
2.45.1

</pre></div></content></entry><entry><author><name>Wu Hoi Pok</name><email>wuhoipok@gmail.com</email></author><title
type="html">[PATCH v3 7/7] drm/radeon: rdev-&gt;ddev to rdev_to_drm(rdev) 6</title><updated>2024-06-25T07:06:28Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624151122.23724-8-wuhoipok@gmail.com/"/><id>urn:uuid:8fee769b-65b0-60f7-10d4-5c974c10c457</id><thr:in-reply-to
ref="urn:uuid:2852997b-2246-744b-58b7-40f63f8a6232"
href="http://lore.kernel.org/amd-gfx/20240624151122.23724-1-wuhoipok@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Please refer to patch 1.

Signed-off-by: Wu Hoi Pok &lt;wuhoipok@gmail.com&gt;
---
 drivers/gpu/drm/radeon/rs400.c |  6 +++---
 drivers/gpu/drm/radeon/rs600.c | 14 +++++++-------
 drivers/gpu/drm/radeon/rs690.c |  2 +-
 drivers/gpu/drm/radeon/rv515.c |  4 ++--
 drivers/gpu/drm/radeon/rv770.c |  2 +-
 drivers/gpu/drm/radeon/si.c    |  4 ++--
 6 files <a href="http://lore.kernel.org/amd-gfx/20240624151122.23724-8-wuhoipok@gmail.com/#related">changed</a>, 16 insertions(+), 16 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/radeon/rs400.c b/drivers/gpu/drm/radeon/rs400.c
index d4d1501e6576..d6c18fd740ec 100644
--- a/drivers/gpu/drm/radeon/rs400.c
+++ b/drivers/gpu/drm/radeon/rs400.c
</span><span
class="hunk">@@ -379,7 +379,7 @@ DEFINE_SHOW_ATTRIBUTE(rs400_debugfs_gart_info);
</span> static void rs400_debugfs_pcie_gart_info_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;rs400_gart_info&#34;, 0444, root, rdev,
 			    &#38;rs400_debugfs_gart_info_fops);
<span
class="hunk">@@ -474,7 +474,7 @@ int rs400_resume(struct radeon_device *rdev)
</span> 			RREG32(R_0007C0_CP_STAT));
 	}
 	/* post */
<span
class="del">-	radeon_combios_asic_init(rdev-&gt;ddev);
</span><span
class="add">+	radeon_combios_asic_init(rdev_to_drm(rdev));
</span> 	/* Resume clock after posting */
 	r300_clock_startup(rdev);
 	/* Initialize surface registers */
<span
class="hunk">@@ -552,7 +552,7 @@ int rs400_init(struct radeon_device *rdev)
</span> 		return -EINVAL;
 
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* initialize memory controller */
 	rs400_mc_init(rdev);
 	/* Fence driver */
<span
class="head">diff --git a/drivers/gpu/drm/radeon/rs600.c b/drivers/gpu/drm/radeon/rs600.c
index 5c162778899b..88c8e91ea651 100644
--- a/drivers/gpu/drm/radeon/rs600.c
+++ b/drivers/gpu/drm/radeon/rs600.c
</span><span
class="hunk">@@ -321,7 +321,7 @@ void rs600_pm_misc(struct radeon_device *rdev)
</span> 
 void rs600_pm_prepare(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
 	u32 tmp;
<span
class="hunk">@@ -339,7 +339,7 @@ void rs600_pm_prepare(struct radeon_device *rdev)
</span> 
 void rs600_pm_finish(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
 	u32 tmp;
<span
class="hunk">@@ -408,7 +408,7 @@ void rs600_hpd_set_polarity(struct radeon_device *rdev,
</span> 
 void rs600_hpd_init(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_connector *connector;
 	unsigned enable = 0;
 
<span
class="hunk">@@ -435,7 +435,7 @@ void rs600_hpd_init(struct radeon_device *rdev)
</span> 
 void rs600_hpd_fini(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_connector *connector;
 	unsigned disable = 0;
 
<span
class="hunk">@@ -797,7 +797,7 @@ int rs600_irq_process(struct radeon_device *rdev)
</span> 		/* Vertical blank interrupts */
 		if (G_007EDC_LB_D1_VBLANK_INTERRUPT(rdev-&gt;irq.stat_regs.r500.disp_int)) {
 			if (rdev-&gt;irq.crtc_vblank_int[0]) {
<span
class="del">-				drm_handle_vblank(rdev-&gt;ddev, 0);
</span><span
class="add">+				drm_handle_vblank(rdev_to_drm(rdev), 0);
</span> 				rdev-&gt;pm.vblank_sync = true;
 				wake_up(&#38;rdev-&gt;irq.vblank_queue);
 			}
<span
class="hunk">@@ -806,7 +806,7 @@ int rs600_irq_process(struct radeon_device *rdev)
</span> 		}
 		if (G_007EDC_LB_D2_VBLANK_INTERRUPT(rdev-&gt;irq.stat_regs.r500.disp_int)) {
 			if (rdev-&gt;irq.crtc_vblank_int[1]) {
<span
class="del">-				drm_handle_vblank(rdev-&gt;ddev, 1);
</span><span
class="add">+				drm_handle_vblank(rdev_to_drm(rdev), 1);
</span> 				rdev-&gt;pm.vblank_sync = true;
 				wake_up(&#38;rdev-&gt;irq.vblank_queue);
 			}
<span
class="hunk">@@ -1133,7 +1133,7 @@ int rs600_init(struct radeon_device *rdev)
</span> 		return -EINVAL;
 
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* initialize memory controller */
 	rs600_mc_init(rdev);
 	r100_debugfs_rbbm_init(rdev);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/rs690.c b/drivers/gpu/drm/radeon/rs690.c
index 14fb0819b8c1..016eb4992803 100644
--- a/drivers/gpu/drm/radeon/rs690.c
+++ b/drivers/gpu/drm/radeon/rs690.c
</span><span
class="hunk">@@ -845,7 +845,7 @@ int rs690_init(struct radeon_device *rdev)
</span> 		return -EINVAL;
 
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* initialize memory controller */
 	rs690_mc_init(rdev);
 	rv515_debugfs(rdev);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/rv515.c b/drivers/gpu/drm/radeon/rv515.c
index bbc6ccabf788..1b4dfb645585 100644
--- a/drivers/gpu/drm/radeon/rv515.c
+++ b/drivers/gpu/drm/radeon/rv515.c
</span><span
class="hunk">@@ -255,7 +255,7 @@ DEFINE_SHOW_ATTRIBUTE(rv515_debugfs_ga_info);
</span> void rv515_debugfs(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;rv515_pipes_info&#34;, 0444, root, rdev,
 			    &#38;rv515_debugfs_pipes_info_fops);
<span
class="hunk">@@ -636,7 +636,7 @@ int rv515_init(struct radeon_device *rdev)
</span> 	if (radeon_boot_test_post_card(rdev) == false)
 		return -EINVAL;
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* initialize AGP */
 	if (rdev-&gt;flags &#38; RADEON_IS_AGP) {
 		r = radeon_agp_init(rdev);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/rv770.c b/drivers/gpu/drm/radeon/rv770.c
index 9ce12fa3c356..7d4b0bf59109 100644
--- a/drivers/gpu/drm/radeon/rv770.c
+++ b/drivers/gpu/drm/radeon/rv770.c
</span><span
class="hunk">@@ -1935,7 +1935,7 @@ int rv770_init(struct radeon_device *rdev)
</span> 	/* Initialize surface registers */
 	radeon_surface_init(rdev);
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* Fence driver */
 	radeon_fence_driver_init(rdev);
 	/* initialize AGP */
<span
class="head">diff --git a/drivers/gpu/drm/radeon/si.c b/drivers/gpu/drm/radeon/si.c
index 15759c8ca5b7..6c95575ce109 100644
--- a/drivers/gpu/drm/radeon/si.c
+++ b/drivers/gpu/drm/radeon/si.c
</span><span
class="hunk">@@ -6277,7 +6277,7 @@ int si_irq_process(struct radeon_device *rdev)
</span> 				event_name = &#34;vblank&#34;;
 
 				if (rdev-&gt;irq.crtc_vblank_int[crtc_idx]) {
<span
class="del">-					drm_handle_vblank(rdev-&gt;ddev, crtc_idx);
</span><span
class="add">+					drm_handle_vblank(rdev_to_drm(rdev), crtc_idx);
</span> 					rdev-&gt;pm.vblank_sync = true;
 					wake_up(&#38;rdev-&gt;irq.vblank_queue);
 				}
<span
class="hunk">@@ -6839,7 +6839,7 @@ int si_init(struct radeon_device *rdev)
</span> 	/* Initialize surface registers */
 	radeon_surface_init(rdev);
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 
 	/* Fence driver */
 	radeon_fence_driver_init(rdev);
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Wu Hoi Pok</name><email>wuhoipok@gmail.com</email></author><title
type="html">[PATCH v3 6/7] drm/radeon: rdev-&gt;ddev to rdev_to_drm(rdev) 5</title><updated>2024-06-25T07:06:26Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624151122.23724-7-wuhoipok@gmail.com/"/><id>urn:uuid:7e864538-313d-e710-f148-60209f8159b3</id><thr:in-reply-to
ref="urn:uuid:2852997b-2246-744b-58b7-40f63f8a6232"
href="http://lore.kernel.org/amd-gfx/20240624151122.23724-1-wuhoipok@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Please refer to patch 1.

Signed-off-by: Wu Hoi Pok &lt;wuhoipok@gmail.com&gt;
---
 drivers/gpu/drm/radeon/radeon_ib.c      |  2 +-
 drivers/gpu/drm/radeon/radeon_irq_kms.c | 12 ++++++------
 drivers/gpu/drm/radeon/radeon_object.c  |  2 +-
 drivers/gpu/drm/radeon/radeon_pm.c      | 20 ++++++++++----------
 drivers/gpu/drm/radeon/radeon_ring.c    |  2 +-
 drivers/gpu/drm/radeon/radeon_ttm.c     |  6 +++---
 6 files <a href="http://lore.kernel.org/amd-gfx/20240624151122.23724-7-wuhoipok@gmail.com/#related">changed</a>, 22 insertions(+), 22 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_ib.c b/drivers/gpu/drm/radeon/radeon_ib.c
index 63d914f3414d..1aa41cc3f991 100644
--- a/drivers/gpu/drm/radeon/radeon_ib.c
+++ b/drivers/gpu/drm/radeon/radeon_ib.c
</span><span
class="hunk">@@ -309,7 +309,7 @@ DEFINE_SHOW_ATTRIBUTE(radeon_debugfs_sa_info);
</span> static void radeon_debugfs_sa_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;radeon_sa_info&#34;, 0444, root, rdev,
 			    &#38;radeon_debugfs_sa_info_fops);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_irq_kms.c b/drivers/gpu/drm/radeon/radeon_irq_kms.c
index c4dda908666c..9961251b44ba 100644
--- a/drivers/gpu/drm/radeon/radeon_irq_kms.c
+++ b/drivers/gpu/drm/radeon/radeon_irq_kms.c
</span><span
class="hunk">@@ -80,7 +80,7 @@ static void radeon_hotplug_work_func(struct work_struct *work)
</span> {
 	struct radeon_device *rdev = container_of(work, struct radeon_device,
 						  hotplug_work.work);
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_mode_config *mode_config = &#38;dev-&gt;mode_config;
 	struct drm_connector *connector;
 
<span
class="hunk">@@ -101,7 +101,7 @@ static void radeon_dp_work_func(struct work_struct *work)
</span> {
 	struct radeon_device *rdev = container_of(work, struct radeon_device,
 						  dp_work);
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_mode_config *mode_config = &#38;dev-&gt;mode_config;
 	struct drm_connector *connector;
 
<span
class="hunk">@@ -197,7 +197,7 @@ static void radeon_driver_irq_uninstall_kms(struct drm_device *dev)
</span> 
 static int radeon_irq_install(struct radeon_device *rdev, int irq)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	int ret;
 
 	if (irq == IRQ_NOTCONNECTED)
<span
class="hunk">@@ -218,7 +218,7 @@ static int radeon_irq_install(struct radeon_device *rdev, int irq)
</span> 
 static void radeon_irq_uninstall(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct pci_dev *pdev = to_pci_dev(dev-&gt;dev);
 
 	radeon_driver_irq_uninstall_kms(dev);
<span
class="hunk">@@ -322,9 +322,9 @@ int radeon_irq_kms_init(struct radeon_device *rdev)
</span> 	spin_lock_init(&#38;rdev-&gt;irq.lock);
 
 	/* Disable vblank irqs aggressively for power-saving */
<span
class="del">-	rdev-&gt;ddev-&gt;vblank_disable_immediate = true;
</span><span
class="add">+	rdev_to_drm(rdev)-&gt;vblank_disable_immediate = true;
</span> 
<span
class="del">-	r = drm_vblank_init(rdev-&gt;ddev, rdev-&gt;num_crtc);
</span><span
class="add">+	r = drm_vblank_init(rdev_to_drm(rdev), rdev-&gt;num_crtc);
</span> 	if (r) {
 		return r;
 	}
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_object.c b/drivers/gpu/drm/radeon/radeon_object.c
index a955f8a2f7fe..450ff7daa46c 100644
--- a/drivers/gpu/drm/radeon/radeon_object.c
+++ b/drivers/gpu/drm/radeon/radeon_object.c
</span><span
class="hunk">@@ -150,7 +150,7 @@ int radeon_bo_create(struct radeon_device *rdev,
</span> 	bo = kzalloc(sizeof(struct radeon_bo), GFP_KERNEL);
 	if (bo == NULL)
 		return -ENOMEM;
<span
class="del">-	drm_gem_private_object_init(rdev-&gt;ddev, &#38;bo-&gt;tbo.base, size);
</span><span
class="add">+	drm_gem_private_object_init(rdev_to_drm(rdev), &#38;bo-&gt;tbo.base, size);
</span> 	bo-&gt;rdev = rdev;
 	bo-&gt;surface_reg = -1;
 	INIT_LIST_HEAD(&#38;bo-&gt;list);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_pm.c b/drivers/gpu/drm/radeon/radeon_pm.c
index 2d9d9f46f243..b4fb7e70320b 100644
--- a/drivers/gpu/drm/radeon/radeon_pm.c
+++ b/drivers/gpu/drm/radeon/radeon_pm.c
</span><span
class="hunk">@@ -282,7 +282,7 @@ static void radeon_pm_set_clocks(struct radeon_device *rdev)
</span> 
 	if (rdev-&gt;irq.installed) {
 		i = 0;
<span
class="del">-		drm_for_each_crtc(crtc, rdev-&gt;ddev) {
</span><span
class="add">+		drm_for_each_crtc(crtc, rdev_to_drm(rdev)) {
</span> 			if (rdev-&gt;pm.active_crtcs &#38; (1 &lt;&lt; i)) {
 				/* This can fail if a modeset is in progress */
 				if (drm_crtc_vblank_get(crtc) == 0)
<span
class="hunk">@@ -299,7 +299,7 @@ static void radeon_pm_set_clocks(struct radeon_device *rdev)
</span> 
 	if (rdev-&gt;irq.installed) {
 		i = 0;
<span
class="del">-		drm_for_each_crtc(crtc, rdev-&gt;ddev) {
</span><span
class="add">+		drm_for_each_crtc(crtc, rdev_to_drm(rdev)) {
</span> 			if (rdev-&gt;pm.req_vblank &#38; (1 &lt;&lt; i)) {
 				rdev-&gt;pm.req_vblank &#38;= ~(1 &lt;&lt; i);
 				drm_crtc_vblank_put(crtc);
<span
class="hunk">@@ -671,7 +671,7 @@ static ssize_t radeon_hwmon_show_temp(struct device *dev,
</span> 				      char *buf)
 {
 	struct radeon_device *rdev = dev_get_drvdata(dev);
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	int temp;
 
 	/* Can&#39;t get temperature when the card is off */
<span
class="hunk">@@ -715,7 +715,7 @@ static ssize_t radeon_hwmon_show_sclk(struct device *dev,
</span> 				      struct device_attribute *attr, char *buf)
 {
 	struct radeon_device *rdev = dev_get_drvdata(dev);
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	u32 sclk = 0;
 
 	/* Can&#39;t get clock frequency when the card is off */
<span
class="hunk">@@ -740,7 +740,7 @@ static ssize_t radeon_hwmon_show_vddc(struct device *dev,
</span> 				      struct device_attribute *attr, char *buf)
 {
 	struct radeon_device *rdev = dev_get_drvdata(dev);
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	u16 vddc = 0;
 
 	/* Can&#39;t get vddc when the card is off */
<span
class="hunk">@@ -1692,7 +1692,7 @@ void radeon_pm_fini(struct radeon_device *rdev)
</span> 
 static void radeon_pm_compute_clocks_old(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
 
<span
class="hunk">@@ -1765,7 +1765,7 @@ static void radeon_pm_compute_clocks_old(struct radeon_device *rdev)
</span> 
 static void radeon_pm_compute_clocks_dpm(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
 	struct radeon_connector *radeon_connector;
<span
class="hunk">@@ -1826,7 +1826,7 @@ static bool radeon_pm_in_vbl(struct radeon_device *rdev)
</span> 	 */
 	for (crtc = 0; (crtc &lt; rdev-&gt;num_crtc) &#38;&#38; in_vbl; crtc++) {
 		if (rdev-&gt;pm.active_crtcs &#38; (1 &lt;&lt; crtc)) {
<span
class="del">-			vbl_status = radeon_get_crtc_scanoutpos(rdev-&gt;ddev,
</span><span
class="add">+			vbl_status = radeon_get_crtc_scanoutpos(rdev_to_drm(rdev),
</span> 								crtc,
 								USE_REAL_VBLANKSTART,
 								&#38;vpos, &#38;hpos, NULL, NULL,
<span
class="hunk">@@ -1918,7 +1918,7 @@ static void radeon_dynpm_idle_work_handler(struct work_struct *work)
</span> static int radeon_debugfs_pm_info_show(struct seq_file *m, void *unused)
 {
 	struct radeon_device *rdev = m-&gt;private;
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 
 	if  ((rdev-&gt;flags &#38; RADEON_IS_PX) &#38;&#38;
 	     (ddev-&gt;switch_power_state != DRM_SWITCH_POWER_ON)) {
<span
class="hunk">@@ -1955,7 +1955,7 @@ DEFINE_SHOW_ATTRIBUTE(radeon_debugfs_pm_info);
</span> static void radeon_debugfs_pm_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;radeon_pm_info&#34;, 0444, root, rdev,
 			    &#38;radeon_debugfs_pm_info_fops);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_ring.c b/drivers/gpu/drm/radeon/radeon_ring.c
index 8d1d458286a8..581ae20c46e4 100644
--- a/drivers/gpu/drm/radeon/radeon_ring.c
+++ b/drivers/gpu/drm/radeon/radeon_ring.c
</span><span
class="hunk">@@ -550,7 +550,7 @@ static void radeon_debugfs_ring_init(struct radeon_device *rdev, struct radeon_r
</span> {
 #if defined(CONFIG_DEBUG_FS)
 	const char *ring_name = radeon_debugfs_ring_idx_to_name(ring-&gt;idx);
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	if (ring_name)
 		debugfs_create_file(ring_name, 0444, root, ring,
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_ttm.c b/drivers/gpu/drm/radeon/radeon_ttm.c
index 5c65b6dfb99a..69d0c12fa419 100644
--- a/drivers/gpu/drm/radeon/radeon_ttm.c
+++ b/drivers/gpu/drm/radeon/radeon_ttm.c
</span><span
class="hunk">@@ -682,8 +682,8 @@ int radeon_ttm_init(struct radeon_device *rdev)
</span> 
 	/* No others user of address space so set it to 0 */
 	r = ttm_device_init(&#38;rdev-&gt;mman.bdev, &#38;radeon_bo_driver, rdev-&gt;dev,
<span
class="del">-			       rdev-&gt;ddev-&gt;anon_inode-&gt;i_mapping,
-			       rdev-&gt;ddev-&gt;vma_offset_manager,
</span><span
class="add">+			       rdev_to_drm(rdev)-&gt;anon_inode-&gt;i_mapping,
+			       rdev_to_drm(rdev)-&gt;vma_offset_manager,
</span> 			       rdev-&gt;need_swiotlb,
 			       dma_addressing_limited(&#38;rdev-&gt;pdev-&gt;dev));
 	if (r) {
<span
class="hunk">@@ -890,7 +890,7 @@ static const struct file_operations radeon_ttm_gtt_fops = {
</span> static void radeon_ttm_debugfs_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct drm_minor *minor = rdev-&gt;ddev-&gt;primary;
</span><span
class="add">+	struct drm_minor *minor = rdev_to_drm(rdev)-&gt;primary;
</span> 	struct dentry *root = minor-&gt;debugfs_root;
 
 	debugfs_create_file(&#34;radeon_vram&#34;, 0444, root, rdev,
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Wu Hoi Pok</name><email>wuhoipok@gmail.com</email></author><title
type="html">[PATCH v3 5/7] drm/radeon: rdev-&gt;ddev to rdev_to_drm(rdev) 4</title><updated>2024-06-25T07:06:35Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624151122.23724-6-wuhoipok@gmail.com/"/><id>urn:uuid:ce441ac0-2222-44cf-f4db-749a6ebe53b7</id><thr:in-reply-to
ref="urn:uuid:2852997b-2246-744b-58b7-40f63f8a6232"
href="http://lore.kernel.org/amd-gfx/20240624151122.23724-1-wuhoipok@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Please refer to patch 1.

Signed-off-by: Wu Hoi Pok &lt;wuhoipok@gmail.com&gt;
---
 drivers/gpu/drm/radeon/radeon_device.c  | 19 +++----
 drivers/gpu/drm/radeon/radeon_display.c | 74 ++++++++++++-------------
 drivers/gpu/drm/radeon/radeon_fbdev.c   | 26 ++++-----
 drivers/gpu/drm/radeon/radeon_fence.c   |  8 +--
 drivers/gpu/drm/radeon/radeon_gem.c     |  2 +-
 drivers/gpu/drm/radeon/radeon_i2c.c     |  2 +-
 6 files <a href="http://lore.kernel.org/amd-gfx/20240624151122.23724-6-wuhoipok@gmail.com/#related">changed</a>, 63 insertions(+), 68 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c
index afbb3a80c0c6..127d8fd7f7cd 100644
--- a/drivers/gpu/drm/radeon/radeon_device.c
+++ b/drivers/gpu/drm/radeon/radeon_device.c
</span><span
class="hunk">@@ -760,7 +760,7 @@ bool radeon_boot_test_post_card(struct radeon_device *rdev)
</span> 		if (rdev-&gt;is_atom_bios)
 			atom_asic_init(rdev-&gt;mode_info.atom_context);
 		else
<span
class="del">-			radeon_combios_asic_init(rdev-&gt;ddev);
</span><span
class="add">+			radeon_combios_asic_init(rdev_to_drm(rdev));
</span> 		return true;
 	} else {
 		dev_err(rdev-&gt;dev, &#34;Card not posted and no BIOS - ignoring\n&#34;);
<span
class="hunk">@@ -980,7 +980,7 @@ int radeon_atombios_init(struct radeon_device *rdev)
</span> 		return -ENOMEM;
 
 	rdev-&gt;mode_info.atom_card_info = atom_card_info;
<span
class="del">-	atom_card_info-&gt;dev = rdev-&gt;ddev;
</span><span
class="add">+	atom_card_info-&gt;dev = rdev_to_drm(rdev);
</span> 	atom_card_info-&gt;reg_read = cail_reg_read;
 	atom_card_info-&gt;reg_write = cail_reg_write;
 	/* needed for iio ops */
<span
class="hunk">@@ -1005,7 +1005,7 @@ int radeon_atombios_init(struct radeon_device *rdev)
</span> 
 	mutex_init(&#38;rdev-&gt;mode_info.atom_context-&gt;mutex);
 	mutex_init(&#38;rdev-&gt;mode_info.atom_context-&gt;scratch_mutex);
<span
class="del">-	radeon_atom_initialize_bios_scratch_regs(rdev-&gt;ddev);
</span><span
class="add">+	radeon_atom_initialize_bios_scratch_regs(rdev_to_drm(rdev));
</span> 	atom_allocate_fb_scratch(rdev-&gt;mode_info.atom_context);
 	return 0;
 }
<span
class="hunk">@@ -1049,7 +1049,7 @@ void radeon_atombios_fini(struct radeon_device *rdev)
</span>  */
 int radeon_combios_init(struct radeon_device *rdev)
 {
<span
class="del">-	radeon_combios_initialize_bios_scratch_regs(rdev-&gt;ddev);
</span><span
class="add">+	radeon_combios_initialize_bios_scratch_regs(rdev_to_drm(rdev));
</span> 	return 0;
 }
 
<span
class="hunk">@@ -1267,8 +1267,6 @@ static const struct vga_switcheroo_client_ops radeon_switcheroo_ops = {
</span>  * radeon_device_init - initialize the driver
  *
  * @rdev: radeon_device pointer
<span
class="del">- * @ddev: drm dev pointer
- * @pdev: pci dev pointer
</span>  * @flags: driver flags
  *
  * Initializes the driver info and hw (all asics).
<span
class="hunk">@@ -1276,18 +1274,15 @@ static const struct vga_switcheroo_client_ops radeon_switcheroo_ops = {
</span>  * Called at driver startup.
  */
 int radeon_device_init(struct radeon_device *rdev,
<span
class="del">-		       struct drm_device *ddev,
-		       struct pci_dev *pdev,
</span> 		       uint32_t flags)
 {
<span
class="add">+	struct pci_dev *pdev = rdev-&gt;pdev;
+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	int r, i;
 	int dma_bits;
 	bool runtime = false;
 
 	rdev-&gt;shutdown = false;
<span
class="del">-	rdev-&gt;dev = &#38;pdev-&gt;dev;
-	rdev-&gt;ddev = ddev;
-	rdev-&gt;pdev = pdev;
</span> 	rdev-&gt;flags = flags;
 	rdev-&gt;family = flags &#38; RADEON_FAMILY_MASK;
 	rdev-&gt;is_atom_bios = false;
<span
class="hunk">@@ -1847,7 +1842,7 @@ int radeon_gpu_reset(struct radeon_device *rdev)
</span> 
 	downgrade_write(&#38;rdev-&gt;exclusive_lock);
 
<span
class="del">-	drm_helper_resume_force_mode(rdev-&gt;ddev);
</span><span
class="add">+	drm_helper_resume_force_mode(rdev_to_drm(rdev));
</span> 
 	/* set the power state here in case we are a PX system or headless */
 	if ((rdev-&gt;pm.pm_method == PM_METHOD_DPM) &#38;&#38; rdev-&gt;pm.dpm_enabled)
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_display.c b/drivers/gpu/drm/radeon/radeon_display.c
index 843383f7237f..10fd58f400bc 100644
--- a/drivers/gpu/drm/radeon/radeon_display.c
+++ b/drivers/gpu/drm/radeon/radeon_display.c
</span><span
class="hunk">@@ -302,13 +302,13 @@ void radeon_crtc_handle_vblank(struct radeon_device *rdev, int crtc_id)
</span> 	if ((radeon_use_pflipirq == 2) &#38;&#38; ASIC_IS_DCE4(rdev))
 		return;
 
<span
class="del">-	spin_lock_irqsave(&#38;rdev-&gt;ddev-&gt;event_lock, flags);
</span><span
class="add">+	spin_lock_irqsave(&#38;rdev_to_drm(rdev)-&gt;event_lock, flags);
</span> 	if (radeon_crtc-&gt;flip_status != RADEON_FLIP_SUBMITTED) {
 		DRM_DEBUG_DRIVER(&#34;radeon_crtc-&gt;flip_status = %d != &#34;
 				 &#34;RADEON_FLIP_SUBMITTED(%d)\n&#34;,
 				 radeon_crtc-&gt;flip_status,
 				 RADEON_FLIP_SUBMITTED);
<span
class="del">-		spin_unlock_irqrestore(&#38;rdev-&gt;ddev-&gt;event_lock, flags);
</span><span
class="add">+		spin_unlock_irqrestore(&#38;rdev_to_drm(rdev)-&gt;event_lock, flags);
</span> 		return;
 	}
 
<span
class="hunk">@@ -334,7 +334,7 @@ void radeon_crtc_handle_vblank(struct radeon_device *rdev, int crtc_id)
</span> 	 */
 	if (update_pending &#38;&#38;
 	    (DRM_SCANOUTPOS_VALID &#38;
<span
class="del">-	     radeon_get_crtc_scanoutpos(rdev-&gt;ddev, crtc_id,
</span><span
class="add">+	     radeon_get_crtc_scanoutpos(rdev_to_drm(rdev), crtc_id,
</span> 					GET_DISTANCE_TO_VBLANKSTART,
 					&#38;vpos, &#38;hpos, NULL, NULL,
 					&#38;rdev-&gt;mode_info.crtcs[crtc_id]-&gt;base.hwmode)) &#38;&#38;
<span
class="hunk">@@ -347,7 +347,7 @@ void radeon_crtc_handle_vblank(struct radeon_device *rdev, int crtc_id)
</span> 		 */
 		update_pending = 0;
 	}
<span
class="del">-	spin_unlock_irqrestore(&#38;rdev-&gt;ddev-&gt;event_lock, flags);
</span><span
class="add">+	spin_unlock_irqrestore(&#38;rdev_to_drm(rdev)-&gt;event_lock, flags);
</span> 	if (!update_pending)
 		radeon_crtc_handle_flip(rdev, crtc_id);
 }
<span
class="hunk">@@ -370,14 +370,14 @@ void radeon_crtc_handle_flip(struct radeon_device *rdev, int crtc_id)
</span> 	if (radeon_crtc == NULL)
 		return;
 
<span
class="del">-	spin_lock_irqsave(&#38;rdev-&gt;ddev-&gt;event_lock, flags);
</span><span
class="add">+	spin_lock_irqsave(&#38;rdev_to_drm(rdev)-&gt;event_lock, flags);
</span> 	work = radeon_crtc-&gt;flip_work;
 	if (radeon_crtc-&gt;flip_status != RADEON_FLIP_SUBMITTED) {
 		DRM_DEBUG_DRIVER(&#34;radeon_crtc-&gt;flip_status = %d != &#34;
 				 &#34;RADEON_FLIP_SUBMITTED(%d)\n&#34;,
 				 radeon_crtc-&gt;flip_status,
 				 RADEON_FLIP_SUBMITTED);
<span
class="del">-		spin_unlock_irqrestore(&#38;rdev-&gt;ddev-&gt;event_lock, flags);
</span><span
class="add">+		spin_unlock_irqrestore(&#38;rdev_to_drm(rdev)-&gt;event_lock, flags);
</span> 		return;
 	}
 
<span
class="hunk">@@ -389,7 +389,7 @@ void radeon_crtc_handle_flip(struct radeon_device *rdev, int crtc_id)
</span> 	if (work-&gt;event)
 		drm_crtc_send_vblank_event(&#38;radeon_crtc-&gt;base, work-&gt;event);
 
<span
class="del">-	spin_unlock_irqrestore(&#38;rdev-&gt;ddev-&gt;event_lock, flags);
</span><span
class="add">+	spin_unlock_irqrestore(&#38;rdev_to_drm(rdev)-&gt;event_lock, flags);
</span> 
 	drm_crtc_vblank_put(&#38;radeon_crtc-&gt;base);
 	radeon_irq_kms_pflip_irq_put(rdev, work-&gt;crtc_id);
<span
class="hunk">@@ -408,7 +408,7 @@ static void radeon_flip_work_func(struct work_struct *__work)
</span> 	struct radeon_flip_work *work =
 		container_of(__work, struct radeon_flip_work, flip_work);
 	struct radeon_device *rdev = work-&gt;rdev;
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct radeon_crtc *radeon_crtc = rdev-&gt;mode_info.crtcs[work-&gt;crtc_id];
 
 	struct drm_crtc *crtc = &#38;radeon_crtc-&gt;base;
<span
class="hunk">@@ -1401,7 +1401,7 @@ static int radeon_modeset_create_props(struct radeon_device *rdev)
</span> 
 	if (rdev-&gt;is_atom_bios) {
 		rdev-&gt;mode_info.coherent_mode_property =
<span
class="del">-			drm_property_create_range(rdev-&gt;ddev, 0 , &#34;coherent&#34;, 0, 1);
</span><span
class="add">+			drm_property_create_range(rdev_to_drm(rdev), 0, &#34;coherent&#34;, 0, 1);
</span> 		if (!rdev-&gt;mode_info.coherent_mode_property)
 			return -ENOMEM;
 	}
<span
class="hunk">@@ -1409,57 +1409,57 @@ static int radeon_modeset_create_props(struct radeon_device *rdev)
</span> 	if (!ASIC_IS_AVIVO(rdev)) {
 		sz = ARRAY_SIZE(radeon_tmds_pll_enum_list);
 		rdev-&gt;mode_info.tmds_pll_property =
<span
class="del">-			drm_property_create_enum(rdev-&gt;ddev, 0,
</span><span
class="add">+			drm_property_create_enum(rdev_to_drm(rdev), 0,
</span> 					    &#34;tmds_pll&#34;,
 					    radeon_tmds_pll_enum_list, sz);
 	}
 
 	rdev-&gt;mode_info.load_detect_property =
<span
class="del">-		drm_property_create_range(rdev-&gt;ddev, 0, &#34;load detection&#34;, 0, 1);
</span><span
class="add">+		drm_property_create_range(rdev_to_drm(rdev), 0, &#34;load detection&#34;, 0, 1);
</span> 	if (!rdev-&gt;mode_info.load_detect_property)
 		return -ENOMEM;
 
<span
class="del">-	drm_mode_create_scaling_mode_property(rdev-&gt;ddev);
</span><span
class="add">+	drm_mode_create_scaling_mode_property(rdev_to_drm(rdev));
</span> 
 	sz = ARRAY_SIZE(radeon_tv_std_enum_list);
 	rdev-&gt;mode_info.tv_std_property =
<span
class="del">-		drm_property_create_enum(rdev-&gt;ddev, 0,
</span><span
class="add">+		drm_property_create_enum(rdev_to_drm(rdev), 0,
</span> 				    &#34;tv standard&#34;,
 				    radeon_tv_std_enum_list, sz);
 
 	sz = ARRAY_SIZE(radeon_underscan_enum_list);
 	rdev-&gt;mode_info.underscan_property =
<span
class="del">-		drm_property_create_enum(rdev-&gt;ddev, 0,
</span><span
class="add">+		drm_property_create_enum(rdev_to_drm(rdev), 0,
</span> 				    &#34;underscan&#34;,
 				    radeon_underscan_enum_list, sz);
 
 	rdev-&gt;mode_info.underscan_hborder_property =
<span
class="del">-		drm_property_create_range(rdev-&gt;ddev, 0,
</span><span
class="add">+		drm_property_create_range(rdev_to_drm(rdev), 0,
</span> 					&#34;underscan hborder&#34;, 0, 128);
 	if (!rdev-&gt;mode_info.underscan_hborder_property)
 		return -ENOMEM;
 
 	rdev-&gt;mode_info.underscan_vborder_property =
<span
class="del">-		drm_property_create_range(rdev-&gt;ddev, 0,
</span><span
class="add">+		drm_property_create_range(rdev_to_drm(rdev), 0,
</span> 					&#34;underscan vborder&#34;, 0, 128);
 	if (!rdev-&gt;mode_info.underscan_vborder_property)
 		return -ENOMEM;
 
 	sz = ARRAY_SIZE(radeon_audio_enum_list);
 	rdev-&gt;mode_info.audio_property =
<span
class="del">-		drm_property_create_enum(rdev-&gt;ddev, 0,
</span><span
class="add">+		drm_property_create_enum(rdev_to_drm(rdev), 0,
</span> 					 &#34;audio&#34;,
 					 radeon_audio_enum_list, sz);
 
 	sz = ARRAY_SIZE(radeon_dither_enum_list);
 	rdev-&gt;mode_info.dither_property =
<span
class="del">-		drm_property_create_enum(rdev-&gt;ddev, 0,
</span><span
class="add">+		drm_property_create_enum(rdev_to_drm(rdev), 0,
</span> 					 &#34;dither&#34;,
 					 radeon_dither_enum_list, sz);
 
 	sz = ARRAY_SIZE(radeon_output_csc_enum_list);
 	rdev-&gt;mode_info.output_csc_property =
<span
class="del">-		drm_property_create_enum(rdev-&gt;ddev, 0,
</span><span
class="add">+		drm_property_create_enum(rdev_to_drm(rdev), 0,
</span> 					 &#34;output_csc&#34;,
 					 radeon_output_csc_enum_list, sz);
 
<span
class="hunk">@@ -1578,29 +1578,29 @@ int radeon_modeset_init(struct radeon_device *rdev)
</span> 	int i;
 	int ret;
 
<span
class="del">-	drm_mode_config_init(rdev-&gt;ddev);
</span><span
class="add">+	drm_mode_config_init(rdev_to_drm(rdev));
</span> 	rdev-&gt;mode_info.mode_config_initialized = true;
 
<span
class="del">-	rdev-&gt;ddev-&gt;mode_config.funcs = &#38;radeon_mode_funcs;
</span><span
class="add">+	rdev_to_drm(rdev)-&gt;mode_config.funcs = &#38;radeon_mode_funcs;
</span> 
 	if (radeon_use_pflipirq == 2 &#38;&#38; rdev-&gt;family &gt;= CHIP_R600)
<span
class="del">-		rdev-&gt;ddev-&gt;mode_config.async_page_flip = true;
</span><span
class="add">+		rdev_to_drm(rdev)-&gt;mode_config.async_page_flip = true;
</span> 
 	if (ASIC_IS_DCE5(rdev)) {
<span
class="del">-		rdev-&gt;ddev-&gt;mode_config.max_width = 16384;
-		rdev-&gt;ddev-&gt;mode_config.max_height = 16384;
</span><span
class="add">+		rdev_to_drm(rdev)-&gt;mode_config.max_width = 16384;
+		rdev_to_drm(rdev)-&gt;mode_config.max_height = 16384;
</span> 	} else if (ASIC_IS_AVIVO(rdev)) {
<span
class="del">-		rdev-&gt;ddev-&gt;mode_config.max_width = 8192;
-		rdev-&gt;ddev-&gt;mode_config.max_height = 8192;
</span><span
class="add">+		rdev_to_drm(rdev)-&gt;mode_config.max_width = 8192;
+		rdev_to_drm(rdev)-&gt;mode_config.max_height = 8192;
</span> 	} else {
<span
class="del">-		rdev-&gt;ddev-&gt;mode_config.max_width = 4096;
-		rdev-&gt;ddev-&gt;mode_config.max_height = 4096;
</span><span
class="add">+		rdev_to_drm(rdev)-&gt;mode_config.max_width = 4096;
+		rdev_to_drm(rdev)-&gt;mode_config.max_height = 4096;
</span> 	}
 
<span
class="del">-	rdev-&gt;ddev-&gt;mode_config.preferred_depth = 24;
-	rdev-&gt;ddev-&gt;mode_config.prefer_shadow = 1;
</span><span
class="add">+	rdev_to_drm(rdev)-&gt;mode_config.preferred_depth = 24;
+	rdev_to_drm(rdev)-&gt;mode_config.prefer_shadow = 1;
</span> 
<span
class="del">-	rdev-&gt;ddev-&gt;mode_config.fb_modifiers_not_supported = true;
</span><span
class="add">+	rdev_to_drm(rdev)-&gt;mode_config.fb_modifiers_not_supported = true;
</span> 
 	ret = radeon_modeset_create_props(rdev);
 	if (ret) {
<span
class="hunk">@@ -1618,11 +1618,11 @@ int radeon_modeset_init(struct radeon_device *rdev)
</span> 
 	/* allocate crtcs */
 	for (i = 0; i &lt; rdev-&gt;num_crtc; i++) {
<span
class="del">-		radeon_crtc_init(rdev-&gt;ddev, i);
</span><span
class="add">+		radeon_crtc_init(rdev_to_drm(rdev), i);
</span> 	}
 
 	/* okay we should have all the bios connectors */
<span
class="del">-	ret = radeon_setup_enc_conn(rdev-&gt;ddev);
</span><span
class="add">+	ret = radeon_setup_enc_conn(rdev_to_drm(rdev));
</span> 	if (!ret) {
 		return ret;
 	}
<span
class="hunk">@@ -1639,7 +1639,7 @@ int radeon_modeset_init(struct radeon_device *rdev)
</span> 	/* setup afmt */
 	radeon_afmt_init(rdev);
 
<span
class="del">-	drm_kms_helper_poll_init(rdev-&gt;ddev);
</span><span
class="add">+	drm_kms_helper_poll_init(rdev_to_drm(rdev));
</span> 
 	/* do pm late init */
 	ret = radeon_pm_late_init(rdev);
<span
class="hunk">@@ -1650,11 +1650,11 @@ int radeon_modeset_init(struct radeon_device *rdev)
</span> void radeon_modeset_fini(struct radeon_device *rdev)
 {
 	if (rdev-&gt;mode_info.mode_config_initialized) {
<span
class="del">-		drm_kms_helper_poll_fini(rdev-&gt;ddev);
</span><span
class="add">+		drm_kms_helper_poll_fini(rdev_to_drm(rdev));
</span> 		radeon_hpd_fini(rdev);
<span
class="del">-		drm_helper_force_disable_all(rdev-&gt;ddev);
</span><span
class="add">+		drm_helper_force_disable_all(rdev_to_drm(rdev));
</span> 		radeon_afmt_fini(rdev);
<span
class="del">-		drm_mode_config_cleanup(rdev-&gt;ddev);
</span><span
class="add">+		drm_mode_config_cleanup(rdev_to_drm(rdev));
</span> 		rdev-&gt;mode_info.mode_config_initialized = false;
 	}
 
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_fbdev.c b/drivers/gpu/drm/radeon/radeon_fbdev.c
index 02bf25759059..fb70de29545c 100644
--- a/drivers/gpu/drm/radeon/radeon_fbdev.c
+++ b/drivers/gpu/drm/radeon/radeon_fbdev.c
</span><span
class="hunk">@@ -67,7 +67,7 @@ static int radeon_fbdev_create_pinned_object(struct drm_fb_helper *fb_helper,
</span> 	int height = mode_cmd-&gt;height;
 	u32 cpp;
 
<span
class="del">-	info = drm_get_format_info(rdev-&gt;ddev, mode_cmd);
</span><span
class="add">+	info = drm_get_format_info(rdev_to_drm(rdev), mode_cmd);
</span> 	cpp = info-&gt;cpp[0];
 
 	/* need to align pitch with crtc limits */
<span
class="hunk">@@ -148,15 +148,15 @@ static int radeon_fbdev_fb_open(struct fb_info *info, int user)
</span> 	struct radeon_device *rdev = fb_helper-&gt;dev-&gt;dev_private;
 	int ret;
 
<span
class="del">-	ret = pm_runtime_get_sync(rdev-&gt;ddev-&gt;dev);
</span><span
class="add">+	ret = pm_runtime_get_sync(rdev_to_drm(rdev)-&gt;dev);
</span> 	if (ret &lt; 0 &#38;&#38; ret != -EACCES)
 		goto err_pm_runtime_mark_last_busy;
 
 	return 0;
 
 err_pm_runtime_mark_last_busy:
<span
class="del">-	pm_runtime_mark_last_busy(rdev-&gt;ddev-&gt;dev);
-	pm_runtime_put_autosuspend(rdev-&gt;ddev-&gt;dev);
</span><span
class="add">+	pm_runtime_mark_last_busy(rdev_to_drm(rdev)-&gt;dev);
+	pm_runtime_put_autosuspend(rdev_to_drm(rdev)-&gt;dev);
</span> 	return ret;
 }
 
<span
class="hunk">@@ -165,8 +165,8 @@ static int radeon_fbdev_fb_release(struct fb_info *info, int user)
</span> 	struct drm_fb_helper *fb_helper = info-&gt;par;
 	struct radeon_device *rdev = fb_helper-&gt;dev-&gt;dev_private;
 
<span
class="del">-	pm_runtime_mark_last_busy(rdev-&gt;ddev-&gt;dev);
-	pm_runtime_put_autosuspend(rdev-&gt;ddev-&gt;dev);
</span><span
class="add">+	pm_runtime_mark_last_busy(rdev_to_drm(rdev)-&gt;dev);
+	pm_runtime_put_autosuspend(rdev_to_drm(rdev)-&gt;dev);
</span> 
 	return 0;
 }
<span
class="hunk">@@ -236,7 +236,7 @@ static int radeon_fbdev_fb_helper_fb_probe(struct drm_fb_helper *fb_helper,
</span> 		ret = -ENOMEM;
 		goto err_radeon_fbdev_destroy_pinned_object;
 	}
<span
class="del">-	ret = radeon_framebuffer_init(rdev-&gt;ddev, fb, &#38;mode_cmd, gobj);
</span><span
class="add">+	ret = radeon_framebuffer_init(rdev_to_drm(rdev), fb, &#38;mode_cmd, gobj);
</span> 	if (ret) {
 		DRM_ERROR(&#34;failed to initialize framebuffer %d\n&#34;, ret);
 		goto err_kfree;
<span
class="hunk">@@ -374,12 +374,12 @@ void radeon_fbdev_setup(struct radeon_device *rdev)
</span> 	fb_helper = kzalloc(sizeof(*fb_helper), GFP_KERNEL);
 	if (!fb_helper)
 		return;
<span
class="del">-	drm_fb_helper_prepare(rdev-&gt;ddev, fb_helper, bpp_sel, &#38;radeon_fbdev_fb_helper_funcs);
</span><span
class="add">+	drm_fb_helper_prepare(rdev_to_drm(rdev), fb_helper, bpp_sel, &#38;radeon_fbdev_fb_helper_funcs);
</span> 
<span
class="del">-	ret = drm_client_init(rdev-&gt;ddev, &#38;fb_helper-&gt;client, &#34;radeon-fbdev&#34;,
</span><span
class="add">+	ret = drm_client_init(rdev_to_drm(rdev), &#38;fb_helper-&gt;client, &#34;radeon-fbdev&#34;,
</span> 			      &#38;radeon_fbdev_client_funcs);
 	if (ret) {
<span
class="del">-		drm_err(rdev-&gt;ddev, &#34;Failed to register client: %d\n&#34;, ret);
</span><span
class="add">+		drm_err(rdev_to_drm(rdev), &#34;Failed to register client: %d\n&#34;, ret);
</span> 		goto err_drm_client_init;
 	}
 
<span
class="hunk">@@ -394,13 +394,13 @@ void radeon_fbdev_setup(struct radeon_device *rdev)
</span> 
 void radeon_fbdev_set_suspend(struct radeon_device *rdev, int state)
 {
<span
class="del">-	if (rdev-&gt;ddev-&gt;fb_helper)
-		drm_fb_helper_set_suspend(rdev-&gt;ddev-&gt;fb_helper, state);
</span><span
class="add">+	if (rdev_to_drm(rdev)-&gt;fb_helper)
+		drm_fb_helper_set_suspend(rdev_to_drm(rdev)-&gt;fb_helper, state);
</span> }
 
 bool radeon_fbdev_robj_is_fb(struct radeon_device *rdev, struct radeon_bo *robj)
 {
<span
class="del">-	struct drm_fb_helper *fb_helper = rdev-&gt;ddev-&gt;fb_helper;
</span><span
class="add">+	struct drm_fb_helper *fb_helper = rdev_to_drm(rdev)-&gt;fb_helper;
</span> 	struct drm_gem_object *gobj;
 
 	if (!fb_helper)
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_fence.c b/drivers/gpu/drm/radeon/radeon_fence.c
index 4fb780d96f32..daff61586be5 100644
--- a/drivers/gpu/drm/radeon/radeon_fence.c
+++ b/drivers/gpu/drm/radeon/radeon_fence.c
</span><span
class="hunk">@@ -150,7 +150,7 @@ int radeon_fence_emit(struct radeon_device *rdev,
</span> 		       rdev-&gt;fence_context + ring,
 		       seq);
 	radeon_fence_ring_emit(rdev, ring, *fence);
<span
class="del">-	trace_radeon_fence_emit(rdev-&gt;ddev, ring, (*fence)-&gt;seq);
</span><span
class="add">+	trace_radeon_fence_emit(rdev_to_drm(rdev), ring, (*fence)-&gt;seq);
</span> 	radeon_fence_schedule_check(rdev, ring);
 	return 0;
 }
<span
class="hunk">@@ -489,7 +489,7 @@ static long radeon_fence_wait_seq_timeout(struct radeon_device *rdev,
</span> 		if (!target_seq[i])
 			continue;
 
<span
class="del">-		trace_radeon_fence_wait_begin(rdev-&gt;ddev, i, target_seq[i]);
</span><span
class="add">+		trace_radeon_fence_wait_begin(rdev_to_drm(rdev), i, target_seq[i]);
</span> 		radeon_irq_kms_sw_irq_get(rdev, i);
 	}
 
<span
class="hunk">@@ -511,7 +511,7 @@ static long radeon_fence_wait_seq_timeout(struct radeon_device *rdev,
</span> 			continue;
 
 		radeon_irq_kms_sw_irq_put(rdev, i);
<span
class="del">-		trace_radeon_fence_wait_end(rdev-&gt;ddev, i, target_seq[i]);
</span><span
class="add">+		trace_radeon_fence_wait_end(rdev_to_drm(rdev), i, target_seq[i]);
</span> 	}
 
 	return r;
<span
class="hunk">@@ -995,7 +995,7 @@ DEFINE_DEBUGFS_ATTRIBUTE(radeon_debugfs_gpu_reset_fops,
</span> void radeon_debugfs_fence_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;radeon_gpu_reset&#34;, 0444, root, rdev,
 			    &#38;radeon_debugfs_gpu_reset_fops);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_gem.c b/drivers/gpu/drm/radeon/radeon_gem.c
index 2ef201a072f1..9dd4ff09d562 100644
--- a/drivers/gpu/drm/radeon/radeon_gem.c
+++ b/drivers/gpu/drm/radeon/radeon_gem.c
</span><span
class="hunk">@@ -899,7 +899,7 @@ DEFINE_SHOW_ATTRIBUTE(radeon_debugfs_gem_info);
</span> void radeon_gem_debugfs_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;radeon_gem_info&#34;, 0444, root, rdev,
 			    &#38;radeon_debugfs_gem_info_fops);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_i2c.c b/drivers/gpu/drm/radeon/radeon_i2c.c
index 3d174390a8af..1f16619ed06e 100644
--- a/drivers/gpu/drm/radeon/radeon_i2c.c
+++ b/drivers/gpu/drm/radeon/radeon_i2c.c
</span><span
class="hunk">@@ -1011,7 +1011,7 @@ void radeon_i2c_add(struct radeon_device *rdev,
</span> 		    struct radeon_i2c_bus_rec *rec,
 		    const char *name)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	int i;
 
 	for (i = 0; i &lt; RADEON_MAX_I2C_BUS; i++) {
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Wu Hoi Pok</name><email>wuhoipok@gmail.com</email></author><title
type="html">[PATCH v3 4/7] drm/radeon: rdev-&gt;ddev to rdev_to_drm(rdev) 3</title><updated>2024-06-25T07:06:22Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624151122.23724-5-wuhoipok@gmail.com/"/><id>urn:uuid:02817b12-dabf-5b1c-c3d2-04f442afe7c9</id><thr:in-reply-to
ref="urn:uuid:2852997b-2246-744b-58b7-40f63f8a6232"
href="http://lore.kernel.org/amd-gfx/20240624151122.23724-1-wuhoipok@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Please refer to patch 1.

Signed-off-by: Wu Hoi Pok &lt;wuhoipok@gmail.com&gt;
---
 drivers/gpu/drm/radeon/r600_hdmi.c       |  2 +-
 drivers/gpu/drm/radeon/radeon_acpi.c     | 10 +++++-----
 drivers/gpu/drm/radeon/radeon_agp.c      |  2 +-
 drivers/gpu/drm/radeon/radeon_atombios.c |  2 +-
 drivers/gpu/drm/radeon/radeon_audio.c    |  4 ++--
 drivers/gpu/drm/radeon/radeon_combios.c  | 12 ++++++------
 6 files <a href="http://lore.kernel.org/amd-gfx/20240624151122.23724-5-wuhoipok@gmail.com/#related">changed</a>, 16 insertions(+), 16 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/radeon/r600_hdmi.c b/drivers/gpu/drm/radeon/r600_hdmi.c
index f3551ebaa2f0..661f374f5f27 100644
--- a/drivers/gpu/drm/radeon/r600_hdmi.c
+++ b/drivers/gpu/drm/radeon/r600_hdmi.c
</span><span
class="hunk">@@ -116,7 +116,7 @@ void r600_audio_update_hdmi(struct work_struct *work)
</span> {
 	struct radeon_device *rdev = container_of(work, struct radeon_device,
 						  audio_work);
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct r600_audio_pin audio_status = r600_audio_status(rdev);
 	struct drm_encoder *encoder;
 	bool changed = false;
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_acpi.c b/drivers/gpu/drm/radeon/radeon_acpi.c
index 603a78e41ba5..22ce61bdfc06 100644
--- a/drivers/gpu/drm/radeon/radeon_acpi.c
+++ b/drivers/gpu/drm/radeon/radeon_acpi.c
</span><span
class="hunk">@@ -405,11 +405,11 @@ static int radeon_atif_handler(struct radeon_device *rdev,
</span> 	if (req.pending &#38; ATIF_DGPU_DISPLAY_EVENT) {
 		if ((rdev-&gt;flags &#38; RADEON_IS_PX) &#38;&#38;
 		    radeon_atpx_dgpu_req_power_for_displays()) {
<span
class="del">-			pm_runtime_get_sync(rdev-&gt;ddev-&gt;dev);
</span><span
class="add">+			pm_runtime_get_sync(rdev_to_drm(rdev)-&gt;dev);
</span> 			/* Just fire off a uevent and let userspace tell us what to do */
<span
class="del">-			drm_helper_hpd_irq_event(rdev-&gt;ddev);
-			pm_runtime_mark_last_busy(rdev-&gt;ddev-&gt;dev);
-			pm_runtime_put_autosuspend(rdev-&gt;ddev-&gt;dev);
</span><span
class="add">+			drm_helper_hpd_irq_event(rdev_to_drm(rdev));
+			pm_runtime_mark_last_busy(rdev_to_drm(rdev)-&gt;dev);
+			pm_runtime_put_autosuspend(rdev_to_drm(rdev)-&gt;dev);
</span> 		}
 	}
 	/* TODO: check other events */
<span
class="hunk">@@ -736,7 +736,7 @@ int radeon_acpi_init(struct radeon_device *rdev)
</span> 		struct radeon_encoder *target = NULL;
 
 		/* Find the encoder controlling the brightness */
<span
class="del">-		list_for_each_entry(tmp, &#38;rdev-&gt;ddev-&gt;mode_config.encoder_list,
</span><span
class="add">+		list_for_each_entry(tmp, &#38;rdev_to_drm(rdev)-&gt;mode_config.encoder_list,
</span> 				head) {
 			struct radeon_encoder *enc = to_radeon_encoder(tmp);
 
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_agp.c b/drivers/gpu/drm/radeon/radeon_agp.c
index a3d749e350f9..89d7b0e9e79f 100644
--- a/drivers/gpu/drm/radeon/radeon_agp.c
+++ b/drivers/gpu/drm/radeon/radeon_agp.c
</span><span
class="hunk">@@ -161,7 +161,7 @@ struct radeon_agp_head *radeon_agp_head_init(struct drm_device *dev)
</span> 
 static int radeon_agp_head_acquire(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct pci_dev *pdev = to_pci_dev(dev-&gt;dev);
 
 	if (!rdev-&gt;agp)
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_atombios.c b/drivers/gpu/drm/radeon/radeon_atombios.c
index 10793a433bf5..97c4e10d0550 100644
--- a/drivers/gpu/drm/radeon/radeon_atombios.c
+++ b/drivers/gpu/drm/radeon/radeon_atombios.c
</span><span
class="hunk">@@ -187,7 +187,7 @@ void radeon_atombios_i2c_init(struct radeon_device *rdev)
</span> 
 			if (i2c.valid) {
 				sprintf(stmp, &#34;0x%x&#34;, i2c.i2c_id);
<span
class="del">-				rdev-&gt;i2c_bus[i] = radeon_i2c_create(rdev-&gt;ddev, &#38;i2c, stmp);
</span><span
class="add">+				rdev-&gt;i2c_bus[i] = radeon_i2c_create(rdev_to_drm(rdev), &#38;i2c, stmp);
</span> 			}
 			gpio = (ATOM_GPIO_I2C_ASSIGMENT *)
 				((u8 *)gpio + sizeof(ATOM_GPIO_I2C_ASSIGMENT));
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 0bcd767b9f47..47aa06a9a942 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
</span><span
class="hunk">@@ -196,7 +196,7 @@ static void radeon_audio_enable(struct radeon_device *rdev,
</span> 		return;
 
 	if (rdev-&gt;mode_info.mode_config_initialized) {
<span
class="del">-		list_for_each_entry(encoder, &#38;rdev-&gt;ddev-&gt;mode_config.encoder_list, head) {
</span><span
class="add">+		list_for_each_entry(encoder, &#38;rdev_to_drm(rdev)-&gt;mode_config.encoder_list, head) {
</span> 			if (radeon_encoder_is_digital(encoder)) {
 				radeon_encoder = to_radeon_encoder(encoder);
 				dig = radeon_encoder-&gt;enc_priv;
<span
class="hunk">@@ -760,7 +760,7 @@ static int radeon_audio_component_get_eld(struct device *kdev, int port,
</span> 	if (!rdev-&gt;audio.enabled || !rdev-&gt;mode_info.mode_config_initialized)
 		return 0;
 
<span
class="del">-	list_for_each_entry(encoder, &#38;rdev-&gt;ddev-&gt;mode_config.encoder_list, head) {
</span><span
class="add">+	list_for_each_entry(encoder, &#38;rdev_to_drm(rdev)-&gt;mode_config.encoder_list, head) {
</span> 		if (!radeon_encoder_is_digital(encoder))
 			continue;
 		radeon_encoder = to_radeon_encoder(encoder);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_combios.c b/drivers/gpu/drm/radeon/radeon_combios.c
index 6952b1273b0f..41ddc576f8f8 100644
--- a/drivers/gpu/drm/radeon/radeon_combios.c
+++ b/drivers/gpu/drm/radeon/radeon_combios.c
</span><span
class="hunk">@@ -372,7 +372,7 @@ bool radeon_combios_check_hardcoded_edid(struct radeon_device *rdev)
</span> 	int edid_info, size;
 	struct edid *edid;
 	unsigned char *raw;
<span
class="del">-	edid_info = combios_get_table_offset(rdev-&gt;ddev, COMBIOS_HARDCODED_EDID_TABLE);
</span><span
class="add">+	edid_info = combios_get_table_offset(rdev_to_drm(rdev), COMBIOS_HARDCODED_EDID_TABLE);
</span> 	if (!edid_info)
 		return false;
 
<span
class="hunk">@@ -642,7 +642,7 @@ static struct radeon_i2c_bus_rec combios_setup_i2c_bus(struct radeon_device *rde
</span> 
 static struct radeon_i2c_bus_rec radeon_combios_get_i2c_info_from_table(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct radeon_i2c_bus_rec i2c;
 	u16 offset;
 	u8 id, blocks, clk, data;
<span
class="hunk">@@ -670,7 +670,7 @@ static struct radeon_i2c_bus_rec radeon_combios_get_i2c_info_from_table(struct r
</span> 
 void radeon_combios_i2c_init(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct radeon_i2c_bus_rec i2c;
 
 	/* actual hw pads
<span
class="hunk">@@ -812,7 +812,7 @@ bool radeon_combios_get_clock_info(struct drm_device *dev)
</span> 
 bool radeon_combios_sideport_present(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	u16 igp_info;
 
 	/* sideport is AMD only */
<span
class="hunk">@@ -915,7 +915,7 @@ struct radeon_encoder_primary_dac *radeon_combios_get_primary_dac_info(struct
</span> enum radeon_tv_std
 radeon_combios_get_tv_info(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	uint16_t tv_info;
 	enum radeon_tv_std tv_std = TV_STD_NTSC;
 
<span
class="hunk">@@ -2637,7 +2637,7 @@ static const char *thermal_controller_names[] = {
</span> 
 void radeon_combios_get_power_modes(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	u16 offset, misc, misc2 = 0;
 	u8 rev, tmp;
 	int state_index = 0;
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Wu Hoi Pok</name><email>wuhoipok@gmail.com</email></author><title
type="html">[PATCH v3 3/7] drm/radeon: rdev-&gt;ddev to rdev_to_drm(rdev) 2</title><updated>2024-06-25T07:06:35Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624151122.23724-4-wuhoipok@gmail.com/"/><id>urn:uuid:32be4916-5291-0b39-98a6-d6b0a3449093</id><thr:in-reply-to
ref="urn:uuid:2852997b-2246-744b-58b7-40f63f8a6232"
href="http://lore.kernel.org/amd-gfx/20240624151122.23724-1-wuhoipok@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Please refer to patch 1.

Signed-off-by: Wu Hoi Pok &lt;wuhoipok@gmail.com&gt;
---
 drivers/gpu/drm/radeon/r300.c     |  6 +++---
 drivers/gpu/drm/radeon/r420.c     |  6 +++---
 drivers/gpu/drm/radeon/r520.c     |  2 +-
 drivers/gpu/drm/radeon/r600.c     | 12 ++++++------
 drivers/gpu/drm/radeon/r600_cs.c  |  2 +-
 drivers/gpu/drm/radeon/r600_dpm.c |  4 ++--
 6 files <a href="http://lore.kernel.org/amd-gfx/20240624151122.23724-4-wuhoipok@gmail.com/#related">changed</a>, 16 insertions(+), 16 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/radeon/r300.c b/drivers/gpu/drm/radeon/r300.c
index 1620f534f55f..05c13102a8cb 100644
--- a/drivers/gpu/drm/radeon/r300.c
+++ b/drivers/gpu/drm/radeon/r300.c
</span><span
class="hunk">@@ -616,7 +616,7 @@ DEFINE_SHOW_ATTRIBUTE(rv370_debugfs_pcie_gart_info);
</span> static void rv370_debugfs_pcie_gart_info_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;rv370_pcie_gart_info&#34;, 0444, root, rdev,
 			    &#38;rv370_debugfs_pcie_gart_info_fops);
<span
class="hunk">@@ -1452,7 +1452,7 @@ int r300_resume(struct radeon_device *rdev)
</span> 			RREG32(R_0007C0_CP_STAT));
 	}
 	/* post */
<span
class="del">-	radeon_combios_asic_init(rdev-&gt;ddev);
</span><span
class="add">+	radeon_combios_asic_init(rdev_to_drm(rdev));
</span> 	/* Resume clock after posting */
 	r300_clock_startup(rdev);
 	/* Initialize surface registers */
<span
class="hunk">@@ -1538,7 +1538,7 @@ int r300_init(struct radeon_device *rdev)
</span> 	/* Set asic errata */
 	r300_errata(rdev);
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* initialize AGP */
 	if (rdev-&gt;flags &#38; RADEON_IS_AGP) {
 		r = radeon_agp_init(rdev);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/r420.c b/drivers/gpu/drm/radeon/r420.c
index a979662eaa73..9a31cdec6415 100644
--- a/drivers/gpu/drm/radeon/r420.c
+++ b/drivers/gpu/drm/radeon/r420.c
</span><span
class="hunk">@@ -322,7 +322,7 @@ int r420_resume(struct radeon_device *rdev)
</span> 	if (rdev-&gt;is_atom_bios) {
 		atom_asic_init(rdev-&gt;mode_info.atom_context);
 	} else {
<span
class="del">-		radeon_combios_asic_init(rdev-&gt;ddev);
</span><span
class="add">+		radeon_combios_asic_init(rdev_to_drm(rdev));
</span> 	}
 	/* Resume clock after posting */
 	r420_clock_resume(rdev);
<span
class="hunk">@@ -414,7 +414,7 @@ int r420_init(struct radeon_device *rdev)
</span> 		return -EINVAL;
 
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* initialize AGP */
 	if (rdev-&gt;flags &#38; RADEON_IS_AGP) {
 		r = radeon_agp_init(rdev);
<span
class="hunk">@@ -493,7 +493,7 @@ DEFINE_SHOW_ATTRIBUTE(r420_debugfs_pipes_info);
</span> void r420_debugfs_pipes_info_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;r420_pipes_info&#34;, 0444, root, rdev,
 			    &#38;r420_debugfs_pipes_info_fops);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/r520.c b/drivers/gpu/drm/radeon/r520.c
index 6cbcaa845192..08e127b3249a 100644
--- a/drivers/gpu/drm/radeon/r520.c
+++ b/drivers/gpu/drm/radeon/r520.c
</span><span
class="hunk">@@ -287,7 +287,7 @@ int r520_init(struct radeon_device *rdev)
</span> 		atom_asic_init(rdev-&gt;mode_info.atom_context);
 	}
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* initialize AGP */
 	if (rdev-&gt;flags &#38; RADEON_IS_AGP) {
 		r = radeon_agp_init(rdev);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/r600.c b/drivers/gpu/drm/radeon/r600.c
index 087d41e370fd..8b62f7faa5b9 100644
--- a/drivers/gpu/drm/radeon/r600.c
+++ b/drivers/gpu/drm/radeon/r600.c
</span><span
class="hunk">@@ -950,7 +950,7 @@ void r600_hpd_set_polarity(struct radeon_device *rdev,
</span> 
 void r600_hpd_init(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_connector *connector;
 	unsigned enable = 0;
 
<span
class="hunk">@@ -1017,7 +1017,7 @@ void r600_hpd_init(struct radeon_device *rdev)
</span> 
 void r600_hpd_fini(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_connector *connector;
 	unsigned disable = 0;
 
<span
class="hunk">@@ -3280,7 +3280,7 @@ int r600_init(struct radeon_device *rdev)
</span> 	/* Initialize surface registers */
 	radeon_surface_init(rdev);
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* Fence driver */
 	radeon_fence_driver_init(rdev);
 	if (rdev-&gt;flags &#38; RADEON_IS_AGP) {
<span
class="hunk">@@ -4136,7 +4136,7 @@ int r600_irq_process(struct radeon_device *rdev)
</span> 					DRM_DEBUG(&#34;IH: D1 vblank - IH event w/o asserted irq bit?\n&#34;);
 
 				if (rdev-&gt;irq.crtc_vblank_int[0]) {
<span
class="del">-					drm_handle_vblank(rdev-&gt;ddev, 0);
</span><span
class="add">+					drm_handle_vblank(rdev_to_drm(rdev), 0);
</span> 					rdev-&gt;pm.vblank_sync = true;
 					wake_up(&#38;rdev-&gt;irq.vblank_queue);
 				}
<span
class="hunk">@@ -4166,7 +4166,7 @@ int r600_irq_process(struct radeon_device *rdev)
</span> 					DRM_DEBUG(&#34;IH: D2 vblank - IH event w/o asserted irq bit?\n&#34;);
 
 				if (rdev-&gt;irq.crtc_vblank_int[1]) {
<span
class="del">-					drm_handle_vblank(rdev-&gt;ddev, 1);
</span><span
class="add">+					drm_handle_vblank(rdev_to_drm(rdev), 1);
</span> 					rdev-&gt;pm.vblank_sync = true;
 					wake_up(&#38;rdev-&gt;irq.vblank_queue);
 				}
<span
class="hunk">@@ -4358,7 +4358,7 @@ DEFINE_SHOW_ATTRIBUTE(r600_debugfs_mc_info);
</span> static void r600_debugfs_mc_info_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;r600_mc_info&#34;, 0444, root, rdev,
 			    &#38;r600_debugfs_mc_info_fops);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/r600_cs.c b/drivers/gpu/drm/radeon/r600_cs.c
index 6cf54a747749..1b2d31c4d77c 100644
--- a/drivers/gpu/drm/radeon/r600_cs.c
+++ b/drivers/gpu/drm/radeon/r600_cs.c
</span><span
class="hunk">@@ -884,7 +884,7 @@ int r600_cs_common_vline_parse(struct radeon_cs_parser *p,
</span> 	crtc_id = radeon_get_ib_value(p, h_idx + 2 + 7 + 1);
 	reg = R600_CP_PACKET0_GET_REG(header);
 
<span
class="del">-	crtc = drm_crtc_find(p-&gt;rdev-&gt;ddev, p-&gt;filp, crtc_id);
</span><span
class="add">+	crtc = drm_crtc_find(rdev_to_drm(p-&gt;rdev), p-&gt;filp, crtc_id);
</span> 	if (!crtc) {
 		DRM_ERROR(&#34;cannot find crtc %d\n&#34;, crtc_id);
 		return -ENOENT;
<span
class="head">diff --git a/drivers/gpu/drm/radeon/r600_dpm.c b/drivers/gpu/drm/radeon/r600_dpm.c
index 64980a61d38a..81d58ef667dd 100644
--- a/drivers/gpu/drm/radeon/r600_dpm.c
+++ b/drivers/gpu/drm/radeon/r600_dpm.c
</span><span
class="hunk">@@ -153,7 +153,7 @@ void r600_dpm_print_ps_status(struct radeon_device *rdev,
</span> 
 u32 r600_dpm_get_vblank_time(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
 	u32 vblank_in_pixels;
<span
class="hunk">@@ -180,7 +180,7 @@ u32 r600_dpm_get_vblank_time(struct radeon_device *rdev)
</span> 
 u32 r600_dpm_get_vrefresh(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
 	u32 vrefresh = 0;
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Wu Hoi Pok</name><email>wuhoipok@gmail.com</email></author><title
type="html">[PATCH v3 2/7] drm/radeon: rdev-&gt;ddev to rdev_to_drm(rdev) 1</title><updated>2024-06-25T07:06:32Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624151122.23724-3-wuhoipok@gmail.com/"/><id>urn:uuid:2e7fc2a8-415d-605b-529d-6ab5395741d8</id><thr:in-reply-to
ref="urn:uuid:2852997b-2246-744b-58b7-40f63f8a6232"
href="http://lore.kernel.org/amd-gfx/20240624151122.23724-1-wuhoipok@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Please refer to patch 1.

Signed-off-by: Wu Hoi Pok &lt;wuhoipok@gmail.com&gt;
---
 drivers/gpu/drm/radeon/atombios_encoders.c |  2 +-
 drivers/gpu/drm/radeon/cik.c               | 14 ++++++-------
 drivers/gpu/drm/radeon/dce6_afmt.c         |  2 +-
 drivers/gpu/drm/radeon/evergreen.c         | 12 +++++------
 drivers/gpu/drm/radeon/ni.c                |  2 +-
 drivers/gpu/drm/radeon/r100.c              | 24 +++++++++++-----------
 6 files <a href="http://lore.kernel.org/amd-gfx/20240624151122.23724-3-wuhoipok@gmail.com/#related">changed</a>, 28 insertions(+), 28 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/radeon/atombios_encoders.c b/drivers/gpu/drm/radeon/atombios_encoders.c
index 03e6871b3065..c82e0fbc49b4 100644
--- a/drivers/gpu/drm/radeon/atombios_encoders.c
+++ b/drivers/gpu/drm/radeon/atombios_encoders.c
</span><span
class="hunk">@@ -2179,7 +2179,7 @@ int radeon_atom_pick_dig_encoder(struct drm_encoder *encoder, int fe_idx)
</span> void
 radeon_atom_encoder_init(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_encoder *encoder;
 
 	list_for_each_entry(encoder, &#38;dev-&gt;mode_config.encoder_list, head) {
<span
class="head">diff --git a/drivers/gpu/drm/radeon/cik.c b/drivers/gpu/drm/radeon/cik.c
index b5e96a8fc2c1..11a492f21157 100644
--- a/drivers/gpu/drm/radeon/cik.c
+++ b/drivers/gpu/drm/radeon/cik.c
</span><span
class="hunk">@@ -7585,7 +7585,7 @@ int cik_irq_process(struct radeon_device *rdev)
</span> 					DRM_DEBUG(&#34;IH: IH event w/o asserted irq bit?\n&#34;);
 
 				if (rdev-&gt;irq.crtc_vblank_int[0]) {
<span
class="del">-					drm_handle_vblank(rdev-&gt;ddev, 0);
</span><span
class="add">+					drm_handle_vblank(rdev_to_drm(rdev), 0);
</span> 					rdev-&gt;pm.vblank_sync = true;
 					wake_up(&#38;rdev-&gt;irq.vblank_queue);
 				}
<span
class="hunk">@@ -7615,7 +7615,7 @@ int cik_irq_process(struct radeon_device *rdev)
</span> 					DRM_DEBUG(&#34;IH: IH event w/o asserted irq bit?\n&#34;);
 
 				if (rdev-&gt;irq.crtc_vblank_int[1]) {
<span
class="del">-					drm_handle_vblank(rdev-&gt;ddev, 1);
</span><span
class="add">+					drm_handle_vblank(rdev_to_drm(rdev), 1);
</span> 					rdev-&gt;pm.vblank_sync = true;
 					wake_up(&#38;rdev-&gt;irq.vblank_queue);
 				}
<span
class="hunk">@@ -7645,7 +7645,7 @@ int cik_irq_process(struct radeon_device *rdev)
</span> 					DRM_DEBUG(&#34;IH: IH event w/o asserted irq bit?\n&#34;);
 
 				if (rdev-&gt;irq.crtc_vblank_int[2]) {
<span
class="del">-					drm_handle_vblank(rdev-&gt;ddev, 2);
</span><span
class="add">+					drm_handle_vblank(rdev_to_drm(rdev), 2);
</span> 					rdev-&gt;pm.vblank_sync = true;
 					wake_up(&#38;rdev-&gt;irq.vblank_queue);
 				}
<span
class="hunk">@@ -7675,7 +7675,7 @@ int cik_irq_process(struct radeon_device *rdev)
</span> 					DRM_DEBUG(&#34;IH: IH event w/o asserted irq bit?\n&#34;);
 
 				if (rdev-&gt;irq.crtc_vblank_int[3]) {
<span
class="del">-					drm_handle_vblank(rdev-&gt;ddev, 3);
</span><span
class="add">+					drm_handle_vblank(rdev_to_drm(rdev), 3);
</span> 					rdev-&gt;pm.vblank_sync = true;
 					wake_up(&#38;rdev-&gt;irq.vblank_queue);
 				}
<span
class="hunk">@@ -7705,7 +7705,7 @@ int cik_irq_process(struct radeon_device *rdev)
</span> 					DRM_DEBUG(&#34;IH: IH event w/o asserted irq bit?\n&#34;);
 
 				if (rdev-&gt;irq.crtc_vblank_int[4]) {
<span
class="del">-					drm_handle_vblank(rdev-&gt;ddev, 4);
</span><span
class="add">+					drm_handle_vblank(rdev_to_drm(rdev), 4);
</span> 					rdev-&gt;pm.vblank_sync = true;
 					wake_up(&#38;rdev-&gt;irq.vblank_queue);
 				}
<span
class="hunk">@@ -7735,7 +7735,7 @@ int cik_irq_process(struct radeon_device *rdev)
</span> 					DRM_DEBUG(&#34;IH: IH event w/o asserted irq bit?\n&#34;);
 
 				if (rdev-&gt;irq.crtc_vblank_int[5]) {
<span
class="del">-					drm_handle_vblank(rdev-&gt;ddev, 5);
</span><span
class="add">+					drm_handle_vblank(rdev_to_drm(rdev), 5);
</span> 					rdev-&gt;pm.vblank_sync = true;
 					wake_up(&#38;rdev-&gt;irq.vblank_queue);
 				}
<span
class="hunk">@@ -8581,7 +8581,7 @@ int cik_init(struct radeon_device *rdev)
</span> 	/* Initialize surface registers */
 	radeon_surface_init(rdev);
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 
 	/* Fence driver */
 	radeon_fence_driver_init(rdev);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/dce6_afmt.c b/drivers/gpu/drm/radeon/dce6_afmt.c
index 4c06f47453fd..d6ab93ed9ec4 100644
--- a/drivers/gpu/drm/radeon/dce6_afmt.c
+++ b/drivers/gpu/drm/radeon/dce6_afmt.c
</span><span
class="hunk">@@ -91,7 +91,7 @@ struct r600_audio_pin *dce6_audio_get_pin(struct radeon_device *rdev)
</span> 			pin = &#38;rdev-&gt;audio.pin[i];
 			pin_count = 0;
 
<span
class="del">-			list_for_each_entry(encoder, &#38;rdev-&gt;ddev-&gt;mode_config.encoder_list, head) {
</span><span
class="add">+			list_for_each_entry(encoder, &#38;rdev_to_drm(rdev)-&gt;mode_config.encoder_list, head) {
</span> 				if (radeon_encoder_is_digital(encoder)) {
 					radeon_encoder = to_radeon_encoder(encoder);
 					dig = radeon_encoder-&gt;enc_priv;
<span
class="head">diff --git a/drivers/gpu/drm/radeon/evergreen.c b/drivers/gpu/drm/radeon/evergreen.c
index c634dc28e6c3..bc4ab71613a5 100644
--- a/drivers/gpu/drm/radeon/evergreen.c
+++ b/drivers/gpu/drm/radeon/evergreen.c
</span><span
class="hunk">@@ -1673,7 +1673,7 @@ void evergreen_pm_misc(struct radeon_device *rdev)
</span>  */
 void evergreen_pm_prepare(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
 	u32 tmp;
<span
class="hunk">@@ -1698,7 +1698,7 @@ void evergreen_pm_prepare(struct radeon_device *rdev)
</span>  */
 void evergreen_pm_finish(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
 	u32 tmp;
<span
class="hunk">@@ -1763,7 +1763,7 @@ void evergreen_hpd_set_polarity(struct radeon_device *rdev,
</span>  */
 void evergreen_hpd_init(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_connector *connector;
 	unsigned enabled = 0;
 	u32 tmp = DC_HPDx_CONNECTION_TIMER(0x9c4) |
<span
class="hunk">@@ -1804,7 +1804,7 @@ void evergreen_hpd_init(struct radeon_device *rdev)
</span>  */
 void evergreen_hpd_fini(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_connector *connector;
 	unsigned disabled = 0;
 
<span
class="hunk">@@ -4753,7 +4753,7 @@ int evergreen_irq_process(struct radeon_device *rdev)
</span> 				event_name = &#34;vblank&#34;;
 
 				if (rdev-&gt;irq.crtc_vblank_int[crtc_idx]) {
<span
class="del">-					drm_handle_vblank(rdev-&gt;ddev, crtc_idx);
</span><span
class="add">+					drm_handle_vblank(rdev_to_drm(rdev), crtc_idx);
</span> 					rdev-&gt;pm.vblank_sync = true;
 					wake_up(&#38;rdev-&gt;irq.vblank_queue);
 				}
<span
class="hunk">@@ -5211,7 +5211,7 @@ int evergreen_init(struct radeon_device *rdev)
</span> 	/* Initialize surface registers */
 	radeon_surface_init(rdev);
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* Fence driver */
 	radeon_fence_driver_init(rdev);
 	/* initialize AGP */
<span
class="head">diff --git a/drivers/gpu/drm/radeon/ni.c b/drivers/gpu/drm/radeon/ni.c
index 77aee99e473a..3890911fe693 100644
--- a/drivers/gpu/drm/radeon/ni.c
+++ b/drivers/gpu/drm/radeon/ni.c
</span><span
class="hunk">@@ -2360,7 +2360,7 @@ int cayman_init(struct radeon_device *rdev)
</span> 	/* Initialize surface registers */
 	radeon_surface_init(rdev);
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* Fence driver */
 	radeon_fence_driver_init(rdev);
 	/* initialize memory controller */
<span
class="head">diff --git a/drivers/gpu/drm/radeon/r100.c b/drivers/gpu/drm/radeon/r100.c
index 0b1e19345f43..d7d7d23bf9a1 100644
--- a/drivers/gpu/drm/radeon/r100.c
+++ b/drivers/gpu/drm/radeon/r100.c
</span><span
class="hunk">@@ -459,7 +459,7 @@ void r100_pm_misc(struct radeon_device *rdev)
</span>  */
 void r100_pm_prepare(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
 	u32 tmp;
<span
class="hunk">@@ -490,7 +490,7 @@ void r100_pm_prepare(struct radeon_device *rdev)
</span>  */
 void r100_pm_finish(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
 	u32 tmp;
<span
class="hunk">@@ -603,7 +603,7 @@ void r100_hpd_set_polarity(struct radeon_device *rdev,
</span>  */
 void r100_hpd_init(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_connector *connector;
 	unsigned enable = 0;
 
<span
class="hunk">@@ -626,7 +626,7 @@ void r100_hpd_init(struct radeon_device *rdev)
</span>  */
 void r100_hpd_fini(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_connector *connector;
 	unsigned disable = 0;
 
<span
class="hunk">@@ -798,7 +798,7 @@ int r100_irq_process(struct radeon_device *rdev)
</span> 		/* Vertical blank interrupts */
 		if (status &#38; RADEON_CRTC_VBLANK_STAT) {
 			if (rdev-&gt;irq.crtc_vblank_int[0]) {
<span
class="del">-				drm_handle_vblank(rdev-&gt;ddev, 0);
</span><span
class="add">+				drm_handle_vblank(rdev_to_drm(rdev), 0);
</span> 				rdev-&gt;pm.vblank_sync = true;
 				wake_up(&#38;rdev-&gt;irq.vblank_queue);
 			}
<span
class="hunk">@@ -807,7 +807,7 @@ int r100_irq_process(struct radeon_device *rdev)
</span> 		}
 		if (status &#38; RADEON_CRTC2_VBLANK_STAT) {
 			if (rdev-&gt;irq.crtc_vblank_int[1]) {
<span
class="del">-				drm_handle_vblank(rdev-&gt;ddev, 1);
</span><span
class="add">+				drm_handle_vblank(rdev_to_drm(rdev), 1);
</span> 				rdev-&gt;pm.vblank_sync = true;
 				wake_up(&#38;rdev-&gt;irq.vblank_queue);
 			}
<span
class="hunk">@@ -1471,7 +1471,7 @@ int r100_cs_packet_parse_vline(struct radeon_cs_parser *p)
</span> 	header = radeon_get_ib_value(p, h_idx);
 	crtc_id = radeon_get_ib_value(p, h_idx + 5);
 	reg = R100_CP_PACKET0_GET_REG(header);
<span
class="del">-	crtc = drm_crtc_find(p-&gt;rdev-&gt;ddev, p-&gt;filp, crtc_id);
</span><span
class="add">+	crtc = drm_crtc_find(rdev_to_drm(p-&gt;rdev), p-&gt;filp, crtc_id);
</span> 	if (!crtc) {
 		DRM_ERROR(&#34;cannot find crtc %d\n&#34;, crtc_id);
 		return -ENOENT;
<span
class="hunk">@@ -3059,7 +3059,7 @@ DEFINE_SHOW_ATTRIBUTE(r100_debugfs_mc_info);
</span> void  r100_debugfs_rbbm_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;r100_rbbm_info&#34;, 0444, root, rdev,
 			    &#38;r100_debugfs_rbbm_info_fops);
<span
class="hunk">@@ -3069,7 +3069,7 @@ void  r100_debugfs_rbbm_init(struct radeon_device *rdev)
</span> void r100_debugfs_cp_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;r100_cp_ring_info&#34;, 0444, root, rdev,
 			    &#38;r100_debugfs_cp_ring_info_fops);
<span
class="hunk">@@ -3081,7 +3081,7 @@ void r100_debugfs_cp_init(struct radeon_device *rdev)
</span> void  r100_debugfs_mc_info_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;r100_mc_info&#34;, 0444, root, rdev,
 			    &#38;r100_debugfs_mc_info_fops);
<span
class="hunk">@@ -3947,7 +3947,7 @@ int r100_resume(struct radeon_device *rdev)
</span> 			RREG32(R_0007C0_CP_STAT));
 	}
 	/* post */
<span
class="del">-	radeon_combios_asic_init(rdev-&gt;ddev);
</span><span
class="add">+	radeon_combios_asic_init(rdev_to_drm(rdev));
</span> 	/* Resume clock after posting */
 	r100_clock_startup(rdev);
 	/* Initialize surface registers */
<span
class="hunk">@@ -4056,7 +4056,7 @@ int r100_init(struct radeon_device *rdev)
</span> 	/* Set asic errata */
 	r100_errata(rdev);
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* initialize AGP */
 	if (rdev-&gt;flags &#38; RADEON_IS_AGP) {
 		r = radeon_agp_init(rdev);
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Wu Hoi Pok</name><email>wuhoipok@gmail.com</email></author><title>[PATCH v3 1/7] drm/radeon: remove load callback</title><updated>2024-06-25T07:06:34Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624151122.23724-2-wuhoipok@gmail.com/"/><id>urn:uuid:aa4faf92-7def-9da9-8cbd-96991e554f60</id><thr:in-reply-to
ref="urn:uuid:2852997b-2246-744b-58b7-40f63f8a6232"
href="http://lore.kernel.org/amd-gfx/20240624151122.23724-1-wuhoipok@gmail.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Remove &#34;.load&#34; callback form &#34;kms_driver&#34;, and move &#34;struct drm_device&#34;
into radeon_device. Patch 2 to 7 follows up with changing the way of
accessing drm_device, from &#34;rdev-&gt;ddev&#34; to &#34;rdev_to_drm(rdev)&#34; which is
&#34;&#38;rdev-&gt;ddev&#34;.

Signed-off-by: Wu Hoi Pok &lt;wuhoipok@gmail.com&gt;
---
 drivers/gpu/drm/radeon/radeon.h     | 11 ++++++++---
 drivers/gpu/drm/radeon/radeon_drv.c | 27 ++++++++++++++++++---------
 drivers/gpu/drm/radeon/radeon_drv.h |  1 -
 drivers/gpu/drm/radeon/radeon_kms.c | 18 ++++++------------
 4 files <a href="http://lore.kernel.org/amd-gfx/20240624151122.23724-2-wuhoipok@gmail.com/#related">changed</a>, 32 insertions(+), 25 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon.h b/drivers/gpu/drm/radeon/radeon.h
index 0999c8eaae94..69bb30ced189 100644
--- a/drivers/gpu/drm/radeon/radeon.h
+++ b/drivers/gpu/drm/radeon/radeon.h
</span><span
class="hunk">@@ -2297,7 +2297,7 @@ typedef void (*radeon_wreg_t)(struct radeon_device*, uint32_t, uint32_t);
</span> 
 struct radeon_device {
 	struct device			*dev;
<span
class="del">-	struct drm_device		*ddev;
</span><span
class="add">+	struct drm_device		ddev;
</span> 	struct pci_dev			*pdev;
 #ifdef __alpha__
 	struct pci_controller		*hose;
<span
class="hunk">@@ -2440,10 +2440,13 @@ struct radeon_device {
</span> 	u64 gart_pin_size;
 };
 
<span
class="add">+static inline struct drm_device *rdev_to_drm(struct radeon_device *rdev)
+{
+	return &#38;rdev-&gt;ddev;
+}
+
</span> bool radeon_is_px(struct drm_device *dev);
 int radeon_device_init(struct radeon_device *rdev,
<span
class="del">-		       struct drm_device *ddev,
-		       struct pci_dev *pdev,
</span> 		       uint32_t flags);
 void radeon_device_fini(struct radeon_device *rdev);
 int radeon_gpu_wait_for_idle(struct radeon_device *rdev);
<span
class="hunk">@@ -2818,6 +2821,8 @@ struct radeon_device *radeon_get_rdev(struct ttm_device *bdev);
</span> 
 /* KMS */
 
<span
class="add">+int radeon_driver_load_kms(struct radeon_device *dev, unsigned long flags);
+
</span> u32 radeon_get_vblank_counter_kms(struct drm_crtc *crtc);
 int radeon_enable_vblank_kms(struct drm_crtc *crtc);
 void radeon_disable_vblank_kms(struct drm_crtc *crtc);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_drv.c b/drivers/gpu/drm/radeon/radeon_drv.c
index 7bf08164140e..ae9cadceba83 100644
--- a/drivers/gpu/drm/radeon/radeon_drv.c
+++ b/drivers/gpu/drm/radeon/radeon_drv.c
</span><span
class="hunk">@@ -259,7 +259,8 @@ static int radeon_pci_probe(struct pci_dev *pdev,
</span> 			    const struct pci_device_id *ent)
 {
 	unsigned long flags = 0;
<span
class="del">-	struct drm_device *dev;
</span><span
class="add">+	struct drm_device *ddev;
+	struct radeon_device *rdev;
</span> 	int ret;
 
 	if (!ent)
<span
class="hunk">@@ -300,28 +301,37 @@ static int radeon_pci_probe(struct pci_dev *pdev,
</span> 	if (ret)
 		return ret;
 
<span
class="del">-	dev = drm_dev_alloc(&#38;kms_driver, &#38;pdev-&gt;dev);
-	if (IS_ERR(dev))
-		return PTR_ERR(dev);
</span><span
class="add">+	rdev = devm_drm_dev_alloc(&#38;pdev-&gt;dev, &#38;kms_driver, typeof(*rdev), ddev);
+	if (IS_ERR(rdev))
+		return PTR_ERR(rdev);
+
+	rdev-&gt;dev  = &#38;pdev-&gt;dev;
+	rdev-&gt;pdev = pdev;
+	ddev = rdev_to_drm(rdev);
+	ddev-&gt;dev_private = rdev;
</span> 
 	ret = pci_enable_device(pdev);
 	if (ret)
 		goto err_free;
 
<span
class="del">-	pci_set_drvdata(pdev, dev);
</span><span
class="add">+	pci_set_drvdata(pdev, ddev);
+
+	ret = radeon_driver_load_kms(rdev, flags);
+	if (ret)
+		goto err_agp;
</span> 
<span
class="del">-	ret = drm_dev_register(dev, ent-&gt;driver_data);
</span><span
class="add">+	ret = drm_dev_register(ddev, flags);
</span> 	if (ret)
 		goto err_agp;
 
<span
class="del">-	radeon_fbdev_setup(dev-&gt;dev_private);
</span><span
class="add">+	radeon_fbdev_setup(ddev-&gt;dev_private);
</span> 
 	return 0;
 
 err_agp:
 	pci_disable_device(pdev);
 err_free:
<span
class="del">-	drm_dev_put(dev);
</span><span
class="add">+	drm_dev_put(ddev);
</span> 	return ret;
 }
 
<span
class="hunk">@@ -569,7 +579,6 @@ static const struct drm_ioctl_desc radeon_ioctls_kms[] = {
</span> static const struct drm_driver kms_driver = {
 	.driver_features =
 	    DRIVER_GEM | DRIVER_RENDER | DRIVER_MODESET,
<span
class="del">-	.load = radeon_driver_load_kms,
</span> 	.open = radeon_driver_open_kms,
 	.postclose = radeon_driver_postclose_kms,
 	.unload = radeon_driver_unload_kms,
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_drv.h b/drivers/gpu/drm/radeon/radeon_drv.h
index 02a65971d140..6c1eb75a951b 100644
--- a/drivers/gpu/drm/radeon/radeon_drv.h
+++ b/drivers/gpu/drm/radeon/radeon_drv.h
</span><span
class="hunk">@@ -117,7 +117,6 @@
</span> long radeon_drm_ioctl(struct file *filp,
 		      unsigned int cmd, unsigned long arg);
 
<span
class="del">-int radeon_driver_load_kms(struct drm_device *dev, unsigned long flags);
</span> void radeon_driver_unload_kms(struct drm_device *dev);
 int radeon_driver_open_kms(struct drm_device *dev, struct drm_file *file_priv);
 void radeon_driver_postclose_kms(struct drm_device *dev,
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_kms.c b/drivers/gpu/drm/radeon/radeon_kms.c
index a16590c6247f..d2df194393af 100644
--- a/drivers/gpu/drm/radeon/radeon_kms.c
+++ b/drivers/gpu/drm/radeon/radeon_kms.c
</span><span
class="hunk">@@ -91,7 +91,7 @@ void radeon_driver_unload_kms(struct drm_device *dev)
</span> /**
  * radeon_driver_load_kms - Main load function for KMS.
  *
<span
class="del">- * @dev: drm dev pointer
</span><span
class="add">+ * @rdev: radeon dev pointer
</span>  * @flags: device flags
  *
  * This is the main load function for KMS (all asics).
<span
class="hunk">@@ -101,24 +101,18 @@ void radeon_driver_unload_kms(struct drm_device *dev)
</span>  * (crtcs, encoders, hotplug detect, etc.).
  * Returns 0 on success, error on failure.
  */
<span
class="del">-int radeon_driver_load_kms(struct drm_device *dev, unsigned long flags)
</span><span
class="add">+int radeon_driver_load_kms(struct radeon_device *rdev, unsigned long flags)
</span> {
<span
class="del">-	struct pci_dev *pdev = to_pci_dev(dev-&gt;dev);
-	struct radeon_device *rdev;
</span><span
class="add">+	struct pci_dev *pdev = rdev-&gt;pdev;
+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	int r, acpi_status;
 
<span
class="del">-	rdev = kzalloc(sizeof(struct radeon_device), GFP_KERNEL);
-	if (rdev == NULL) {
-		return -ENOMEM;
-	}
-	dev-&gt;dev_private = (void *)rdev;
-
</span> #ifdef __alpha__
 	rdev-&gt;hose = pdev-&gt;sysdata;
 #endif
 
 	if (pci_find_capability(pdev, PCI_CAP_ID_AGP))
<span
class="del">-		rdev-&gt;agp = radeon_agp_head_init(dev);
</span><span
class="add">+		rdev-&gt;agp = radeon_agp_head_init(rdev_to_drm(rdev));
</span> 	if (rdev-&gt;agp) {
 		rdev-&gt;agp-&gt;agp_mtrr = arch_phys_wc_add(
 			rdev-&gt;agp-&gt;agp_info.aper_base,
<span
class="hunk">@@ -147,7 +141,7 @@ int radeon_driver_load_kms(struct drm_device *dev, unsigned long flags)
</span> 	 * properly initialize the GPU MC controller and permit
 	 * VRAM allocation
 	 */
<span
class="del">-	r = radeon_device_init(rdev, dev, pdev, flags);
</span><span
class="add">+	r = radeon_device_init(rdev, flags);
</span> 	if (r) {
 		dev_err(dev-&gt;dev, &#34;Fatal error during GPU init\n&#34;);
 		goto out;
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Wu Hoi Pok</name><email>wuhoipok@gmail.com</email></author><title>[PATCH v3 0/7] drm/radeon: remove load callback</title><updated>2024-06-25T07:06:30Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624151122.23724-1-wuhoipok@gmail.com/"/><id>urn:uuid:2852997b-2246-744b-58b7-40f63f8a6232</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Changes between v1 and v3:

1. add &#34;ddev-&gt;dev_private = rdev;&#34;
2. include a cover letter

Wu Hoi Pok (7):
  drm/radeon: remove load callback
  drm/radeon: rdev-&gt;ddev to rdev_to_drm(rdev) 1
  drm/radeon: rdev-&gt;ddev to rdev_to_drm(rdev) 2
  drm/radeon: rdev-&gt;ddev to rdev_to_drm(rdev) 3
  drm/radeon: rdev-&gt;ddev to rdev_to_drm(rdev) 4
  drm/radeon: rdev-&gt;ddev to rdev_to_drm(rdev) 5
  drm/radeon: rdev-&gt;ddev to rdev_to_drm(rdev) 6

 drivers/gpu/drm/radeon/atombios_encoders.c |  2 +-
 drivers/gpu/drm/radeon/cik.c               | 14 ++--
 drivers/gpu/drm/radeon/dce6_afmt.c         |  2 +-
 drivers/gpu/drm/radeon/evergreen.c         | 12 ++--
 drivers/gpu/drm/radeon/ni.c                |  2 +-
 drivers/gpu/drm/radeon/r100.c              | 24 +++----
 drivers/gpu/drm/radeon/r300.c              |  6 +-
 drivers/gpu/drm/radeon/r420.c              |  6 +-
 drivers/gpu/drm/radeon/r520.c              |  2 +-
 drivers/gpu/drm/radeon/r600.c              | 12 ++--
 drivers/gpu/drm/radeon/r600_cs.c           |  2 +-
 drivers/gpu/drm/radeon/r600_dpm.c          |  4 +-
 drivers/gpu/drm/radeon/r600_hdmi.c         |  2 +-
 drivers/gpu/drm/radeon/radeon.h            | 11 +++-
 drivers/gpu/drm/radeon/radeon_acpi.c       | 10 +--
 drivers/gpu/drm/radeon/radeon_agp.c        |  2 +-
 drivers/gpu/drm/radeon/radeon_atombios.c   |  2 +-
 drivers/gpu/drm/radeon/radeon_audio.c      |  4 +-
 drivers/gpu/drm/radeon/radeon_combios.c    | 12 ++--
 drivers/gpu/drm/radeon/radeon_device.c     | 19 ++----
 drivers/gpu/drm/radeon/radeon_display.c    | 74 +++++++++++-----------
 drivers/gpu/drm/radeon/radeon_drv.c        | 27 +++++---
 drivers/gpu/drm/radeon/radeon_drv.h        |  1 -
 drivers/gpu/drm/radeon/radeon_fbdev.c      | 26 ++++----
 drivers/gpu/drm/radeon/radeon_fence.c      |  8 +--
 drivers/gpu/drm/radeon/radeon_gem.c        |  2 +-
 drivers/gpu/drm/radeon/radeon_i2c.c        |  2 +-
 drivers/gpu/drm/radeon/radeon_ib.c         |  2 +-
 drivers/gpu/drm/radeon/radeon_irq_kms.c    | 12 ++--
 drivers/gpu/drm/radeon/radeon_kms.c        | 18 ++----
 drivers/gpu/drm/radeon/radeon_object.c     |  2 +-
 drivers/gpu/drm/radeon/radeon_pm.c         | 20 +++---
 drivers/gpu/drm/radeon/radeon_ring.c       |  2 +-
 drivers/gpu/drm/radeon/radeon_ttm.c        |  6 +-
 drivers/gpu/drm/radeon/rs400.c             |  6 +-
 drivers/gpu/drm/radeon/rs600.c             | 14 ++--
 drivers/gpu/drm/radeon/rs690.c             |  2 +-
 drivers/gpu/drm/radeon/rv515.c             |  4 +-
 drivers/gpu/drm/radeon/rv770.c             |  2 +-
 drivers/gpu/drm/radeon/si.c                |  4 +-
 40 files changed, 193 insertions(+), 191 deletions(-)

-- 
2.45.2

</pre></div></content></entry><entry><author><name>Yunxiang Li</name><email>Yunxiang.Li@amd.com</email></author><title>[PATCH v2 1/2] drm/amdgpu: stop tracking visible memory stats</title><updated>2024-06-24T14:08:38Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624140815.18085-1-Yunxiang.Li@amd.com/"/><id>urn:uuid:da04c1e3-1614-7f24-a68f-05fbe3375fed</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Since on modern systems all of vram can be made visible anyways, to
simplify the new implementation, drops tracking how much memory is
visible for now. If this is still needed we can add it back on top of
the new implementation.

Signed-off-by: Yunxiang Li &lt;Yunxiang.Li@amd.com&gt;
---
v2: split into two patchs for clarity

 drivers/gpu/drm/amd/amdgpu/amdgpu_fdinfo.c |  6 ------
 drivers/gpu/drm/amd/amdgpu/amdgpu_object.c | 11 +----------
 drivers/gpu/drm/amd/amdgpu/amdgpu_object.h | 14 ++++----------
 3 files <a href="http://lore.kernel.org/amd-gfx/20240624140815.18085-1-Yunxiang.Li@amd.com/#related">changed</a>, 5 insertions(+), 26 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_fdinfo.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_fdinfo.c
index c7df7fa3459f..9a40ff5c6dd3 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_fdinfo.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_fdinfo.c
</span><span
class="hunk">@@ -85,16 +85,10 @@ void amdgpu_show_fdinfo(struct drm_printer *p, struct drm_file *file)
</span> 	drm_printf(p, &#34;drm-memory-vram:\t%llu KiB\n&#34;, stats.vram/1024UL);
 	drm_printf(p, &#34;drm-memory-gtt: \t%llu KiB\n&#34;, stats.gtt/1024UL);
 	drm_printf(p, &#34;drm-memory-cpu: \t%llu KiB\n&#34;, stats.cpu/1024UL);
<span
class="del">-	drm_printf(p, &#34;amd-memory-visible-vram:\t%llu KiB\n&#34;,
-		   stats.visible_vram/1024UL);
</span> 	drm_printf(p, &#34;amd-evicted-vram:\t%llu KiB\n&#34;,
 		   stats.evicted_vram/1024UL);
<span
class="del">-	drm_printf(p, &#34;amd-evicted-visible-vram:\t%llu KiB\n&#34;,
-		   stats.evicted_visible_vram/1024UL);
</span> 	drm_printf(p, &#34;amd-requested-vram:\t%llu KiB\n&#34;,
 		   stats.requested_vram/1024UL);
<span
class="del">-	drm_printf(p, &#34;amd-requested-visible-vram:\t%llu KiB\n&#34;,
-		   stats.requested_visible_vram/1024UL);
</span> 	drm_printf(p, &#34;amd-requested-gtt:\t%llu KiB\n&#34;,
 		   stats.requested_gtt/1024UL);
 	drm_printf(p, &#34;drm-shared-vram:\t%llu KiB\n&#34;, stats.vram_shared/1024UL);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
index 6faeb9e4a572..bcf25c7e85e0 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
</span><span
class="hunk">@@ -1282,7 +1282,6 @@ void amdgpu_bo_move_notify(struct ttm_buffer_object *bo,
</span> void amdgpu_bo_get_memory(struct amdgpu_bo *bo,
 			  struct amdgpu_mem_stats *stats)
 {
<span
class="del">-	struct amdgpu_device *adev = amdgpu_ttm_adev(bo-&gt;tbo.bdev);
</span> 	struct ttm_resource *res = bo-&gt;tbo.resource;
 	uint64_t size = amdgpu_bo_size(bo);
 	struct drm_gem_object *obj;
<span
class="hunk">@@ -1298,8 +1297,6 @@ void amdgpu_bo_get_memory(struct amdgpu_bo *bo,
</span> 	switch (res-&gt;mem_type) {
 	case TTM_PL_VRAM:
 		stats-&gt;vram += size;
<span
class="del">-		if (amdgpu_res_cpu_visible(adev, res))
-			stats-&gt;visible_vram += size;
</span> 		if (shared)
 			stats-&gt;vram_shared += size;
 		break;
<span
class="hunk">@@ -1318,14 +1315,8 @@ void amdgpu_bo_get_memory(struct amdgpu_bo *bo,
</span> 
 	if (bo-&gt;preferred_domains &#38; AMDGPU_GEM_DOMAIN_VRAM) {
 		stats-&gt;requested_vram += size;
<span
class="del">-		if (bo-&gt;flags &#38; AMDGPU_GEM_CREATE_CPU_ACCESS_REQUIRED)
-			stats-&gt;requested_visible_vram += size;
-
-		if (res-&gt;mem_type != TTM_PL_VRAM) {
</span><span
class="add">+		if (res-&gt;mem_type != TTM_PL_VRAM)
</span> 			stats-&gt;evicted_vram += size;
<span
class="del">-			if (bo-&gt;flags &#38; AMDGPU_GEM_CREATE_CPU_ACCESS_REQUIRED)
-				stats-&gt;evicted_visible_vram += size;
-		}
</span> 	} else if (bo-&gt;preferred_domains &#38; AMDGPU_GEM_DOMAIN_GTT) {
 		stats-&gt;requested_gtt += size;
 	}
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h
index bc42ccbde659..218919fc13ec 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h
</span><span
class="hunk">@@ -136,12 +136,10 @@ struct amdgpu_bo_vm {
</span> };
 
 struct amdgpu_mem_stats {
<span
class="del">-	/* current VRAM usage, includes visible VRAM */
</span><span
class="add">+	/* current VRAM usage */
</span> 	uint64_t vram;
<span
class="del">-	/* current shared VRAM usage, includes visible VRAM */
</span><span
class="add">+	/* current shared VRAM usage */
</span> 	uint64_t vram_shared;
<span
class="del">-	/* current visible VRAM usage */
-	uint64_t visible_vram;
</span> 	/* current GTT usage */
 	uint64_t gtt;
 	/* current shared GTT usage */
<span
class="hunk">@@ -150,14 +148,10 @@ struct amdgpu_mem_stats {
</span> 	uint64_t cpu;
 	/* current shared system memory usage */
 	uint64_t cpu_shared;
<span
class="del">-	/* sum of evicted buffers, includes visible VRAM */
</span><span
class="add">+	/* sum of evicted buffers */
</span> 	uint64_t evicted_vram;
<span
class="del">-	/* sum of evicted buffers due to CPU access */
-	uint64_t evicted_visible_vram;
-	/* how much userspace asked for, includes vis.VRAM */
-	uint64_t requested_vram;
</span> 	/* how much userspace asked for */
<span
class="del">-	uint64_t requested_visible_vram;
</span><span
class="add">+	uint64_t requested_vram;
</span> 	/* how much userspace asked for */
 	uint64_t requested_gtt;
 };
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Yunxiang Li</name><email>Yunxiang.Li@amd.com</email></author><title>[PATCH v2 2/2] drm/amdgpu: track bo memory stats at runtime</title><updated>2024-06-24T14:08:37Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624140815.18085-2-Yunxiang.Li@amd.com/"/><id>urn:uuid:d506caaa-65bb-7b02-e059-ab96d1f6a80f</id><thr:in-reply-to
ref="urn:uuid:da04c1e3-1614-7f24-a68f-05fbe3375fed"
href="http://lore.kernel.org/amd-gfx/20240624140815.18085-1-Yunxiang.Li@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Before, every time fdinfo is queried we try to lock all the BOs in the
VM and calculate memory usage from scratch. This works okay if the
fdinfo is rarely read and the VMs don&#39;t have a ton of BOs. If either of
these conditions is not true, we get a massive performance hit.

In this new revision, we track the BOs as they change state. This way
when the fdinfo is queried we only need to take the status lock and copy
out the usage stats with minimal impact to the runtime performance.

Signed-off-by: Yunxiang Li &lt;Yunxiang.Li@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c      |   2 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_dma_buf.c |  15 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c     |   3 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_object.c  |   4 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_object.h  |  21 ---
 drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c      | 183 +++++++++++++++-----
 drivers/gpu/drm/amd/amdgpu/amdgpu_vm.h      |  32 +++-
 drivers/gpu/drm/amd/amdgpu/amdgpu_vm_pt.c   |   1 +
 8 files <a href="http://lore.kernel.org/amd-gfx/20240624140815.18085-2-Yunxiang.Li@amd.com/#related">changed</a>, 185 insertions(+), 76 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
index ec888fc6ead8..397cb0f83811 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
</span><span
class="hunk">@@ -1166,7 +1166,7 @@ static int amdgpu_cs_vm_handling(struct amdgpu_cs_parser *p)
</span> 			if (!bo)
 				continue;
 
<span
class="del">-			amdgpu_vm_bo_invalidate(adev, bo, false);
</span><span
class="add">+			amdgpu_vm_bo_invalidate(bo, NULL, false);
</span> 		}
 	}
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dma_buf.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_dma_buf.c
index 8e81a83d37d8..87fc3f37a1eb 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dma_buf.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dma_buf.c
</span><span
class="hunk">@@ -190,6 +190,13 @@ static void amdgpu_dma_buf_unmap(struct dma_buf_attachment *attach,
</span> 	}
 }
 
<span
class="add">+static void amdgpu_dma_buf_release(struct dma_buf *buf)
+{
+	struct amdgpu_bo *bo = gem_to_amdgpu_bo(buf-&gt;priv);
+	amdgpu_vm_bo_handle_shared(bo, true);
+	drm_gem_dmabuf_release(buf);
+}
+
</span> /**
  * amdgpu_dma_buf_begin_cpu_access - &#38;dma_buf_ops.begin_cpu_access implementation
  * @dma_buf: Shared DMA buffer
<span
class="hunk">@@ -237,7 +244,7 @@ const struct dma_buf_ops amdgpu_dmabuf_ops = {
</span> 	.unpin = amdgpu_dma_buf_unpin,
 	.map_dma_buf = amdgpu_dma_buf_map,
 	.unmap_dma_buf = amdgpu_dma_buf_unmap,
<span
class="del">-	.release = drm_gem_dmabuf_release,
</span><span
class="add">+	.release = amdgpu_dma_buf_release,
</span> 	.begin_cpu_access = amdgpu_dma_buf_begin_cpu_access,
 	.mmap = drm_gem_dmabuf_mmap,
 	.vmap = drm_gem_dmabuf_vmap,
<span
class="hunk">@@ -265,8 +272,10 @@ struct dma_buf *amdgpu_gem_prime_export(struct drm_gem_object *gobj,
</span> 		return ERR_PTR(-EPERM);
 
 	buf = drm_gem_prime_export(gobj, flags);
<span
class="del">-	if (!IS_ERR(buf))
</span><span
class="add">+	if (!IS_ERR(buf)) {
</span> 		buf-&gt;ops = &#38;amdgpu_dmabuf_ops;
<span
class="add">+		amdgpu_vm_bo_handle_shared(bo, false);
+	}
</span> 
 	return buf;
 }
<span
class="hunk">@@ -345,7 +354,7 @@ amdgpu_dma_buf_move_notify(struct dma_buf_attachment *attach)
</span> 	/* FIXME: This should be after the &#34;if&#34;, but needs a fix to make sure
 	 * DMABuf imports are initialized in the right VM list.
 	 */
<span
class="del">-	amdgpu_vm_bo_invalidate(adev, bo, false);
</span><span
class="add">+	amdgpu_vm_bo_invalidate(bo, NULL, false);
</span> 	if (!bo-&gt;tbo.resource || bo-&gt;tbo.resource-&gt;mem_type == TTM_PL_SYSTEM)
 		return;
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
index 1f22b4208729..1cd28fc1dcf5 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
</span><span
class="hunk">@@ -843,7 +843,6 @@ int amdgpu_gem_va_ioctl(struct drm_device *dev, void *data,
</span> int amdgpu_gem_op_ioctl(struct drm_device *dev, void *data,
 			struct drm_file *filp)
 {
<span
class="del">-	struct amdgpu_device *adev = drm_to_adev(dev);
</span> 	struct drm_amdgpu_gem_op *args = data;
 	struct drm_gem_object *gobj;
 	struct amdgpu_vm_bo_base *base;
<span
class="hunk">@@ -903,7 +902,7 @@ int amdgpu_gem_op_ioctl(struct drm_device *dev, void *data,
</span> 			robj-&gt;allowed_domains |= AMDGPU_GEM_DOMAIN_GTT;
 
 		if (robj-&gt;flags &#38; AMDGPU_GEM_CREATE_VM_ALWAYS_VALID)
<span
class="del">-			amdgpu_vm_bo_invalidate(adev, robj, true);
</span><span
class="add">+			amdgpu_vm_bo_invalidate(robj, NULL, true);
</span> 
 		amdgpu_bo_unreserve(robj);
 		break;
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
index bcf25c7e85e0..469bb600bcaa 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
</span><span
class="hunk">@@ -37,6 +37,7 @@
</span> #include &lt;drm/amdgpu_drm.h&gt;
 #include &lt;drm/drm_cache.h&gt;
 #include &#34;amdgpu.h&#34;
<span
class="add">+#include &#34;amdgpu_vm.h&#34;
</span> #include &#34;amdgpu_trace.h&#34;
 #include &#34;amdgpu_amdkfd.h&#34;
 
<span
class="hunk">@@ -1258,7 +1259,6 @@ void amdgpu_bo_move_notify(struct ttm_buffer_object *bo,
</span> 			   bool evict,
 			   struct ttm_resource *new_mem)
 {
<span
class="del">-	struct amdgpu_device *adev = amdgpu_ttm_adev(bo-&gt;bdev);
</span> 	struct ttm_resource *old_mem = bo-&gt;resource;
 	struct amdgpu_bo *abo;
 
<span
class="hunk">@@ -1266,7 +1266,7 @@ void amdgpu_bo_move_notify(struct ttm_buffer_object *bo,
</span> 		return;
 
 	abo = ttm_to_amdgpu_bo(bo);
<span
class="del">-	amdgpu_vm_bo_invalidate(adev, abo, evict);
</span><span
class="add">+	amdgpu_vm_bo_invalidate(abo, new_mem, evict);
</span> 
 	amdgpu_bo_kunmap(abo);
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h
index 218919fc13ec..c65463f66cb2 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h
</span><span
class="hunk">@@ -135,27 +135,6 @@ struct amdgpu_bo_vm {
</span> 	struct amdgpu_vm_bo_base        entries[];
 };
 
<span
class="del">-struct amdgpu_mem_stats {
-	/* current VRAM usage */
-	uint64_t vram;
-	/* current shared VRAM usage */
-	uint64_t vram_shared;
-	/* current GTT usage */
-	uint64_t gtt;
-	/* current shared GTT usage */
-	uint64_t gtt_shared;
-	/* current system memory usage */
-	uint64_t cpu;
-	/* current shared system memory usage */
-	uint64_t cpu_shared;
-	/* sum of evicted buffers */
-	uint64_t evicted_vram;
-	/* how much userspace asked for */
-	uint64_t requested_vram;
-	/* how much userspace asked for */
-	uint64_t requested_gtt;
-};
-
</span> static inline struct amdgpu_bo *ttm_to_amdgpu_bo(struct ttm_buffer_object *tbo)
 {
 	return container_of(tbo, struct amdgpu_bo, tbo);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
index 3abfa66d72a2..8dd239912bb9 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
</span><span
class="hunk">@@ -36,6 +36,7 @@
</span> #include &lt;drm/ttm/ttm_tt.h&gt;
 #include &lt;drm/drm_exec.h&gt;
 #include &#34;amdgpu.h&#34;
<span
class="add">+#include &#34;amdgpu_vm.h&#34;
</span> #include &#34;amdgpu_trace.h&#34;
 #include &#34;amdgpu_amdkfd.h&#34;
 #include &#34;amdgpu_gmc.h&#34;
<span
class="hunk">@@ -310,6 +311,111 @@ static void amdgpu_vm_bo_reset_state_machine(struct amdgpu_vm *vm)
</span> 	spin_unlock(&#38;vm-&gt;status_lock);
 }
 
<span
class="add">+static void amdgpu_vm_stats_update_shared(struct amdgpu_vm_bo_base *base,
+				      bool unshare)
+{
+	struct amdgpu_vm *vm = base-&gt;vm;
+	struct amdgpu_bo *bo = base-&gt;bo;
+	struct amdgpu_mem_stats *stats;
+	uint64_t size;
+
+	if (!vm || !bo)
+		return;
+
+	spin_lock(&#38;vm-&gt;status_lock);
+	stats = &#38;vm-&gt;stats;
+	size = amdgpu_bo_size(bo);
+	switch (bo-&gt;tbo.resource-&gt;mem_type) {
+	case TTM_PL_VRAM:
+		stats-&gt;vram_shared += unshare ? -size : size;
+		break;
+	case TTM_PL_TT:
+		stats-&gt;gtt_shared += unshare ? -size : size;
+		break;
+	case TTM_PL_SYSTEM:
+	default:
+		stats-&gt;cpu_shared += unshare ? -size : size;
+		break;
+	}
+	spin_unlock(&#38;vm-&gt;status_lock);
+}
+
+void amdgpu_vm_stats_update(struct amdgpu_vm_bo_base *base,
+			    struct ttm_resource *new_mem,
+			    struct ttm_resource *old_mem)
+{
+	struct amdgpu_vm *vm = base-&gt;vm;
+	struct amdgpu_bo *bo = base-&gt;bo;
+	struct amdgpu_mem_stats *stats;
+	uint64_t size;
+	bool shared;
+
+	if (!vm || !bo || (!new_mem &#38;&#38; !old_mem))
+		return;
+	spin_lock(&#38;vm-&gt;status_lock);
+
+	stats = &#38;vm-&gt;stats;
+	size = amdgpu_bo_size(bo);
+	shared = drm_gem_object_is_shared_for_memory_stats(&#38;bo-&gt;tbo.base);
+
+	if (old_mem) {
+		switch (old_mem-&gt;mem_type) {
+		case TTM_PL_VRAM:
+			stats-&gt;vram -= size;
+			if (shared)
+				stats-&gt;vram_shared -= size;
+			break;
+		case TTM_PL_TT:
+			stats-&gt;gtt -= size;
+			if (shared)
+				stats-&gt;gtt_shared -= size;
+			break;
+		case TTM_PL_SYSTEM:
+		default:
+			stats-&gt;cpu -= size;
+			if (shared)
+				stats-&gt;cpu_shared -= size;
+			break;
+		}
+	}
+	if (new_mem) {
+		switch (new_mem-&gt;mem_type) {
+		case TTM_PL_VRAM:
+			stats-&gt;vram += size;
+			if (shared)
+				stats-&gt;vram_shared += size;
+			break;
+		case TTM_PL_TT:
+			stats-&gt;gtt += size;
+			if (shared)
+				stats-&gt;gtt_shared += size;
+			break;
+		case TTM_PL_SYSTEM:
+		default:
+			stats-&gt;cpu += size;
+			if (shared)
+				stats-&gt;cpu_shared += size;
+			break;
+		}
+	}
+	if (bo-&gt;preferred_domains &#38; AMDGPU_GEM_DOMAIN_VRAM) {
+		if (!old_mem)
+			stats-&gt;requested_vram += size;
+		else if (old_mem-&gt;mem_type != TTM_PL_VRAM)
+			stats-&gt;evicted_vram -= size;
+		if (!new_mem)
+			stats-&gt;requested_vram -= size;
+		else if (new_mem-&gt;mem_type != TTM_PL_VRAM)
+			stats-&gt;evicted_vram += size;
+	} else if (bo-&gt;preferred_domains &#38; AMDGPU_GEM_DOMAIN_GTT) {
+		if (!old_mem)
+			stats-&gt;requested_gtt += size;
+		if (!new_mem)
+			stats-&gt;requested_gtt -= size;
+	}
+	spin_unlock(&#38;vm-&gt;status_lock);
+}
+
</span> /**
  * amdgpu_vm_bo_base_init - Adds bo to the list of bos associated with the vm
  *
<span
class="hunk">@@ -332,6 +438,7 @@ void amdgpu_vm_bo_base_init(struct amdgpu_vm_bo_base *base,
</span> 		return;
 	base-&gt;next = bo-&gt;vm_bo;
 	bo-&gt;vm_bo = base;
<span
class="add">+	amdgpu_vm_stats_update(base, bo-&gt;tbo.resource, NULL);
</span> 
 	if (!amdgpu_vm_is_bo_always_valid(vm, bo))
 		return;
<span
class="hunk">@@ -1088,51 +1195,11 @@ int amdgpu_vm_update_range(struct amdgpu_device *adev, struct amdgpu_vm *vm,
</span> 	return r;
 }
 
<span
class="del">-static void amdgpu_vm_bo_get_memory(struct amdgpu_bo_va *bo_va,
-				    struct amdgpu_mem_stats *stats)
-{
-	struct amdgpu_vm *vm = bo_va-&gt;base.vm;
-	struct amdgpu_bo *bo = bo_va-&gt;base.bo;
-
-	if (!bo)
-		return;
-
-	/*
-	 * For now ignore BOs which are currently locked and potentially
-	 * changing their location.
-	 */
-	if (!amdgpu_vm_is_bo_always_valid(vm, bo) &#38;&#38;
-	    !dma_resv_trylock(bo-&gt;tbo.base.resv))
-		return;
-
-	amdgpu_bo_get_memory(bo, stats);
-	if (!amdgpu_vm_is_bo_always_valid(vm, bo))
-		dma_resv_unlock(bo-&gt;tbo.base.resv);
-}
-
</span> void amdgpu_vm_get_memory(struct amdgpu_vm *vm,
 			  struct amdgpu_mem_stats *stats)
 {
<span
class="del">-	struct amdgpu_bo_va *bo_va, *tmp;
-
</span> 	spin_lock(&#38;vm-&gt;status_lock);
<span
class="del">-	list_for_each_entry_safe(bo_va, tmp, &#38;vm-&gt;idle, base.vm_status)
-		amdgpu_vm_bo_get_memory(bo_va, stats);
-
-	list_for_each_entry_safe(bo_va, tmp, &#38;vm-&gt;evicted, base.vm_status)
-		amdgpu_vm_bo_get_memory(bo_va, stats);
-
-	list_for_each_entry_safe(bo_va, tmp, &#38;vm-&gt;relocated, base.vm_status)
-		amdgpu_vm_bo_get_memory(bo_va, stats);
-
-	list_for_each_entry_safe(bo_va, tmp, &#38;vm-&gt;moved, base.vm_status)
-		amdgpu_vm_bo_get_memory(bo_va, stats);
-
-	list_for_each_entry_safe(bo_va, tmp, &#38;vm-&gt;invalidated, base.vm_status)
-		amdgpu_vm_bo_get_memory(bo_va, stats);
-
-	list_for_each_entry_safe(bo_va, tmp, &#38;vm-&gt;done, base.vm_status)
-		amdgpu_vm_bo_get_memory(bo_va, stats);
</span><span
class="add">+	*stats = vm-&gt;stats;
</span> 	spin_unlock(&#38;vm-&gt;status_lock);
 }
 
<span
class="hunk">@@ -2043,6 +2110,7 @@ void amdgpu_vm_bo_del(struct amdgpu_device *adev,
</span> 			if (*base != &#38;bo_va-&gt;base)
 				continue;
 
<span
class="add">+			amdgpu_vm_stats_update(*base, NULL, bo-&gt;tbo.resource);
</span> 			*base = bo_va-&gt;base.next;
 			break;
 		}
<span
class="hunk">@@ -2108,17 +2176,37 @@ bool amdgpu_vm_evictable(struct amdgpu_bo *bo)
</span> 	return true;
 }
 
<span
class="add">+/**
+ * amdgpu_vm_bo_handle_shared - called when bo gets shared/unshared
+ *
+ * @bo: amdgpu buffer object
+ * @unshare: bo got unshared
+ *
+ * For now the only thing this does is to update the per VM stats
+ */
+void amdgpu_vm_bo_handle_shared(struct amdgpu_bo *bo, bool unshare)
+{
+
+	struct amdgpu_vm_bo_base *bo_base;
+
+	if (bo-&gt;parent &#38;&#38; (amdgpu_bo_shadowed(bo-&gt;parent) == bo))
+		bo = bo-&gt;parent;
+
+	for (bo_base = bo-&gt;vm_bo; bo_base; bo_base = bo_base-&gt;next)
+		amdgpu_vm_stats_update_shared(bo_base, unshare);
+}
+
</span> /**
  * amdgpu_vm_bo_invalidate - mark the bo as invalid
  *
<span
class="del">- * @adev: amdgpu_device pointer
</span>  * @bo: amdgpu buffer object
<span
class="add">+ * @new_mem: the new placement of the BO move, NULL if just invalidate
</span>  * @evicted: is the BO evicted
  *
  * Mark @bo as invalid.
  */
<span
class="del">-void amdgpu_vm_bo_invalidate(struct amdgpu_device *adev,
-			     struct amdgpu_bo *bo, bool evicted)
</span><span
class="add">+void amdgpu_vm_bo_invalidate(struct amdgpu_bo *bo, struct ttm_resource *new_mem,
+			     bool evicted)
</span> {
 	struct amdgpu_vm_bo_base *bo_base;
 
<span
class="hunk">@@ -2129,6 +2217,9 @@ void amdgpu_vm_bo_invalidate(struct amdgpu_device *adev,
</span> 	for (bo_base = bo-&gt;vm_bo; bo_base; bo_base = bo_base-&gt;next) {
 		struct amdgpu_vm *vm = bo_base-&gt;vm;
 
<span
class="add">+		if (new_mem)
+			amdgpu_vm_stats_update(bo_base, new_mem, bo-&gt;tbo.resource);
+
</span> 		if (evicted &#38;&#38; amdgpu_vm_is_bo_always_valid(vm, bo)) {
 			amdgpu_vm_bo_evicted(bo_base);
 			continue;
<span
class="hunk">@@ -2640,6 +2731,10 @@ void amdgpu_vm_fini(struct amdgpu_device *adev, struct amdgpu_vm *vm)
</span> 		}
 	}
 
<span
class="add">+	if (memchr_inv(&#38;vm-&gt;stats, 0, sizeof(vm-&gt;stats)))
+		dev_err(adev-&gt;dev, &#34;VM memory stats is non-zero when fini\n&#34;);
+	else
+		dev_dbg(adev-&gt;dev, &#34;VM memory stats is zero when fini\n&#34;);
</span> }
 
 /**
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.h
index 046949c4b695..13e1ec4deb05 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.h
</span><span
class="hunk">@@ -42,7 +42,27 @@ struct amdgpu_bo_va;
</span> struct amdgpu_job;
 struct amdgpu_bo_list_entry;
 struct amdgpu_bo_vm;
<span
class="del">-struct amdgpu_mem_stats;
</span><span
class="add">+
+struct amdgpu_mem_stats {
+	/* current VRAM usage */
+	uint64_t vram;
+	/* current shared VRAM usage */
+	uint64_t vram_shared;
+	/* current GTT usage */
+	uint64_t gtt;
+	/* current shared GTT usage */
+	uint64_t gtt_shared;
+	/* current system memory usage */
+	uint64_t cpu;
+	/* current shared system memory usage */
+	uint64_t cpu_shared;
+	/* sum of evicted buffers */
+	uint64_t evicted_vram;
+	/* how much userspace asked for */
+	uint64_t requested_vram;
+	/* how much userspace asked for */
+	uint64_t requested_gtt;
+};
</span> 
 /*
  * GPUVM handling
<span
class="hunk">@@ -336,6 +356,8 @@ struct amdgpu_vm {
</span> 	/* Lock to protect vm_bo add/del/move on all lists of vm */
 	spinlock_t		status_lock;
 
<span
class="add">+	struct amdgpu_mem_stats stats;
+
</span> 	/* Per-VM and PT BOs who needs a validation */
 	struct list_head	evicted;
 
<span
class="hunk">@@ -514,8 +536,12 @@ int amdgpu_vm_bo_update(struct amdgpu_device *adev,
</span> 			struct amdgpu_bo_va *bo_va,
 			bool clear);
 bool amdgpu_vm_evictable(struct amdgpu_bo *bo);
<span
class="del">-void amdgpu_vm_bo_invalidate(struct amdgpu_device *adev,
-			     struct amdgpu_bo *bo, bool evicted);
</span><span
class="add">+void amdgpu_vm_stats_update(struct amdgpu_vm_bo_base *base,
+			    struct ttm_resource *new_mem,
+			    struct ttm_resource *old_mem);
+void amdgpu_vm_bo_handle_shared(struct amdgpu_bo *bo, bool unshare);
+void amdgpu_vm_bo_invalidate(struct amdgpu_bo *bo, struct ttm_resource *new_mem,
+			     bool evicted);
</span> uint64_t amdgpu_vm_map_gart(const dma_addr_t *pages_addr, uint64_t addr);
 struct amdgpu_bo_va *amdgpu_vm_bo_find(struct amdgpu_vm *vm,
 				       struct amdgpu_bo *bo);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm_pt.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm_pt.c
index e39d6e7643bf..841a575cb18d 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm_pt.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm_pt.c
</span><span
class="hunk">@@ -586,6 +586,7 @@ static void amdgpu_vm_pt_free(struct amdgpu_vm_bo_base *entry)
</span> 	if (!entry-&gt;bo)
 		return;
 
<span
class="add">+	amdgpu_vm_stats_update(entry, NULL, entry-&gt;bo-&gt;tbo.resource);
</span> 	entry-&gt;bo-&gt;vm_bo = NULL;
 	shadow = amdgpu_bo_shadowed(entry-&gt;bo);
 	if (shadow) {
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Deucher</name><email>alexander.deucher@amd.com</email></author><title>[PATCH] drm/amd/display: Fix Makefile copyright notices</title><updated>2024-06-24T13:58:52Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624135809.3089648-1-alexander.deucher@amd.com/"/><id>urn:uuid:6e8eee10-6788-bd6a-d6d4-bab042c21fe5</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Leftover copy pasta from original code.

Signed-off-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Cc: Harry.Wentland@amd.com
---
 drivers/gpu/drm/amd/display/dc/dcn301/Makefile | 11 ++---------
 drivers/gpu/drm/amd/display/dc/dcn31/Makefile  | 10 ++--------
 drivers/gpu/drm/amd/display/dc/dcn314/Makefile | 11 ++---------
 drivers/gpu/drm/amd/display/dc/dcn401/Makefile |  5 ++---
 4 files <a href="http://lore.kernel.org/amd-gfx/20240624135809.3089648-1-alexander.deucher@amd.com/#related">changed</a>, 8 insertions(+), 29 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dcn301/Makefile b/drivers/gpu/drm/amd/display/dc/dcn301/Makefile
index fadf5e872e38..dc37dbf870df 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn301/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dcn301/Makefile
</span><span
class="hunk">@@ -1,12 +1,5 @@
</span><span
class="del">-#
-# (c) Copyright 2020 Advanced Micro Devices, Inc. All the rights reserved
-#
-#  All rights reserved.  This notice is intended as a precaution against
-#  inadvertent publication and does not imply publication or any waiver
-#  of confidentiality.  The year included in the foregoing notice is the
-#  year of creation of the work.
-#
-#  Authors: AMD
</span><span
class="add">+# SPDX-License-Identifier: MIT
+# Copyright &#169; 2024 Advanced Micro Devices, Inc. All rights reserved.
</span> #
 # Makefile for dcn30.
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dcn31/Makefile b/drivers/gpu/drm/amd/display/dc/dcn31/Makefile
index 62c8ab0e45aa..d9816313c3b1 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn31/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dcn31/Makefile
</span><span
class="hunk">@@ -1,12 +1,6 @@
</span><span
class="add">+# SPDX-License-Identifier: MIT
+# Copyright &#169; 2024 Advanced Micro Devices, Inc. All rights reserved.
</span> #
<span
class="del">-# Copyright 2020 Advanced Micro Devices, Inc. All the rights reserved
-#
-#  All rights reserved.  This notice is intended as a precaution against
-#  inadvertent publication and does not imply publication or any waiver
-#  of confidentiality.  The year included in the foregoing notice is the
-#  year of creation of the work.
-#
-#  Authors: AMD
</span> #
 # Makefile for dcn31.
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dcn314/Makefile b/drivers/gpu/drm/amd/display/dc/dcn314/Makefile
index cac756c75b7f..15fdcf7c6466 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn314/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dcn314/Makefile
</span><span
class="hunk">@@ -1,12 +1,5 @@
</span><span
class="del">-#
-# (c) Copyright 2022 Advanced Micro Devices, Inc. All the rights reserved
-#
-#  All rights reserved.  This notice is intended as a precaution against
-#  inadvertent publication and does not imply publication or any waiver
-#  of confidentiality.  The year included in the foregoing notice is the
-#  year of creation of the work.
-#
-#  Authors: AMD
</span><span
class="add">+# SPDX-License-Identifier: MIT
+# Copyright &#169; 2024 Advanced Micro Devices, Inc. All rights reserved.
</span> #
 # Makefile for dcn314.
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dcn401/Makefile b/drivers/gpu/drm/amd/display/dc/dcn401/Makefile
index 2989e706bccf..ded1f3140beb 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn401/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dcn401/Makefile
</span><span
class="hunk">@@ -1,6 +1,5 @@
</span><span
class="del">-#
-# Copyright &#169; 2023 Advanced Micro Devices, Inc. All rights reserved.
-#
</span><span
class="add">+# SPDX-License-Identifier: MIT
+# Copyright &#169; 2024 Advanced Micro Devices, Inc. All rights reserved.
</span> 
 DCN401 += dcn401_dio_link_encoder.o
 DCN401 += dcn401_dio_stream_encoder.o
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Danijel Slivka</name><email>danijel.slivka@amd.com</email></author><title>[PATCH] drm/amdgpu: clear RB_OVERFLOW bit when enabling interrupts</title><updated>2024-06-24T09:57:48Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624100649.14971-1-danijel.slivka@amd.com/"/><id>urn:uuid:9c7388d4-26eb-3b78-e33f-845b4d2350f4</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Why:
Setting IH_RB_WPTR register to 0 will not clear the RB_OVERFLOW bit
if RB_ENABLE is not set.

How to fix:
Set WPTR_OVERFLOW_CLEAR bit after RB_ENABLE bit is set.
The RB_ENABLE bit is required to be set, together with
WPTR_OVERFLOW_ENABLE bit so that setting WPTR_OVERFLOW_CLEAR bit
would clear the RB_OVERFLOW.

Signed-off-by: Danijel Slivka &lt;danijel.slivka@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/ih_v6_0.c | 34 ++++++++++++++++++++++++++++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240624100649.14971-1-danijel.slivka@amd.com/#related">changed</a>, 34 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/ih_v6_0.c b/drivers/gpu/drm/amd/amdgpu/ih_v6_0.c
index 3cb64c8f7175..cbc70016f479 100644
--- a/drivers/gpu/drm/amd/amdgpu/ih_v6_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/ih_v6_0.c
</span><span
class="hunk">@@ -135,6 +135,40 @@ static int ih_v6_0_toggle_ring_interrupts(struct amdgpu_device *adev,
</span> 
 	tmp = RREG32(ih_regs-&gt;ih_rb_cntl);
 	tmp = REG_SET_FIELD(tmp, IH_RB_CNTL, RB_ENABLE, (enable ? 1 : 0));
<span
class="add">+
+	if (enable) {
+		/* Unset the CLEAR_OVERFLOW bit to make sure the next step
+		 * is switching the bit from 0 to 1
+		 */
+		tmp = REG_SET_FIELD(tmp, IH_RB_CNTL, WPTR_OVERFLOW_CLEAR, 0);
+		if (amdgpu_sriov_vf(adev) &#38;&#38; amdgpu_sriov_reg_indirect_ih(adev)) {
+			if (psp_reg_program(&#38;adev-&gt;psp, ih_regs-&gt;psp_reg_id, tmp))
+				return -ETIMEDOUT;
+		} else {
+			WREG32_NO_KIQ(ih_regs-&gt;ih_rb_cntl, tmp);
+		}
+
+		/* Clear RB_OVERFLOW bit */
+		tmp = REG_SET_FIELD(tmp, IH_RB_CNTL, WPTR_OVERFLOW_CLEAR, 1);
+		if (amdgpu_sriov_vf(adev) &#38;&#38; amdgpu_sriov_reg_indirect_ih(adev)) {
+			if (psp_reg_program(&#38;adev-&gt;psp, ih_regs-&gt;psp_reg_id, tmp))
+				return -ETIMEDOUT;
+		} else {
+			WREG32_NO_KIQ(ih_regs-&gt;ih_rb_cntl, tmp);
+		}
+
+		/* Unset the CLEAR_OVERFLOW bit immediately so new overflows
+		 * can be detected.
+		 */
+		tmp = REG_SET_FIELD(tmp, IH_RB_CNTL, WPTR_OVERFLOW_CLEAR, 0);
+		if (amdgpu_sriov_vf(adev) &#38;&#38; amdgpu_sriov_reg_indirect_ih(adev)) {
+			if (psp_reg_program(&#38;adev-&gt;psp, ih_regs-&gt;psp_reg_id, tmp))
+				return -ETIMEDOUT;
+		} else {
+			WREG32_NO_KIQ(ih_regs-&gt;ih_rb_cntl, tmp);
+		}
+	}
+
</span> 	/* enable_intr field is only valid in ring0 */
 	if (ih == &#38;adev-&gt;irq.ih)
 		tmp = REG_SET_FIELD(tmp, IH_RB_CNTL, ENABLE_INTR, (enable ? 1 : 0));
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Jane Jian</name><email>Jane.Jian@amd.com</email></author><title>[PATCH] drm/amdgpu: normalize registers as local xcc to read/write under sriov in TLB flush</title><updated>2024-06-24T09:13:29Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624091318.2487733-1-Jane.Jian@amd.com/"/><id>urn:uuid:d795dc3e-dfeb-aad2-5fa3-6e00bf45de1a</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHY]
sriov has the higher bit violation when flushing tlb

[HOW]
normalize the registers to keep lower 16-bit(dword aligned) to aviod higher bit violation
RLCG will mask xcd out and always assume it&#39;s accessing its own xcd

[TODO]
later will add the normalization in sriovw/rreg after fixing bugs

v2
rename the normalized macro, add ip block type for further use
move asics func declaration after ip block type since new func refers ip block type
add normalization in emit flush tlb as well

v3
declare the new func in the asic specific header

Signed-off-by: Jane Jian &lt;Jane.Jian@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu.h        | 112 +++++++++++----------
 drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c |  17 ++++
 drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.h |  28 ++++++
 drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c      |  32 ++++--
 drivers/gpu/drm/amd/amdgpu/soc15.c         |   2 +
 drivers/gpu/drm/amd/amdgpu/soc15_common.h  |   5 +-
 6 files <a href="http://lore.kernel.org/amd-gfx/20240624091318.2487733-1-Jane.Jian@amd.com/#related">changed</a>, 130 insertions(+), 66 deletions(-)
 create mode 100644 drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.h

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
index 083f353cff6e..070fd9e601fe 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
</span><span
class="hunk">@@ -583,61 +583,6 @@ struct amdgpu_video_codecs {
</span> 	const struct amdgpu_video_codec_info *codec_array;
 };
 
<span
class="del">-/*
- * ASIC specific functions.
- */
-struct amdgpu_asic_funcs {
-	bool (*read_disabled_bios)(struct amdgpu_device *adev);
-	bool (*read_bios_from_rom)(struct amdgpu_device *adev,
-				   u8 *bios, u32 length_bytes);
-	int (*read_register)(struct amdgpu_device *adev, u32 se_num,
-			     u32 sh_num, u32 reg_offset, u32 *value);
-	void (*set_vga_state)(struct amdgpu_device *adev, bool state);
-	int (*reset)(struct amdgpu_device *adev);
-	enum amd_reset_method (*reset_method)(struct amdgpu_device *adev);
-	/* get the reference clock */
-	u32 (*get_xclk)(struct amdgpu_device *adev);
-	/* MM block clocks */
-	int (*set_uvd_clocks)(struct amdgpu_device *adev, u32 vclk, u32 dclk);
-	int (*set_vce_clocks)(struct amdgpu_device *adev, u32 evclk, u32 ecclk);
-	/* static power management */
-	int (*get_pcie_lanes)(struct amdgpu_device *adev);
-	void (*set_pcie_lanes)(struct amdgpu_device *adev, int lanes);
-	/* get config memsize register */
-	u32 (*get_config_memsize)(struct amdgpu_device *adev);
-	/* flush hdp write queue */
-	void (*flush_hdp)(struct amdgpu_device *adev, struct amdgpu_ring *ring);
-	/* invalidate hdp read cache */
-	void (*invalidate_hdp)(struct amdgpu_device *adev,
-			       struct amdgpu_ring *ring);
-	/* check if the asic needs a full reset of if soft reset will work */
-	bool (*need_full_reset)(struct amdgpu_device *adev);
-	/* initialize doorbell layout for specific asic*/
-	void (*init_doorbell_index)(struct amdgpu_device *adev);
-	/* PCIe bandwidth usage */
-	void (*get_pcie_usage)(struct amdgpu_device *adev, uint64_t *count0,
-			       uint64_t *count1);
-	/* do we need to reset the asic at init time (e.g., kexec) */
-	bool (*need_reset_on_init)(struct amdgpu_device *adev);
-	/* PCIe replay counter */
-	uint64_t (*get_pcie_replay_count)(struct amdgpu_device *adev);
-	/* device supports BACO */
-	int (*supports_baco)(struct amdgpu_device *adev);
-	/* pre asic_init quirks */
-	void (*pre_asic_init)(struct amdgpu_device *adev);
-	/* enter/exit umd stable pstate */
-	int (*update_umd_stable_pstate)(struct amdgpu_device *adev, bool enter);
-	/* query video codecs */
-	int (*query_video_codecs)(struct amdgpu_device *adev, bool encode,
-				  const struct amdgpu_video_codecs **codecs);
-	/* encode &#34;&gt; 32bits&#34; smn addressing */
-	u64 (*encode_ext_smn_addressing)(int ext_id);
-
-	ssize_t (*get_reg_state)(struct amdgpu_device *adev,
-				 enum amdgpu_reg_state reg_state, void *buf,
-				 size_t max_size);
-};
-
</span> /*
  * IOCTL.
  */
<span
class="hunk">@@ -728,6 +673,63 @@ enum amd_hw_ip_block_type {
</span> 	MAX_HWIP
 };
 
<span
class="add">+/*
+ * ASIC specific functions.
+ */
+struct amdgpu_asic_funcs {
+	bool (*read_disabled_bios)(struct amdgpu_device *adev);
+	bool (*read_bios_from_rom)(struct amdgpu_device *adev,
+				   u8 *bios, u32 length_bytes);
+	int (*read_register)(struct amdgpu_device *adev, u32 se_num,
+			     u32 sh_num, u32 reg_offset, u32 *value);
+	void (*set_vga_state)(struct amdgpu_device *adev, bool state);
+	int (*reset)(struct amdgpu_device *adev);
+	enum amd_reset_method (*reset_method)(struct amdgpu_device *adev);
+	/* get the reference clock */
+	u32 (*get_xclk)(struct amdgpu_device *adev);
+	/* MM block clocks */
+	int (*set_uvd_clocks)(struct amdgpu_device *adev, u32 vclk, u32 dclk);
+	int (*set_vce_clocks)(struct amdgpu_device *adev, u32 evclk, u32 ecclk);
+	/* static power management */
+	int (*get_pcie_lanes)(struct amdgpu_device *adev);
+	void (*set_pcie_lanes)(struct amdgpu_device *adev, int lanes);
+	/* get config memsize register */
+	u32 (*get_config_memsize)(struct amdgpu_device *adev);
+	/* flush hdp write queue */
+	void (*flush_hdp)(struct amdgpu_device *adev, struct amdgpu_ring *ring);
+	/* invalidate hdp read cache */
+	void (*invalidate_hdp)(struct amdgpu_device *adev,
+			       struct amdgpu_ring *ring);
+	/* check if the asic needs a full reset of if soft reset will work */
+	bool (*need_full_reset)(struct amdgpu_device *adev);
+	/* initialize doorbell layout for specific asic*/
+	void (*init_doorbell_index)(struct amdgpu_device *adev);
+	/* PCIe bandwidth usage */
+	void (*get_pcie_usage)(struct amdgpu_device *adev, uint64_t *count0,
+			       uint64_t *count1);
+	/* do we need to reset the asic at init time (e.g., kexec) */
+	bool (*need_reset_on_init)(struct amdgpu_device *adev);
+	/* PCIe replay counter */
+	uint64_t (*get_pcie_replay_count)(struct amdgpu_device *adev);
+	/* device supports BACO */
+	int (*supports_baco)(struct amdgpu_device *adev);
+	/* pre asic_init quirks */
+	void (*pre_asic_init)(struct amdgpu_device *adev);
+	/* enter/exit umd stable pstate */
+	int (*update_umd_stable_pstate)(struct amdgpu_device *adev, bool enter);
+	/* query video codecs */
+	int (*query_video_codecs)(struct amdgpu_device *adev, bool encode,
+				  const struct amdgpu_video_codecs **codecs);
+	/* encode &#34;&gt; 32bits&#34; smn addressing */
+	u64 (*encode_ext_smn_addressing)(int ext_id);
+
+	ssize_t (*get_reg_state)(struct amdgpu_device *adev,
+				 enum amdgpu_reg_state reg_state, void *buf,
+				 size_t max_size);
+	/* normalize offset to keep in lower 16-bit */
+	u32 (*normalize_reg_offset)(enum amd_hw_ip_block_type hwip, u32 offset);
+};
+
</span> #define HWIP_MAX_INSTANCE	44
 
 #define HW_ID_MAX		300
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c b/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c
index 2c9a0aa41e2d..7cdd4b9d08ba 100644
--- a/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c
+++ b/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c
</span><span
class="hunk">@@ -29,6 +29,7 @@
</span> #include &#34;gfx_v9_4_3.h&#34;
 #include &#34;gfxhub_v1_2.h&#34;
 #include &#34;sdma_v4_4_2.h&#34;
<span
class="add">+#include &#34;aqua_vanjaram.h&#34;
</span> 
 #define XCP_INST_MASK(num_inst, xcp_id)                                        \
 	(num_inst ? GENMASK(num_inst - 1, 0) &lt;&lt; (xcp_id * num_inst) : 0)
<span
class="hunk">@@ -1085,3 +1086,19 @@ ssize_t aqua_vanjaram_get_reg_state(struct amdgpu_device *adev,
</span> 
 	return size;
 }
<span
class="add">+
+u32 aqua_vanjaram_normalize_reg_offset(enum amd_hw_ip_block_type hwip, u32 offset)
+{
+	u32 normalized_offset;
+
+	switch (hwip) {
+	case GC_HWIP:
+		normalized_offset = offset &#38; 0xffff;
+		break;
+	default:
+		normalized_offset = offset;
+		break;
+	}
+
+	return normalized_offset;
+}
</span><span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.h b/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.h
new file mode 100644
index 000000000000..8d1b7a89cb71
--- /dev/null
+++ b/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.h
</span><span
class="hunk">@@ -0,0 +1,28 @@
</span><span
class="add">+/*
+ * Copyright 2024 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &#34;Software&#34;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+#ifndef __AQUA_VANJARAM_H__
+#define __AQUA_VANJARAM_H__
+
+u32 aqua_vanjaram_normalize_reg_offset(enum amd_hw_ip_block_type hwip, u32 offset);
+
+#endif
</span>\ No newline at end of file
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
index 88b4644f8e96..19e4429db37c 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
</span><span
class="hunk">@@ -853,8 +853,12 @@ static void gmc_v9_0_flush_gpu_tlb(struct amdgpu_device *adev, uint32_t vmid,
</span> 	 */
 	if (adev-&gt;gfx.kiq[inst].ring.sched.ready &#38;&#38;
 	    (amdgpu_sriov_runtime(adev) || !amdgpu_sriov_vf(adev))) {
<span
class="del">-		uint32_t req = hub-&gt;vm_inv_eng0_req + hub-&gt;eng_distance * eng;
-		uint32_t ack = hub-&gt;vm_inv_eng0_ack + hub-&gt;eng_distance * eng;
</span><span
class="add">+
+		/* Select lower 16 bits to write in local xcc */
+		if (AMDGPU_IS_GFXHUB(vmhub)) {
+			req = NORMALIZE_XCC_REG_OFFSET(req);
+			ack = NORMALIZE_XCC_REG_OFFSET(ack);
+		}
</span> 
 		amdgpu_gmc_fw_reg_write_reg_wait(adev, req, ack, inv_req,
 						 1 &lt;&lt; vmid, inst);
<span
class="hunk">@@ -979,6 +983,7 @@ static uint64_t gmc_v9_0_emit_flush_gpu_tlb(struct amdgpu_ring *ring,
</span> 	struct amdgpu_vmhub *hub = &#38;adev-&gt;vmhub[ring-&gt;vm_hub];
 	uint32_t req = gmc_v9_0_get_invalidate_req(vmid, 0);
 	unsigned int eng = ring-&gt;vm_inv_eng;
<span
class="add">+	u32 low_distance, high_distance, req_offset, ack;
</span> 
 	/*
 	 * It may lose gpuvm invalidate acknowldege state across power-gating
<span
class="hunk">@@ -986,7 +991,18 @@ static uint64_t gmc_v9_0_emit_flush_gpu_tlb(struct amdgpu_ring *ring,
</span> 	 * release after invalidation to avoid entering power gated state
 	 * to WA the Issue
 	 */
<span
class="add">+	low_distance = hub-&gt;ctx0_ptb_addr_lo32 + (hub-&gt;ctx_addr_distance * vmid);
+	high_distance = hub-&gt;ctx0_ptb_addr_hi32 + (hub-&gt;ctx_addr_distance * vmid);
+	req_offset = hub-&gt;vm_inv_eng0_req + hub-&gt;eng_distance * eng;
+	ack = hub-&gt;vm_inv_eng0_ack + hub-&gt;eng_distance * eng;
</span> 
<span
class="add">+	/* Select lower 16 bits to write in local xcc */
+	if (AMDGPU_IS_GFXHUB(ring-&gt;vm_hub)) {
+		low_distance = NORMALIZE_XCC_REG_OFFSET(low_distance);
+		high_distance = NORMALIZE_XCC_REG_OFFSET(high_distance);
+		req_offset = NORMALIZE_XCC_REG_OFFSET(req_offset);
+		ack = NORMALIZE_XCC_REG_OFFSET(ack);
+	}
</span> 	/* TODO: It needs to continue working on debugging with semaphore for GFXHUB as well. */
 	if (use_semaphore)
 		/* a read return value of 1 means semaphore acuqire */
<span
class="hunk">@@ -994,18 +1010,14 @@ static uint64_t gmc_v9_0_emit_flush_gpu_tlb(struct amdgpu_ring *ring,
</span> 					  hub-&gt;vm_inv_eng0_sem +
 					  hub-&gt;eng_distance * eng, 0x1, 0x1);
 
<span
class="del">-	amdgpu_ring_emit_wreg(ring, hub-&gt;ctx0_ptb_addr_lo32 +
-			      (hub-&gt;ctx_addr_distance * vmid),
</span><span
class="add">+	amdgpu_ring_emit_wreg(ring, low_distance,
</span> 			      lower_32_bits(pd_addr));
 
<span
class="del">-	amdgpu_ring_emit_wreg(ring, hub-&gt;ctx0_ptb_addr_hi32 +
-			      (hub-&gt;ctx_addr_distance * vmid),
</span><span
class="add">+	amdgpu_ring_emit_wreg(ring, high_distance,
</span> 			      upper_32_bits(pd_addr));
 
<span
class="del">-	amdgpu_ring_emit_reg_write_reg_wait(ring, hub-&gt;vm_inv_eng0_req +
-					    hub-&gt;eng_distance * eng,
-					    hub-&gt;vm_inv_eng0_ack +
-					    hub-&gt;eng_distance * eng,
</span><span
class="add">+	amdgpu_ring_emit_reg_write_reg_wait(ring, req_offset,
+					    ack,
</span> 					    req, 1 &lt;&lt; vmid);
 
 	/* TODO: It needs to continue working on debugging with semaphore for GFXHUB as well. */
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/soc15.c b/drivers/gpu/drm/amd/amdgpu/soc15.c
index 8d16dacdc172..3a1fa2797f02 100644
--- a/drivers/gpu/drm/amd/amdgpu/soc15.c
+++ b/drivers/gpu/drm/amd/amdgpu/soc15.c
</span><span
class="hunk">@@ -78,6 +78,7 @@
</span> #include &#34;mxgpu_ai.h&#34;
 #include &#34;amdgpu_ras.h&#34;
 #include &#34;amdgpu_xgmi.h&#34;
<span
class="add">+#include &#34;aqua_vanjaram.h&#34;
</span> #include &lt;uapi/linux/kfd_ioctl.h&gt;
 
 #define mmMP0_MISC_CGTT_CTRL0                                                                   0x01b9
<span
class="hunk">@@ -927,6 +928,7 @@ static const struct amdgpu_asic_funcs aqua_vanjaram_asic_funcs =
</span> 	.query_video_codecs = &#38;soc15_query_video_codecs,
 	.encode_ext_smn_addressing = &#38;aqua_vanjaram_encode_ext_smn_addressing,
 	.get_reg_state = &#38;aqua_vanjaram_get_reg_state,
<span
class="add">+	.normalize_reg_offset = &#38;aqua_vanjaram_normalize_reg_offset,
</span> };
 
 static int soc15_common_early_init(void *handle)
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/soc15_common.h b/drivers/gpu/drm/amd/amdgpu/soc15_common.h
index 242b24f73c17..01afd1a24e8b 100644
--- a/drivers/gpu/drm/amd/amdgpu/soc15_common.h
+++ b/drivers/gpu/drm/amd/amdgpu/soc15_common.h
</span><span
class="hunk">@@ -210,4 +210,7 @@
</span> #define WREG64_MCA(ext, mca_base, idx, val) \
 	WREG64_PCIE_EXT(adev-&gt;asic_funcs-&gt;encode_ext_smn_addressing(ext) + mca_base + (idx * 8), val)
 
<span
class="del">-#endif
</span><span
class="add">+#define NORMALIZE_XCC_REG_OFFSET(offset) \
+	((amdgpu_sriov_vf(adev) &#38;&#38; adev-&gt;asic_funcs-&gt;normalize_reg_offset) ? \
+	adev-&gt;asic_funcs-&gt;normalize_reg_offset(GC_HWIP, offset) : offset)
+#endif
</span>\ No newline at end of file
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Christian K&#246;nig</name><email>ckoenig.leichtzumerken@gmail.com</email></author><title
type="html">[PATCH] drm/amdgpu: revert allow write access to mapped userptrs&#34;</title><updated>2024-06-24T09:10:58Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624091040.1623473-1-christian.koenig@amd.com/"/><id>urn:uuid:188d4ed5-0775-36de-adc4-6f9bffcbb161</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This reverts commit 358c258a816baed4c6997b59c2117578a1360498.

Jerome actually pointed out why that stuff doesn&#39;t work in 2016:
<a
href="https://lists.freedesktop.org/archives/dri-devel/2016-March/103062.html">https://lists.freedesktop.org/archives/dri-devel/2016-March/103062.html</a>

Unfortunately the revert somehow got lost.

Signed-off-by: Christian K&#246;nig &lt;christian.koenig@amd.com&gt;
Fixes: 358c258a816baed4c6997b59c2117578a1360498
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c | 8 +++++---
 1 file <a href="http://lore.kernel.org/amd-gfx/20240624091040.1623473-1-christian.koenig@amd.com/#related">changed</a>, 5 insertions(+), 3 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
index 3adaa4670103..331969b96a5a 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
</span><span
class="hunk">@@ -433,10 +433,12 @@ int amdgpu_gem_userptr_ioctl(struct drm_device *dev, void *data,
</span> 	    AMDGPU_GEM_USERPTR_REGISTER))
 		return -EINVAL;
 
<span
class="del">-	if (!(args-&gt;flags &#38; AMDGPU_GEM_USERPTR_READONLY) &#38;&#38;
-	     !(args-&gt;flags &#38; AMDGPU_GEM_USERPTR_REGISTER)) {
</span><span
class="add">+	if (!(args-&gt;flags &#38; AMDGPU_GEM_USERPTR_READONLY) &#38;&#38; (
+	     !(args-&gt;flags &#38; AMDGPU_GEM_USERPTR_ANONONLY) ||
+	     !(args-&gt;flags &#38; AMDGPU_GEM_USERPTR_REGISTER))) {
</span> 
<span
class="del">-		/* if we want to write to it we must install a MMU notifier */
</span><span
class="add">+		/* if we want to write to it we must require anonymous
+		   memory and install a MMU notifier */
</span> 		return -EACCES;
 	}
 
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Danijel Slivka</name><email>danijel.slivka@amd.com</email></author><title>[PATCH] drm/amdgpu: clear RB_OVERFLOW bit if detected when enabling interrupts</title><updated>2024-06-24T06:50:04Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624065854.17711-1-danijel.slivka@amd.com/"/><id>urn:uuid:d0550c60-bf36-0dd9-d05f-eb4db6ee0cea</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Why:
Setting IH_RB_WPTR register to 0 will not clear the RB_OVERFLOW bit
if RB_ENABLE is not set.

How to fix:
Set WPTR_OVERFLOW_CLEAR bit after RB_ENABLE bit is set.
The RB_ENABLE bit is required to be set, together with
WPTR_OVERFLOW_ENABLE bit so that setting WPTR_OVERFLOW_CLEAR bit
would clear the RB_OVERFLOW.

Signed-off-by: Danijel Slivka &lt;danijel.slivka@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/ih_v6_0.c | 23 +++++++++++++++++++++++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240624065854.17711-1-danijel.slivka@amd.com/#related">changed</a>, 23 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/ih_v6_0.c b/drivers/gpu/drm/amd/amdgpu/ih_v6_0.c
index 3cb64c8f7175..44872a8ce6a2 100644
--- a/drivers/gpu/drm/amd/amdgpu/ih_v6_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/ih_v6_0.c
</span><span
class="hunk">@@ -135,6 +135,29 @@ static int ih_v6_0_toggle_ring_interrupts(struct amdgpu_device *adev,
</span> 
 	tmp = RREG32(ih_regs-&gt;ih_rb_cntl);
 	tmp = REG_SET_FIELD(tmp, IH_RB_CNTL, RB_ENABLE, (enable ? 1 : 0));
<span
class="add">+
+	if (enable &#38;&#38; REG_GET_FIELD(RREG32_NO_KIQ(ih_regs-&gt;ih_rb_wptr), IH_RB_WPTR, RB_OVERFLOW)) {
+		/* Clear RB_OVERFLOW bit if detected */
+		tmp = REG_SET_FIELD(tmp, IH_RB_CNTL, WPTR_OVERFLOW_CLEAR, 1);
+		if (amdgpu_sriov_vf(adev) &#38;&#38; amdgpu_sriov_reg_indirect_ih(adev)) {
+			if (psp_reg_program(&#38;adev-&gt;psp, ih_regs-&gt;psp_reg_id, tmp))
+				return -ETIMEDOUT;
+		} else {
+			WREG32_NO_KIQ(ih_regs-&gt;ih_rb_cntl, tmp);
+		}
+
+		/* Unset the CLEAR_OVERFLOW bit immediately so new overflows
+		 * can be detected.
+		 */
+		tmp = REG_SET_FIELD(tmp, IH_RB_CNTL, WPTR_OVERFLOW_CLEAR, 0);
+		if (amdgpu_sriov_vf(adev) &#38;&#38; amdgpu_sriov_reg_indirect_ih(adev)) {
+			if (psp_reg_program(&#38;adev-&gt;psp, ih_regs-&gt;psp_reg_id, tmp))
+				return -ETIMEDOUT;
+		} else {
+			WREG32_NO_KIQ(ih_regs-&gt;ih_rb_cntl, tmp);
+		}
+	}
+
</span> 	/* enable_intr field is only valid in ring0 */
 	if (ih == &#38;adev-&gt;irq.ih)
 		tmp = REG_SET_FIELD(tmp, IH_RB_CNTL, ENABLE_INTR, (enable ? 1 : 0));
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Vignesh Chander</name><email>Vignesh.Chander@amd.com</email></author><title>[PATCH] drm/amdgpu: drop kiq access while in reset</title><updated>2024-06-24T06:31:32Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624063109.655690-1-Vignesh.Chander@amd.com/"/><id>urn:uuid:b9358f21-51ee-2a62-e520-d844e27df236</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">correctly handle the case when trylock fails when gpu is
about to be reset by dropping the request instead of using mmio

Signed-off-by: Vignesh Chander &lt;Vignesh.Chander@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_device.c | 38 ++++++++++++----------
 1 file <a href="http://lore.kernel.org/amd-gfx/20240624063109.655690-1-Vignesh.Chander@amd.com/#related">changed</a>, 21 insertions(+), 17 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
index a7ce8280b17ce7..3cfd24699d691d 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
</span><span
class="hunk">@@ -613,10 +613,11 @@ uint32_t amdgpu_device_rreg(struct amdgpu_device *adev,
</span> 
 	if ((reg * 4) &lt; adev-&gt;rmmio_size) {
 		if (!(acc_flags &#38; AMDGPU_REGS_NO_KIQ) &#38;&#38;
<span
class="del">-		    amdgpu_sriov_runtime(adev) &#38;&#38;
-		    down_read_trylock(&#38;adev-&gt;reset_domain-&gt;sem)) {
-			ret = amdgpu_kiq_rreg(adev, reg, 0);
-			up_read(&#38;adev-&gt;reset_domain-&gt;sem);
</span><span
class="add">+		    amdgpu_sriov_runtime(adev) {
+			if (down_read_trylock(&#38;adev-&gt;reset_domain-&gt;sem)) {
+				ret = amdgpu_kiq_rreg(adev, reg, 0);
+				up_read(&#38;adev-&gt;reset_domain-&gt;sem);
+			}
</span> 		} else {
 			ret = readl(((void __iomem *)adev-&gt;rmmio) + (reg * 4));
 		}
<span
class="hunk">@@ -681,10 +682,11 @@ uint32_t amdgpu_device_xcc_rreg(struct amdgpu_device *adev,
</span> 							 &#38;rlcg_flag)) {
 			ret = amdgpu_virt_rlcg_reg_rw(adev, reg, 0, rlcg_flag, GET_INST(GC, xcc_id));
 		} else if (!(acc_flags &#38; AMDGPU_REGS_NO_KIQ) &#38;&#38;
<span
class="del">-		    amdgpu_sriov_runtime(adev) &#38;&#38;
-		    down_read_trylock(&#38;adev-&gt;reset_domain-&gt;sem)) {
-			ret = amdgpu_kiq_rreg(adev, reg, xcc_id);
-			up_read(&#38;adev-&gt;reset_domain-&gt;sem);
</span><span
class="add">+		    amdgpu_sriov_runtime(adev) {
+			if (down_read_trylock(&#38;adev-&gt;reset_domain-&gt;sem)) {
+				ret = amdgpu_kiq_rreg(adev, reg, xcc_id);
+				up_read(&#38;adev-&gt;reset_domain-&gt;sem);
+			}
</span> 		} else {
 			ret = readl(((void __iomem *)adev-&gt;rmmio) + (reg * 4));
 		}
<span
class="hunk">@@ -740,10 +742,11 @@ void amdgpu_device_wreg(struct amdgpu_device *adev,
</span> 
 	if ((reg * 4) &lt; adev-&gt;rmmio_size) {
 		if (!(acc_flags &#38; AMDGPU_REGS_NO_KIQ) &#38;&#38;
<span
class="del">-		    amdgpu_sriov_runtime(adev) &#38;&#38;
-		    down_read_trylock(&#38;adev-&gt;reset_domain-&gt;sem)) {
-			amdgpu_kiq_wreg(adev, reg, v, 0);
-			up_read(&#38;adev-&gt;reset_domain-&gt;sem);
</span><span
class="add">+		    amdgpu_sriov_runtime(adev) {
+			if (down_read_trylock(&#38;adev-&gt;reset_domain-&gt;sem)) {
+				amdgpu_kiq_wreg(adev, reg, v, 0);
+				up_read(&#38;adev-&gt;reset_domain-&gt;sem);
+			}
</span> 		} else {
 			writel(v, ((void __iomem *)adev-&gt;rmmio) + (reg * 4));
 		}
<span
class="hunk">@@ -812,11 +815,12 @@ void amdgpu_device_xcc_wreg(struct amdgpu_device *adev,
</span> 							 &#38;rlcg_flag)) {
 			amdgpu_virt_rlcg_reg_rw(adev, reg, v, rlcg_flag, GET_INST(GC, xcc_id));
 		} else if (!(acc_flags &#38; AMDGPU_REGS_NO_KIQ) &#38;&#38;
<span
class="del">-		    amdgpu_sriov_runtime(adev) &#38;&#38;
-		    down_read_trylock(&#38;adev-&gt;reset_domain-&gt;sem)) {
-			amdgpu_kiq_wreg(adev, reg, v, xcc_id);
-			up_read(&#38;adev-&gt;reset_domain-&gt;sem);
-		} else {
</span><span
class="add">+		    amdgpu_sriov_runtime(adev) {
+			if (down_read_trylock(&#38;adev-&gt;reset_domain-&gt;sem)) {
+				amdgpu_kiq_wreg(adev, reg, v, xcc_id);
+				up_read(&#38;adev-&gt;reset_domain-&gt;sem);
+			}
+		    } else {
</span> 			writel(v, ((void __iomem *)adev-&gt;rmmio) + (reg * 4));
 		}
 	} else {
-- 
2.25.1

</pre></div></content></entry><entry><author><name>Jiapeng Chong</name><email>jiapeng.chong@linux.alibaba.com</email></author><title>[PATCH] drm/amd/display: Use ARRAY_SIZE for array length</title><updated>2024-06-24T07:42:26Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624031158.98502-1-jiapeng.chong@linux.alibaba.com/"/><id>urn:uuid:6c91ea00-1b2b-207f-5362-8dbdee933e1f</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Use of macro ARRAY_SIZE to calculate array size minimizes
the redundant code and improves code reusability.

./drivers/gpu/drm/amd/display/modules/hdcp/hdcp_ddc.c:164:45-46: WARNING: Use ARRAY_SIZE.
./drivers/gpu/drm/amd/display/modules/hdcp/hdcp_ddc.c:183:47-48: WARNING: Use ARRAY_SIZE.
./drivers/gpu/drm/amd/display/modules/hdcp/hdcp_ddc.c:237:45-46: WARNING: Use ARRAY_SIZE.
./drivers/gpu/drm/amd/display/modules/hdcp/hdcp_ddc.c:257:47-48: WARNING: Use ARRAY_SIZE.

Reported-by: Abaci Robot &lt;abaci@linux.alibaba.com&gt;
Closes: <a
href="https://bugzilla.openanolis.cn/show_bug.cgi?id=9405">https://bugzilla.openanolis.cn/show_bug.cgi?id=9405</a>
Signed-off-by: Jiapeng Chong &lt;jiapeng.chong@linux.alibaba.com&gt;
---
 drivers/gpu/drm/amd/display/modules/hdcp/hdcp_ddc.c | 12 ++++--------
 1 file <a href="http://lore.kernel.org/amd-gfx/20240624031158.98502-1-jiapeng.chong@linux.alibaba.com/#related">changed</a>, 4 insertions(+), 8 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/modules/hdcp/hdcp_ddc.c b/drivers/gpu/drm/amd/display/modules/hdcp/hdcp_ddc.c
index 1b2df97226a3..7ecf76aea950 100644
--- a/drivers/gpu/drm/amd/display/modules/hdcp/hdcp_ddc.c
+++ b/drivers/gpu/drm/amd/display/modules/hdcp/hdcp_ddc.c
</span><span
class="hunk">@@ -161,8 +161,7 @@ static enum mod_hdcp_status read(struct mod_hdcp *hdcp,
</span> 		return MOD_HDCP_STATUS_DDC_FAILURE;
 
 	if (is_dp_hdcp(hdcp)) {
<span
class="del">-		int num_dpcd_addrs = sizeof(hdcp_dpcd_addrs) /
-			sizeof(hdcp_dpcd_addrs[0]);
</span><span
class="add">+		int num_dpcd_addrs = ARRAY_SIZE(hdcp_dpcd_addrs);
</span> 		if (msg_id &gt;= num_dpcd_addrs)
 			return MOD_HDCP_STATUS_DDC_FAILURE;
 
<span
class="hunk">@@ -180,8 +179,7 @@ static enum mod_hdcp_status read(struct mod_hdcp *hdcp,
</span> 			data_offset += cur_size;
 		}
 	} else {
<span
class="del">-		int num_i2c_offsets = sizeof(hdcp_i2c_offsets) /
-			sizeof(hdcp_i2c_offsets[0]);
</span><span
class="add">+		int num_i2c_offsets = ARRAY_SIZE(hdcp_i2c_offsets);
</span> 		if (msg_id &gt;= num_i2c_offsets)
 			return MOD_HDCP_STATUS_DDC_FAILURE;
 
<span
class="hunk">@@ -234,8 +232,7 @@ static enum mod_hdcp_status write(struct mod_hdcp *hdcp,
</span> 		return MOD_HDCP_STATUS_DDC_FAILURE;
 
 	if (is_dp_hdcp(hdcp)) {
<span
class="del">-		int num_dpcd_addrs = sizeof(hdcp_dpcd_addrs) /
-			sizeof(hdcp_dpcd_addrs[0]);
</span><span
class="add">+		int num_dpcd_addrs = ARRAY_SIZE(hdcp_dpcd_addrs);
</span> 		if (msg_id &gt;= num_dpcd_addrs)
 			return MOD_HDCP_STATUS_DDC_FAILURE;
 
<span
class="hunk">@@ -254,8 +251,7 @@ static enum mod_hdcp_status write(struct mod_hdcp *hdcp,
</span> 			data_offset += cur_size;
 		}
 	} else {
<span
class="del">-		int num_i2c_offsets = sizeof(hdcp_i2c_offsets) /
-			sizeof(hdcp_i2c_offsets[0]);
</span><span
class="add">+		int num_i2c_offsets = ARRAY_SIZE(hdcp_i2c_offsets);
</span> 		if (msg_id &gt;= num_i2c_offsets)
 			return MOD_HDCP_STATUS_DDC_FAILURE;
 
-- 
2.20.1.7.g153144c

</pre></div></content></entry><entry><author><name>Ma Ke</name><email>make24@iscas.ac.cn</email></author><title>[PATCH] drm/amd/display: Check pipe_ctx before it is used</title><updated>2024-06-24T07:42:23Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624024835.2278651-1-make24@iscas.ac.cn/"/><id>urn:uuid:764b2e2f-e928-bd55-579d-c4d01fbc07b7</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">resource_get_otg_master_for_stream() could return NULL, we
should check the return value of &#39;otg_master&#39; before it is
used in resource_log_pipe_for_stream().

Signed-off-by: Ma Ke &lt;make24@iscas.ac.cn&gt;
---
 drivers/gpu/drm/amd/display/dc/core/dc_resource.c | 2 ++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240624024835.2278651-1-make24@iscas.ac.cn/#related">changed</a>, 2 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 15819416a2f3..597ca9f369c6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
</span><span
class="hunk">@@ -2279,6 +2279,8 @@ void resource_log_pipe_topology_update(struct dc *dc, struct dc_state *state)
</span> 					state-&gt;stream_status[stream_idx].mall_stream_config.paired_stream);
 			otg_master = resource_get_otg_master_for_stream(
 					&#38;state-&gt;res_ctx, state-&gt;streams[phantom_stream_idx]);
<span
class="add">+			if (!otg_master)
+				continue;
</span> 			resource_log_pipe_for_stream(dc, state, otg_master, stream_idx);
 		}
 	}
-- 
2.25.1

</pre></div></content></entry><entry><author><name>Jiapeng Chong</name><email>jiapeng.chong@linux.alibaba.com</email></author><title>[PATCH] drm/amd/display: Remove unused function reverse_planes_order</title><updated>2024-06-24T07:42:26Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624022225.28655-1-jiapeng.chong@linux.alibaba.com/"/><id>urn:uuid:2602b244-dfb2-3847-c728-802eaf9f31ce</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The function are defined in the amdgpu_dm.c file, but not called
anywhere, so delete the unused function.

drivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm.c:371:20: warning: unused function &#39;reverse_planes_order&#39;.

Reported-by: Abaci Robot &lt;abaci@linux.alibaba.com&gt;
Closes: <a
href="https://bugzilla.openanolis.cn/show_bug.cgi?id=9402">https://bugzilla.openanolis.cn/show_bug.cgi?id=9402</a>
Signed-off-by: Jiapeng Chong &lt;jiapeng.chong@linux.alibaba.com&gt;
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c | 9 ---------
 1 file <a href="http://lore.kernel.org/amd-gfx/20240624022225.28655-1-jiapeng.chong@linux.alibaba.com/#related">changed</a>, 9 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index 4b86b30eddc4..1e0e33b565f1 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
</span><span
class="hunk">@@ -368,15 +368,6 @@ static inline bool is_dc_timing_adjust_needed(struct dm_crtc_state *old_state,
</span> 		return false;
 }
 
<span
class="del">-static inline void reverse_planes_order(struct dc_surface_update *array_of_surface_update,
-					int planes_count)
-{
-	int i, j;
-
-	for (i = 0, j = planes_count - 1; i &lt; j; i++, j--)
-		swap(array_of_surface_update[i], array_of_surface_update[j]);
-}
-
</span> /*
  * DC will program planes with their z-order determined by their ordering
  * in the dc_surface_updates array. This comparator is used to sort them
-- 
2.20.1.7.g153144c

</pre></div></content></entry><entry><author><name>Jiapeng Chong</name><email>jiapeng.chong@linux.alibaba.com</email></author><title>[PATCH] drm/amd/display: use swap() in is_config_schedulable()</title><updated>2024-06-24T07:42:32Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240624015707.121287-1-jiapeng.chong@linux.alibaba.com/"/><id>urn:uuid:3a9db8c6-92b8-ffd3-9edc-fc4bc9c0e9da</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Use existing swap() function rather than duplicating its implementation.

./drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c:1171:103-104: WARNING opportunity for swap().
./drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c:1231:99-100: WARNING opportunity for swap().

Reported-by: Abaci Robot &lt;abaci@linux.alibaba.com&gt;
Closes: <a
href="https://bugzilla.openanolis.cn/show_bug.cgi?id=9400">https://bugzilla.openanolis.cn/show_bug.cgi?id=9400</a>
Signed-off-by: Jiapeng Chong &lt;jiapeng.chong@linux.alibaba.com&gt;
---
 .../dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c  | 11 ++++-------
 1 file <a href="http://lore.kernel.org/amd-gfx/20240624015707.121287-1-jiapeng.chong@linux.alibaba.com/#related">changed</a>, 4 insertions(+), 7 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c b/drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c
index 7272a04b9d1d..926d45496e79 100644
--- a/drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c
+++ b/drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c
</span><span
class="hunk">@@ -1158,7 +1158,6 @@ static bool is_config_schedulable(
</span> 	schedulable = true;
 
 	/* sort disallow times from greatest to least */
<span
class="del">-	unsigned int temp;
</span> 	for (i = 0; i &lt; s-&gt;pmo_dcn4.num_timing_groups; i++) {
 		bool swapped = false;
 
<span
class="hunk">@@ -1167,9 +1166,8 @@ static bool is_config_schedulable(
</span> 			double jp1_disallow_us = s-&gt;pmo_dcn4.group_common_fams2_meta[s-&gt;pmo_dcn4.sorted_group_gtl_disallow_index[j + 1]].disallow_time_us;
 			if (j_disallow_us &lt; jp1_disallow_us) {
 				/* swap as A &lt; B */
<span
class="del">-				temp = s-&gt;pmo_dcn4.sorted_group_gtl_disallow_index[j];
-				s-&gt;pmo_dcn4.sorted_group_gtl_disallow_index[j] = s-&gt;pmo_dcn4.sorted_group_gtl_disallow_index[j + 1];
-				s-&gt;pmo_dcn4.sorted_group_gtl_disallow_index[j + 1] = temp;
</span><span
class="add">+				swap(s-&gt;pmo_dcn4.sorted_group_gtl_disallow_index[j],
+				     s-&gt;pmo_dcn4.sorted_group_gtl_disallow_index[j+1]);
</span> 				swapped = true;
 			}
 		}
<span
class="hunk">@@ -1227,9 +1225,8 @@ static bool is_config_schedulable(
</span> 			double jp1_period_us = s-&gt;pmo_dcn4.group_common_fams2_meta[s-&gt;pmo_dcn4.sorted_group_gtl_period_index[j + 1]].period_us;
 			if (j_period_us &lt; jp1_period_us) {
 				/* swap as A &lt; B */
<span
class="del">-				temp = s-&gt;pmo_dcn4.sorted_group_gtl_period_index[j];
-				s-&gt;pmo_dcn4.sorted_group_gtl_period_index[j] = s-&gt;pmo_dcn4.sorted_group_gtl_period_index[j + 1];
-				s-&gt;pmo_dcn4.sorted_group_gtl_period_index[j + 1] = temp;
</span><span
class="add">+				swap(s-&gt;pmo_dcn4.sorted_group_gtl_period_index[j],
+				     s-&gt;pmo_dcn4.sorted_group_gtl_period_index[j+1]);
</span> 				swapped = true;
 			}
 		}
-- 
2.20.1.7.g153144c

</pre></div></content></entry><entry><author><name>Ma Ke</name><email>make24@iscas.ac.cn</email></author><title>[PATCH] drm/amd/display: Add otg_master NULL check within init_pipe_slice_table_from_context</title><updated>2024-06-24T07:42:25Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240623133252.2136231-1-make24@iscas.ac.cn/"/><id>urn:uuid:3c9e5ba1-0a1a-1720-6a3d-828c2f3bac3a</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">To avoid reports of NULL_RETURN warning, we should add
otg_master NULL check.

Signed-off-by: Ma Ke &lt;make24@iscas.ac.cn&gt;
---
 drivers/gpu/drm/amd/display/dc/dml/dcn32/dcn32_fpu.c | 2 ++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240623133252.2136231-1-make24@iscas.ac.cn/#related">changed</a>, 2 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml/dcn32/dcn32_fpu.c b/drivers/gpu/drm/amd/display/dc/dml/dcn32/dcn32_fpu.c
index f6fe0a64beac..20f0951b00f1 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/dcn32/dcn32_fpu.c
+++ b/drivers/gpu/drm/amd/display/dc/dml/dcn32/dcn32_fpu.c
</span><span
class="hunk">@@ -1177,6 +1177,8 @@ static void init_pipe_slice_table_from_context(
</span> 		stream = context-&gt;streams[i];
 		otg_master = resource_get_otg_master_for_stream(
 				&#38;context-&gt;res_ctx, stream);
<span
class="add">+		if (!otg_master)
+			continue;
</span> 		count = resource_get_odm_slice_count(otg_master);
 		update_slice_table_for_stream(table, stream, count);
 
-- 
2.25.1

</pre></div></content></entry><entry><author><name>Thomas Wei&#223;schuh</name><email>linux@weissschuh.net</email></author><title>[PATCH v2 2/3] drm: panel-backlight-quirks: Add Framework 13 matte panel</title><updated>2024-06-24T07:42:33Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240623-amdgpu-min-backlight-quirk-v2-2-cecf7f49da9b@weissschuh.net/"/><id>urn:uuid:56662a9e-6604-18b1-bd4e-b30d1a410782</id><thr:in-reply-to
ref="urn:uuid:c794e76c-7f4d-4f50-4bc8-b651453123f1"
href="http://lore.kernel.org/amd-gfx/20240623-amdgpu-min-backlight-quirk-v2-0-cecf7f49da9b@weissschuh.net/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The value of &#34;min_input_signal&#34; returned from ATIF on a Framework AMD 13
is &#34;12&#34;. This leads to a fairly bright minimum display backlight.

Add a quirk to override that the minimum backlight PWM to &#34;0&#34; which
leads to a much lower minimum brightness, which is still visible.

Tested on a Framework AMD 13 BIOS 3.05 with the matte panel.

Link: <a
href="https://community.frame.work/t/25711/9">https://community.frame.work/t/25711/9</a>
Link: <a
href="https://community.frame.work/t/47036">https://community.frame.work/t/47036</a>
Signed-off-by: Thomas Wei&#223;schuh &lt;linux@weissschuh.net&gt;
---
 drivers/gpu/drm/drm_panel_backlight_quirks.c | 9 +++++++++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240623-amdgpu-min-backlight-quirk-v2-2-cecf7f49da9b@weissschuh.net/#related">changed</a>, 9 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/drm_panel_backlight_quirks.c b/drivers/gpu/drm/drm_panel_backlight_quirks.c
index a89b5fd1940e..e7671b1ba885 100644
--- a/drivers/gpu/drm/drm_panel_backlight_quirks.c
+++ b/drivers/gpu/drm/drm_panel_backlight_quirks.c
</span><span
class="hunk">@@ -17,6 +17,15 @@ struct drm_panel_backlight_entry {
</span> };
 
 static const struct drm_panel_backlight_entry drm_panel_backlight_entries[] = {
<span
class="add">+	/* 13 inch matte panel */
+	{
+		.dmi_match.field = DMI_BOARD_VENDOR,
+		.dmi_match.value = &#34;Framework&#34;,
+		.ident.panel_id = drm_edid_encode_panel_id(&#39;B&#39;, &#39;O&#39;, &#39;E&#39;, 0x0bca),
+		.ident.name = &#34;NE135FBM-N41&#34;,
+		.quirk.overrides.pwm_min_brightness = true,
+		.quirk.pwm_min_brightness = 0,
+	},
</span> };
 
 static bool drm_panel_backlight_entry_matches(const struct drm_panel_backlight_entry *entry,

-- 
2.45.2

</pre></div></content></entry><entry><author><name>Thomas Wei&#223;schuh</name><email>linux@weissschuh.net</email></author><title>[PATCH v2 0/3] drm: backlight quirk infrastructure and lower minimum for Framework AMD 13</title><updated>2024-06-24T07:42:21Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240623-amdgpu-min-backlight-quirk-v2-0-cecf7f49da9b@weissschuh.net/"/><id>urn:uuid:c794e76c-7f4d-4f50-4bc8-b651453123f1</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The value of &#34;min_input_signal&#34; returned from ATIF on a Framework AMD 13
is &#34;12&#34;. This leads to a fairly bright minimum display backlight.

Add a generic quirk infrastructure for backlight configuration to
override the settings provided by the firmware.
Also add amdgpu as a user of that infrastructure and a quirk for the
Framework 13 matte panel.
Most likely this will also work for the glossy panel, but I can&#39;t test
that.

One solution would be a fixed firmware version, but given that the
problem exists since the release of the hardware, it has been known for
a month that the hardware can go lower and there was no acknowledgment
from Framework in any way, I&#39;d like to explore this alternative
way forward.

Notes:

* Should the quirk infrastructure be part of drm_edid.c?
* The current allocation of struct drm_edid in amdgpu is bad.
  But it is done the same way in other parts of amdgpu.
  I do have patches migrating amdgpu to proper usage of struct drm_edid [0]

Mario:

I intentionally left out the consideration of the firmware version.
The quirk will stay correct even if the firmware starts reporting
correct values.
If there are strong opinions it would be easy to add, though.

Based on amdgpu/drm-next.

[0] <a
href="https://lore.kernel.org/lkml/20240616-amdgpu-edid-bios-v1-1-2874f212b365@weissschuh.net/">https://lore.kernel.org/lkml/20240616-amdgpu-edid-bios-v1-1-2874f212b365@weissschuh.net/</a>

---
Changes in v2:
- Introduce proper drm backlight quirk infrastructure
- Quirk by EDID and DMI instead of only DMI
- Limit quirk to only single Framework 13 matte panel
- Link to v1: <a
href="https://lore.kernel.org/r/20240610-amdgpu-min-backlight-quirk-v1-1-8459895a5b2a@weissschuh.net">https://lore.kernel.org/r/20240610-amdgpu-min-backlight-quirk-v1-1-8459895a5b2a@weissschuh.net</a>

---
Thomas Wei&#223;schuh (3):
      drm: Add panel backlight quirks
      drm: panel-backlight-quirks: Add Framework 13 matte panel
      drm/amd/display: Add support backlight quirks

 Documentation/gpu/drm-kms-helpers.rst             |  3 +
 drivers/gpu/drm/Kconfig                           |  4 ++
 drivers/gpu/drm/Makefile                          |  1 +
 drivers/gpu/drm/amd/amdgpu/Kconfig                |  1 +
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c | 28 +++++++++
 drivers/gpu/drm/drm_panel_backlight_quirks.c      | 76 +++++++++++++++++++++++
 include/drm/drm_utils.h                           | 11 ++++
 7 files changed, 124 insertions(+)
---
base-commit: 1ecef5589320fd56af599b624d59c355d162ac7b
change-id: 20240610-amdgpu-min-backlight-quirk-8402fd8e736a

Best regards,
-- 
Thomas Wei&#223;schuh &lt;linux@weissschuh.net&gt;

</pre></div></content></entry><entry><author><name>Thomas Wei&#223;schuh</name><email>linux@weissschuh.net</email></author><title>[PATCH v2 1/3] drm: Add panel backlight quirks</title><updated>2024-06-24T07:42:33Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240623-amdgpu-min-backlight-quirk-v2-1-cecf7f49da9b@weissschuh.net/"/><id>urn:uuid:b01b4045-6ea9-889b-aaab-ebae4e0498f8</id><thr:in-reply-to
ref="urn:uuid:c794e76c-7f4d-4f50-4bc8-b651453123f1"
href="http://lore.kernel.org/amd-gfx/20240623-amdgpu-min-backlight-quirk-v2-0-cecf7f49da9b@weissschuh.net/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Panels using a PWM-controlled backlight source without an do not have a
standard way to communicate their valid PWM ranges.
On x86 the ranges are read from ACPI through driver-specific tables.
The built-in ranges are not necessarily correct, or may grow stale if an
older device can be retrofitted with newer panels.

Add a quirk infrastructure with which the valid backlight ranges can be
maintained as part of the kernel.

Signed-off-by: Thomas Wei&#223;schuh &lt;linux@weissschuh.net&gt;
---
 Documentation/gpu/drm-kms-helpers.rst        |  3 ++
 drivers/gpu/drm/Kconfig                      |  4 ++
 drivers/gpu/drm/Makefile                     |  1 +
 drivers/gpu/drm/drm_panel_backlight_quirks.c | 67 ++++++++++++++++++++++++++++
 include/drm/drm_utils.h                      | 11 +++++
 5 files <a href="http://lore.kernel.org/amd-gfx/20240623-amdgpu-min-backlight-quirk-v2-1-cecf7f49da9b@weissschuh.net/#related">changed</a>, 86 insertions(+)

<span
class="head">diff --git a/Documentation/gpu/drm-kms-helpers.rst b/Documentation/gpu/drm-kms-helpers.rst
index 59cfe8a7a8ba..1998a2675210 100644
--- a/Documentation/gpu/drm-kms-helpers.rst
+++ b/Documentation/gpu/drm-kms-helpers.rst
</span><span
class="hunk">@@ -224,6 +224,9 @@ Panel Helper Reference
</span> .. kernel-doc:: drivers/gpu/drm/drm_panel_orientation_quirks.c
    :export:
 
<span
class="add">+.. kernel-doc:: drivers/gpu/drm/drm_panel_backlight_quirks.c
+   :export:
+
</span> Panel Self Refresh Helper Reference
 ===================================
 
<span
class="head">diff --git a/drivers/gpu/drm/Kconfig b/drivers/gpu/drm/Kconfig
index 959b19a04101..50ccb43315bf 100644
--- a/drivers/gpu/drm/Kconfig
+++ b/drivers/gpu/drm/Kconfig
</span><span
class="hunk">@@ -443,6 +443,10 @@ config DRM_EXPORT_FOR_TESTS
</span> config DRM_PANEL_ORIENTATION_QUIRKS
 	tristate
 
<span
class="add">+# Separate option as not all DRM drivers use it
+config DRM_PANEL_BACKLIGHT_QUIRKS
+	tristate
+
</span> config DRM_LIB_RANDOM
 	bool
 	default n
<span
class="head">diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index f9ca4f8fa6c5..6669913b907e 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
</span><span
class="hunk">@@ -92,6 +92,7 @@ drm-$(CONFIG_DRM_PANIC) += drm_panic.o
</span> obj-$(CONFIG_DRM)	+= drm.o
 
 obj-$(CONFIG_DRM_PANEL_ORIENTATION_QUIRKS) += drm_panel_orientation_quirks.o
<span
class="add">+obj-$(CONFIG_DRM_PANEL_BACKLIGHT_QUIRKS) += drm_panel_backlight_quirks.o
</span> 
 #
 # Memory-management helpers
<span
class="head">diff --git a/drivers/gpu/drm/drm_panel_backlight_quirks.c b/drivers/gpu/drm/drm_panel_backlight_quirks.c
new file mode 100644
index 000000000000..a89b5fd1940e
--- /dev/null
+++ b/drivers/gpu/drm/drm_panel_backlight_quirks.c
</span><span
class="hunk">@@ -0,0 +1,67 @@
</span><span
class="add">+// SPDX-License-Identifier: GPL-2.0
+
+#include &lt;linux/array_size.h&gt;
+#include &lt;linux/dmi.h&gt;
+#include &lt;linux/mod_devicetable.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;drm/drm_connector.h&gt;
+#include &lt;drm/drm_utils.h&gt;
+
+struct drm_panel_backlight_entry {
+	struct {
+		enum dmi_field field;
+		const char * const value;
+	} dmi_match;
+	struct drm_edid_ident ident;
+	struct drm_panel_backlight_quirk quirk;
+};
+
+static const struct drm_panel_backlight_entry drm_panel_backlight_entries[] = {
+};
+
+static bool drm_panel_backlight_entry_matches(const struct drm_panel_backlight_entry *entry,
+					      const struct drm_edid *edid)
+{
+	if (!dmi_match(entry-&gt;dmi_match.field, entry-&gt;dmi_match.value))
+		return false;
+
+	if (!drm_edid_match(edid, &#38;entry-&gt;ident))
+		return false;
+
+	return true;
+}
+
+/**
+ * drm_get_panel_panel_quirk - Check for panel backlight quirks
+ * @edid: EDID of the panel to check
+ *
+ * This function checks for platform specific (e.g. DMI based) quirks
+ * providing info on backlight control for systems where this cannot be
+ * probed from the hard-/firm-ware.
+ *
+ * Returns:
+ * A struct drm_panel_backlight_quirk if a quirk is found or NULL otherwise.
+ */
+const struct drm_panel_backlight_quirk *drm_get_panel_backlight_quirk(const struct drm_edid *edid)
+{
+	const struct drm_panel_backlight_entry *entry;
+	size_t i;
+
+	if (!IS_ENABLED(CONFIG_DMI))
+		return NULL;
+
+	if (!edid)
+		return NULL;
+
+	for (i = 0; i &lt; ARRAY_SIZE(drm_panel_backlight_entries); i++) {
+		entry = &#38;drm_panel_backlight_entries[i];
+
+		if (drm_panel_backlight_entry_matches(entry, edid))
+			return &#38;entry-&gt;quirk;
+	}
+
+	return NULL;
+}
+EXPORT_SYMBOL(drm_get_panel_backlight_quirk);
+
+MODULE_LICENSE(&#34;GPL&#34;);
</span><span
class="head">diff --git a/include/drm/drm_utils.h b/include/drm/drm_utils.h
index 70775748d243..37cc6de1a01a 100644
--- a/include/drm/drm_utils.h
+++ b/include/drm/drm_utils.h
</span><span
class="hunk">@@ -11,9 +11,20 @@
</span> #define __DRM_UTILS_H__
 
 #include &lt;linux/types.h&gt;
<span
class="add">+#include &lt;drm/drm_edid.h&gt;
+
+struct drm_panel_backlight_quirk {
+	struct {
+		bool pwm_min_brightness:1;
+	} overrides;
+
+	u8 pwm_min_brightness; /* min_brightness/255 of max */
+};
</span> 
 int drm_get_panel_orientation_quirk(int width, int height);
 
<span
class="add">+const struct drm_panel_backlight_quirk *drm_get_panel_backlight_quirk(const struct drm_edid *edid);
+
</span> signed long drm_timeout_abs_to_jiffies(int64_t timeout_nsec);
 
 #endif

-- 
2.45.2

</pre></div></content></entry><entry><author><name>Thomas Wei&#223;schuh</name><email>linux@weissschuh.net</email></author><title>[PATCH v2 3/3] drm/amd/display: Add support backlight quirks</title><updated>2024-06-24T07:42:24Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240623-amdgpu-min-backlight-quirk-v2-3-cecf7f49da9b@weissschuh.net/"/><id>urn:uuid:50428a30-1021-9be5-85a8-7d3a2bd0f546</id><thr:in-reply-to
ref="urn:uuid:c794e76c-7f4d-4f50-4bc8-b651453123f1"
href="http://lore.kernel.org/amd-gfx/20240623-amdgpu-min-backlight-quirk-v2-0-cecf7f49da9b@weissschuh.net/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Not all platforms provide correct PWM backlight capabilities through ATIF.
Use the generic drm backlight quirk infrastructure to override the
capabilities where necessary.

Signed-off-by: Thomas Wei&#223;schuh &lt;linux@weissschuh.net&gt;
---
 drivers/gpu/drm/amd/amdgpu/Kconfig                |  1 +
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c | 28 +++++++++++++++++++++++
 2 files <a href="http://lore.kernel.org/amd-gfx/20240623-amdgpu-min-backlight-quirk-v2-3-cecf7f49da9b@weissschuh.net/#related">changed</a>, 29 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/Kconfig b/drivers/gpu/drm/amd/amdgpu/Kconfig
index 692fa7cf8fd2..4fe0e8e74bb9 100644
--- a/drivers/gpu/drm/amd/amdgpu/Kconfig
+++ b/drivers/gpu/drm/amd/amdgpu/Kconfig
</span><span
class="hunk">@@ -25,6 +25,7 @@ config DRM_AMDGPU
</span> 	select DRM_BUDDY
 	select DRM_SUBALLOC_HELPER
 	select DRM_EXEC
<span
class="add">+	select DRM_PANEL_BACKLIGHT_QUIRKS
</span> 	# amdgpu depends on ACPI_VIDEO when ACPI is enabled, for select to work
 	# ACPI_VIDEO&#39;s dependencies must also be selected.
 	select INPUT if ACPI
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index 60404385d4d0..2d8a6d875170 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
</span><span
class="hunk">@@ -93,6 +93,7 @@
</span> #include &lt;drm/drm_fourcc.h&gt;
 #include &lt;drm/drm_edid.h&gt;
 #include &lt;drm/drm_eld.h&gt;
<span
class="add">+#include &lt;drm/drm_utils.h&gt;
</span> #include &lt;drm/drm_vblank.h&gt;
 #include &lt;drm/drm_audio_component.h&gt;
 #include &lt;drm/drm_gem_atomic_helper.h&gt;
<span
class="hunk">@@ -3329,6 +3330,31 @@ static struct drm_mode_config_helper_funcs amdgpu_dm_mode_config_helperfuncs = {
</span> 	.atomic_commit_setup = drm_dp_mst_atomic_setup_commit,
 };
 
<span
class="add">+static void amdgpu_dm_apply_backlight_quirks(struct amdgpu_dm_connector *aconnector,
+					     struct amdgpu_dm_backlight_caps *caps)
+{
+	const struct drm_panel_backlight_quirk *quirk;
+	const struct drm_edid *edid;
+
+	edid = drm_edid_alloc(aconnector-&gt;edid, EDID_LENGTH * (aconnector-&gt;edid-&gt;extensions + 1));
+	if (!edid)
+		return;
+
+	quirk = drm_get_panel_backlight_quirk(edid);
+
+	drm_edid_free(edid);
+
+	if (!quirk)
+		return;
+
+	if (quirk-&gt;overrides.pwm_min_brightness &#38;&#38;
+	    caps-&gt;min_input_signal != quirk-&gt;pwm_min_brightness) {
+		drm_info(aconnector-&gt;base.dev,
+			 &#34;Quirk: backlight min_input_signal=%d\n&#34;, quirk-&gt;pwm_min_brightness);
+		caps-&gt;min_input_signal = quirk-&gt;pwm_min_brightness;
+	}
+}
+
</span> static void update_connector_ext_caps(struct amdgpu_dm_connector *aconnector)
 {
 	struct amdgpu_dm_backlight_caps *caps;
<span
class="hunk">@@ -3369,6 +3395,8 @@ static void update_connector_ext_caps(struct amdgpu_dm_connector *aconnector)
</span> 		caps-&gt;aux_min_input_signal = 0;
 		caps-&gt;aux_max_input_signal = 512;
 	}
<span
class="add">+
+	amdgpu_dm_apply_backlight_quirks(aconnector, caps);
</span> }
 
 void amdgpu_dm_update_connector_after_detect(

-- 
2.45.2

</pre></div></content></entry><entry><author><name>Dmitry Baryshkov</name><email>dmitry.baryshkov@linaro.org</email></author><title>[PATCH v5] drm/display: split DSC helpers from DP helpers</title><updated>2024-06-22T22:44:25Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240623-panel-sw43408-fix-v5-1-5401ab61e738@linaro.org/"/><id>urn:uuid:8f15f3af-ccbb-dd4b-cd9f-0bea5149ba9c</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Currently the DRM DSC functions are selected by the
DRM_DISPLAY_DP_HELPER Kconfig symbol. This is not optimal, since the DSI
code (both panel and host drivers) end up selecting the seemingly
irrelevant DP helpers. Split the DSC code to be guarded by the separate
DRM_DISPLAY_DSC_HELPER Kconfig symbol.

Reviewed-by: Jessica Zhang &lt;quic_jesszhan@quicinc.com&gt;
Reviewed-by: Marijn Suijten &lt;marijn.suijten@somainline.org&gt;
Signed-off-by: Dmitry Baryshkov &lt;dmitry.baryshkov@linaro.org&gt;
---
To: Alex Deucher &lt;alexander.deucher@amd.com&gt;
To: Christian K&#246;nig &lt;christian.koenig@amd.com&gt;
To: Pan, Xinhui &lt;Xinhui.Pan@amd.com&gt;
To: David Airlie &lt;airlied@gmail.com&gt;
To: Daniel Vetter &lt;daniel@ffwll.ch&gt;
To: Maarten Lankhorst &lt;maarten.lankhorst@linux.intel.com&gt;
To: Maxime Ripard &lt;mripard@kernel.org&gt;
To: Thomas Zimmermann &lt;tzimmermann@suse.de&gt;
To: Jani Nikula &lt;jani.nikula@linux.intel.com&gt;
To: Joonas Lahtinen &lt;joonas.lahtinen@linux.intel.com&gt;
To: Rodrigo Vivi &lt;rodrigo.vivi@intel.com&gt;
To: Tvrtko Ursulin &lt;tursulin@ursulin.net&gt;
To: Rob Clark &lt;robdclark@gmail.com&gt;
To: Abhinav Kumar &lt;quic_abhinavk@quicinc.com&gt;
To: Sean Paul &lt;sean@poorly.run&gt;
To: Marijn Suijten &lt;marijn.suijten@somainline.org&gt;
To: Neil Armstrong &lt;neil.armstrong@linaro.org&gt;
To: Jessica Zhang &lt;quic_jesszhan@quicinc.com&gt;
Cc: amd-gfx@lists.freedesktop.org
Cc: dri-devel@lists.freedesktop.org
Cc: linux-kernel@vger.kernel.org
Cc: intel-gfx@lists.freedesktop.org
Cc: linux-arm-msm@vger.kernel.org
Cc: freedreno@lists.freedesktop.org
Signed-off-by: Dmitry Baryshkov &lt;dmitry.baryshkov@linaro.org&gt;

Changes in v5:
- Drop applied patches
- Link to v4: <a
href="https://lore.kernel.org/r/20240528-panel-sw43408-fix-v4-0-330b42445bcc@linaro.org">https://lore.kernel.org/r/20240528-panel-sw43408-fix-v4-0-330b42445bcc@linaro.org</a>

Changes in v4:
- Reoder patches so that fixes come first, to be able to land them to
  drm-misc-fixes
- Link to v3: <a
href="https://lore.kernel.org/r/20240522-panel-sw43408-fix-v3-0-6902285adcc0@linaro.org">https://lore.kernel.org/r/20240522-panel-sw43408-fix-v3-0-6902285adcc0@linaro.org</a>

Changes in v3:
- Split DRM_DISPLAY_DSC_HELPER from DRM_DISPLAY_DP_HELPER
- Added missing Fixes tags
- Link to v2: <a
href="https://lore.kernel.org/r/20240510-panel-sw43408-fix-v2-0-d1ef91ee1b7d@linaro.org">https://lore.kernel.org/r/20240510-panel-sw43408-fix-v2-0-d1ef91ee1b7d@linaro.org</a>

Changes in v2:
- use SELECT instead of DEPEND to follow the reverted Kconfig changes
- Link to v1: <a
href="https://lore.kernel.org/r/20240420-panel-sw43408-fix-v1-0-b282ff725242@linaro.org">https://lore.kernel.org/r/20240420-panel-sw43408-fix-v1-0-b282ff725242@linaro.org</a>
---
 drivers/gpu/drm/amd/amdgpu/Kconfig | 1 +
 drivers/gpu/drm/display/Kconfig    | 6 ++++++
 drivers/gpu/drm/display/Makefile   | 3 ++-
 drivers/gpu/drm/i915/Kconfig       | 1 +
 drivers/gpu/drm/msm/Kconfig        | 1 +
 drivers/gpu/drm/panel/Kconfig      | 6 +++---
 6 files <a href="http://lore.kernel.org/amd-gfx/20240623-panel-sw43408-fix-v5-1-5401ab61e738@linaro.org/#related">changed</a>, 14 insertions(+), 4 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/Kconfig b/drivers/gpu/drm/amd/amdgpu/Kconfig
index 4232ab27f990..5933ca8c6b96 100644
--- a/drivers/gpu/drm/amd/amdgpu/Kconfig
+++ b/drivers/gpu/drm/amd/amdgpu/Kconfig
</span><span
class="hunk">@@ -6,6 +6,7 @@ config DRM_AMDGPU
</span> 	depends on !UML
 	select FW_LOADER
 	select DRM_DISPLAY_DP_HELPER
<span
class="add">+	select DRM_DISPLAY_DSC_HELPER
</span> 	select DRM_DISPLAY_HDMI_HELPER
 	select DRM_DISPLAY_HDCP_HELPER
 	select DRM_DISPLAY_HELPER
<span
class="head">diff --git a/drivers/gpu/drm/display/Kconfig b/drivers/gpu/drm/display/Kconfig
index 479e62690d75..a2e42014ffe0 100644
--- a/drivers/gpu/drm/display/Kconfig
+++ b/drivers/gpu/drm/display/Kconfig
</span><span
class="hunk">@@ -59,6 +59,12 @@ config DRM_DISPLAY_DP_TUNNEL_STATE_DEBUG
</span> 
 	  If in doubt, say &#34;N&#34;.
 
<span
class="add">+config DRM_DISPLAY_DSC_HELPER
+	bool
+	depends on DRM_DISPLAY_HELPER
+	help
+	  DRM display helpers for VESA DSC (used by DSI and DisplayPort).
+
</span> config DRM_DISPLAY_HDCP_HELPER
 	bool
 	depends on DRM_DISPLAY_HELPER
<span
class="head">diff --git a/drivers/gpu/drm/display/Makefile b/drivers/gpu/drm/display/Makefile
index 629df2f4d322..df8f22c7e916 100644
--- a/drivers/gpu/drm/display/Makefile
+++ b/drivers/gpu/drm/display/Makefile
</span><span
class="hunk">@@ -6,7 +6,8 @@ drm_display_helper-y := drm_display_helper_mod.o
</span> drm_display_helper-$(CONFIG_DRM_DISPLAY_DP_HELPER) += \
 	drm_dp_dual_mode_helper.o \
 	drm_dp_helper.o \
<span
class="del">-	drm_dp_mst_topology.o \
</span><span
class="add">+	drm_dp_mst_topology.o
+drm_display_helper-$(CONFIG_DRM_DISPLAY_DSC_HELPER) += \
</span> 	drm_dsc_helper.o
 drm_display_helper-$(CONFIG_DRM_DISPLAY_DP_TUNNEL) += \
 	drm_dp_tunnel.o
<span
class="head">diff --git a/drivers/gpu/drm/i915/Kconfig b/drivers/gpu/drm/i915/Kconfig
index faa253b27664..db400aad88fa 100644
--- a/drivers/gpu/drm/i915/Kconfig
+++ b/drivers/gpu/drm/i915/Kconfig
</span><span
class="hunk">@@ -11,6 +11,7 @@ config DRM_I915
</span> 	select SHMEM
 	select TMPFS
 	select DRM_DISPLAY_DP_HELPER
<span
class="add">+	select DRM_DISPLAY_DSC_HELPER
</span> 	select DRM_DISPLAY_HDCP_HELPER
 	select DRM_DISPLAY_HDMI_HELPER
 	select DRM_DISPLAY_HELPER
<span
class="head">diff --git a/drivers/gpu/drm/msm/Kconfig b/drivers/gpu/drm/msm/Kconfig
index 1931ecf73e32..6dcd26180611 100644
--- a/drivers/gpu/drm/msm/Kconfig
+++ b/drivers/gpu/drm/msm/Kconfig
</span><span
class="hunk">@@ -111,6 +111,7 @@ config DRM_MSM_DSI
</span> 	depends on DRM_MSM
 	select DRM_PANEL
 	select DRM_MIPI_DSI
<span
class="add">+	select DRM_DISPLAY_DSC_HELPER
</span> 	default y
 	help
 	  Choose this option if you have a need for MIPI DSI connector
<span
class="head">diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index bf4eadfe21cb..afae8b130e9a 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
</span><span
class="hunk">@@ -349,7 +349,7 @@ config DRM_PANEL_LG_SW43408
</span> 	depends on OF
 	depends on DRM_MIPI_DSI
 	depends on BACKLIGHT_CLASS_DEVICE
<span
class="del">-	select DRM_DISPLAY_DP_HELPER
</span><span
class="add">+	select DRM_DISPLAY_DSC_HELPER
</span> 	select DRM_DISPLAY_HELPER
 	help
 	  Say Y here if you want to enable support for LG sw43408 panel.
<span
class="hunk">@@ -558,7 +558,7 @@ config DRM_PANEL_RAYDIUM_RM692E5
</span> 	depends on OF
 	depends on DRM_MIPI_DSI
 	depends on BACKLIGHT_CLASS_DEVICE
<span
class="del">-	select DRM_DISPLAY_DP_HELPER
</span><span
class="add">+	select DRM_DISPLAY_DSC_HELPER
</span> 	select DRM_DISPLAY_HELPER
 	help
 	  Say Y here if you want to enable support for Raydium RM692E5-based
<span
class="hunk">@@ -916,7 +916,7 @@ config DRM_PANEL_VISIONOX_R66451
</span> 	depends on OF
 	depends on DRM_MIPI_DSI
 	depends on BACKLIGHT_CLASS_DEVICE
<span
class="del">-	select DRM_DISPLAY_DP_HELPER
</span><span
class="add">+	select DRM_DISPLAY_DSC_HELPER
</span> 	select DRM_DISPLAY_HELPER
 	help
 	  Say Y here if you want to enable support for Visionox

<span
class="del">---
</span>base-commit: 2102cb0d050d34d50b9642a3a50861787527e922
change-id: 20240420-panel-sw43408-fix-ff6549c121be

Best regards,
-- 
Dmitry Baryshkov &lt;dmitry.baryshkov@linaro.org&gt;

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH 1/1] drm/atomic: Allow userspace to use explicit sync with atomic async flips</title><updated>2024-06-22T17:10:19Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240622170951.738735-1-andrealmeid@igalia.com/"/><id>urn:uuid:dca4bc27-3dd4-baa5-22e5-45df8d460598</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Allow userspace to use explicit synchronization with atomic async flips.
That means that the flip will wait for some hardware fence, and then
will flip as soon as possible (async) in regard of the vblank.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---

This patch is originally from a patchset, but it doesn&#39;t really depends on the
rest of the work, so I&#39;m sending it standalone now.

Original thread: <a
href="https://lore.kernel.org/dri-devel/20240618030024.500532-1-andrealmeid@igalia.com/">https://lore.kernel.org/dri-devel/20240618030024.500532-1-andrealmeid@igalia.com/</a>

 drivers/gpu/drm/drm_atomic_uapi.c | 4 +++-
 1 file <a href="http://lore.kernel.org/amd-gfx/20240622170951.738735-1-andrealmeid@igalia.com/#related">changed</a>, 3 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/drm_atomic_uapi.c b/drivers/gpu/drm/drm_atomic_uapi.c
index 22bbb2d83e30..2e1d9391febe 100644
--- a/drivers/gpu/drm/drm_atomic_uapi.c
+++ b/drivers/gpu/drm/drm_atomic_uapi.c
</span><span
class="hunk">@@ -1070,7 +1070,9 @@ int drm_atomic_set_property(struct drm_atomic_state *state,
</span> 			break;
 		}
 
<span
class="del">-		if (async_flip &#38;&#38; prop != config-&gt;prop_fb_id) {
</span><span
class="add">+		if (async_flip &#38;&#38;
+		    prop != config-&gt;prop_fb_id &#38;&#38;
+		    prop != config-&gt;prop_in_fence_fd) {
</span> 			ret = drm_atomic_plane_get_property(plane, plane_state,
 							    prop, &#38;old_val);
 			ret = drm_atomic_check_prop_changes(ret, old_val, prop_value, prop);
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Rajneesh Bhardwaj</name><email>rajneesh.bhardwaj@amd.com</email></author><title
type="html">[Patch v2 2/2] drm/amdgpu: Don&#39;t warn for compute mode switch under SRIOV</title><updated>2024-06-22T15:48:12Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240622154751.632271-2-rajneesh.bhardwaj@amd.com/"/><id>urn:uuid:4a3900d5-c972-d1d3-5d58-077409c19ba6</id><thr:in-reply-to
ref="urn:uuid:1d1ec00d-5940-b0a1-cb96-ad47443fabae"
href="http://lore.kernel.org/amd-gfx/20240622154751.632271-1-rajneesh.bhardwaj@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Under SRIOV environment, the compute partition mode is setup by the
host driver so state machine cached copy might be different when doing
the transition for the first time.

Signed-off-by: Rajneesh Bhardwaj &lt;rajneesh.bhardwaj@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_xcp.c | 3 ++-
 1 file <a href="http://lore.kernel.org/amd-gfx/20240622154751.632271-2-rajneesh.bhardwaj@amd.com/#related">changed</a>, 2 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_xcp.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_xcp.c
index 2b99eed5ba19..c4a9669bceb0 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_xcp.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_xcp.c
</span><span
class="hunk">@@ -228,7 +228,8 @@ int amdgpu_xcp_query_partition_mode(struct amdgpu_xcp_mgr *xcp_mgr, u32 flags)
</span> 	if (!(flags &#38; AMDGPU_XCP_FL_LOCKED))
 		mutex_lock(&#38;xcp_mgr-&gt;xcp_lock);
 	mode = xcp_mgr-&gt;funcs-&gt;query_partition_mode(xcp_mgr);
<span
class="del">-	if (xcp_mgr-&gt;mode != AMDGPU_XCP_MODE_TRANS &#38;&#38; mode != xcp_mgr-&gt;mode)
</span><span
class="add">+	if (xcp_mgr-&gt;mode != AMDGPU_XCP_MODE_TRANS &#38;&#38; mode != xcp_mgr-&gt;mode
+	    &#38;&#38; !amdgpu_sriov_vf(xcp_mgr-&gt;adev))
</span> 		dev_WARN(
 			xcp_mgr-&gt;adev-&gt;dev,
 			&#34;Cached partition mode %d not matching with device mode %d&#34;,
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Rajneesh Bhardwaj</name><email>rajneesh.bhardwaj@amd.com</email></author><title>[Patch v2 1/2] drm/amdgpu: Disable compute partition switch under SRIOV</title><updated>2024-06-22T15:48:10Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240622154751.632271-1-rajneesh.bhardwaj@amd.com/"/><id>urn:uuid:1d1ec00d-5940-b0a1-cb96-ad47443fabae</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Do not allow the compute partition mode switch from the guest driver but
still allow the query for current_compute_partition.

Signed-off-by: Rajneesh Bhardwaj &lt;rajneesh.bhardwaj@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c | 5 +++++
 drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c | 9 ++-------
 2 files <a href="http://lore.kernel.org/amd-gfx/20240622154751.632271-1-rajneesh.bhardwaj@amd.com/#related">changed</a>, 7 insertions(+), 7 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c
index 82452606ae6c..1c673c0b65d1 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c
</span><span
class="hunk">@@ -1292,6 +1292,11 @@ static ssize_t amdgpu_gfx_set_compute_partition(struct device *dev,
</span> 	enum amdgpu_gfx_partition mode;
 	int ret = 0, num_xcc;
 
<span
class="add">+	/* Under SRIOV, this is allowed only via the host driver but not from
+	 * within the VF */
+	if (amdgpu_sriov_vf(adev))
+		return -EPERM;
+
</span> 	num_xcc = NUM_XCC(adev-&gt;gfx.xcc_mask);
 	if (num_xcc % 2 != 0)
 		return -EINVAL;
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c b/drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c
index 8d8763ebe027..f87dc1b9d77c 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c
</span><span
class="hunk">@@ -936,11 +936,7 @@ static int gfx_v9_4_3_sw_init(void *handle)
</span> 	if (r)
 		return r;
 
<span
class="del">-
-	if (!amdgpu_sriov_vf(adev))
-		r = amdgpu_gfx_sysfs_init(adev);
-
-	return r;
</span><span
class="add">+	return amdgpu_gfx_sysfs_init(adev);
</span> }
 
 static int gfx_v9_4_3_sw_fini(void *handle)
<span
class="hunk">@@ -961,8 +957,7 @@ static int gfx_v9_4_3_sw_fini(void *handle)
</span> 	gfx_v9_4_3_mec_fini(adev);
 	amdgpu_bo_unref(&#38;adev-&gt;gfx.rlc.clear_state_obj);
 	gfx_v9_4_3_free_microcode(adev);
<span
class="del">-	if (!amdgpu_sriov_vf(adev))
-		amdgpu_gfx_sysfs_fini(adev);
</span><span
class="add">+	amdgpu_gfx_sysfs_fini(adev);
</span> 
 	return 0;
 }
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Ma Ke</name><email>make24@iscas.ac.cn</email></author><title>[PATCH] drm/amdgpu: fix a possible null pointer dereference</title><updated>2024-06-22T15:01:23Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240622082219.1876200-1-make24@iscas.ac.cn/"/><id>urn:uuid:7503e502-e14b-7acf-f836-0fc4bdf0d384</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">In amdgpu_connector_add_common_modes(), the return value of drm_cvt_mode()
is assigned to mode, which will lead to a NULL pointer dereference on
failure of drm_cvt_mode(). Add a check to avoid npd.

Signed-off-by: Ma Ke &lt;make24@iscas.ac.cn&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c | 2 ++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240622082219.1876200-1-make24@iscas.ac.cn/#related">changed</a>, 2 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c
index 9caba10315a8..6cf946adb6fe 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c
</span><span
class="hunk">@@ -458,6 +458,8 @@ static void amdgpu_connector_add_common_modes(struct drm_encoder *encoder,
</span> 			continue;
 
 		mode = drm_cvt_mode(dev, common_modes[i].w, common_modes[i].h, 60, false, false, false);
<span
class="add">+		if (!mode)
+			continue;
</span> 		drm_mode_probed_add(connector, mode);
 	}
 }
-- 
2.25.1

</pre></div></content></entry><entry><author><name>Rajneesh Bhardwaj</name><email>rajneesh.bhardwaj@amd.com</email></author><title>[PATCH 1/2] drm/amdgpu: Disable compute partition switch under SRIOV</title><updated>2024-06-21T22:04:27Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240621220402.578671-1-rajneesh.bhardwaj@amd.com/"/><id>urn:uuid:0ec1694b-e24d-e302-dd86-0746bf7142ee</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Do not allow the compute partition mode switch from the guest driver.

Signed-off-by: Rajneesh Bhardwaj &lt;rajneesh.bhardwaj@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c | 3 +++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240621220402.578671-1-rajneesh.bhardwaj@amd.com/#related">changed</a>, 3 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c
index 82452606ae6c..722c3fef09a5 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c
</span><span
class="hunk">@@ -1292,6 +1292,9 @@ static ssize_t amdgpu_gfx_set_compute_partition(struct device *dev,
</span> 	enum amdgpu_gfx_partition mode;
 	int ret = 0, num_xcc;
 
<span
class="add">+	if (amdgpu_sriov_vf(adev))
+		return -EINVAL;
+
</span> 	num_xcc = NUM_XCC(adev-&gt;gfx.xcc_mask);
 	if (num_xcc % 2 != 0)
 		return -EINVAL;
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Rajneesh Bhardwaj</name><email>rajneesh.bhardwaj@amd.com</email></author><title
type="html">[PATCH 2/2] drm/amdgpu: Don&#39;t warn for compute mode switch under SRIOV</title><updated>2024-06-21T22:04:26Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240621220402.578671-2-rajneesh.bhardwaj@amd.com/"/><id>urn:uuid:5fca0236-36e9-0097-cf3f-5ec05082b70e</id><thr:in-reply-to
ref="urn:uuid:0ec1694b-e24d-e302-dd86-0746bf7142ee"
href="http://lore.kernel.org/amd-gfx/20240621220402.578671-1-rajneesh.bhardwaj@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Under SRIOV environment, the compute partition mode is setup by the
host driver so state machine cached copy might be different when doing
the transition for the first time.

Signed-off-by: Rajneesh Bhardwaj &lt;rajneesh.bhardwaj@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_xcp.c | 3 ++-
 1 file <a href="http://lore.kernel.org/amd-gfx/20240621220402.578671-2-rajneesh.bhardwaj@amd.com/#related">changed</a>, 2 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_xcp.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_xcp.c
index 2b99eed5ba19..c4a9669bceb0 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_xcp.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_xcp.c
</span><span
class="hunk">@@ -228,7 +228,8 @@ int amdgpu_xcp_query_partition_mode(struct amdgpu_xcp_mgr *xcp_mgr, u32 flags)
</span> 	if (!(flags &#38; AMDGPU_XCP_FL_LOCKED))
 		mutex_lock(&#38;xcp_mgr-&gt;xcp_lock);
 	mode = xcp_mgr-&gt;funcs-&gt;query_partition_mode(xcp_mgr);
<span
class="del">-	if (xcp_mgr-&gt;mode != AMDGPU_XCP_MODE_TRANS &#38;&#38; mode != xcp_mgr-&gt;mode)
</span><span
class="add">+	if (xcp_mgr-&gt;mode != AMDGPU_XCP_MODE_TRANS &#38;&#38; mode != xcp_mgr-&gt;mode
+	    &#38;&#38; !amdgpu_sriov_vf(xcp_mgr-&gt;adev))
</span> 		dev_WARN(
 			xcp_mgr-&gt;adev-&gt;dev,
 			&#34;Cached partition mode %d not matching with device mode %d&#34;,
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Xiaogang.Chen</name><email>xiaogang.chen@amd.com</email></author><title>[PATCH] drm/amdkfd: Correct svm prange overlapping handling at svm_range_set_attr ioctl</title><updated>2024-06-21T17:26:24Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240621172823.168595-1-xiaogang.chen@amd.com/"/><id>urn:uuid:69602b5b-2d3f-54e6-3eea-b2904665f5a7</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Xiaogang Chen &lt;xiaogang.chen@amd.com&gt;

When user adds new vm range that has overlapping with existing svm pranges
current kfd clones new prange and remove existing pranges including all data
associate with it. It is not necessary. We can handle the overlapping on
existing pranges directly that would simplify kfd code. And, when remove a
existing prange the locks from it will get destroyed. This may cause issue if
code still use these locks. And locks from cloned prange do not inherit
context of locks that got removed.

This patch does not remove existing pranges or clone new pranges, keeps locks
of pranges alive.

Signed-off-by: Xiaogang Chen&lt;Xiaogang.Chen@amd.com&gt;
---
 drivers/gpu/drm/amd/amdkfd/kfd_svm.c | 89 ++++------------------------
 1 file <a href="http://lore.kernel.org/amd-gfx/20240621172823.168595-1-xiaogang.chen@amd.com/#related">changed</a>, 12 insertions(+), 77 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_svm.c b/drivers/gpu/drm/amd/amdkfd/kfd_svm.c
index 407636a68814..a8fcace6f9a2 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_svm.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_svm.c
</span><span
class="hunk">@@ -904,23 +904,6 @@ svm_range_copy_array(void *psrc, size_t size, uint64_t num_elements,
</span> 	return (void *)dst;
 }
 
<span
class="del">-static int
-svm_range_copy_dma_addrs(struct svm_range *dst, struct svm_range *src)
-{
-	int i;
-
-	for (i = 0; i &lt; MAX_GPU_INSTANCE; i++) {
-		if (!src-&gt;dma_addr[i])
-			continue;
-		dst-&gt;dma_addr[i] = svm_range_copy_array(src-&gt;dma_addr[i],
-					sizeof(*src-&gt;dma_addr[i]), src-&gt;npages, 0, NULL);
-		if (!dst-&gt;dma_addr[i])
-			return -ENOMEM;
-	}
-
-	return 0;
-}
-
</span> static int
 svm_range_split_array(void *ppnew, void *ppold, size_t size,
 		      uint64_t old_start, uint64_t old_n,
<span
class="hunk">@@ -1967,38 +1950,6 @@ svm_range_evict(struct svm_range *prange, struct mm_struct *mm,
</span> 	return r;
 }
 
<span
class="del">-static struct svm_range *svm_range_clone(struct svm_range *old)
-{
-	struct svm_range *new;
-
-	new = svm_range_new(old-&gt;svms, old-&gt;start, old-&gt;last, false);
-	if (!new)
-		return NULL;
-	if (svm_range_copy_dma_addrs(new, old)) {
-		svm_range_free(new, false);
-		return NULL;
-	}
-	if (old-&gt;svm_bo) {
-		new-&gt;ttm_res = old-&gt;ttm_res;
-		new-&gt;offset = old-&gt;offset;
-		new-&gt;svm_bo = svm_range_bo_ref(old-&gt;svm_bo);
-		spin_lock(&#38;new-&gt;svm_bo-&gt;list_lock);
-		list_add(&#38;new-&gt;svm_bo_list, &#38;new-&gt;svm_bo-&gt;range_list);
-		spin_unlock(&#38;new-&gt;svm_bo-&gt;list_lock);
-	}
-	new-&gt;flags = old-&gt;flags;
-	new-&gt;preferred_loc = old-&gt;preferred_loc;
-	new-&gt;prefetch_loc = old-&gt;prefetch_loc;
-	new-&gt;actual_loc = old-&gt;actual_loc;
-	new-&gt;granularity = old-&gt;granularity;
-	new-&gt;mapped_to_gpu = old-&gt;mapped_to_gpu;
-	new-&gt;vram_pages = old-&gt;vram_pages;
-	bitmap_copy(new-&gt;bitmap_access, old-&gt;bitmap_access, MAX_GPU_INSTANCE);
-	bitmap_copy(new-&gt;bitmap_aip, old-&gt;bitmap_aip, MAX_GPU_INSTANCE);
-
-	return new;
-}
-
</span> void svm_range_set_max_pages(struct amdgpu_device *adev)
 {
 	uint64_t max_pages;
<span
class="hunk">@@ -2057,7 +2008,6 @@ svm_range_split_new(struct svm_range_list *svms, uint64_t start, uint64_t last,
</span>  * @attrs: array of attributes
  * @update_list: output, the ranges need validate and update GPU mapping
  * @insert_list: output, the ranges need insert to svms
<span
class="del">- * @remove_list: output, the ranges are replaced and need remove from svms
</span>  * @remap_list: output, remap unaligned svm ranges
  *
  * Check if the virtual address range has overlap with any existing ranges,
<span
class="hunk">@@ -2082,7 +2032,7 @@ static int
</span> svm_range_add(struct kfd_process *p, uint64_t start, uint64_t size,
 	      uint32_t nattr, struct kfd_ioctl_svm_attribute *attrs,
 	      struct list_head *update_list, struct list_head *insert_list,
<span
class="del">-	      struct list_head *remove_list, struct list_head *remap_list)
</span><span
class="add">+	      struct list_head *remap_list)
</span> {
 	unsigned long last = start + size - 1UL;
 	struct svm_range_list *svms = &#38;p-&gt;svms;
<span
class="hunk">@@ -2096,7 +2046,6 @@ svm_range_add(struct kfd_process *p, uint64_t start, uint64_t size,
</span> 
 	INIT_LIST_HEAD(update_list);
 	INIT_LIST_HEAD(insert_list);
<span
class="del">-	INIT_LIST_HEAD(remove_list);
</span> 	INIT_LIST_HEAD(&#38;new_list);
 	INIT_LIST_HEAD(remap_list);
 
<span
class="hunk">@@ -2117,20 +2066,11 @@ svm_range_add(struct kfd_process *p, uint64_t start, uint64_t size,
</span> 			/* nothing to do */
 		} else if (node-&gt;start &lt; start || node-&gt;last &gt; last) {
 			/* node intersects the update range and its attributes
<span
class="del">-			 * will change. Clone and split it, apply updates only
</span><span
class="add">+			 * will change. Split it, apply updates only
</span> 			 * to the overlapping part
 			 */
<span
class="del">-			struct svm_range *old = prange;
-
-			prange = svm_range_clone(old);
-			if (!prange) {
-				r = -ENOMEM;
-				goto out;
-			}
-
-			list_add(&#38;old-&gt;update_list, remove_list);
-			list_add(&#38;prange-&gt;list, insert_list);
-			list_add(&#38;prange-&gt;update_list, update_list);
</span><span
class="add">+			list_move_tail(&#38;prange-&gt;list, insert_list);
+			list_move_tail(&#38;prange-&gt;update_list, update_list);
</span> 
 			if (node-&gt;start &lt; start) {
 				pr_debug(&#34;change old range start\n&#34;);
<span
class="hunk">@@ -3533,7 +3473,6 @@ svm_range_set_attr(struct kfd_process *p, struct mm_struct *mm,
</span> 	struct amdkfd_process_info *process_info = p-&gt;kgd_process_info;
 	struct list_head update_list;
 	struct list_head insert_list;
<span
class="del">-	struct list_head remove_list;
</span> 	struct list_head remap_list;
 	struct svm_range_list *svms;
 	struct svm_range *prange;
<span
class="hunk">@@ -3563,10 +3502,9 @@ svm_range_set_attr(struct kfd_process *p, struct mm_struct *mm,
</span> 	}
 
 	mutex_lock(&#38;svms-&gt;lock);
<span
class="del">-
</span> 	/* Add new range and split existing ranges as needed */
 	r = svm_range_add(p, start, size, nattr, attrs, &#38;update_list,
<span
class="del">-			  &#38;insert_list, &#38;remove_list, &#38;remap_list);
</span><span
class="add">+			  &#38;insert_list, &#38;remap_list);
</span> 	if (r) {
 		mutex_unlock(&#38;svms-&gt;lock);
 		mmap_write_unlock(mm);
<span
class="hunk">@@ -3574,21 +3512,18 @@ svm_range_set_attr(struct kfd_process *p, struct mm_struct *mm,
</span> 	}
 	/* Apply changes as a transaction */
 	list_for_each_entry_safe(prange, next, &#38;insert_list, list) {
<span
class="del">-		svm_range_add_to_svms(prange);
-		svm_range_add_notifier_locked(mm, prange);
</span><span
class="add">+		/* prange can be new or old range, put it at svms-&gt;list */
+		list_move_tail(&#38;prange-&gt;list, &#38;prange-&gt;svms-&gt;list);
+		/* update prange at interval trees: svms-&gt;objects and
+		 * mm interval notifier tree
+		 */
+		svm_range_update_notifier_and_interval_tree(mm, prange);
</span> 	}
<span
class="add">+
</span> 	list_for_each_entry(prange, &#38;update_list, update_list) {
 		svm_range_apply_attrs(p, prange, nattr, attrs, &#38;update_mapping);
 		/* TODO: unmap ranges from GPU that lost access */
 	}
<span
class="del">-	list_for_each_entry_safe(prange, next, &#38;remove_list, update_list) {
-		pr_debug(&#34;unlink old 0x%p prange 0x%p [0x%lx 0x%lx]\n&#34;,
-			 prange-&gt;svms, prange, prange-&gt;start,
-			 prange-&gt;last);
-		svm_range_unlink(prange);
-		svm_range_remove_notifier(prange);
-		svm_range_free(prange, false);
-	}
</span> 
 	mmap_write_downgrade(mm);
 	/* Trigger migrations and revalidate and map to GPUs as needed. If
-- 
2.25.1

</pre></div></content></entry><entry><author><name>Wu Hoi Pok</name><email>wuhoipok@gmail.com</email></author><title
type="html">[PATCH v2 7/7] drm/radeon: rdev-&gt;ddev to rdev_to_drm(rdev) 6</title><updated>2024-06-22T15:01:20Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240621142052.20152-1-wuhoipok@gmail.com/"/><id>urn:uuid:331b5473-bc2f-9520-395f-3f00813f79ad</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Please see Patch v2 1/7 for details.

Signed-off-by: Wu Hoi Pok &lt;wuhoipok@gmail.com&gt;
---
 drivers/gpu/drm/radeon/rs400.c |  6 +++---
 drivers/gpu/drm/radeon/rs600.c | 14 +++++++-------
 drivers/gpu/drm/radeon/rs690.c |  2 +-
 drivers/gpu/drm/radeon/rv515.c |  4 ++--
 drivers/gpu/drm/radeon/rv770.c |  2 +-
 drivers/gpu/drm/radeon/si.c    |  4 ++--
 6 files <a href="http://lore.kernel.org/amd-gfx/20240621142052.20152-1-wuhoipok@gmail.com/#related">changed</a>, 16 insertions(+), 16 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/radeon/rs400.c b/drivers/gpu/drm/radeon/rs400.c
index d4d1501e6576..d6c18fd740ec 100644
--- a/drivers/gpu/drm/radeon/rs400.c
+++ b/drivers/gpu/drm/radeon/rs400.c
</span><span
class="hunk">@@ -379,7 +379,7 @@ DEFINE_SHOW_ATTRIBUTE(rs400_debugfs_gart_info);
</span> static void rs400_debugfs_pcie_gart_info_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;rs400_gart_info&#34;, 0444, root, rdev,
 			    &#38;rs400_debugfs_gart_info_fops);
<span
class="hunk">@@ -474,7 +474,7 @@ int rs400_resume(struct radeon_device *rdev)
</span> 			RREG32(R_0007C0_CP_STAT));
 	}
 	/* post */
<span
class="del">-	radeon_combios_asic_init(rdev-&gt;ddev);
</span><span
class="add">+	radeon_combios_asic_init(rdev_to_drm(rdev));
</span> 	/* Resume clock after posting */
 	r300_clock_startup(rdev);
 	/* Initialize surface registers */
<span
class="hunk">@@ -552,7 +552,7 @@ int rs400_init(struct radeon_device *rdev)
</span> 		return -EINVAL;
 
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* initialize memory controller */
 	rs400_mc_init(rdev);
 	/* Fence driver */
<span
class="head">diff --git a/drivers/gpu/drm/radeon/rs600.c b/drivers/gpu/drm/radeon/rs600.c
index 5c162778899b..88c8e91ea651 100644
--- a/drivers/gpu/drm/radeon/rs600.c
+++ b/drivers/gpu/drm/radeon/rs600.c
</span><span
class="hunk">@@ -321,7 +321,7 @@ void rs600_pm_misc(struct radeon_device *rdev)
</span> 
 void rs600_pm_prepare(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
 	u32 tmp;
<span
class="hunk">@@ -339,7 +339,7 @@ void rs600_pm_prepare(struct radeon_device *rdev)
</span> 
 void rs600_pm_finish(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
 	u32 tmp;
<span
class="hunk">@@ -408,7 +408,7 @@ void rs600_hpd_set_polarity(struct radeon_device *rdev,
</span> 
 void rs600_hpd_init(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_connector *connector;
 	unsigned enable = 0;
 
<span
class="hunk">@@ -435,7 +435,7 @@ void rs600_hpd_init(struct radeon_device *rdev)
</span> 
 void rs600_hpd_fini(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_connector *connector;
 	unsigned disable = 0;
 
<span
class="hunk">@@ -797,7 +797,7 @@ int rs600_irq_process(struct radeon_device *rdev)
</span> 		/* Vertical blank interrupts */
 		if (G_007EDC_LB_D1_VBLANK_INTERRUPT(rdev-&gt;irq.stat_regs.r500.disp_int)) {
 			if (rdev-&gt;irq.crtc_vblank_int[0]) {
<span
class="del">-				drm_handle_vblank(rdev-&gt;ddev, 0);
</span><span
class="add">+				drm_handle_vblank(rdev_to_drm(rdev), 0);
</span> 				rdev-&gt;pm.vblank_sync = true;
 				wake_up(&#38;rdev-&gt;irq.vblank_queue);
 			}
<span
class="hunk">@@ -806,7 +806,7 @@ int rs600_irq_process(struct radeon_device *rdev)
</span> 		}
 		if (G_007EDC_LB_D2_VBLANK_INTERRUPT(rdev-&gt;irq.stat_regs.r500.disp_int)) {
 			if (rdev-&gt;irq.crtc_vblank_int[1]) {
<span
class="del">-				drm_handle_vblank(rdev-&gt;ddev, 1);
</span><span
class="add">+				drm_handle_vblank(rdev_to_drm(rdev), 1);
</span> 				rdev-&gt;pm.vblank_sync = true;
 				wake_up(&#38;rdev-&gt;irq.vblank_queue);
 			}
<span
class="hunk">@@ -1133,7 +1133,7 @@ int rs600_init(struct radeon_device *rdev)
</span> 		return -EINVAL;
 
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* initialize memory controller */
 	rs600_mc_init(rdev);
 	r100_debugfs_rbbm_init(rdev);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/rs690.c b/drivers/gpu/drm/radeon/rs690.c
index 14fb0819b8c1..016eb4992803 100644
--- a/drivers/gpu/drm/radeon/rs690.c
+++ b/drivers/gpu/drm/radeon/rs690.c
</span><span
class="hunk">@@ -845,7 +845,7 @@ int rs690_init(struct radeon_device *rdev)
</span> 		return -EINVAL;
 
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* initialize memory controller */
 	rs690_mc_init(rdev);
 	rv515_debugfs(rdev);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/rv515.c b/drivers/gpu/drm/radeon/rv515.c
index bbc6ccabf788..1b4dfb645585 100644
--- a/drivers/gpu/drm/radeon/rv515.c
+++ b/drivers/gpu/drm/radeon/rv515.c
</span><span
class="hunk">@@ -255,7 +255,7 @@ DEFINE_SHOW_ATTRIBUTE(rv515_debugfs_ga_info);
</span> void rv515_debugfs(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;rv515_pipes_info&#34;, 0444, root, rdev,
 			    &#38;rv515_debugfs_pipes_info_fops);
<span
class="hunk">@@ -636,7 +636,7 @@ int rv515_init(struct radeon_device *rdev)
</span> 	if (radeon_boot_test_post_card(rdev) == false)
 		return -EINVAL;
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* initialize AGP */
 	if (rdev-&gt;flags &#38; RADEON_IS_AGP) {
 		r = radeon_agp_init(rdev);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/rv770.c b/drivers/gpu/drm/radeon/rv770.c
index 9ce12fa3c356..7d4b0bf59109 100644
--- a/drivers/gpu/drm/radeon/rv770.c
+++ b/drivers/gpu/drm/radeon/rv770.c
</span><span
class="hunk">@@ -1935,7 +1935,7 @@ int rv770_init(struct radeon_device *rdev)
</span> 	/* Initialize surface registers */
 	radeon_surface_init(rdev);
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* Fence driver */
 	radeon_fence_driver_init(rdev);
 	/* initialize AGP */
<span
class="head">diff --git a/drivers/gpu/drm/radeon/si.c b/drivers/gpu/drm/radeon/si.c
index 15759c8ca5b7..6c95575ce109 100644
--- a/drivers/gpu/drm/radeon/si.c
+++ b/drivers/gpu/drm/radeon/si.c
</span><span
class="hunk">@@ -6277,7 +6277,7 @@ int si_irq_process(struct radeon_device *rdev)
</span> 				event_name = &#34;vblank&#34;;
 
 				if (rdev-&gt;irq.crtc_vblank_int[crtc_idx]) {
<span
class="del">-					drm_handle_vblank(rdev-&gt;ddev, crtc_idx);
</span><span
class="add">+					drm_handle_vblank(rdev_to_drm(rdev), crtc_idx);
</span> 					rdev-&gt;pm.vblank_sync = true;
 					wake_up(&#38;rdev-&gt;irq.vblank_queue);
 				}
<span
class="hunk">@@ -6839,7 +6839,7 @@ int si_init(struct radeon_device *rdev)
</span> 	/* Initialize surface registers */
 	radeon_surface_init(rdev);
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 
 	/* Fence driver */
 	radeon_fence_driver_init(rdev);
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Wu Hoi Pok</name><email>wuhoipok@gmail.com</email></author><title
type="html">[PATCH v2 6/7] drm/radeon: rdev-&gt;ddev to rdev_to_drm(rdev) 5</title><updated>2024-06-22T15:01:21Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240621142018.20117-1-wuhoipok@gmail.com/"/><id>urn:uuid:6dfbfe62-f1d6-9074-a03e-02d448413832</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Please see Patch v2 1/7 for details.

Signed-off-by: Wu Hoi Pok &lt;wuhoipok@gmail.com&gt;
---
 drivers/gpu/drm/radeon/radeon_ib.c      |  2 +-
 drivers/gpu/drm/radeon/radeon_irq_kms.c | 12 ++++++------
 drivers/gpu/drm/radeon/radeon_object.c  |  2 +-
 drivers/gpu/drm/radeon/radeon_pm.c      | 20 ++++++++++----------
 drivers/gpu/drm/radeon/radeon_ring.c    |  2 +-
 drivers/gpu/drm/radeon/radeon_ttm.c     |  6 +++---
 6 files <a href="http://lore.kernel.org/amd-gfx/20240621142018.20117-1-wuhoipok@gmail.com/#related">changed</a>, 22 insertions(+), 22 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_ib.c b/drivers/gpu/drm/radeon/radeon_ib.c
index 63d914f3414d..1aa41cc3f991 100644
--- a/drivers/gpu/drm/radeon/radeon_ib.c
+++ b/drivers/gpu/drm/radeon/radeon_ib.c
</span><span
class="hunk">@@ -309,7 +309,7 @@ DEFINE_SHOW_ATTRIBUTE(radeon_debugfs_sa_info);
</span> static void radeon_debugfs_sa_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;radeon_sa_info&#34;, 0444, root, rdev,
 			    &#38;radeon_debugfs_sa_info_fops);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_irq_kms.c b/drivers/gpu/drm/radeon/radeon_irq_kms.c
index c4dda908666c..9961251b44ba 100644
--- a/drivers/gpu/drm/radeon/radeon_irq_kms.c
+++ b/drivers/gpu/drm/radeon/radeon_irq_kms.c
</span><span
class="hunk">@@ -80,7 +80,7 @@ static void radeon_hotplug_work_func(struct work_struct *work)
</span> {
 	struct radeon_device *rdev = container_of(work, struct radeon_device,
 						  hotplug_work.work);
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_mode_config *mode_config = &#38;dev-&gt;mode_config;
 	struct drm_connector *connector;
 
<span
class="hunk">@@ -101,7 +101,7 @@ static void radeon_dp_work_func(struct work_struct *work)
</span> {
 	struct radeon_device *rdev = container_of(work, struct radeon_device,
 						  dp_work);
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_mode_config *mode_config = &#38;dev-&gt;mode_config;
 	struct drm_connector *connector;
 
<span
class="hunk">@@ -197,7 +197,7 @@ static void radeon_driver_irq_uninstall_kms(struct drm_device *dev)
</span> 
 static int radeon_irq_install(struct radeon_device *rdev, int irq)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	int ret;
 
 	if (irq == IRQ_NOTCONNECTED)
<span
class="hunk">@@ -218,7 +218,7 @@ static int radeon_irq_install(struct radeon_device *rdev, int irq)
</span> 
 static void radeon_irq_uninstall(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct pci_dev *pdev = to_pci_dev(dev-&gt;dev);
 
 	radeon_driver_irq_uninstall_kms(dev);
<span
class="hunk">@@ -322,9 +322,9 @@ int radeon_irq_kms_init(struct radeon_device *rdev)
</span> 	spin_lock_init(&#38;rdev-&gt;irq.lock);
 
 	/* Disable vblank irqs aggressively for power-saving */
<span
class="del">-	rdev-&gt;ddev-&gt;vblank_disable_immediate = true;
</span><span
class="add">+	rdev_to_drm(rdev)-&gt;vblank_disable_immediate = true;
</span> 
<span
class="del">-	r = drm_vblank_init(rdev-&gt;ddev, rdev-&gt;num_crtc);
</span><span
class="add">+	r = drm_vblank_init(rdev_to_drm(rdev), rdev-&gt;num_crtc);
</span> 	if (r) {
 		return r;
 	}
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_object.c b/drivers/gpu/drm/radeon/radeon_object.c
index a955f8a2f7fe..450ff7daa46c 100644
--- a/drivers/gpu/drm/radeon/radeon_object.c
+++ b/drivers/gpu/drm/radeon/radeon_object.c
</span><span
class="hunk">@@ -150,7 +150,7 @@ int radeon_bo_create(struct radeon_device *rdev,
</span> 	bo = kzalloc(sizeof(struct radeon_bo), GFP_KERNEL);
 	if (bo == NULL)
 		return -ENOMEM;
<span
class="del">-	drm_gem_private_object_init(rdev-&gt;ddev, &#38;bo-&gt;tbo.base, size);
</span><span
class="add">+	drm_gem_private_object_init(rdev_to_drm(rdev), &#38;bo-&gt;tbo.base, size);
</span> 	bo-&gt;rdev = rdev;
 	bo-&gt;surface_reg = -1;
 	INIT_LIST_HEAD(&#38;bo-&gt;list);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_pm.c b/drivers/gpu/drm/radeon/radeon_pm.c
index 2d9d9f46f243..b4fb7e70320b 100644
--- a/drivers/gpu/drm/radeon/radeon_pm.c
+++ b/drivers/gpu/drm/radeon/radeon_pm.c
</span><span
class="hunk">@@ -282,7 +282,7 @@ static void radeon_pm_set_clocks(struct radeon_device *rdev)
</span> 
 	if (rdev-&gt;irq.installed) {
 		i = 0;
<span
class="del">-		drm_for_each_crtc(crtc, rdev-&gt;ddev) {
</span><span
class="add">+		drm_for_each_crtc(crtc, rdev_to_drm(rdev)) {
</span> 			if (rdev-&gt;pm.active_crtcs &#38; (1 &lt;&lt; i)) {
 				/* This can fail if a modeset is in progress */
 				if (drm_crtc_vblank_get(crtc) == 0)
<span
class="hunk">@@ -299,7 +299,7 @@ static void radeon_pm_set_clocks(struct radeon_device *rdev)
</span> 
 	if (rdev-&gt;irq.installed) {
 		i = 0;
<span
class="del">-		drm_for_each_crtc(crtc, rdev-&gt;ddev) {
</span><span
class="add">+		drm_for_each_crtc(crtc, rdev_to_drm(rdev)) {
</span> 			if (rdev-&gt;pm.req_vblank &#38; (1 &lt;&lt; i)) {
 				rdev-&gt;pm.req_vblank &#38;= ~(1 &lt;&lt; i);
 				drm_crtc_vblank_put(crtc);
<span
class="hunk">@@ -671,7 +671,7 @@ static ssize_t radeon_hwmon_show_temp(struct device *dev,
</span> 				      char *buf)
 {
 	struct radeon_device *rdev = dev_get_drvdata(dev);
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	int temp;
 
 	/* Can&#39;t get temperature when the card is off */
<span
class="hunk">@@ -715,7 +715,7 @@ static ssize_t radeon_hwmon_show_sclk(struct device *dev,
</span> 				      struct device_attribute *attr, char *buf)
 {
 	struct radeon_device *rdev = dev_get_drvdata(dev);
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	u32 sclk = 0;
 
 	/* Can&#39;t get clock frequency when the card is off */
<span
class="hunk">@@ -740,7 +740,7 @@ static ssize_t radeon_hwmon_show_vddc(struct device *dev,
</span> 				      struct device_attribute *attr, char *buf)
 {
 	struct radeon_device *rdev = dev_get_drvdata(dev);
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	u16 vddc = 0;
 
 	/* Can&#39;t get vddc when the card is off */
<span
class="hunk">@@ -1692,7 +1692,7 @@ void radeon_pm_fini(struct radeon_device *rdev)
</span> 
 static void radeon_pm_compute_clocks_old(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
 
<span
class="hunk">@@ -1765,7 +1765,7 @@ static void radeon_pm_compute_clocks_old(struct radeon_device *rdev)
</span> 
 static void radeon_pm_compute_clocks_dpm(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
 	struct radeon_connector *radeon_connector;
<span
class="hunk">@@ -1826,7 +1826,7 @@ static bool radeon_pm_in_vbl(struct radeon_device *rdev)
</span> 	 */
 	for (crtc = 0; (crtc &lt; rdev-&gt;num_crtc) &#38;&#38; in_vbl; crtc++) {
 		if (rdev-&gt;pm.active_crtcs &#38; (1 &lt;&lt; crtc)) {
<span
class="del">-			vbl_status = radeon_get_crtc_scanoutpos(rdev-&gt;ddev,
</span><span
class="add">+			vbl_status = radeon_get_crtc_scanoutpos(rdev_to_drm(rdev),
</span> 								crtc,
 								USE_REAL_VBLANKSTART,
 								&#38;vpos, &#38;hpos, NULL, NULL,
<span
class="hunk">@@ -1918,7 +1918,7 @@ static void radeon_dynpm_idle_work_handler(struct work_struct *work)
</span> static int radeon_debugfs_pm_info_show(struct seq_file *m, void *unused)
 {
 	struct radeon_device *rdev = m-&gt;private;
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 
 	if  ((rdev-&gt;flags &#38; RADEON_IS_PX) &#38;&#38;
 	     (ddev-&gt;switch_power_state != DRM_SWITCH_POWER_ON)) {
<span
class="hunk">@@ -1955,7 +1955,7 @@ DEFINE_SHOW_ATTRIBUTE(radeon_debugfs_pm_info);
</span> static void radeon_debugfs_pm_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;radeon_pm_info&#34;, 0444, root, rdev,
 			    &#38;radeon_debugfs_pm_info_fops);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_ring.c b/drivers/gpu/drm/radeon/radeon_ring.c
index 8d1d458286a8..581ae20c46e4 100644
--- a/drivers/gpu/drm/radeon/radeon_ring.c
+++ b/drivers/gpu/drm/radeon/radeon_ring.c
</span><span
class="hunk">@@ -550,7 +550,7 @@ static void radeon_debugfs_ring_init(struct radeon_device *rdev, struct radeon_r
</span> {
 #if defined(CONFIG_DEBUG_FS)
 	const char *ring_name = radeon_debugfs_ring_idx_to_name(ring-&gt;idx);
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	if (ring_name)
 		debugfs_create_file(ring_name, 0444, root, ring,
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_ttm.c b/drivers/gpu/drm/radeon/radeon_ttm.c
index 5c65b6dfb99a..69d0c12fa419 100644
--- a/drivers/gpu/drm/radeon/radeon_ttm.c
+++ b/drivers/gpu/drm/radeon/radeon_ttm.c
</span><span
class="hunk">@@ -682,8 +682,8 @@ int radeon_ttm_init(struct radeon_device *rdev)
</span> 
 	/* No others user of address space so set it to 0 */
 	r = ttm_device_init(&#38;rdev-&gt;mman.bdev, &#38;radeon_bo_driver, rdev-&gt;dev,
<span
class="del">-			       rdev-&gt;ddev-&gt;anon_inode-&gt;i_mapping,
-			       rdev-&gt;ddev-&gt;vma_offset_manager,
</span><span
class="add">+			       rdev_to_drm(rdev)-&gt;anon_inode-&gt;i_mapping,
+			       rdev_to_drm(rdev)-&gt;vma_offset_manager,
</span> 			       rdev-&gt;need_swiotlb,
 			       dma_addressing_limited(&#38;rdev-&gt;pdev-&gt;dev));
 	if (r) {
<span
class="hunk">@@ -890,7 +890,7 @@ static const struct file_operations radeon_ttm_gtt_fops = {
</span> static void radeon_ttm_debugfs_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct drm_minor *minor = rdev-&gt;ddev-&gt;primary;
</span><span
class="add">+	struct drm_minor *minor = rdev_to_drm(rdev)-&gt;primary;
</span> 	struct dentry *root = minor-&gt;debugfs_root;
 
 	debugfs_create_file(&#34;radeon_vram&#34;, 0444, root, rdev,
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Wu Hoi Pok</name><email>wuhoipok@gmail.com</email></author><title
type="html">[PATCH v2 5/7] drm/radeon: rdev-&gt;ddev to rdev_to_drm(rdev) 4</title><updated>2024-06-22T15:01:17Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240621141953.20081-1-wuhoipok@gmail.com/"/><id>urn:uuid:d89ff3f5-9674-c83c-3f92-58f1dc5872b1</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Please see Patch v2 1/7 for details.

Signed-off-by: Wu Hoi Pok &lt;wuhoipok@gmail.com&gt;
---
 drivers/gpu/drm/radeon/radeon_device.c  | 19 +++----
 drivers/gpu/drm/radeon/radeon_display.c | 74 ++++++++++++-------------
 drivers/gpu/drm/radeon/radeon_fbdev.c   | 26 ++++-----
 drivers/gpu/drm/radeon/radeon_fence.c   |  8 +--
 drivers/gpu/drm/radeon/radeon_gem.c     |  2 +-
 drivers/gpu/drm/radeon/radeon_i2c.c     |  2 +-
 6 files <a href="http://lore.kernel.org/amd-gfx/20240621141953.20081-1-wuhoipok@gmail.com/#related">changed</a>, 63 insertions(+), 68 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c
index afbb3a80c0c6..127d8fd7f7cd 100644
--- a/drivers/gpu/drm/radeon/radeon_device.c
+++ b/drivers/gpu/drm/radeon/radeon_device.c
</span><span
class="hunk">@@ -760,7 +760,7 @@ bool radeon_boot_test_post_card(struct radeon_device *rdev)
</span> 		if (rdev-&gt;is_atom_bios)
 			atom_asic_init(rdev-&gt;mode_info.atom_context);
 		else
<span
class="del">-			radeon_combios_asic_init(rdev-&gt;ddev);
</span><span
class="add">+			radeon_combios_asic_init(rdev_to_drm(rdev));
</span> 		return true;
 	} else {
 		dev_err(rdev-&gt;dev, &#34;Card not posted and no BIOS - ignoring\n&#34;);
<span
class="hunk">@@ -980,7 +980,7 @@ int radeon_atombios_init(struct radeon_device *rdev)
</span> 		return -ENOMEM;
 
 	rdev-&gt;mode_info.atom_card_info = atom_card_info;
<span
class="del">-	atom_card_info-&gt;dev = rdev-&gt;ddev;
</span><span
class="add">+	atom_card_info-&gt;dev = rdev_to_drm(rdev);
</span> 	atom_card_info-&gt;reg_read = cail_reg_read;
 	atom_card_info-&gt;reg_write = cail_reg_write;
 	/* needed for iio ops */
<span
class="hunk">@@ -1005,7 +1005,7 @@ int radeon_atombios_init(struct radeon_device *rdev)
</span> 
 	mutex_init(&#38;rdev-&gt;mode_info.atom_context-&gt;mutex);
 	mutex_init(&#38;rdev-&gt;mode_info.atom_context-&gt;scratch_mutex);
<span
class="del">-	radeon_atom_initialize_bios_scratch_regs(rdev-&gt;ddev);
</span><span
class="add">+	radeon_atom_initialize_bios_scratch_regs(rdev_to_drm(rdev));
</span> 	atom_allocate_fb_scratch(rdev-&gt;mode_info.atom_context);
 	return 0;
 }
<span
class="hunk">@@ -1049,7 +1049,7 @@ void radeon_atombios_fini(struct radeon_device *rdev)
</span>  */
 int radeon_combios_init(struct radeon_device *rdev)
 {
<span
class="del">-	radeon_combios_initialize_bios_scratch_regs(rdev-&gt;ddev);
</span><span
class="add">+	radeon_combios_initialize_bios_scratch_regs(rdev_to_drm(rdev));
</span> 	return 0;
 }
 
<span
class="hunk">@@ -1267,8 +1267,6 @@ static const struct vga_switcheroo_client_ops radeon_switcheroo_ops = {
</span>  * radeon_device_init - initialize the driver
  *
  * @rdev: radeon_device pointer
<span
class="del">- * @ddev: drm dev pointer
- * @pdev: pci dev pointer
</span>  * @flags: driver flags
  *
  * Initializes the driver info and hw (all asics).
<span
class="hunk">@@ -1276,18 +1274,15 @@ static const struct vga_switcheroo_client_ops radeon_switcheroo_ops = {
</span>  * Called at driver startup.
  */
 int radeon_device_init(struct radeon_device *rdev,
<span
class="del">-		       struct drm_device *ddev,
-		       struct pci_dev *pdev,
</span> 		       uint32_t flags)
 {
<span
class="add">+	struct pci_dev *pdev = rdev-&gt;pdev;
+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	int r, i;
 	int dma_bits;
 	bool runtime = false;
 
 	rdev-&gt;shutdown = false;
<span
class="del">-	rdev-&gt;dev = &#38;pdev-&gt;dev;
-	rdev-&gt;ddev = ddev;
-	rdev-&gt;pdev = pdev;
</span> 	rdev-&gt;flags = flags;
 	rdev-&gt;family = flags &#38; RADEON_FAMILY_MASK;
 	rdev-&gt;is_atom_bios = false;
<span
class="hunk">@@ -1847,7 +1842,7 @@ int radeon_gpu_reset(struct radeon_device *rdev)
</span> 
 	downgrade_write(&#38;rdev-&gt;exclusive_lock);
 
<span
class="del">-	drm_helper_resume_force_mode(rdev-&gt;ddev);
</span><span
class="add">+	drm_helper_resume_force_mode(rdev_to_drm(rdev));
</span> 
 	/* set the power state here in case we are a PX system or headless */
 	if ((rdev-&gt;pm.pm_method == PM_METHOD_DPM) &#38;&#38; rdev-&gt;pm.dpm_enabled)
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_display.c b/drivers/gpu/drm/radeon/radeon_display.c
index 843383f7237f..10fd58f400bc 100644
--- a/drivers/gpu/drm/radeon/radeon_display.c
+++ b/drivers/gpu/drm/radeon/radeon_display.c
</span><span
class="hunk">@@ -302,13 +302,13 @@ void radeon_crtc_handle_vblank(struct radeon_device *rdev, int crtc_id)
</span> 	if ((radeon_use_pflipirq == 2) &#38;&#38; ASIC_IS_DCE4(rdev))
 		return;
 
<span
class="del">-	spin_lock_irqsave(&#38;rdev-&gt;ddev-&gt;event_lock, flags);
</span><span
class="add">+	spin_lock_irqsave(&#38;rdev_to_drm(rdev)-&gt;event_lock, flags);
</span> 	if (radeon_crtc-&gt;flip_status != RADEON_FLIP_SUBMITTED) {
 		DRM_DEBUG_DRIVER(&#34;radeon_crtc-&gt;flip_status = %d != &#34;
 				 &#34;RADEON_FLIP_SUBMITTED(%d)\n&#34;,
 				 radeon_crtc-&gt;flip_status,
 				 RADEON_FLIP_SUBMITTED);
<span
class="del">-		spin_unlock_irqrestore(&#38;rdev-&gt;ddev-&gt;event_lock, flags);
</span><span
class="add">+		spin_unlock_irqrestore(&#38;rdev_to_drm(rdev)-&gt;event_lock, flags);
</span> 		return;
 	}
 
<span
class="hunk">@@ -334,7 +334,7 @@ void radeon_crtc_handle_vblank(struct radeon_device *rdev, int crtc_id)
</span> 	 */
 	if (update_pending &#38;&#38;
 	    (DRM_SCANOUTPOS_VALID &#38;
<span
class="del">-	     radeon_get_crtc_scanoutpos(rdev-&gt;ddev, crtc_id,
</span><span
class="add">+	     radeon_get_crtc_scanoutpos(rdev_to_drm(rdev), crtc_id,
</span> 					GET_DISTANCE_TO_VBLANKSTART,
 					&#38;vpos, &#38;hpos, NULL, NULL,
 					&#38;rdev-&gt;mode_info.crtcs[crtc_id]-&gt;base.hwmode)) &#38;&#38;
<span
class="hunk">@@ -347,7 +347,7 @@ void radeon_crtc_handle_vblank(struct radeon_device *rdev, int crtc_id)
</span> 		 */
 		update_pending = 0;
 	}
<span
class="del">-	spin_unlock_irqrestore(&#38;rdev-&gt;ddev-&gt;event_lock, flags);
</span><span
class="add">+	spin_unlock_irqrestore(&#38;rdev_to_drm(rdev)-&gt;event_lock, flags);
</span> 	if (!update_pending)
 		radeon_crtc_handle_flip(rdev, crtc_id);
 }
<span
class="hunk">@@ -370,14 +370,14 @@ void radeon_crtc_handle_flip(struct radeon_device *rdev, int crtc_id)
</span> 	if (radeon_crtc == NULL)
 		return;
 
<span
class="del">-	spin_lock_irqsave(&#38;rdev-&gt;ddev-&gt;event_lock, flags);
</span><span
class="add">+	spin_lock_irqsave(&#38;rdev_to_drm(rdev)-&gt;event_lock, flags);
</span> 	work = radeon_crtc-&gt;flip_work;
 	if (radeon_crtc-&gt;flip_status != RADEON_FLIP_SUBMITTED) {
 		DRM_DEBUG_DRIVER(&#34;radeon_crtc-&gt;flip_status = %d != &#34;
 				 &#34;RADEON_FLIP_SUBMITTED(%d)\n&#34;,
 				 radeon_crtc-&gt;flip_status,
 				 RADEON_FLIP_SUBMITTED);
<span
class="del">-		spin_unlock_irqrestore(&#38;rdev-&gt;ddev-&gt;event_lock, flags);
</span><span
class="add">+		spin_unlock_irqrestore(&#38;rdev_to_drm(rdev)-&gt;event_lock, flags);
</span> 		return;
 	}
 
<span
class="hunk">@@ -389,7 +389,7 @@ void radeon_crtc_handle_flip(struct radeon_device *rdev, int crtc_id)
</span> 	if (work-&gt;event)
 		drm_crtc_send_vblank_event(&#38;radeon_crtc-&gt;base, work-&gt;event);
 
<span
class="del">-	spin_unlock_irqrestore(&#38;rdev-&gt;ddev-&gt;event_lock, flags);
</span><span
class="add">+	spin_unlock_irqrestore(&#38;rdev_to_drm(rdev)-&gt;event_lock, flags);
</span> 
 	drm_crtc_vblank_put(&#38;radeon_crtc-&gt;base);
 	radeon_irq_kms_pflip_irq_put(rdev, work-&gt;crtc_id);
<span
class="hunk">@@ -408,7 +408,7 @@ static void radeon_flip_work_func(struct work_struct *__work)
</span> 	struct radeon_flip_work *work =
 		container_of(__work, struct radeon_flip_work, flip_work);
 	struct radeon_device *rdev = work-&gt;rdev;
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct radeon_crtc *radeon_crtc = rdev-&gt;mode_info.crtcs[work-&gt;crtc_id];
 
 	struct drm_crtc *crtc = &#38;radeon_crtc-&gt;base;
<span
class="hunk">@@ -1401,7 +1401,7 @@ static int radeon_modeset_create_props(struct radeon_device *rdev)
</span> 
 	if (rdev-&gt;is_atom_bios) {
 		rdev-&gt;mode_info.coherent_mode_property =
<span
class="del">-			drm_property_create_range(rdev-&gt;ddev, 0 , &#34;coherent&#34;, 0, 1);
</span><span
class="add">+			drm_property_create_range(rdev_to_drm(rdev), 0, &#34;coherent&#34;, 0, 1);
</span> 		if (!rdev-&gt;mode_info.coherent_mode_property)
 			return -ENOMEM;
 	}
<span
class="hunk">@@ -1409,57 +1409,57 @@ static int radeon_modeset_create_props(struct radeon_device *rdev)
</span> 	if (!ASIC_IS_AVIVO(rdev)) {
 		sz = ARRAY_SIZE(radeon_tmds_pll_enum_list);
 		rdev-&gt;mode_info.tmds_pll_property =
<span
class="del">-			drm_property_create_enum(rdev-&gt;ddev, 0,
</span><span
class="add">+			drm_property_create_enum(rdev_to_drm(rdev), 0,
</span> 					    &#34;tmds_pll&#34;,
 					    radeon_tmds_pll_enum_list, sz);
 	}
 
 	rdev-&gt;mode_info.load_detect_property =
<span
class="del">-		drm_property_create_range(rdev-&gt;ddev, 0, &#34;load detection&#34;, 0, 1);
</span><span
class="add">+		drm_property_create_range(rdev_to_drm(rdev), 0, &#34;load detection&#34;, 0, 1);
</span> 	if (!rdev-&gt;mode_info.load_detect_property)
 		return -ENOMEM;
 
<span
class="del">-	drm_mode_create_scaling_mode_property(rdev-&gt;ddev);
</span><span
class="add">+	drm_mode_create_scaling_mode_property(rdev_to_drm(rdev));
</span> 
 	sz = ARRAY_SIZE(radeon_tv_std_enum_list);
 	rdev-&gt;mode_info.tv_std_property =
<span
class="del">-		drm_property_create_enum(rdev-&gt;ddev, 0,
</span><span
class="add">+		drm_property_create_enum(rdev_to_drm(rdev), 0,
</span> 				    &#34;tv standard&#34;,
 				    radeon_tv_std_enum_list, sz);
 
 	sz = ARRAY_SIZE(radeon_underscan_enum_list);
 	rdev-&gt;mode_info.underscan_property =
<span
class="del">-		drm_property_create_enum(rdev-&gt;ddev, 0,
</span><span
class="add">+		drm_property_create_enum(rdev_to_drm(rdev), 0,
</span> 				    &#34;underscan&#34;,
 				    radeon_underscan_enum_list, sz);
 
 	rdev-&gt;mode_info.underscan_hborder_property =
<span
class="del">-		drm_property_create_range(rdev-&gt;ddev, 0,
</span><span
class="add">+		drm_property_create_range(rdev_to_drm(rdev), 0,
</span> 					&#34;underscan hborder&#34;, 0, 128);
 	if (!rdev-&gt;mode_info.underscan_hborder_property)
 		return -ENOMEM;
 
 	rdev-&gt;mode_info.underscan_vborder_property =
<span
class="del">-		drm_property_create_range(rdev-&gt;ddev, 0,
</span><span
class="add">+		drm_property_create_range(rdev_to_drm(rdev), 0,
</span> 					&#34;underscan vborder&#34;, 0, 128);
 	if (!rdev-&gt;mode_info.underscan_vborder_property)
 		return -ENOMEM;
 
 	sz = ARRAY_SIZE(radeon_audio_enum_list);
 	rdev-&gt;mode_info.audio_property =
<span
class="del">-		drm_property_create_enum(rdev-&gt;ddev, 0,
</span><span
class="add">+		drm_property_create_enum(rdev_to_drm(rdev), 0,
</span> 					 &#34;audio&#34;,
 					 radeon_audio_enum_list, sz);
 
 	sz = ARRAY_SIZE(radeon_dither_enum_list);
 	rdev-&gt;mode_info.dither_property =
<span
class="del">-		drm_property_create_enum(rdev-&gt;ddev, 0,
</span><span
class="add">+		drm_property_create_enum(rdev_to_drm(rdev), 0,
</span> 					 &#34;dither&#34;,
 					 radeon_dither_enum_list, sz);
 
 	sz = ARRAY_SIZE(radeon_output_csc_enum_list);
 	rdev-&gt;mode_info.output_csc_property =
<span
class="del">-		drm_property_create_enum(rdev-&gt;ddev, 0,
</span><span
class="add">+		drm_property_create_enum(rdev_to_drm(rdev), 0,
</span> 					 &#34;output_csc&#34;,
 					 radeon_output_csc_enum_list, sz);
 
<span
class="hunk">@@ -1578,29 +1578,29 @@ int radeon_modeset_init(struct radeon_device *rdev)
</span> 	int i;
 	int ret;
 
<span
class="del">-	drm_mode_config_init(rdev-&gt;ddev);
</span><span
class="add">+	drm_mode_config_init(rdev_to_drm(rdev));
</span> 	rdev-&gt;mode_info.mode_config_initialized = true;
 
<span
class="del">-	rdev-&gt;ddev-&gt;mode_config.funcs = &#38;radeon_mode_funcs;
</span><span
class="add">+	rdev_to_drm(rdev)-&gt;mode_config.funcs = &#38;radeon_mode_funcs;
</span> 
 	if (radeon_use_pflipirq == 2 &#38;&#38; rdev-&gt;family &gt;= CHIP_R600)
<span
class="del">-		rdev-&gt;ddev-&gt;mode_config.async_page_flip = true;
</span><span
class="add">+		rdev_to_drm(rdev)-&gt;mode_config.async_page_flip = true;
</span> 
 	if (ASIC_IS_DCE5(rdev)) {
<span
class="del">-		rdev-&gt;ddev-&gt;mode_config.max_width = 16384;
-		rdev-&gt;ddev-&gt;mode_config.max_height = 16384;
</span><span
class="add">+		rdev_to_drm(rdev)-&gt;mode_config.max_width = 16384;
+		rdev_to_drm(rdev)-&gt;mode_config.max_height = 16384;
</span> 	} else if (ASIC_IS_AVIVO(rdev)) {
<span
class="del">-		rdev-&gt;ddev-&gt;mode_config.max_width = 8192;
-		rdev-&gt;ddev-&gt;mode_config.max_height = 8192;
</span><span
class="add">+		rdev_to_drm(rdev)-&gt;mode_config.max_width = 8192;
+		rdev_to_drm(rdev)-&gt;mode_config.max_height = 8192;
</span> 	} else {
<span
class="del">-		rdev-&gt;ddev-&gt;mode_config.max_width = 4096;
-		rdev-&gt;ddev-&gt;mode_config.max_height = 4096;
</span><span
class="add">+		rdev_to_drm(rdev)-&gt;mode_config.max_width = 4096;
+		rdev_to_drm(rdev)-&gt;mode_config.max_height = 4096;
</span> 	}
 
<span
class="del">-	rdev-&gt;ddev-&gt;mode_config.preferred_depth = 24;
-	rdev-&gt;ddev-&gt;mode_config.prefer_shadow = 1;
</span><span
class="add">+	rdev_to_drm(rdev)-&gt;mode_config.preferred_depth = 24;
+	rdev_to_drm(rdev)-&gt;mode_config.prefer_shadow = 1;
</span> 
<span
class="del">-	rdev-&gt;ddev-&gt;mode_config.fb_modifiers_not_supported = true;
</span><span
class="add">+	rdev_to_drm(rdev)-&gt;mode_config.fb_modifiers_not_supported = true;
</span> 
 	ret = radeon_modeset_create_props(rdev);
 	if (ret) {
<span
class="hunk">@@ -1618,11 +1618,11 @@ int radeon_modeset_init(struct radeon_device *rdev)
</span> 
 	/* allocate crtcs */
 	for (i = 0; i &lt; rdev-&gt;num_crtc; i++) {
<span
class="del">-		radeon_crtc_init(rdev-&gt;ddev, i);
</span><span
class="add">+		radeon_crtc_init(rdev_to_drm(rdev), i);
</span> 	}
 
 	/* okay we should have all the bios connectors */
<span
class="del">-	ret = radeon_setup_enc_conn(rdev-&gt;ddev);
</span><span
class="add">+	ret = radeon_setup_enc_conn(rdev_to_drm(rdev));
</span> 	if (!ret) {
 		return ret;
 	}
<span
class="hunk">@@ -1639,7 +1639,7 @@ int radeon_modeset_init(struct radeon_device *rdev)
</span> 	/* setup afmt */
 	radeon_afmt_init(rdev);
 
<span
class="del">-	drm_kms_helper_poll_init(rdev-&gt;ddev);
</span><span
class="add">+	drm_kms_helper_poll_init(rdev_to_drm(rdev));
</span> 
 	/* do pm late init */
 	ret = radeon_pm_late_init(rdev);
<span
class="hunk">@@ -1650,11 +1650,11 @@ int radeon_modeset_init(struct radeon_device *rdev)
</span> void radeon_modeset_fini(struct radeon_device *rdev)
 {
 	if (rdev-&gt;mode_info.mode_config_initialized) {
<span
class="del">-		drm_kms_helper_poll_fini(rdev-&gt;ddev);
</span><span
class="add">+		drm_kms_helper_poll_fini(rdev_to_drm(rdev));
</span> 		radeon_hpd_fini(rdev);
<span
class="del">-		drm_helper_force_disable_all(rdev-&gt;ddev);
</span><span
class="add">+		drm_helper_force_disable_all(rdev_to_drm(rdev));
</span> 		radeon_afmt_fini(rdev);
<span
class="del">-		drm_mode_config_cleanup(rdev-&gt;ddev);
</span><span
class="add">+		drm_mode_config_cleanup(rdev_to_drm(rdev));
</span> 		rdev-&gt;mode_info.mode_config_initialized = false;
 	}
 
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_fbdev.c b/drivers/gpu/drm/radeon/radeon_fbdev.c
index 02bf25759059..fb70de29545c 100644
--- a/drivers/gpu/drm/radeon/radeon_fbdev.c
+++ b/drivers/gpu/drm/radeon/radeon_fbdev.c
</span><span
class="hunk">@@ -67,7 +67,7 @@ static int radeon_fbdev_create_pinned_object(struct drm_fb_helper *fb_helper,
</span> 	int height = mode_cmd-&gt;height;
 	u32 cpp;
 
<span
class="del">-	info = drm_get_format_info(rdev-&gt;ddev, mode_cmd);
</span><span
class="add">+	info = drm_get_format_info(rdev_to_drm(rdev), mode_cmd);
</span> 	cpp = info-&gt;cpp[0];
 
 	/* need to align pitch with crtc limits */
<span
class="hunk">@@ -148,15 +148,15 @@ static int radeon_fbdev_fb_open(struct fb_info *info, int user)
</span> 	struct radeon_device *rdev = fb_helper-&gt;dev-&gt;dev_private;
 	int ret;
 
<span
class="del">-	ret = pm_runtime_get_sync(rdev-&gt;ddev-&gt;dev);
</span><span
class="add">+	ret = pm_runtime_get_sync(rdev_to_drm(rdev)-&gt;dev);
</span> 	if (ret &lt; 0 &#38;&#38; ret != -EACCES)
 		goto err_pm_runtime_mark_last_busy;
 
 	return 0;
 
 err_pm_runtime_mark_last_busy:
<span
class="del">-	pm_runtime_mark_last_busy(rdev-&gt;ddev-&gt;dev);
-	pm_runtime_put_autosuspend(rdev-&gt;ddev-&gt;dev);
</span><span
class="add">+	pm_runtime_mark_last_busy(rdev_to_drm(rdev)-&gt;dev);
+	pm_runtime_put_autosuspend(rdev_to_drm(rdev)-&gt;dev);
</span> 	return ret;
 }
 
<span
class="hunk">@@ -165,8 +165,8 @@ static int radeon_fbdev_fb_release(struct fb_info *info, int user)
</span> 	struct drm_fb_helper *fb_helper = info-&gt;par;
 	struct radeon_device *rdev = fb_helper-&gt;dev-&gt;dev_private;
 
<span
class="del">-	pm_runtime_mark_last_busy(rdev-&gt;ddev-&gt;dev);
-	pm_runtime_put_autosuspend(rdev-&gt;ddev-&gt;dev);
</span><span
class="add">+	pm_runtime_mark_last_busy(rdev_to_drm(rdev)-&gt;dev);
+	pm_runtime_put_autosuspend(rdev_to_drm(rdev)-&gt;dev);
</span> 
 	return 0;
 }
<span
class="hunk">@@ -236,7 +236,7 @@ static int radeon_fbdev_fb_helper_fb_probe(struct drm_fb_helper *fb_helper,
</span> 		ret = -ENOMEM;
 		goto err_radeon_fbdev_destroy_pinned_object;
 	}
<span
class="del">-	ret = radeon_framebuffer_init(rdev-&gt;ddev, fb, &#38;mode_cmd, gobj);
</span><span
class="add">+	ret = radeon_framebuffer_init(rdev_to_drm(rdev), fb, &#38;mode_cmd, gobj);
</span> 	if (ret) {
 		DRM_ERROR(&#34;failed to initialize framebuffer %d\n&#34;, ret);
 		goto err_kfree;
<span
class="hunk">@@ -374,12 +374,12 @@ void radeon_fbdev_setup(struct radeon_device *rdev)
</span> 	fb_helper = kzalloc(sizeof(*fb_helper), GFP_KERNEL);
 	if (!fb_helper)
 		return;
<span
class="del">-	drm_fb_helper_prepare(rdev-&gt;ddev, fb_helper, bpp_sel, &#38;radeon_fbdev_fb_helper_funcs);
</span><span
class="add">+	drm_fb_helper_prepare(rdev_to_drm(rdev), fb_helper, bpp_sel, &#38;radeon_fbdev_fb_helper_funcs);
</span> 
<span
class="del">-	ret = drm_client_init(rdev-&gt;ddev, &#38;fb_helper-&gt;client, &#34;radeon-fbdev&#34;,
</span><span
class="add">+	ret = drm_client_init(rdev_to_drm(rdev), &#38;fb_helper-&gt;client, &#34;radeon-fbdev&#34;,
</span> 			      &#38;radeon_fbdev_client_funcs);
 	if (ret) {
<span
class="del">-		drm_err(rdev-&gt;ddev, &#34;Failed to register client: %d\n&#34;, ret);
</span><span
class="add">+		drm_err(rdev_to_drm(rdev), &#34;Failed to register client: %d\n&#34;, ret);
</span> 		goto err_drm_client_init;
 	}
 
<span
class="hunk">@@ -394,13 +394,13 @@ void radeon_fbdev_setup(struct radeon_device *rdev)
</span> 
 void radeon_fbdev_set_suspend(struct radeon_device *rdev, int state)
 {
<span
class="del">-	if (rdev-&gt;ddev-&gt;fb_helper)
-		drm_fb_helper_set_suspend(rdev-&gt;ddev-&gt;fb_helper, state);
</span><span
class="add">+	if (rdev_to_drm(rdev)-&gt;fb_helper)
+		drm_fb_helper_set_suspend(rdev_to_drm(rdev)-&gt;fb_helper, state);
</span> }
 
 bool radeon_fbdev_robj_is_fb(struct radeon_device *rdev, struct radeon_bo *robj)
 {
<span
class="del">-	struct drm_fb_helper *fb_helper = rdev-&gt;ddev-&gt;fb_helper;
</span><span
class="add">+	struct drm_fb_helper *fb_helper = rdev_to_drm(rdev)-&gt;fb_helper;
</span> 	struct drm_gem_object *gobj;
 
 	if (!fb_helper)
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_fence.c b/drivers/gpu/drm/radeon/radeon_fence.c
index 4fb780d96f32..daff61586be5 100644
--- a/drivers/gpu/drm/radeon/radeon_fence.c
+++ b/drivers/gpu/drm/radeon/radeon_fence.c
</span><span
class="hunk">@@ -150,7 +150,7 @@ int radeon_fence_emit(struct radeon_device *rdev,
</span> 		       rdev-&gt;fence_context + ring,
 		       seq);
 	radeon_fence_ring_emit(rdev, ring, *fence);
<span
class="del">-	trace_radeon_fence_emit(rdev-&gt;ddev, ring, (*fence)-&gt;seq);
</span><span
class="add">+	trace_radeon_fence_emit(rdev_to_drm(rdev), ring, (*fence)-&gt;seq);
</span> 	radeon_fence_schedule_check(rdev, ring);
 	return 0;
 }
<span
class="hunk">@@ -489,7 +489,7 @@ static long radeon_fence_wait_seq_timeout(struct radeon_device *rdev,
</span> 		if (!target_seq[i])
 			continue;
 
<span
class="del">-		trace_radeon_fence_wait_begin(rdev-&gt;ddev, i, target_seq[i]);
</span><span
class="add">+		trace_radeon_fence_wait_begin(rdev_to_drm(rdev), i, target_seq[i]);
</span> 		radeon_irq_kms_sw_irq_get(rdev, i);
 	}
 
<span
class="hunk">@@ -511,7 +511,7 @@ static long radeon_fence_wait_seq_timeout(struct radeon_device *rdev,
</span> 			continue;
 
 		radeon_irq_kms_sw_irq_put(rdev, i);
<span
class="del">-		trace_radeon_fence_wait_end(rdev-&gt;ddev, i, target_seq[i]);
</span><span
class="add">+		trace_radeon_fence_wait_end(rdev_to_drm(rdev), i, target_seq[i]);
</span> 	}
 
 	return r;
<span
class="hunk">@@ -995,7 +995,7 @@ DEFINE_DEBUGFS_ATTRIBUTE(radeon_debugfs_gpu_reset_fops,
</span> void radeon_debugfs_fence_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;radeon_gpu_reset&#34;, 0444, root, rdev,
 			    &#38;radeon_debugfs_gpu_reset_fops);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_gem.c b/drivers/gpu/drm/radeon/radeon_gem.c
index 2ef201a072f1..9dd4ff09d562 100644
--- a/drivers/gpu/drm/radeon/radeon_gem.c
+++ b/drivers/gpu/drm/radeon/radeon_gem.c
</span><span
class="hunk">@@ -899,7 +899,7 @@ DEFINE_SHOW_ATTRIBUTE(radeon_debugfs_gem_info);
</span> void radeon_gem_debugfs_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;radeon_gem_info&#34;, 0444, root, rdev,
 			    &#38;radeon_debugfs_gem_info_fops);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_i2c.c b/drivers/gpu/drm/radeon/radeon_i2c.c
index 3d174390a8af..1f16619ed06e 100644
--- a/drivers/gpu/drm/radeon/radeon_i2c.c
+++ b/drivers/gpu/drm/radeon/radeon_i2c.c
</span><span
class="hunk">@@ -1011,7 +1011,7 @@ void radeon_i2c_add(struct radeon_device *rdev,
</span> 		    struct radeon_i2c_bus_rec *rec,
 		    const char *name)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	int i;
 
 	for (i = 0; i &lt; RADEON_MAX_I2C_BUS; i++) {
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Wu Hoi Pok</name><email>wuhoipok@gmail.com</email></author><title
type="html">[PATCH v2 4/7] drm/radeon: rdev-&gt;ddev to rdev_to_drm(rdev) 3</title><updated>2024-06-22T15:01:13Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240621141924.20033-1-wuhoipok@gmail.com/"/><id>urn:uuid:f33ca19b-4590-d55d-9533-e9fd7bfef406</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Please see Patch v2 1/7 for details.

Signed-off-by: Wu Hoi Pok &lt;wuhoipok@gmail.com&gt;
---
 drivers/gpu/drm/radeon/r600_hdmi.c       |  2 +-
 drivers/gpu/drm/radeon/radeon_acpi.c     | 10 +++++-----
 drivers/gpu/drm/radeon/radeon_agp.c      |  2 +-
 drivers/gpu/drm/radeon/radeon_atombios.c |  2 +-
 drivers/gpu/drm/radeon/radeon_audio.c    |  4 ++--
 drivers/gpu/drm/radeon/radeon_combios.c  | 12 ++++++------
 6 files <a href="http://lore.kernel.org/amd-gfx/20240621141924.20033-1-wuhoipok@gmail.com/#related">changed</a>, 16 insertions(+), 16 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/radeon/r600_hdmi.c b/drivers/gpu/drm/radeon/r600_hdmi.c
index f3551ebaa2f0..661f374f5f27 100644
--- a/drivers/gpu/drm/radeon/r600_hdmi.c
+++ b/drivers/gpu/drm/radeon/r600_hdmi.c
</span><span
class="hunk">@@ -116,7 +116,7 @@ void r600_audio_update_hdmi(struct work_struct *work)
</span> {
 	struct radeon_device *rdev = container_of(work, struct radeon_device,
 						  audio_work);
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct r600_audio_pin audio_status = r600_audio_status(rdev);
 	struct drm_encoder *encoder;
 	bool changed = false;
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_acpi.c b/drivers/gpu/drm/radeon/radeon_acpi.c
index 603a78e41ba5..22ce61bdfc06 100644
--- a/drivers/gpu/drm/radeon/radeon_acpi.c
+++ b/drivers/gpu/drm/radeon/radeon_acpi.c
</span><span
class="hunk">@@ -405,11 +405,11 @@ static int radeon_atif_handler(struct radeon_device *rdev,
</span> 	if (req.pending &#38; ATIF_DGPU_DISPLAY_EVENT) {
 		if ((rdev-&gt;flags &#38; RADEON_IS_PX) &#38;&#38;
 		    radeon_atpx_dgpu_req_power_for_displays()) {
<span
class="del">-			pm_runtime_get_sync(rdev-&gt;ddev-&gt;dev);
</span><span
class="add">+			pm_runtime_get_sync(rdev_to_drm(rdev)-&gt;dev);
</span> 			/* Just fire off a uevent and let userspace tell us what to do */
<span
class="del">-			drm_helper_hpd_irq_event(rdev-&gt;ddev);
-			pm_runtime_mark_last_busy(rdev-&gt;ddev-&gt;dev);
-			pm_runtime_put_autosuspend(rdev-&gt;ddev-&gt;dev);
</span><span
class="add">+			drm_helper_hpd_irq_event(rdev_to_drm(rdev));
+			pm_runtime_mark_last_busy(rdev_to_drm(rdev)-&gt;dev);
+			pm_runtime_put_autosuspend(rdev_to_drm(rdev)-&gt;dev);
</span> 		}
 	}
 	/* TODO: check other events */
<span
class="hunk">@@ -736,7 +736,7 @@ int radeon_acpi_init(struct radeon_device *rdev)
</span> 		struct radeon_encoder *target = NULL;
 
 		/* Find the encoder controlling the brightness */
<span
class="del">-		list_for_each_entry(tmp, &#38;rdev-&gt;ddev-&gt;mode_config.encoder_list,
</span><span
class="add">+		list_for_each_entry(tmp, &#38;rdev_to_drm(rdev)-&gt;mode_config.encoder_list,
</span> 				head) {
 			struct radeon_encoder *enc = to_radeon_encoder(tmp);
 
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_agp.c b/drivers/gpu/drm/radeon/radeon_agp.c
index a3d749e350f9..89d7b0e9e79f 100644
--- a/drivers/gpu/drm/radeon/radeon_agp.c
+++ b/drivers/gpu/drm/radeon/radeon_agp.c
</span><span
class="hunk">@@ -161,7 +161,7 @@ struct radeon_agp_head *radeon_agp_head_init(struct drm_device *dev)
</span> 
 static int radeon_agp_head_acquire(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct pci_dev *pdev = to_pci_dev(dev-&gt;dev);
 
 	if (!rdev-&gt;agp)
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_atombios.c b/drivers/gpu/drm/radeon/radeon_atombios.c
index 10793a433bf5..97c4e10d0550 100644
--- a/drivers/gpu/drm/radeon/radeon_atombios.c
+++ b/drivers/gpu/drm/radeon/radeon_atombios.c
</span><span
class="hunk">@@ -187,7 +187,7 @@ void radeon_atombios_i2c_init(struct radeon_device *rdev)
</span> 
 			if (i2c.valid) {
 				sprintf(stmp, &#34;0x%x&#34;, i2c.i2c_id);
<span
class="del">-				rdev-&gt;i2c_bus[i] = radeon_i2c_create(rdev-&gt;ddev, &#38;i2c, stmp);
</span><span
class="add">+				rdev-&gt;i2c_bus[i] = radeon_i2c_create(rdev_to_drm(rdev), &#38;i2c, stmp);
</span> 			}
 			gpio = (ATOM_GPIO_I2C_ASSIGMENT *)
 				((u8 *)gpio + sizeof(ATOM_GPIO_I2C_ASSIGMENT));
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 0bcd767b9f47..47aa06a9a942 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
</span><span
class="hunk">@@ -196,7 +196,7 @@ static void radeon_audio_enable(struct radeon_device *rdev,
</span> 		return;
 
 	if (rdev-&gt;mode_info.mode_config_initialized) {
<span
class="del">-		list_for_each_entry(encoder, &#38;rdev-&gt;ddev-&gt;mode_config.encoder_list, head) {
</span><span
class="add">+		list_for_each_entry(encoder, &#38;rdev_to_drm(rdev)-&gt;mode_config.encoder_list, head) {
</span> 			if (radeon_encoder_is_digital(encoder)) {
 				radeon_encoder = to_radeon_encoder(encoder);
 				dig = radeon_encoder-&gt;enc_priv;
<span
class="hunk">@@ -760,7 +760,7 @@ static int radeon_audio_component_get_eld(struct device *kdev, int port,
</span> 	if (!rdev-&gt;audio.enabled || !rdev-&gt;mode_info.mode_config_initialized)
 		return 0;
 
<span
class="del">-	list_for_each_entry(encoder, &#38;rdev-&gt;ddev-&gt;mode_config.encoder_list, head) {
</span><span
class="add">+	list_for_each_entry(encoder, &#38;rdev_to_drm(rdev)-&gt;mode_config.encoder_list, head) {
</span> 		if (!radeon_encoder_is_digital(encoder))
 			continue;
 		radeon_encoder = to_radeon_encoder(encoder);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_combios.c b/drivers/gpu/drm/radeon/radeon_combios.c
index 6952b1273b0f..41ddc576f8f8 100644
--- a/drivers/gpu/drm/radeon/radeon_combios.c
+++ b/drivers/gpu/drm/radeon/radeon_combios.c
</span><span
class="hunk">@@ -372,7 +372,7 @@ bool radeon_combios_check_hardcoded_edid(struct radeon_device *rdev)
</span> 	int edid_info, size;
 	struct edid *edid;
 	unsigned char *raw;
<span
class="del">-	edid_info = combios_get_table_offset(rdev-&gt;ddev, COMBIOS_HARDCODED_EDID_TABLE);
</span><span
class="add">+	edid_info = combios_get_table_offset(rdev_to_drm(rdev), COMBIOS_HARDCODED_EDID_TABLE);
</span> 	if (!edid_info)
 		return false;
 
<span
class="hunk">@@ -642,7 +642,7 @@ static struct radeon_i2c_bus_rec combios_setup_i2c_bus(struct radeon_device *rde
</span> 
 static struct radeon_i2c_bus_rec radeon_combios_get_i2c_info_from_table(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct radeon_i2c_bus_rec i2c;
 	u16 offset;
 	u8 id, blocks, clk, data;
<span
class="hunk">@@ -670,7 +670,7 @@ static struct radeon_i2c_bus_rec radeon_combios_get_i2c_info_from_table(struct r
</span> 
 void radeon_combios_i2c_init(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct radeon_i2c_bus_rec i2c;
 
 	/* actual hw pads
<span
class="hunk">@@ -812,7 +812,7 @@ bool radeon_combios_get_clock_info(struct drm_device *dev)
</span> 
 bool radeon_combios_sideport_present(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	u16 igp_info;
 
 	/* sideport is AMD only */
<span
class="hunk">@@ -915,7 +915,7 @@ struct radeon_encoder_primary_dac *radeon_combios_get_primary_dac_info(struct
</span> enum radeon_tv_std
 radeon_combios_get_tv_info(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	uint16_t tv_info;
 	enum radeon_tv_std tv_std = TV_STD_NTSC;
 
<span
class="hunk">@@ -2637,7 +2637,7 @@ static const char *thermal_controller_names[] = {
</span> 
 void radeon_combios_get_power_modes(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	u16 offset, misc, misc2 = 0;
 	u8 rev, tmp;
 	int state_index = 0;
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Wu Hoi Pok</name><email>wuhoipok@gmail.com</email></author><title
type="html">[PATCH v2 3/7] drm/radeon: rdev-&gt;ddev to rdev_to_drm(rdev) 2</title><updated>2024-06-22T15:01:16Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240621141810.19964-1-wuhoipok@gmail.com/"/><id>urn:uuid:a1bd328d-b9d8-5ee0-c31c-df347f26581b</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Please see Patch v2 1/7 for details.

Signed-off-by: Wu Hoi Pok &lt;wuhoipok@gmail.com&gt;
---
 drivers/gpu/drm/radeon/r300.c     |  6 +++---
 drivers/gpu/drm/radeon/r420.c     |  6 +++---
 drivers/gpu/drm/radeon/r520.c     |  2 +-
 drivers/gpu/drm/radeon/r600.c     | 12 ++++++------
 drivers/gpu/drm/radeon/r600_cs.c  |  2 +-
 drivers/gpu/drm/radeon/r600_dpm.c |  4 ++--
 6 files <a href="http://lore.kernel.org/amd-gfx/20240621141810.19964-1-wuhoipok@gmail.com/#related">changed</a>, 16 insertions(+), 16 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/radeon/r300.c b/drivers/gpu/drm/radeon/r300.c
index 1620f534f55f..05c13102a8cb 100644
--- a/drivers/gpu/drm/radeon/r300.c
+++ b/drivers/gpu/drm/radeon/r300.c
</span><span
class="hunk">@@ -616,7 +616,7 @@ DEFINE_SHOW_ATTRIBUTE(rv370_debugfs_pcie_gart_info);
</span> static void rv370_debugfs_pcie_gart_info_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;rv370_pcie_gart_info&#34;, 0444, root, rdev,
 			    &#38;rv370_debugfs_pcie_gart_info_fops);
<span
class="hunk">@@ -1452,7 +1452,7 @@ int r300_resume(struct radeon_device *rdev)
</span> 			RREG32(R_0007C0_CP_STAT));
 	}
 	/* post */
<span
class="del">-	radeon_combios_asic_init(rdev-&gt;ddev);
</span><span
class="add">+	radeon_combios_asic_init(rdev_to_drm(rdev));
</span> 	/* Resume clock after posting */
 	r300_clock_startup(rdev);
 	/* Initialize surface registers */
<span
class="hunk">@@ -1538,7 +1538,7 @@ int r300_init(struct radeon_device *rdev)
</span> 	/* Set asic errata */
 	r300_errata(rdev);
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* initialize AGP */
 	if (rdev-&gt;flags &#38; RADEON_IS_AGP) {
 		r = radeon_agp_init(rdev);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/r420.c b/drivers/gpu/drm/radeon/r420.c
index a979662eaa73..9a31cdec6415 100644
--- a/drivers/gpu/drm/radeon/r420.c
+++ b/drivers/gpu/drm/radeon/r420.c
</span><span
class="hunk">@@ -322,7 +322,7 @@ int r420_resume(struct radeon_device *rdev)
</span> 	if (rdev-&gt;is_atom_bios) {
 		atom_asic_init(rdev-&gt;mode_info.atom_context);
 	} else {
<span
class="del">-		radeon_combios_asic_init(rdev-&gt;ddev);
</span><span
class="add">+		radeon_combios_asic_init(rdev_to_drm(rdev));
</span> 	}
 	/* Resume clock after posting */
 	r420_clock_resume(rdev);
<span
class="hunk">@@ -414,7 +414,7 @@ int r420_init(struct radeon_device *rdev)
</span> 		return -EINVAL;
 
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* initialize AGP */
 	if (rdev-&gt;flags &#38; RADEON_IS_AGP) {
 		r = radeon_agp_init(rdev);
<span
class="hunk">@@ -493,7 +493,7 @@ DEFINE_SHOW_ATTRIBUTE(r420_debugfs_pipes_info);
</span> void r420_debugfs_pipes_info_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;r420_pipes_info&#34;, 0444, root, rdev,
 			    &#38;r420_debugfs_pipes_info_fops);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/r520.c b/drivers/gpu/drm/radeon/r520.c
index 6cbcaa845192..08e127b3249a 100644
--- a/drivers/gpu/drm/radeon/r520.c
+++ b/drivers/gpu/drm/radeon/r520.c
</span><span
class="hunk">@@ -287,7 +287,7 @@ int r520_init(struct radeon_device *rdev)
</span> 		atom_asic_init(rdev-&gt;mode_info.atom_context);
 	}
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* initialize AGP */
 	if (rdev-&gt;flags &#38; RADEON_IS_AGP) {
 		r = radeon_agp_init(rdev);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/r600.c b/drivers/gpu/drm/radeon/r600.c
index 087d41e370fd..8b62f7faa5b9 100644
--- a/drivers/gpu/drm/radeon/r600.c
+++ b/drivers/gpu/drm/radeon/r600.c
</span><span
class="hunk">@@ -950,7 +950,7 @@ void r600_hpd_set_polarity(struct radeon_device *rdev,
</span> 
 void r600_hpd_init(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_connector *connector;
 	unsigned enable = 0;
 
<span
class="hunk">@@ -1017,7 +1017,7 @@ void r600_hpd_init(struct radeon_device *rdev)
</span> 
 void r600_hpd_fini(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_connector *connector;
 	unsigned disable = 0;
 
<span
class="hunk">@@ -3280,7 +3280,7 @@ int r600_init(struct radeon_device *rdev)
</span> 	/* Initialize surface registers */
 	radeon_surface_init(rdev);
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* Fence driver */
 	radeon_fence_driver_init(rdev);
 	if (rdev-&gt;flags &#38; RADEON_IS_AGP) {
<span
class="hunk">@@ -4136,7 +4136,7 @@ int r600_irq_process(struct radeon_device *rdev)
</span> 					DRM_DEBUG(&#34;IH: D1 vblank - IH event w/o asserted irq bit?\n&#34;);
 
 				if (rdev-&gt;irq.crtc_vblank_int[0]) {
<span
class="del">-					drm_handle_vblank(rdev-&gt;ddev, 0);
</span><span
class="add">+					drm_handle_vblank(rdev_to_drm(rdev), 0);
</span> 					rdev-&gt;pm.vblank_sync = true;
 					wake_up(&#38;rdev-&gt;irq.vblank_queue);
 				}
<span
class="hunk">@@ -4166,7 +4166,7 @@ int r600_irq_process(struct radeon_device *rdev)
</span> 					DRM_DEBUG(&#34;IH: D2 vblank - IH event w/o asserted irq bit?\n&#34;);
 
 				if (rdev-&gt;irq.crtc_vblank_int[1]) {
<span
class="del">-					drm_handle_vblank(rdev-&gt;ddev, 1);
</span><span
class="add">+					drm_handle_vblank(rdev_to_drm(rdev), 1);
</span> 					rdev-&gt;pm.vblank_sync = true;
 					wake_up(&#38;rdev-&gt;irq.vblank_queue);
 				}
<span
class="hunk">@@ -4358,7 +4358,7 @@ DEFINE_SHOW_ATTRIBUTE(r600_debugfs_mc_info);
</span> static void r600_debugfs_mc_info_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;r600_mc_info&#34;, 0444, root, rdev,
 			    &#38;r600_debugfs_mc_info_fops);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/r600_cs.c b/drivers/gpu/drm/radeon/r600_cs.c
index 6cf54a747749..1b2d31c4d77c 100644
--- a/drivers/gpu/drm/radeon/r600_cs.c
+++ b/drivers/gpu/drm/radeon/r600_cs.c
</span><span
class="hunk">@@ -884,7 +884,7 @@ int r600_cs_common_vline_parse(struct radeon_cs_parser *p,
</span> 	crtc_id = radeon_get_ib_value(p, h_idx + 2 + 7 + 1);
 	reg = R600_CP_PACKET0_GET_REG(header);
 
<span
class="del">-	crtc = drm_crtc_find(p-&gt;rdev-&gt;ddev, p-&gt;filp, crtc_id);
</span><span
class="add">+	crtc = drm_crtc_find(rdev_to_drm(p-&gt;rdev), p-&gt;filp, crtc_id);
</span> 	if (!crtc) {
 		DRM_ERROR(&#34;cannot find crtc %d\n&#34;, crtc_id);
 		return -ENOENT;
<span
class="head">diff --git a/drivers/gpu/drm/radeon/r600_dpm.c b/drivers/gpu/drm/radeon/r600_dpm.c
index 64980a61d38a..81d58ef667dd 100644
--- a/drivers/gpu/drm/radeon/r600_dpm.c
+++ b/drivers/gpu/drm/radeon/r600_dpm.c
</span><span
class="hunk">@@ -153,7 +153,7 @@ void r600_dpm_print_ps_status(struct radeon_device *rdev,
</span> 
 u32 r600_dpm_get_vblank_time(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
 	u32 vblank_in_pixels;
<span
class="hunk">@@ -180,7 +180,7 @@ u32 r600_dpm_get_vblank_time(struct radeon_device *rdev)
</span> 
 u32 r600_dpm_get_vrefresh(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
 	u32 vrefresh = 0;
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Wu Hoi Pok</name><email>wuhoipok@gmail.com</email></author><title
type="html">[PATCH v2 2/7] drm/radeon: rdev-&gt;ddev to rdev_to_drm(rdev) 1</title><updated>2024-06-22T15:01:22Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240621141725.19913-1-wuhoipok@gmail.com/"/><id>urn:uuid:fb1e8be1-9545-719c-756b-4e886f6f58f0</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Please see Patch v2 1/7 for details.

Signed-off-by: Wu Hoi Pok &lt;wuhoipok@gmail.com&gt;
---
 drivers/gpu/drm/radeon/atombios_encoders.c |  2 +-
 drivers/gpu/drm/radeon/cik.c               | 14 ++++++-------
 drivers/gpu/drm/radeon/dce6_afmt.c         |  2 +-
 drivers/gpu/drm/radeon/evergreen.c         | 12 +++++------
 drivers/gpu/drm/radeon/ni.c                |  2 +-
 drivers/gpu/drm/radeon/r100.c              | 24 +++++++++++-----------
 6 files <a href="http://lore.kernel.org/amd-gfx/20240621141725.19913-1-wuhoipok@gmail.com/#related">changed</a>, 28 insertions(+), 28 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/radeon/atombios_encoders.c b/drivers/gpu/drm/radeon/atombios_encoders.c
index 03e6871b3065..c82e0fbc49b4 100644
--- a/drivers/gpu/drm/radeon/atombios_encoders.c
+++ b/drivers/gpu/drm/radeon/atombios_encoders.c
</span><span
class="hunk">@@ -2179,7 +2179,7 @@ int radeon_atom_pick_dig_encoder(struct drm_encoder *encoder, int fe_idx)
</span> void
 radeon_atom_encoder_init(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_encoder *encoder;
 
 	list_for_each_entry(encoder, &#38;dev-&gt;mode_config.encoder_list, head) {
<span
class="head">diff --git a/drivers/gpu/drm/radeon/cik.c b/drivers/gpu/drm/radeon/cik.c
index b5e96a8fc2c1..11a492f21157 100644
--- a/drivers/gpu/drm/radeon/cik.c
+++ b/drivers/gpu/drm/radeon/cik.c
</span><span
class="hunk">@@ -7585,7 +7585,7 @@ int cik_irq_process(struct radeon_device *rdev)
</span> 					DRM_DEBUG(&#34;IH: IH event w/o asserted irq bit?\n&#34;);
 
 				if (rdev-&gt;irq.crtc_vblank_int[0]) {
<span
class="del">-					drm_handle_vblank(rdev-&gt;ddev, 0);
</span><span
class="add">+					drm_handle_vblank(rdev_to_drm(rdev), 0);
</span> 					rdev-&gt;pm.vblank_sync = true;
 					wake_up(&#38;rdev-&gt;irq.vblank_queue);
 				}
<span
class="hunk">@@ -7615,7 +7615,7 @@ int cik_irq_process(struct radeon_device *rdev)
</span> 					DRM_DEBUG(&#34;IH: IH event w/o asserted irq bit?\n&#34;);
 
 				if (rdev-&gt;irq.crtc_vblank_int[1]) {
<span
class="del">-					drm_handle_vblank(rdev-&gt;ddev, 1);
</span><span
class="add">+					drm_handle_vblank(rdev_to_drm(rdev), 1);
</span> 					rdev-&gt;pm.vblank_sync = true;
 					wake_up(&#38;rdev-&gt;irq.vblank_queue);
 				}
<span
class="hunk">@@ -7645,7 +7645,7 @@ int cik_irq_process(struct radeon_device *rdev)
</span> 					DRM_DEBUG(&#34;IH: IH event w/o asserted irq bit?\n&#34;);
 
 				if (rdev-&gt;irq.crtc_vblank_int[2]) {
<span
class="del">-					drm_handle_vblank(rdev-&gt;ddev, 2);
</span><span
class="add">+					drm_handle_vblank(rdev_to_drm(rdev), 2);
</span> 					rdev-&gt;pm.vblank_sync = true;
 					wake_up(&#38;rdev-&gt;irq.vblank_queue);
 				}
<span
class="hunk">@@ -7675,7 +7675,7 @@ int cik_irq_process(struct radeon_device *rdev)
</span> 					DRM_DEBUG(&#34;IH: IH event w/o asserted irq bit?\n&#34;);
 
 				if (rdev-&gt;irq.crtc_vblank_int[3]) {
<span
class="del">-					drm_handle_vblank(rdev-&gt;ddev, 3);
</span><span
class="add">+					drm_handle_vblank(rdev_to_drm(rdev), 3);
</span> 					rdev-&gt;pm.vblank_sync = true;
 					wake_up(&#38;rdev-&gt;irq.vblank_queue);
 				}
<span
class="hunk">@@ -7705,7 +7705,7 @@ int cik_irq_process(struct radeon_device *rdev)
</span> 					DRM_DEBUG(&#34;IH: IH event w/o asserted irq bit?\n&#34;);
 
 				if (rdev-&gt;irq.crtc_vblank_int[4]) {
<span
class="del">-					drm_handle_vblank(rdev-&gt;ddev, 4);
</span><span
class="add">+					drm_handle_vblank(rdev_to_drm(rdev), 4);
</span> 					rdev-&gt;pm.vblank_sync = true;
 					wake_up(&#38;rdev-&gt;irq.vblank_queue);
 				}
<span
class="hunk">@@ -7735,7 +7735,7 @@ int cik_irq_process(struct radeon_device *rdev)
</span> 					DRM_DEBUG(&#34;IH: IH event w/o asserted irq bit?\n&#34;);
 
 				if (rdev-&gt;irq.crtc_vblank_int[5]) {
<span
class="del">-					drm_handle_vblank(rdev-&gt;ddev, 5);
</span><span
class="add">+					drm_handle_vblank(rdev_to_drm(rdev), 5);
</span> 					rdev-&gt;pm.vblank_sync = true;
 					wake_up(&#38;rdev-&gt;irq.vblank_queue);
 				}
<span
class="hunk">@@ -8581,7 +8581,7 @@ int cik_init(struct radeon_device *rdev)
</span> 	/* Initialize surface registers */
 	radeon_surface_init(rdev);
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 
 	/* Fence driver */
 	radeon_fence_driver_init(rdev);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/dce6_afmt.c b/drivers/gpu/drm/radeon/dce6_afmt.c
index 4c06f47453fd..d6ab93ed9ec4 100644
--- a/drivers/gpu/drm/radeon/dce6_afmt.c
+++ b/drivers/gpu/drm/radeon/dce6_afmt.c
</span><span
class="hunk">@@ -91,7 +91,7 @@ struct r600_audio_pin *dce6_audio_get_pin(struct radeon_device *rdev)
</span> 			pin = &#38;rdev-&gt;audio.pin[i];
 			pin_count = 0;
 
<span
class="del">-			list_for_each_entry(encoder, &#38;rdev-&gt;ddev-&gt;mode_config.encoder_list, head) {
</span><span
class="add">+			list_for_each_entry(encoder, &#38;rdev_to_drm(rdev)-&gt;mode_config.encoder_list, head) {
</span> 				if (radeon_encoder_is_digital(encoder)) {
 					radeon_encoder = to_radeon_encoder(encoder);
 					dig = radeon_encoder-&gt;enc_priv;
<span
class="head">diff --git a/drivers/gpu/drm/radeon/evergreen.c b/drivers/gpu/drm/radeon/evergreen.c
index c634dc28e6c3..bc4ab71613a5 100644
--- a/drivers/gpu/drm/radeon/evergreen.c
+++ b/drivers/gpu/drm/radeon/evergreen.c
</span><span
class="hunk">@@ -1673,7 +1673,7 @@ void evergreen_pm_misc(struct radeon_device *rdev)
</span>  */
 void evergreen_pm_prepare(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
 	u32 tmp;
<span
class="hunk">@@ -1698,7 +1698,7 @@ void evergreen_pm_prepare(struct radeon_device *rdev)
</span>  */
 void evergreen_pm_finish(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
 	u32 tmp;
<span
class="hunk">@@ -1763,7 +1763,7 @@ void evergreen_hpd_set_polarity(struct radeon_device *rdev,
</span>  */
 void evergreen_hpd_init(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_connector *connector;
 	unsigned enabled = 0;
 	u32 tmp = DC_HPDx_CONNECTION_TIMER(0x9c4) |
<span
class="hunk">@@ -1804,7 +1804,7 @@ void evergreen_hpd_init(struct radeon_device *rdev)
</span>  */
 void evergreen_hpd_fini(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_connector *connector;
 	unsigned disabled = 0;
 
<span
class="hunk">@@ -4753,7 +4753,7 @@ int evergreen_irq_process(struct radeon_device *rdev)
</span> 				event_name = &#34;vblank&#34;;
 
 				if (rdev-&gt;irq.crtc_vblank_int[crtc_idx]) {
<span
class="del">-					drm_handle_vblank(rdev-&gt;ddev, crtc_idx);
</span><span
class="add">+					drm_handle_vblank(rdev_to_drm(rdev), crtc_idx);
</span> 					rdev-&gt;pm.vblank_sync = true;
 					wake_up(&#38;rdev-&gt;irq.vblank_queue);
 				}
<span
class="hunk">@@ -5211,7 +5211,7 @@ int evergreen_init(struct radeon_device *rdev)
</span> 	/* Initialize surface registers */
 	radeon_surface_init(rdev);
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* Fence driver */
 	radeon_fence_driver_init(rdev);
 	/* initialize AGP */
<span
class="head">diff --git a/drivers/gpu/drm/radeon/ni.c b/drivers/gpu/drm/radeon/ni.c
index 77aee99e473a..3890911fe693 100644
--- a/drivers/gpu/drm/radeon/ni.c
+++ b/drivers/gpu/drm/radeon/ni.c
</span><span
class="hunk">@@ -2360,7 +2360,7 @@ int cayman_init(struct radeon_device *rdev)
</span> 	/* Initialize surface registers */
 	radeon_surface_init(rdev);
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* Fence driver */
 	radeon_fence_driver_init(rdev);
 	/* initialize memory controller */
<span
class="head">diff --git a/drivers/gpu/drm/radeon/r100.c b/drivers/gpu/drm/radeon/r100.c
index 0b1e19345f43..d7d7d23bf9a1 100644
--- a/drivers/gpu/drm/radeon/r100.c
+++ b/drivers/gpu/drm/radeon/r100.c
</span><span
class="hunk">@@ -459,7 +459,7 @@ void r100_pm_misc(struct radeon_device *rdev)
</span>  */
 void r100_pm_prepare(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
 	u32 tmp;
<span
class="hunk">@@ -490,7 +490,7 @@ void r100_pm_prepare(struct radeon_device *rdev)
</span>  */
 void r100_pm_finish(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *ddev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *ddev = rdev_to_drm(rdev);
</span> 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
 	u32 tmp;
<span
class="hunk">@@ -603,7 +603,7 @@ void r100_hpd_set_polarity(struct radeon_device *rdev,
</span>  */
 void r100_hpd_init(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_connector *connector;
 	unsigned enable = 0;
 
<span
class="hunk">@@ -626,7 +626,7 @@ void r100_hpd_init(struct radeon_device *rdev)
</span>  */
 void r100_hpd_fini(struct radeon_device *rdev)
 {
<span
class="del">-	struct drm_device *dev = rdev-&gt;ddev;
</span><span
class="add">+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	struct drm_connector *connector;
 	unsigned disable = 0;
 
<span
class="hunk">@@ -798,7 +798,7 @@ int r100_irq_process(struct radeon_device *rdev)
</span> 		/* Vertical blank interrupts */
 		if (status &#38; RADEON_CRTC_VBLANK_STAT) {
 			if (rdev-&gt;irq.crtc_vblank_int[0]) {
<span
class="del">-				drm_handle_vblank(rdev-&gt;ddev, 0);
</span><span
class="add">+				drm_handle_vblank(rdev_to_drm(rdev), 0);
</span> 				rdev-&gt;pm.vblank_sync = true;
 				wake_up(&#38;rdev-&gt;irq.vblank_queue);
 			}
<span
class="hunk">@@ -807,7 +807,7 @@ int r100_irq_process(struct radeon_device *rdev)
</span> 		}
 		if (status &#38; RADEON_CRTC2_VBLANK_STAT) {
 			if (rdev-&gt;irq.crtc_vblank_int[1]) {
<span
class="del">-				drm_handle_vblank(rdev-&gt;ddev, 1);
</span><span
class="add">+				drm_handle_vblank(rdev_to_drm(rdev), 1);
</span> 				rdev-&gt;pm.vblank_sync = true;
 				wake_up(&#38;rdev-&gt;irq.vblank_queue);
 			}
<span
class="hunk">@@ -1471,7 +1471,7 @@ int r100_cs_packet_parse_vline(struct radeon_cs_parser *p)
</span> 	header = radeon_get_ib_value(p, h_idx);
 	crtc_id = radeon_get_ib_value(p, h_idx + 5);
 	reg = R100_CP_PACKET0_GET_REG(header);
<span
class="del">-	crtc = drm_crtc_find(p-&gt;rdev-&gt;ddev, p-&gt;filp, crtc_id);
</span><span
class="add">+	crtc = drm_crtc_find(rdev_to_drm(p-&gt;rdev), p-&gt;filp, crtc_id);
</span> 	if (!crtc) {
 		DRM_ERROR(&#34;cannot find crtc %d\n&#34;, crtc_id);
 		return -ENOENT;
<span
class="hunk">@@ -3059,7 +3059,7 @@ DEFINE_SHOW_ATTRIBUTE(r100_debugfs_mc_info);
</span> void  r100_debugfs_rbbm_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;r100_rbbm_info&#34;, 0444, root, rdev,
 			    &#38;r100_debugfs_rbbm_info_fops);
<span
class="hunk">@@ -3069,7 +3069,7 @@ void  r100_debugfs_rbbm_init(struct radeon_device *rdev)
</span> void r100_debugfs_cp_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;r100_cp_ring_info&#34;, 0444, root, rdev,
 			    &#38;r100_debugfs_cp_ring_info_fops);
<span
class="hunk">@@ -3081,7 +3081,7 @@ void r100_debugfs_cp_init(struct radeon_device *rdev)
</span> void  r100_debugfs_mc_info_init(struct radeon_device *rdev)
 {
 #if defined(CONFIG_DEBUG_FS)
<span
class="del">-	struct dentry *root = rdev-&gt;ddev-&gt;primary-&gt;debugfs_root;
</span><span
class="add">+	struct dentry *root = rdev_to_drm(rdev)-&gt;primary-&gt;debugfs_root;
</span> 
 	debugfs_create_file(&#34;r100_mc_info&#34;, 0444, root, rdev,
 			    &#38;r100_debugfs_mc_info_fops);
<span
class="hunk">@@ -3947,7 +3947,7 @@ int r100_resume(struct radeon_device *rdev)
</span> 			RREG32(R_0007C0_CP_STAT));
 	}
 	/* post */
<span
class="del">-	radeon_combios_asic_init(rdev-&gt;ddev);
</span><span
class="add">+	radeon_combios_asic_init(rdev_to_drm(rdev));
</span> 	/* Resume clock after posting */
 	r100_clock_startup(rdev);
 	/* Initialize surface registers */
<span
class="hunk">@@ -4056,7 +4056,7 @@ int r100_init(struct radeon_device *rdev)
</span> 	/* Set asic errata */
 	r100_errata(rdev);
 	/* Initialize clocks */
<span
class="del">-	radeon_get_clock_info(rdev-&gt;ddev);
</span><span
class="add">+	radeon_get_clock_info(rdev_to_drm(rdev));
</span> 	/* initialize AGP */
 	if (rdev-&gt;flags &#38; RADEON_IS_AGP) {
 		r = radeon_agp_init(rdev);
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Wu Hoi Pok</name><email>wuhoipok@gmail.com</email></author><title>[PATCH v2 1/7] drm/radeon: remove load callback</title><updated>2024-06-22T15:01:18Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240621141544.19817-1-wuhoipok@gmail.com/"/><id>urn:uuid:2c688fee-438c-0dfb-988d-f5217ee5a87d</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This is &#34;drm/radeon: remove load callback&#34; v2, the only changes
were made are adding &#34;ddev-&gt;dev_private = rdev;&#34;, right after
the allocation of &#34;struct radeon_device&#34;. Patch v2 2-7 mostly
describes simple &#34;rdev-&gt;ddev&#34; to &#34;rdev_to_drm(rdev)&#34; to suit
Patch v2 1/7.

Please be aware that these 7 patches depends on each other.

Thank you.

Signed-off-by: Wu Hoi Pok &lt;wuhoipok@gmail.com&gt;
---
 drivers/gpu/drm/radeon/radeon.h     | 11 ++++++++---
 drivers/gpu/drm/radeon/radeon_drv.c | 27 ++++++++++++++++++---------
 drivers/gpu/drm/radeon/radeon_drv.h |  1 -
 drivers/gpu/drm/radeon/radeon_kms.c | 18 ++++++------------
 4 files <a href="http://lore.kernel.org/amd-gfx/20240621141544.19817-1-wuhoipok@gmail.com/#related">changed</a>, 32 insertions(+), 25 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon.h b/drivers/gpu/drm/radeon/radeon.h
index 0999c8eaae94..69bb30ced189 100644
--- a/drivers/gpu/drm/radeon/radeon.h
+++ b/drivers/gpu/drm/radeon/radeon.h
</span><span
class="hunk">@@ -2297,7 +2297,7 @@ typedef void (*radeon_wreg_t)(struct radeon_device*, uint32_t, uint32_t);
</span> 
 struct radeon_device {
 	struct device			*dev;
<span
class="del">-	struct drm_device		*ddev;
</span><span
class="add">+	struct drm_device		ddev;
</span> 	struct pci_dev			*pdev;
 #ifdef __alpha__
 	struct pci_controller		*hose;
<span
class="hunk">@@ -2440,10 +2440,13 @@ struct radeon_device {
</span> 	u64 gart_pin_size;
 };
 
<span
class="add">+static inline struct drm_device *rdev_to_drm(struct radeon_device *rdev)
+{
+	return &#38;rdev-&gt;ddev;
+}
+
</span> bool radeon_is_px(struct drm_device *dev);
 int radeon_device_init(struct radeon_device *rdev,
<span
class="del">-		       struct drm_device *ddev,
-		       struct pci_dev *pdev,
</span> 		       uint32_t flags);
 void radeon_device_fini(struct radeon_device *rdev);
 int radeon_gpu_wait_for_idle(struct radeon_device *rdev);
<span
class="hunk">@@ -2818,6 +2821,8 @@ struct radeon_device *radeon_get_rdev(struct ttm_device *bdev);
</span> 
 /* KMS */
 
<span
class="add">+int radeon_driver_load_kms(struct radeon_device *dev, unsigned long flags);
+
</span> u32 radeon_get_vblank_counter_kms(struct drm_crtc *crtc);
 int radeon_enable_vblank_kms(struct drm_crtc *crtc);
 void radeon_disable_vblank_kms(struct drm_crtc *crtc);
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_drv.c b/drivers/gpu/drm/radeon/radeon_drv.c
index 7bf08164140e..ae9cadceba83 100644
--- a/drivers/gpu/drm/radeon/radeon_drv.c
+++ b/drivers/gpu/drm/radeon/radeon_drv.c
</span><span
class="hunk">@@ -259,7 +259,8 @@ static int radeon_pci_probe(struct pci_dev *pdev,
</span> 			    const struct pci_device_id *ent)
 {
 	unsigned long flags = 0;
<span
class="del">-	struct drm_device *dev;
</span><span
class="add">+	struct drm_device *ddev;
+	struct radeon_device *rdev;
</span> 	int ret;
 
 	if (!ent)
<span
class="hunk">@@ -300,28 +301,37 @@ static int radeon_pci_probe(struct pci_dev *pdev,
</span> 	if (ret)
 		return ret;
 
<span
class="del">-	dev = drm_dev_alloc(&#38;kms_driver, &#38;pdev-&gt;dev);
-	if (IS_ERR(dev))
-		return PTR_ERR(dev);
</span><span
class="add">+	rdev = devm_drm_dev_alloc(&#38;pdev-&gt;dev, &#38;kms_driver, typeof(*rdev), ddev);
+	if (IS_ERR(rdev))
+		return PTR_ERR(rdev);
+
+	rdev-&gt;dev  = &#38;pdev-&gt;dev;
+	rdev-&gt;pdev = pdev;
+	ddev = rdev_to_drm(rdev);
+	ddev-&gt;dev_private = rdev;
</span> 
 	ret = pci_enable_device(pdev);
 	if (ret)
 		goto err_free;
 
<span
class="del">-	pci_set_drvdata(pdev, dev);
</span><span
class="add">+	pci_set_drvdata(pdev, ddev);
+
+	ret = radeon_driver_load_kms(rdev, flags);
+	if (ret)
+		goto err_agp;
</span> 
<span
class="del">-	ret = drm_dev_register(dev, ent-&gt;driver_data);
</span><span
class="add">+	ret = drm_dev_register(ddev, flags);
</span> 	if (ret)
 		goto err_agp;
 
<span
class="del">-	radeon_fbdev_setup(dev-&gt;dev_private);
</span><span
class="add">+	radeon_fbdev_setup(ddev-&gt;dev_private);
</span> 
 	return 0;
 
 err_agp:
 	pci_disable_device(pdev);
 err_free:
<span
class="del">-	drm_dev_put(dev);
</span><span
class="add">+	drm_dev_put(ddev);
</span> 	return ret;
 }
 
<span
class="hunk">@@ -569,7 +579,6 @@ static const struct drm_ioctl_desc radeon_ioctls_kms[] = {
</span> static const struct drm_driver kms_driver = {
 	.driver_features =
 	    DRIVER_GEM | DRIVER_RENDER | DRIVER_MODESET,
<span
class="del">-	.load = radeon_driver_load_kms,
</span> 	.open = radeon_driver_open_kms,
 	.postclose = radeon_driver_postclose_kms,
 	.unload = radeon_driver_unload_kms,
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_drv.h b/drivers/gpu/drm/radeon/radeon_drv.h
index 02a65971d140..6c1eb75a951b 100644
--- a/drivers/gpu/drm/radeon/radeon_drv.h
+++ b/drivers/gpu/drm/radeon/radeon_drv.h
</span><span
class="hunk">@@ -117,7 +117,6 @@
</span> long radeon_drm_ioctl(struct file *filp,
 		      unsigned int cmd, unsigned long arg);
 
<span
class="del">-int radeon_driver_load_kms(struct drm_device *dev, unsigned long flags);
</span> void radeon_driver_unload_kms(struct drm_device *dev);
 int radeon_driver_open_kms(struct drm_device *dev, struct drm_file *file_priv);
 void radeon_driver_postclose_kms(struct drm_device *dev,
<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_kms.c b/drivers/gpu/drm/radeon/radeon_kms.c
index a16590c6247f..d2df194393af 100644
--- a/drivers/gpu/drm/radeon/radeon_kms.c
+++ b/drivers/gpu/drm/radeon/radeon_kms.c
</span><span
class="hunk">@@ -91,7 +91,7 @@ void radeon_driver_unload_kms(struct drm_device *dev)
</span> /**
  * radeon_driver_load_kms - Main load function for KMS.
  *
<span
class="del">- * @dev: drm dev pointer
</span><span
class="add">+ * @rdev: radeon dev pointer
</span>  * @flags: device flags
  *
  * This is the main load function for KMS (all asics).
<span
class="hunk">@@ -101,24 +101,18 @@ void radeon_driver_unload_kms(struct drm_device *dev)
</span>  * (crtcs, encoders, hotplug detect, etc.).
  * Returns 0 on success, error on failure.
  */
<span
class="del">-int radeon_driver_load_kms(struct drm_device *dev, unsigned long flags)
</span><span
class="add">+int radeon_driver_load_kms(struct radeon_device *rdev, unsigned long flags)
</span> {
<span
class="del">-	struct pci_dev *pdev = to_pci_dev(dev-&gt;dev);
-	struct radeon_device *rdev;
</span><span
class="add">+	struct pci_dev *pdev = rdev-&gt;pdev;
+	struct drm_device *dev = rdev_to_drm(rdev);
</span> 	int r, acpi_status;
 
<span
class="del">-	rdev = kzalloc(sizeof(struct radeon_device), GFP_KERNEL);
-	if (rdev == NULL) {
-		return -ENOMEM;
-	}
-	dev-&gt;dev_private = (void *)rdev;
-
</span> #ifdef __alpha__
 	rdev-&gt;hose = pdev-&gt;sysdata;
 #endif
 
 	if (pci_find_capability(pdev, PCI_CAP_ID_AGP))
<span
class="del">-		rdev-&gt;agp = radeon_agp_head_init(dev);
</span><span
class="add">+		rdev-&gt;agp = radeon_agp_head_init(rdev_to_drm(rdev));
</span> 	if (rdev-&gt;agp) {
 		rdev-&gt;agp-&gt;agp_mtrr = arch_phys_wc_add(
 			rdev-&gt;agp-&gt;agp_info.aper_base,
<span
class="hunk">@@ -147,7 +141,7 @@ int radeon_driver_load_kms(struct drm_device *dev, unsigned long flags)
</span> 	 * properly initialize the GPU MC controller and permit
 	 * VRAM allocation
 	 */
<span
class="del">-	r = radeon_device_init(rdev, dev, pdev, flags);
</span><span
class="add">+	r = radeon_device_init(rdev, flags);
</span> 	if (r) {
 		dev_err(dev-&gt;dev, &#34;Fatal error during GPU init\n&#34;);
 		goto out;
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Hawking Zhang</name><email>Hawking.Zhang@amd.com</email></author><title>[PATCH] drm/amdgpu: Fix smatch static checker warning</title><updated>2024-06-21T09:54:35Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240621095425.27355-1-Hawking.Zhang@amd.com/"/><id>urn:uuid:b2e55134-a800-39fb-9320-530dd8fef14e</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">adev-&gt;gfx.imu.funcs could be NULL

Signed-off-by: Hawking Zhang &lt;Hawking.Zhang@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c | 8 ++++----
 1 file <a href="http://lore.kernel.org/amd-gfx/20240621095425.27355-1-Hawking.Zhang@amd.com/#related">changed</a>, 4 insertions(+), 4 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c b/drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c
index b4575765d7a8..5c17409439f8 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c
</span><span
class="hunk">@@ -4498,11 +4498,11 @@ static int gfx_v11_0_hw_init(void *handle)
</span> 			/* RLC autoload sequence 1: Program rlc ram */
 			if (adev-&gt;gfx.imu.funcs-&gt;program_rlc_ram)
 				adev-&gt;gfx.imu.funcs-&gt;program_rlc_ram(adev);
<span
class="add">+			/* rlc autoload firmware */
+			r = gfx_v11_0_rlc_backdoor_autoload_enable(adev);
+			if (r)
+				return r;
</span> 		}
<span
class="del">-		/* rlc autoload firmware */
-		r = gfx_v11_0_rlc_backdoor_autoload_enable(adev);
-		if (r)
-			return r;
</span> 	} else {
 		if (adev-&gt;firmware.load_type == AMDGPU_FW_LOAD_DIRECT) {
 			if (adev-&gt;gfx.imu.funcs &#38;&#38; (amdgpu_dpm &gt; 0)) {
-- 
2.17.1

</pre></div></content></entry><entry><author><name>Bob Zhou</name><email>bob.zhou@amd.com</email></author><title>[PATCH] drm/amdgpu: add missing error handling for amdgpu_ring_alloc()</title><updated>2024-06-21T09:25:08Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240621092454.42879-1-bob.zhou@amd.com/"/><id>urn:uuid:241291ab-8bce-0568-4cbf-bc6517093016</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Fix the unchecked return value warning reported by Coverity,
so add error handling.

Signed-off-by: Bob Zhou &lt;bob.zhou@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c      | 7 +++++--
 drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.c      | 4 +++-
 drivers/gpu/drm/amd/amdgpu/amdgpu_ring_mux.c | 6 ++++--
 drivers/gpu/drm/amd/amdgpu/amdgpu_vpe.c      | 3 ++-
 drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c        | 8 ++++++--
 drivers/gpu/drm/amd/amdgpu/sdma_v5_0.c       | 6 +++++-
 drivers/gpu/drm/amd/amdgpu/sdma_v5_2.c       | 6 +++++-
 drivers/gpu/drm/amd/amdgpu/sdma_v6_0.c       | 6 +++++-
 8 files <a href="http://lore.kernel.org/amd-gfx/20240621092454.42879-1-bob.zhou@amd.com/#related">changed</a>, 35 insertions(+), 11 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c
index 82452606ae6c..25cab6a8d478 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c
</span><span
class="hunk">@@ -1005,7 +1005,8 @@ uint32_t amdgpu_kiq_rreg(struct amdgpu_device *adev, uint32_t reg, uint32_t xcc_
</span> 		pr_err(&#34;critical bug! too many kiq readers\n&#34;);
 		goto failed_unlock;
 	}
<span
class="del">-	amdgpu_ring_alloc(ring, 32);
</span><span
class="add">+	if (amdgpu_ring_alloc(ring, 32))
+		goto failed_unlock;
</span> 	amdgpu_ring_emit_rreg(ring, reg, reg_val_offs);
 	r = amdgpu_fence_emit_polling(ring, &#38;seq, MAX_KIQ_REG_WAIT);
 	if (r)
<span
class="hunk">@@ -1071,7 +1072,8 @@ void amdgpu_kiq_wreg(struct amdgpu_device *adev, uint32_t reg, uint32_t v, uint3
</span> 	}
 
 	spin_lock_irqsave(&#38;kiq-&gt;ring_lock, flags);
<span
class="del">-	amdgpu_ring_alloc(ring, 32);
</span><span
class="add">+	if (amdgpu_ring_alloc(ring, 32))
+		goto failed_unlock;
</span> 	amdgpu_ring_emit_wreg(ring, reg, v);
 	r = amdgpu_fence_emit_polling(ring, &#38;seq, MAX_KIQ_REG_WAIT);
 	if (r)
<span
class="hunk">@@ -1107,6 +1109,7 @@ void amdgpu_kiq_wreg(struct amdgpu_device *adev, uint32_t reg, uint32_t v, uint3
</span> 
 failed_undo:
 	amdgpu_ring_undo(ring);
<span
class="add">+failed_unlock:
</span> 	spin_unlock_irqrestore(&#38;kiq-&gt;ring_lock, flags);
 failed_kiq_write:
 	dev_err(adev-&gt;dev, &#34;failed to write reg:%x\n&#34;, reg);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.c
index 3a7622611916..778941f47c96 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.c
</span><span
class="hunk">@@ -768,7 +768,8 @@ void amdgpu_gmc_fw_reg_write_reg_wait(struct amdgpu_device *adev,
</span> 	}
 
 	spin_lock_irqsave(&#38;kiq-&gt;ring_lock, flags);
<span
class="del">-	amdgpu_ring_alloc(ring, 32);
</span><span
class="add">+	if (amdgpu_ring_alloc(ring, 32))
+		goto failed_unlock;
</span> 	amdgpu_ring_emit_reg_write_reg_wait(ring, reg0, reg1,
 					    ref, mask);
 	r = amdgpu_fence_emit_polling(ring, &#38;seq, MAX_KIQ_REG_WAIT);
<span
class="hunk">@@ -798,6 +799,7 @@ void amdgpu_gmc_fw_reg_write_reg_wait(struct amdgpu_device *adev,
</span> 
 failed_undo:
 	amdgpu_ring_undo(ring);
<span
class="add">+failed_unlock:
</span> 	spin_unlock_irqrestore(&#38;kiq-&gt;ring_lock, flags);
 failed_kiq:
 	dev_err(adev-&gt;dev, &#34;failed to write reg %x wait reg %x\n&#34;, reg0, reg1);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ring_mux.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ring_mux.c
index d234b7ccfaaf..01864990a192 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ring_mux.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ring_mux.c
</span><span
class="hunk">@@ -63,12 +63,14 @@ static void amdgpu_ring_mux_copy_pkt_from_sw_ring(struct amdgpu_ring_mux *mux,
</span> 		return;
 	}
 	if (start &gt; end) {
<span
class="del">-		amdgpu_ring_alloc(real_ring, (ring-&gt;ring_size &gt;&gt; 2) + end - start);
</span><span
class="add">+		if (amdgpu_ring_alloc(real_ring, (ring-&gt;ring_size &gt;&gt; 2) + end - start))
+			return;
</span> 		amdgpu_ring_write_multiple(real_ring, (void *)&#38;ring-&gt;ring[start],
 					   (ring-&gt;ring_size &gt;&gt; 2) - start);
 		amdgpu_ring_write_multiple(real_ring, (void *)&#38;ring-&gt;ring[0], end);
 	} else {
<span
class="del">-		amdgpu_ring_alloc(real_ring, end - start);
</span><span
class="add">+		if (amdgpu_ring_alloc(real_ring, end - start))
+			return;
</span> 		amdgpu_ring_write_multiple(real_ring, (void *)&#38;ring-&gt;ring[start], end - start);
 	}
 }
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vpe.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vpe.c
index bad232859972..d7d68e61506d 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vpe.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vpe.c
</span><span
class="hunk">@@ -610,7 +610,8 @@ static int vpe_ring_preempt_ib(struct amdgpu_ring *ring)
</span> 
 	/* emit the trailing fence */
 	ring-&gt;trail_seq += 1;
<span
class="del">-	amdgpu_ring_alloc(ring, 10);
</span><span
class="add">+	if (amdgpu_ring_alloc(ring, 10))
+		return -ENOMEM;
</span> 	vpe_ring_emit_fence(ring, ring-&gt;trail_fence_gpu_addr, ring-&gt;trail_seq, 0);
 	amdgpu_ring_commit(ring);
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c b/drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c
index 2929c8972ea7..810f7f7e279d 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c
</span><span
class="hunk">@@ -4093,7 +4093,8 @@ static uint64_t gfx_v9_0_kiq_read_clock(struct amdgpu_device *adev)
</span> 		pr_err(&#34;critical bug! too many kiq readers\n&#34;);
 		goto failed_unlock;
 	}
<span
class="del">-	amdgpu_ring_alloc(ring, 32);
</span><span
class="add">+	if (amdgpu_ring_alloc(ring, 32))
+		goto failed_unlock;
</span> 	amdgpu_ring_write(ring, PACKET3(PACKET3_COPY_DATA, 4));
 	amdgpu_ring_write(ring, 9 |	/* src: register*/
 				(5 &lt;&lt; 8) |	/* dst: memory */
<span
class="hunk">@@ -5639,7 +5640,10 @@ static int gfx_v9_0_ring_preempt_ib(struct amdgpu_ring *ring)
</span> 	amdgpu_ring_set_preempt_cond_exec(ring, false);
 
 	ring-&gt;trail_seq += 1;
<span
class="del">-	amdgpu_ring_alloc(ring, 13);
</span><span
class="add">+	if (amdgpu_ring_alloc(ring, 13)) {
+		spin_unlock_irqrestore(&#38;kiq-&gt;ring_lock, flags);
+		return -ENOMEM;
+	}
</span> 	gfx_v9_0_ring_emit_fence(ring, ring-&gt;trail_fence_gpu_addr,
 				 ring-&gt;trail_seq, AMDGPU_FENCE_FLAG_EXEC | AMDGPU_FENCE_FLAG_INT);
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/sdma_v5_0.c b/drivers/gpu/drm/amd/amdgpu/sdma_v5_0.c
index b7d33d78bce0..07ca9264085b 100644
--- a/drivers/gpu/drm/amd/amdgpu/sdma_v5_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/sdma_v5_0.c
</span><span
class="hunk">@@ -1490,7 +1490,11 @@ static int sdma_v5_0_ring_preempt_ib(struct amdgpu_ring *ring)
</span> 
 	/* emit the trailing fence */
 	ring-&gt;trail_seq += 1;
<span
class="del">-	amdgpu_ring_alloc(ring, 10);
</span><span
class="add">+	r = amdgpu_ring_alloc(ring, 10);
+	if (r) {
+		DRM_ERROR(&#34;ring %d failed to be allocated\n&#34;, ring-&gt;idx);
+		return r;
+	}
</span> 	sdma_v5_0_ring_emit_fence(ring, ring-&gt;trail_fence_gpu_addr,
 				  ring-&gt;trail_seq, 0);
 	amdgpu_ring_commit(ring);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/sdma_v5_2.c b/drivers/gpu/drm/amd/amdgpu/sdma_v5_2.c
index cc9e961f0078..d51d5bd7de30 100644
--- a/drivers/gpu/drm/amd/amdgpu/sdma_v5_2.c
+++ b/drivers/gpu/drm/amd/amdgpu/sdma_v5_2.c
</span><span
class="hunk">@@ -1345,7 +1345,11 @@ static int sdma_v5_2_ring_preempt_ib(struct amdgpu_ring *ring)
</span> 
 	/* emit the trailing fence */
 	ring-&gt;trail_seq += 1;
<span
class="del">-	amdgpu_ring_alloc(ring, 10);
</span><span
class="add">+	r = amdgpu_ring_alloc(ring, 10);
+	if (r) {
+		DRM_ERROR(&#34;ring %d failed to be allocated\n&#34;, ring-&gt;idx);
+		return r;
+	}
</span> 	sdma_v5_2_ring_emit_fence(ring, ring-&gt;trail_fence_gpu_addr,
 				  ring-&gt;trail_seq, 0);
 	amdgpu_ring_commit(ring);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/sdma_v6_0.c b/drivers/gpu/drm/amd/amdgpu/sdma_v6_0.c
index c833b6b8373b..e82426459cc7 100644
--- a/drivers/gpu/drm/amd/amdgpu/sdma_v6_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/sdma_v6_0.c
</span><span
class="hunk">@@ -1371,7 +1371,11 @@ static int sdma_v6_0_ring_preempt_ib(struct amdgpu_ring *ring)
</span> 
 	/* emit the trailing fence */
 	ring-&gt;trail_seq += 1;
<span
class="del">-	amdgpu_ring_alloc(ring, 10);
</span><span
class="add">+	r = amdgpu_ring_alloc(ring, 10);
+	if (r) {
+		DRM_ERROR(&#34;ring %d failed to be allocated\n&#34;, ring-&gt;idx);
+		return r;
+	}
</span> 	sdma_v6_0_ring_emit_fence(ring, ring-&gt;trail_fence_gpu_addr,
 				  ring-&gt;trail_seq, 0);
 	amdgpu_ring_commit(ring);
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Jane Jian</name><email>Jane.Jian@amd.com</email></author><title>[PATCH] drm/amdgpu: normalize registers as local xcc to read/write under sriov in TLB flush</title><updated>2024-06-21T08:15:36Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240621081515.2441125-1-Jane.Jian@amd.com/"/><id>urn:uuid:b37f9d18-07c8-e2e3-4901-a4c1e6663bf9</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHY]
sriov has the higher bit violation when flushing tlb

[HOW]
normalize the registers to keep lower 16-bit(dword aligned) to aviod higher bit violation
RLCG will mask xcd out and always assume it&#39;s accessing its own xcd

[TODO]
later will add the normalization in sriovw/rreg after fixing bugs

v2
rename the normalized macro, add ip block type for further use
move asics func declaration after ip block type since new func refers ip block type
add normalization in emit flush tlb as well

Signed-off-by: Jane Jian &lt;Jane.Jian@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu.h        | 112 +++++++++++----------
 drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c |  16 +++
 drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c      |  32 ++++--
 drivers/gpu/drm/amd/amdgpu/soc15.c         |   1 +
 drivers/gpu/drm/amd/amdgpu/soc15.h         |   1 +
 drivers/gpu/drm/amd/amdgpu/soc15_common.h  |   5 +-
 6 files <a href="http://lore.kernel.org/amd-gfx/20240621081515.2441125-1-Jane.Jian@amd.com/#related">changed</a>, 101 insertions(+), 66 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
index 083f353cff6e..070fd9e601fe 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
</span><span
class="hunk">@@ -583,61 +583,6 @@ struct amdgpu_video_codecs {
</span> 	const struct amdgpu_video_codec_info *codec_array;
 };
 
<span
class="del">-/*
- * ASIC specific functions.
- */
-struct amdgpu_asic_funcs {
-	bool (*read_disabled_bios)(struct amdgpu_device *adev);
-	bool (*read_bios_from_rom)(struct amdgpu_device *adev,
-				   u8 *bios, u32 length_bytes);
-	int (*read_register)(struct amdgpu_device *adev, u32 se_num,
-			     u32 sh_num, u32 reg_offset, u32 *value);
-	void (*set_vga_state)(struct amdgpu_device *adev, bool state);
-	int (*reset)(struct amdgpu_device *adev);
-	enum amd_reset_method (*reset_method)(struct amdgpu_device *adev);
-	/* get the reference clock */
-	u32 (*get_xclk)(struct amdgpu_device *adev);
-	/* MM block clocks */
-	int (*set_uvd_clocks)(struct amdgpu_device *adev, u32 vclk, u32 dclk);
-	int (*set_vce_clocks)(struct amdgpu_device *adev, u32 evclk, u32 ecclk);
-	/* static power management */
-	int (*get_pcie_lanes)(struct amdgpu_device *adev);
-	void (*set_pcie_lanes)(struct amdgpu_device *adev, int lanes);
-	/* get config memsize register */
-	u32 (*get_config_memsize)(struct amdgpu_device *adev);
-	/* flush hdp write queue */
-	void (*flush_hdp)(struct amdgpu_device *adev, struct amdgpu_ring *ring);
-	/* invalidate hdp read cache */
-	void (*invalidate_hdp)(struct amdgpu_device *adev,
-			       struct amdgpu_ring *ring);
-	/* check if the asic needs a full reset of if soft reset will work */
-	bool (*need_full_reset)(struct amdgpu_device *adev);
-	/* initialize doorbell layout for specific asic*/
-	void (*init_doorbell_index)(struct amdgpu_device *adev);
-	/* PCIe bandwidth usage */
-	void (*get_pcie_usage)(struct amdgpu_device *adev, uint64_t *count0,
-			       uint64_t *count1);
-	/* do we need to reset the asic at init time (e.g., kexec) */
-	bool (*need_reset_on_init)(struct amdgpu_device *adev);
-	/* PCIe replay counter */
-	uint64_t (*get_pcie_replay_count)(struct amdgpu_device *adev);
-	/* device supports BACO */
-	int (*supports_baco)(struct amdgpu_device *adev);
-	/* pre asic_init quirks */
-	void (*pre_asic_init)(struct amdgpu_device *adev);
-	/* enter/exit umd stable pstate */
-	int (*update_umd_stable_pstate)(struct amdgpu_device *adev, bool enter);
-	/* query video codecs */
-	int (*query_video_codecs)(struct amdgpu_device *adev, bool encode,
-				  const struct amdgpu_video_codecs **codecs);
-	/* encode &#34;&gt; 32bits&#34; smn addressing */
-	u64 (*encode_ext_smn_addressing)(int ext_id);
-
-	ssize_t (*get_reg_state)(struct amdgpu_device *adev,
-				 enum amdgpu_reg_state reg_state, void *buf,
-				 size_t max_size);
-};
-
</span> /*
  * IOCTL.
  */
<span
class="hunk">@@ -728,6 +673,63 @@ enum amd_hw_ip_block_type {
</span> 	MAX_HWIP
 };
 
<span
class="add">+/*
+ * ASIC specific functions.
+ */
+struct amdgpu_asic_funcs {
+	bool (*read_disabled_bios)(struct amdgpu_device *adev);
+	bool (*read_bios_from_rom)(struct amdgpu_device *adev,
+				   u8 *bios, u32 length_bytes);
+	int (*read_register)(struct amdgpu_device *adev, u32 se_num,
+			     u32 sh_num, u32 reg_offset, u32 *value);
+	void (*set_vga_state)(struct amdgpu_device *adev, bool state);
+	int (*reset)(struct amdgpu_device *adev);
+	enum amd_reset_method (*reset_method)(struct amdgpu_device *adev);
+	/* get the reference clock */
+	u32 (*get_xclk)(struct amdgpu_device *adev);
+	/* MM block clocks */
+	int (*set_uvd_clocks)(struct amdgpu_device *adev, u32 vclk, u32 dclk);
+	int (*set_vce_clocks)(struct amdgpu_device *adev, u32 evclk, u32 ecclk);
+	/* static power management */
+	int (*get_pcie_lanes)(struct amdgpu_device *adev);
+	void (*set_pcie_lanes)(struct amdgpu_device *adev, int lanes);
+	/* get config memsize register */
+	u32 (*get_config_memsize)(struct amdgpu_device *adev);
+	/* flush hdp write queue */
+	void (*flush_hdp)(struct amdgpu_device *adev, struct amdgpu_ring *ring);
+	/* invalidate hdp read cache */
+	void (*invalidate_hdp)(struct amdgpu_device *adev,
+			       struct amdgpu_ring *ring);
+	/* check if the asic needs a full reset of if soft reset will work */
+	bool (*need_full_reset)(struct amdgpu_device *adev);
+	/* initialize doorbell layout for specific asic*/
+	void (*init_doorbell_index)(struct amdgpu_device *adev);
+	/* PCIe bandwidth usage */
+	void (*get_pcie_usage)(struct amdgpu_device *adev, uint64_t *count0,
+			       uint64_t *count1);
+	/* do we need to reset the asic at init time (e.g., kexec) */
+	bool (*need_reset_on_init)(struct amdgpu_device *adev);
+	/* PCIe replay counter */
+	uint64_t (*get_pcie_replay_count)(struct amdgpu_device *adev);
+	/* device supports BACO */
+	int (*supports_baco)(struct amdgpu_device *adev);
+	/* pre asic_init quirks */
+	void (*pre_asic_init)(struct amdgpu_device *adev);
+	/* enter/exit umd stable pstate */
+	int (*update_umd_stable_pstate)(struct amdgpu_device *adev, bool enter);
+	/* query video codecs */
+	int (*query_video_codecs)(struct amdgpu_device *adev, bool encode,
+				  const struct amdgpu_video_codecs **codecs);
+	/* encode &#34;&gt; 32bits&#34; smn addressing */
+	u64 (*encode_ext_smn_addressing)(int ext_id);
+
+	ssize_t (*get_reg_state)(struct amdgpu_device *adev,
+				 enum amdgpu_reg_state reg_state, void *buf,
+				 size_t max_size);
+	/* normalize offset to keep in lower 16-bit */
+	u32 (*normalize_reg_offset)(enum amd_hw_ip_block_type hwip, u32 offset);
+};
+
</span> #define HWIP_MAX_INSTANCE	44
 
 #define HW_ID_MAX		300
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c b/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c
index 2c9a0aa41e2d..98b00c0e522f 100644
--- a/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c
+++ b/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c
</span><span
class="hunk">@@ -1085,3 +1085,19 @@ ssize_t aqua_vanjaram_get_reg_state(struct amdgpu_device *adev,
</span> 
 	return size;
 }
<span
class="add">+
+u32 aqua_vanjaram_normalize_reg_offset(enum amd_hw_ip_block_type hwip, u32 offset)
+{
+	u32 normalized_offset;
+
+	switch (hwip) {
+	case GC_HWIP:
+		normalized_offset = offset &#38; 0xffff;
+		break;
+	default:
+		normalized_offset = offset;
+		break;
+	}
+
+	return normalized_offset;
+}
</span><span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
index 88b4644f8e96..7542a75f068b 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
</span><span
class="hunk">@@ -853,8 +853,12 @@ static void gmc_v9_0_flush_gpu_tlb(struct amdgpu_device *adev, uint32_t vmid,
</span> 	 */
 	if (adev-&gt;gfx.kiq[inst].ring.sched.ready &#38;&#38;
 	    (amdgpu_sriov_runtime(adev) || !amdgpu_sriov_vf(adev))) {
<span
class="del">-		uint32_t req = hub-&gt;vm_inv_eng0_req + hub-&gt;eng_distance * eng;
-		uint32_t ack = hub-&gt;vm_inv_eng0_ack + hub-&gt;eng_distance * eng;
</span><span
class="add">+
+		/* Select lower 16 bits to write in local xcc */
+		if (AMDGPU_IS_GFXHUB(vmhub)) {
+			req = NORMALIZE_XCC_REG_OFFSET(GC, req);
+			ack = NORMALIZE_XCC_REG_OFFSET(GC, ack);
+		}
</span> 
 		amdgpu_gmc_fw_reg_write_reg_wait(adev, req, ack, inv_req,
 						 1 &lt;&lt; vmid, inst);
<span
class="hunk">@@ -979,6 +983,7 @@ static uint64_t gmc_v9_0_emit_flush_gpu_tlb(struct amdgpu_ring *ring,
</span> 	struct amdgpu_vmhub *hub = &#38;adev-&gt;vmhub[ring-&gt;vm_hub];
 	uint32_t req = gmc_v9_0_get_invalidate_req(vmid, 0);
 	unsigned int eng = ring-&gt;vm_inv_eng;
<span
class="add">+	u32 low_distance, high_distance, req_offset, ack;
</span> 
 	/*
 	 * It may lose gpuvm invalidate acknowldege state across power-gating
<span
class="hunk">@@ -986,7 +991,18 @@ static uint64_t gmc_v9_0_emit_flush_gpu_tlb(struct amdgpu_ring *ring,
</span> 	 * release after invalidation to avoid entering power gated state
 	 * to WA the Issue
 	 */
<span
class="add">+	low_distance = hub-&gt;ctx0_ptb_addr_lo32 + (hub-&gt;ctx_addr_distance * vmid);
+	high_distance = hub-&gt;ctx0_ptb_addr_hi32 + (hub-&gt;ctx_addr_distance * vmid);
+	req_offset = hub-&gt;vm_inv_eng0_req + hub-&gt;eng_distance * eng;
+	ack = hub-&gt;vm_inv_eng0_ack + hub-&gt;eng_distance * eng;
</span> 
<span
class="add">+	/* Select lower 16 bits to write in local xcc */
+	if (AMDGPU_IS_GFXHUB(ring-&gt;vm_hub)) {
+		low_distance = NORMALIZE_XCC_REG_OFFSET(GC, low_distance);
+		high_distance = NORMALIZE_XCC_REG_OFFSET(GC, high_distance);
+		req_offset = NORMALIZE_XCC_REG_OFFSET(GC, req_offset);
+		ack = NORMALIZE_XCC_REG_OFFSET(GC, ack);
+	}
</span> 	/* TODO: It needs to continue working on debugging with semaphore for GFXHUB as well. */
 	if (use_semaphore)
 		/* a read return value of 1 means semaphore acuqire */
<span
class="hunk">@@ -994,18 +1010,14 @@ static uint64_t gmc_v9_0_emit_flush_gpu_tlb(struct amdgpu_ring *ring,
</span> 					  hub-&gt;vm_inv_eng0_sem +
 					  hub-&gt;eng_distance * eng, 0x1, 0x1);
 
<span
class="del">-	amdgpu_ring_emit_wreg(ring, hub-&gt;ctx0_ptb_addr_lo32 +
-			      (hub-&gt;ctx_addr_distance * vmid),
</span><span
class="add">+	amdgpu_ring_emit_wreg(ring, low_distance,
</span> 			      lower_32_bits(pd_addr));
 
<span
class="del">-	amdgpu_ring_emit_wreg(ring, hub-&gt;ctx0_ptb_addr_hi32 +
-			      (hub-&gt;ctx_addr_distance * vmid),
</span><span
class="add">+	amdgpu_ring_emit_wreg(ring, high_distance,
</span> 			      upper_32_bits(pd_addr));
 
<span
class="del">-	amdgpu_ring_emit_reg_write_reg_wait(ring, hub-&gt;vm_inv_eng0_req +
-					    hub-&gt;eng_distance * eng,
-					    hub-&gt;vm_inv_eng0_ack +
-					    hub-&gt;eng_distance * eng,
</span><span
class="add">+	amdgpu_ring_emit_reg_write_reg_wait(ring, req_offset,
+					    ack,
</span> 					    req, 1 &lt;&lt; vmid);
 
 	/* TODO: It needs to continue working on debugging with semaphore for GFXHUB as well. */
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/soc15.c b/drivers/gpu/drm/amd/amdgpu/soc15.c
index 8d16dacdc172..e6e61fc77080 100644
--- a/drivers/gpu/drm/amd/amdgpu/soc15.c
+++ b/drivers/gpu/drm/amd/amdgpu/soc15.c
</span><span
class="hunk">@@ -927,6 +927,7 @@ static const struct amdgpu_asic_funcs aqua_vanjaram_asic_funcs =
</span> 	.query_video_codecs = &#38;soc15_query_video_codecs,
 	.encode_ext_smn_addressing = &#38;aqua_vanjaram_encode_ext_smn_addressing,
 	.get_reg_state = &#38;aqua_vanjaram_get_reg_state,
<span
class="add">+	.normalize_reg_offset = &#38;aqua_vanjaram_normalize_reg_offset,
</span> };
 
 static int soc15_common_early_init(void *handle)
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/soc15.h b/drivers/gpu/drm/amd/amdgpu/soc15.h
index 282584a48be0..f1e974604e3e 100644
--- a/drivers/gpu/drm/amd/amdgpu/soc15.h
+++ b/drivers/gpu/drm/amd/amdgpu/soc15.h
</span><span
class="hunk">@@ -124,4 +124,5 @@ ssize_t aqua_vanjaram_get_reg_state(struct amdgpu_device *adev,
</span> void vega10_doorbell_index_init(struct amdgpu_device *adev);
 void vega20_doorbell_index_init(struct amdgpu_device *adev);
 void aqua_vanjaram_doorbell_index_init(struct amdgpu_device *adev);
<span
class="add">+u32 aqua_vanjaram_normalize_reg_offset(u32 hwip, u32 offset);
</span> #endif
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/soc15_common.h b/drivers/gpu/drm/amd/amdgpu/soc15_common.h
index 242b24f73c17..ddf0aad51821 100644
--- a/drivers/gpu/drm/amd/amdgpu/soc15_common.h
+++ b/drivers/gpu/drm/amd/amdgpu/soc15_common.h
</span><span
class="hunk">@@ -210,4 +210,7 @@
</span> #define WREG64_MCA(ext, mca_base, idx, val) \
 	WREG64_PCIE_EXT(adev-&gt;asic_funcs-&gt;encode_ext_smn_addressing(ext) + mca_base + (idx * 8), val)
 
<span
class="del">-#endif
</span><span
class="add">+#define NORMALIZE_XCC_REG_OFFSET(ip, offset) \
+	((amdgpu_sriov_vf(adev) &#38;&#38; adev-&gt;asic_funcs-&gt;normalize_reg_offset) ? \
+	adev-&gt;asic_funcs-&gt;normalize_reg_offset(ip##_HWIP, offset) : offset)
+#endif
</span>\ No newline at end of file
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Hawking Zhang</name><email>Hawking.Zhang@amd.com</email></author><title>[PATCH] drm/amdgpu: Fix smatch static checker warning</title><updated>2024-06-21T07:56:41Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240621075629.27060-1-Hawking.Zhang@amd.com/"/><id>urn:uuid:6176122f-b215-cf03-62eb-87b467fff7a0</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">adev-&gt;gfx.imu.funcs could be NULL.

Signed-off-by: Hawking Zhang &lt;Hawking.Zhang@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c | 8 ++++----
 drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c | 8 ++++----
 2 files <a href="http://lore.kernel.org/amd-gfx/20240621075629.27060-1-Hawking.Zhang@amd.com/#related">changed</a>, 8 insertions(+), 8 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c b/drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c
index b4575765d7a8..5c17409439f8 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c
</span><span
class="hunk">@@ -4498,11 +4498,11 @@ static int gfx_v11_0_hw_init(void *handle)
</span> 			/* RLC autoload sequence 1: Program rlc ram */
 			if (adev-&gt;gfx.imu.funcs-&gt;program_rlc_ram)
 				adev-&gt;gfx.imu.funcs-&gt;program_rlc_ram(adev);
<span
class="add">+			/* rlc autoload firmware */
+			r = gfx_v11_0_rlc_backdoor_autoload_enable(adev);
+			if (r)
+				return r;
</span> 		}
<span
class="del">-		/* rlc autoload firmware */
-		r = gfx_v11_0_rlc_backdoor_autoload_enable(adev);
-		if (r)
-			return r;
</span> 	} else {
 		if (adev-&gt;firmware.load_type == AMDGPU_FW_LOAD_DIRECT) {
 			if (adev-&gt;gfx.imu.funcs &#38;&#38; (amdgpu_dpm &gt; 0)) {
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c b/drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c
index 460bf33a22b1..16fc5c5b15f5 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c
</span><span
class="hunk">@@ -3258,11 +3258,11 @@ static int gfx_v12_0_hw_init(void *handle)
</span> 			/* RLC autoload sequence 1: Program rlc ram */
 			if (adev-&gt;gfx.imu.funcs-&gt;program_rlc_ram)
 				adev-&gt;gfx.imu.funcs-&gt;program_rlc_ram(adev);
<span
class="add">+			/* rlc autoload firmware */
+			r = gfx_v12_0_rlc_backdoor_autoload_enable(adev);
+			if (r)
+				return r;
</span> 		}
<span
class="del">-		/* rlc autoload firmware */
-		r = gfx_v12_0_rlc_backdoor_autoload_enable(adev);
-		if (r)
-			return r;
</span> 	} else {
 		if (adev-&gt;firmware.load_type == AMDGPU_FW_LOAD_DIRECT) {
 			if (adev-&gt;gfx.imu.funcs &#38;&#38; (amdgpu_dpm &gt; 0)) {
-- 
2.17.1

</pre></div></content></entry><entry><author><name>Arunpravin Paneer Selvam</name><email>Arunpravin.PaneerSelvam@amd.com</email></author><title>[PATCH] drm/buddy: Add start address support to trim function</title><updated>2024-06-21T05:29:57Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240621052909.450539-1-Arunpravin.PaneerSelvam@amd.com/"/><id>urn:uuid:4a1a9cec-558a-add0-a264-8f57405142bd</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">- Add a new start parameter in trim function to specify exact
  address from where to start the trimming. This would help us
  in situations like if drivers would like to do address alignment
  for specific requirements.

- Add a new flag DRM_BUDDY_TRIM_DISABLE. Drivers can use this
  flag to disable the allocator trimming part. This patch enables
  the drivers control trimming and they can do it themselves
  based on the application requirements.

Signed-off-by: Arunpravin Paneer Selvam &lt;Arunpravin.PaneerSelvam@amd.com&gt;
---
 drivers/gpu/drm/drm_buddy.c          | 22 ++++++++++++++++++++--
 drivers/gpu/drm/xe/xe_ttm_vram_mgr.c |  2 +-
 include/drm/drm_buddy.h              |  2 ++
 3 files <a href="http://lore.kernel.org/amd-gfx/20240621052909.450539-1-Arunpravin.PaneerSelvam@amd.com/#related">changed</a>, 23 insertions(+), 3 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/drm_buddy.c b/drivers/gpu/drm/drm_buddy.c
index 6a8e45e9d0ec..287b6acb1637 100644
--- a/drivers/gpu/drm/drm_buddy.c
+++ b/drivers/gpu/drm/drm_buddy.c
</span><span
class="hunk">@@ -851,6 +851,7 @@ static int __alloc_contig_try_harder(struct drm_buddy *mm,
</span>  * drm_buddy_block_trim - free unused pages
  *
  * @mm: DRM buddy manager
<span
class="add">+ * @start: start address to begin the trimming.
</span>  * @new_size: original size requested
  * @blocks: Input and output list of allocated blocks.
  * MUST contain single block as input to be trimmed.
<span
class="hunk">@@ -866,11 +867,13 @@ static int __alloc_contig_try_harder(struct drm_buddy *mm,
</span>  * 0 on success, error code on failure.
  */
 int drm_buddy_block_trim(struct drm_buddy *mm,
<span
class="add">+			 u64 *start,
</span> 			 u64 new_size,
 			 struct list_head *blocks)
 {
 	struct drm_buddy_block *parent;
 	struct drm_buddy_block *block;
<span
class="add">+	u64 block_start, block_end;
</span> 	LIST_HEAD(dfs);
 	u64 new_start;
 	int err;
<span
class="hunk">@@ -882,6 +885,9 @@ int drm_buddy_block_trim(struct drm_buddy *mm,
</span> 				 struct drm_buddy_block,
 				 link);
 
<span
class="add">+	block_start = drm_buddy_block_offset(block);
+	block_end = block_start + drm_buddy_block_size(mm, block) - 1;
+
</span> 	if (WARN_ON(!drm_buddy_block_is_allocated(block)))
 		return -EINVAL;
 
<span
class="hunk">@@ -894,6 +900,17 @@ int drm_buddy_block_trim(struct drm_buddy *mm,
</span> 	if (new_size == drm_buddy_block_size(mm, block))
 		return 0;
 
<span
class="add">+	new_start = block_start;
+	if (start) {
+		new_start = *start;
+
+		if (new_start &lt; block_start)
+			return -EINVAL;
+
+		if ((new_start + new_size) &gt; block_end)
+			return -EINVAL;
+	}
+
</span> 	list_del(&#38;block-&gt;link);
 	mark_free(mm, block);
 	mm-&gt;avail += drm_buddy_block_size(mm, block);
<span
class="hunk">@@ -904,7 +921,6 @@ int drm_buddy_block_trim(struct drm_buddy *mm,
</span> 	parent = block-&gt;parent;
 	block-&gt;parent = NULL;
 
<span
class="del">-	new_start = drm_buddy_block_offset(block);
</span> 	list_add(&#38;block-&gt;tmp_link, &#38;dfs);
 	err =  __alloc_range(mm, &#38;dfs, new_start, new_size, blocks, NULL);
 	if (err) {
<span
class="hunk">@@ -1066,7 +1082,8 @@ int drm_buddy_alloc_blocks(struct drm_buddy *mm,
</span> 	} while (1);
 
 	/* Trim the allocated block to the required size */
<span
class="del">-	if (original_size != size) {
</span><span
class="add">+	if (!(flags &#38; DRM_BUDDY_TRIM_DISABLE) &#38;&#38;
+	    original_size != size) {
</span> 		struct list_head *trim_list;
 		LIST_HEAD(temp);
 		u64 trim_size;
<span
class="hunk">@@ -1083,6 +1100,7 @@ int drm_buddy_alloc_blocks(struct drm_buddy *mm,
</span> 		}
 
 		drm_buddy_block_trim(mm,
<span
class="add">+				     NULL,
</span> 				     trim_size,
 				     trim_list);
 
<span
class="head">diff --git a/drivers/gpu/drm/xe/xe_ttm_vram_mgr.c b/drivers/gpu/drm/xe/xe_ttm_vram_mgr.c
index fe3779fdba2c..423b261ea743 100644
--- a/drivers/gpu/drm/xe/xe_ttm_vram_mgr.c
+++ b/drivers/gpu/drm/xe/xe_ttm_vram_mgr.c
</span><span
class="hunk">@@ -150,7 +150,7 @@ static int xe_ttm_vram_mgr_new(struct ttm_resource_manager *man,
</span> 	} while (remaining_size);
 
 	if (place-&gt;flags &#38; TTM_PL_FLAG_CONTIGUOUS) {
<span
class="del">-		if (!drm_buddy_block_trim(mm, vres-&gt;base.size, &#38;vres-&gt;blocks))
</span><span
class="add">+		if (!drm_buddy_block_trim(mm, NULL, vres-&gt;base.size, &#38;vres-&gt;blocks))
</span> 			size = vres-&gt;base.size;
 	}
 
<span
class="head">diff --git a/include/drm/drm_buddy.h b/include/drm/drm_buddy.h
index 2a74fa9d0ce5..9689a7c5dd36 100644
--- a/include/drm/drm_buddy.h
+++ b/include/drm/drm_buddy.h
</span><span
class="hunk">@@ -27,6 +27,7 @@
</span> #define DRM_BUDDY_CONTIGUOUS_ALLOCATION		BIT(2)
 #define DRM_BUDDY_CLEAR_ALLOCATION		BIT(3)
 #define DRM_BUDDY_CLEARED			BIT(4)
<span
class="add">+#define DRM_BUDDY_TRIM_DISABLE			BIT(5)
</span> 
 struct drm_buddy_block {
 #define DRM_BUDDY_HEADER_OFFSET GENMASK_ULL(63, 12)
<span
class="hunk">@@ -155,6 +156,7 @@ int drm_buddy_alloc_blocks(struct drm_buddy *mm,
</span> 			   unsigned long flags);
 
 int drm_buddy_block_trim(struct drm_buddy *mm,
<span
class="add">+			 u64 *start,
</span> 			 u64 new_size,
 			 struct list_head *blocks);
 
-- 
2.25.1

</pre></div></content></entry><entry><author><name>Jane Jian</name><email>Jane.Jian@amd.com</email></author><title>[PATCH] drm/amdgpu: normalize registers as local xcc to read/write under sriov in TLB flush</title><updated>2024-06-21T03:39:57Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240621033948.1738395-1-Jane.Jian@amd.com/"/><id>urn:uuid:b6f0fc7b-5766-e652-74dd-924ea0489928</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHY]
sriov has the higher bit violation when flushing tlb

[HOW]
normalize the registers to keep lower 16-bit(dword aligned) to aviod higher bit violation
RLCG will mask xcd out and always assume it&#39;s accessing its own xcd

[TODO]
later will add the normalization in sriovw/rreg after fixing bugs

v2
rename the normalized macro, add ip block type for further use
move asics func declaration after ip block type since new func
refers ip block type

Signed-off-by: Jane Jian &lt;Jane.Jian@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu.h        | 112 +++++++++++----------
 drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c |  16 +++
 drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c      |   8 +-
 drivers/gpu/drm/amd/amdgpu/soc15.c         |   1 +
 drivers/gpu/drm/amd/amdgpu/soc15.h         |   1 +
 drivers/gpu/drm/amd/amdgpu/soc15_common.h  |   5 +-
 6 files <a href="http://lore.kernel.org/amd-gfx/20240621033948.1738395-1-Jane.Jian@amd.com/#related">changed</a>, 85 insertions(+), 58 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
index 083f353cff6e..070fd9e601fe 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
</span><span
class="hunk">@@ -583,61 +583,6 @@ struct amdgpu_video_codecs {
</span> 	const struct amdgpu_video_codec_info *codec_array;
 };
 
<span
class="del">-/*
- * ASIC specific functions.
- */
-struct amdgpu_asic_funcs {
-	bool (*read_disabled_bios)(struct amdgpu_device *adev);
-	bool (*read_bios_from_rom)(struct amdgpu_device *adev,
-				   u8 *bios, u32 length_bytes);
-	int (*read_register)(struct amdgpu_device *adev, u32 se_num,
-			     u32 sh_num, u32 reg_offset, u32 *value);
-	void (*set_vga_state)(struct amdgpu_device *adev, bool state);
-	int (*reset)(struct amdgpu_device *adev);
-	enum amd_reset_method (*reset_method)(struct amdgpu_device *adev);
-	/* get the reference clock */
-	u32 (*get_xclk)(struct amdgpu_device *adev);
-	/* MM block clocks */
-	int (*set_uvd_clocks)(struct amdgpu_device *adev, u32 vclk, u32 dclk);
-	int (*set_vce_clocks)(struct amdgpu_device *adev, u32 evclk, u32 ecclk);
-	/* static power management */
-	int (*get_pcie_lanes)(struct amdgpu_device *adev);
-	void (*set_pcie_lanes)(struct amdgpu_device *adev, int lanes);
-	/* get config memsize register */
-	u32 (*get_config_memsize)(struct amdgpu_device *adev);
-	/* flush hdp write queue */
-	void (*flush_hdp)(struct amdgpu_device *adev, struct amdgpu_ring *ring);
-	/* invalidate hdp read cache */
-	void (*invalidate_hdp)(struct amdgpu_device *adev,
-			       struct amdgpu_ring *ring);
-	/* check if the asic needs a full reset of if soft reset will work */
-	bool (*need_full_reset)(struct amdgpu_device *adev);
-	/* initialize doorbell layout for specific asic*/
-	void (*init_doorbell_index)(struct amdgpu_device *adev);
-	/* PCIe bandwidth usage */
-	void (*get_pcie_usage)(struct amdgpu_device *adev, uint64_t *count0,
-			       uint64_t *count1);
-	/* do we need to reset the asic at init time (e.g., kexec) */
-	bool (*need_reset_on_init)(struct amdgpu_device *adev);
-	/* PCIe replay counter */
-	uint64_t (*get_pcie_replay_count)(struct amdgpu_device *adev);
-	/* device supports BACO */
-	int (*supports_baco)(struct amdgpu_device *adev);
-	/* pre asic_init quirks */
-	void (*pre_asic_init)(struct amdgpu_device *adev);
-	/* enter/exit umd stable pstate */
-	int (*update_umd_stable_pstate)(struct amdgpu_device *adev, bool enter);
-	/* query video codecs */
-	int (*query_video_codecs)(struct amdgpu_device *adev, bool encode,
-				  const struct amdgpu_video_codecs **codecs);
-	/* encode &#34;&gt; 32bits&#34; smn addressing */
-	u64 (*encode_ext_smn_addressing)(int ext_id);
-
-	ssize_t (*get_reg_state)(struct amdgpu_device *adev,
-				 enum amdgpu_reg_state reg_state, void *buf,
-				 size_t max_size);
-};
-
</span> /*
  * IOCTL.
  */
<span
class="hunk">@@ -728,6 +673,63 @@ enum amd_hw_ip_block_type {
</span> 	MAX_HWIP
 };
 
<span
class="add">+/*
+ * ASIC specific functions.
+ */
+struct amdgpu_asic_funcs {
+	bool (*read_disabled_bios)(struct amdgpu_device *adev);
+	bool (*read_bios_from_rom)(struct amdgpu_device *adev,
+				   u8 *bios, u32 length_bytes);
+	int (*read_register)(struct amdgpu_device *adev, u32 se_num,
+			     u32 sh_num, u32 reg_offset, u32 *value);
+	void (*set_vga_state)(struct amdgpu_device *adev, bool state);
+	int (*reset)(struct amdgpu_device *adev);
+	enum amd_reset_method (*reset_method)(struct amdgpu_device *adev);
+	/* get the reference clock */
+	u32 (*get_xclk)(struct amdgpu_device *adev);
+	/* MM block clocks */
+	int (*set_uvd_clocks)(struct amdgpu_device *adev, u32 vclk, u32 dclk);
+	int (*set_vce_clocks)(struct amdgpu_device *adev, u32 evclk, u32 ecclk);
+	/* static power management */
+	int (*get_pcie_lanes)(struct amdgpu_device *adev);
+	void (*set_pcie_lanes)(struct amdgpu_device *adev, int lanes);
+	/* get config memsize register */
+	u32 (*get_config_memsize)(struct amdgpu_device *adev);
+	/* flush hdp write queue */
+	void (*flush_hdp)(struct amdgpu_device *adev, struct amdgpu_ring *ring);
+	/* invalidate hdp read cache */
+	void (*invalidate_hdp)(struct amdgpu_device *adev,
+			       struct amdgpu_ring *ring);
+	/* check if the asic needs a full reset of if soft reset will work */
+	bool (*need_full_reset)(struct amdgpu_device *adev);
+	/* initialize doorbell layout for specific asic*/
+	void (*init_doorbell_index)(struct amdgpu_device *adev);
+	/* PCIe bandwidth usage */
+	void (*get_pcie_usage)(struct amdgpu_device *adev, uint64_t *count0,
+			       uint64_t *count1);
+	/* do we need to reset the asic at init time (e.g., kexec) */
+	bool (*need_reset_on_init)(struct amdgpu_device *adev);
+	/* PCIe replay counter */
+	uint64_t (*get_pcie_replay_count)(struct amdgpu_device *adev);
+	/* device supports BACO */
+	int (*supports_baco)(struct amdgpu_device *adev);
+	/* pre asic_init quirks */
+	void (*pre_asic_init)(struct amdgpu_device *adev);
+	/* enter/exit umd stable pstate */
+	int (*update_umd_stable_pstate)(struct amdgpu_device *adev, bool enter);
+	/* query video codecs */
+	int (*query_video_codecs)(struct amdgpu_device *adev, bool encode,
+				  const struct amdgpu_video_codecs **codecs);
+	/* encode &#34;&gt; 32bits&#34; smn addressing */
+	u64 (*encode_ext_smn_addressing)(int ext_id);
+
+	ssize_t (*get_reg_state)(struct amdgpu_device *adev,
+				 enum amdgpu_reg_state reg_state, void *buf,
+				 size_t max_size);
+	/* normalize offset to keep in lower 16-bit */
+	u32 (*normalize_reg_offset)(enum amd_hw_ip_block_type hwip, u32 offset);
+};
+
</span> #define HWIP_MAX_INSTANCE	44
 
 #define HW_ID_MAX		300
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c b/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c
index 2c9a0aa41e2d..98b00c0e522f 100644
--- a/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c
+++ b/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c
</span><span
class="hunk">@@ -1085,3 +1085,19 @@ ssize_t aqua_vanjaram_get_reg_state(struct amdgpu_device *adev,
</span> 
 	return size;
 }
<span
class="add">+
+u32 aqua_vanjaram_normalize_reg_offset(enum amd_hw_ip_block_type hwip, u32 offset)
+{
+	u32 normalized_offset;
+
+	switch (hwip) {
+	case GC_HWIP:
+		normalized_offset = offset &#38; 0xffff;
+		break;
+	default:
+		normalized_offset = offset;
+		break;
+	}
+
+	return normalized_offset;
+}
</span><span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
index 88b4644f8e96..66fd229c196a 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
</span><span
class="hunk">@@ -853,8 +853,12 @@ static void gmc_v9_0_flush_gpu_tlb(struct amdgpu_device *adev, uint32_t vmid,
</span> 	 */
 	if (adev-&gt;gfx.kiq[inst].ring.sched.ready &#38;&#38;
 	    (amdgpu_sriov_runtime(adev) || !amdgpu_sriov_vf(adev))) {
<span
class="del">-		uint32_t req = hub-&gt;vm_inv_eng0_req + hub-&gt;eng_distance * eng;
-		uint32_t ack = hub-&gt;vm_inv_eng0_ack + hub-&gt;eng_distance * eng;
</span><span
class="add">+
+		/* Select lower 16 bits to write in local xcc */
+		if (AMDGPU_IS_GFXHUB(vmhub)) {
+			req = NORMALIZE_XCC_REG_OFFSET(GC, req);
+			ack = NORMALIZE_XCC_REG_OFFSET(GC, ack);
+		}
</span> 
 		amdgpu_gmc_fw_reg_write_reg_wait(adev, req, ack, inv_req,
 						 1 &lt;&lt; vmid, inst);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/soc15.c b/drivers/gpu/drm/amd/amdgpu/soc15.c
index 8d16dacdc172..e6e61fc77080 100644
--- a/drivers/gpu/drm/amd/amdgpu/soc15.c
+++ b/drivers/gpu/drm/amd/amdgpu/soc15.c
</span><span
class="hunk">@@ -927,6 +927,7 @@ static const struct amdgpu_asic_funcs aqua_vanjaram_asic_funcs =
</span> 	.query_video_codecs = &#38;soc15_query_video_codecs,
 	.encode_ext_smn_addressing = &#38;aqua_vanjaram_encode_ext_smn_addressing,
 	.get_reg_state = &#38;aqua_vanjaram_get_reg_state,
<span
class="add">+	.normalize_reg_offset = &#38;aqua_vanjaram_normalize_reg_offset,
</span> };
 
 static int soc15_common_early_init(void *handle)
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/soc15.h b/drivers/gpu/drm/amd/amdgpu/soc15.h
index 282584a48be0..f1e974604e3e 100644
--- a/drivers/gpu/drm/amd/amdgpu/soc15.h
+++ b/drivers/gpu/drm/amd/amdgpu/soc15.h
</span><span
class="hunk">@@ -124,4 +124,5 @@ ssize_t aqua_vanjaram_get_reg_state(struct amdgpu_device *adev,
</span> void vega10_doorbell_index_init(struct amdgpu_device *adev);
 void vega20_doorbell_index_init(struct amdgpu_device *adev);
 void aqua_vanjaram_doorbell_index_init(struct amdgpu_device *adev);
<span
class="add">+u32 aqua_vanjaram_normalize_reg_offset(u32 hwip, u32 offset);
</span> #endif
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/soc15_common.h b/drivers/gpu/drm/amd/amdgpu/soc15_common.h
index 242b24f73c17..ddf0aad51821 100644
--- a/drivers/gpu/drm/amd/amdgpu/soc15_common.h
+++ b/drivers/gpu/drm/amd/amdgpu/soc15_common.h
</span><span
class="hunk">@@ -210,4 +210,7 @@
</span> #define WREG64_MCA(ext, mca_base, idx, val) \
 	WREG64_PCIE_EXT(adev-&gt;asic_funcs-&gt;encode_ext_smn_addressing(ext) + mca_base + (idx * 8), val)
 
<span
class="del">-#endif
</span><span
class="add">+#define NORMALIZE_XCC_REG_OFFSET(ip, offset) \
+	((amdgpu_sriov_vf(adev) &#38;&#38; adev-&gt;asic_funcs-&gt;normalize_reg_offset) ? \
+	adev-&gt;asic_funcs-&gt;normalize_reg_offset(ip##_HWIP, offset) : offset)
+#endif
</span>\ No newline at end of file
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Hawking Zhang</name><email>Hawking.Zhang@amd.com</email></author><title>[PATCH] drm/amdgpu: Fix register access violation</title><updated>2024-06-21T03:30:46Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240621033006.19213-1-Hawking.Zhang@amd.com/"/><id>urn:uuid:cb054478-6e39-acc4-f8fd-2bd5fc13b5e8</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">fault_status is read only register. fault_cntl
is not accessible from guest environment.

Signed-off-by: Hawking Zhang &lt;Hawking.Zhang@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/gfxhub_v1_2.c | 8 +++++---
 drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c    | 3 ++-
 drivers/gpu/drm/amd/amdgpu/mmhub_v1_8.c  | 8 +++++---
 3 files <a href="http://lore.kernel.org/amd-gfx/20240621033006.19213-1-Hawking.Zhang@amd.com/#related">changed</a>, 12 insertions(+), 7 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gfxhub_v1_2.c b/drivers/gpu/drm/amd/amdgpu/gfxhub_v1_2.c
index e14acab5cceb..72109abe7c86 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfxhub_v1_2.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfxhub_v1_2.c
</span><span
class="hunk">@@ -629,9 +629,11 @@ static bool gfxhub_v1_2_query_utcl2_poison_status(struct amdgpu_device *adev,
</span> 
 	status = RREG32_SOC15(GC, GET_INST(GC, xcc_id), regVM_L2_PROTECTION_FAULT_STATUS);
 	fed = REG_GET_FIELD(status, VM_L2_PROTECTION_FAULT_STATUS, FED);
<span
class="del">-	/* reset page fault status */
-	WREG32_P(SOC15_REG_OFFSET(GC, GET_INST(GC, xcc_id),
-			regVM_L2_PROTECTION_FAULT_STATUS), 1, ~1);
</span><span
class="add">+	if (!amdgpu_sriov_vf(adev)) {
+		/* clear page fault status and address */
+		WREG32_P(SOC15_REG_OFFSET(GC, GET_INST(GC, xcc_id),
+			 regVM_L2_PROTECTION_FAULT_CNTL), 1, ~1);
+	}
</span> 
 	return fed;
 }
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
index 88b4644f8e96..b73136d390cc 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
</span><span
class="hunk">@@ -672,7 +672,8 @@ static int gmc_v9_0_process_interrupt(struct amdgpu_device *adev,
</span> 	    (amdgpu_ip_version(adev, GC_HWIP, 0) &gt;= IP_VERSION(9, 4, 2)))
 		return 0;
 
<span
class="del">-	WREG32_P(hub-&gt;vm_l2_pro_fault_cntl, 1, ~1);
</span><span
class="add">+	if (!amdgpu_sriov_vf(adev))
+		WREG32_P(hub-&gt;vm_l2_pro_fault_cntl, 1, ~1);
</span> 
 	amdgpu_vm_update_fault_cache(adev, entry-&gt;pasid, addr, status, vmhub);
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/mmhub_v1_8.c b/drivers/gpu/drm/amd/amdgpu/mmhub_v1_8.c
index 7a1ff298417a..8d7267a013d2 100644
--- a/drivers/gpu/drm/amd/amdgpu/mmhub_v1_8.c
+++ b/drivers/gpu/drm/amd/amdgpu/mmhub_v1_8.c
</span><span
class="hunk">@@ -566,9 +566,11 @@ static bool mmhub_v1_8_query_utcl2_poison_status(struct amdgpu_device *adev,
</span> 
 	status = RREG32_SOC15(MMHUB, hub_inst, regVM_L2_PROTECTION_FAULT_STATUS);
 	fed = REG_GET_FIELD(status, VM_L2_PROTECTION_FAULT_STATUS, FED);
<span
class="del">-	/* reset page fault status */
-	WREG32_P(SOC15_REG_OFFSET(MMHUB, hub_inst,
-			regVM_L2_PROTECTION_FAULT_STATUS), 1, ~1);
</span><span
class="add">+	if (!amdgpu_sriov_vf(adev)) {
+		/* clear page fault status and address */
+		WREG32_P(SOC15_REG_OFFSET(MMHUB, hub_inst,
+			 regVM_L2_PROTECTION_FAULT_STATUS), 1, ~1);
+	}
</span> 
 	return fed;
 }
-- 
2.17.1

</pre></div></content></entry><entry><author><name>Alex Deucher</name><email>alexander.deucher@amd.com</email></author><title>[PATCH] drm/amdgpu/gfx10: handle SDMA in KIQ map/unmap</title><updated>2024-06-20T17:29:38Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620172911.3965888-1-alexander.deucher@amd.com/"/><id>urn:uuid:4f9de377-8175-8afe-b4da-191dacf317f9</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Add support for SMDA to the KIQ map/unmap functions.

Signed-off-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c | 85 +++++++++++++++++++++-----
 drivers/gpu/drm/amd/amdgpu/nvd.h       |  2 +
 2 files <a href="http://lore.kernel.org/amd-gfx/20240620172911.3965888-1-alexander.deucher@amd.com/#related">changed</a>, 73 insertions(+), 14 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c b/drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c
index 18488c02d1cf..abbf906496fd 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c
</span><span
class="hunk">@@ -3693,25 +3693,58 @@ static void gfx10_kiq_map_queues(struct amdgpu_ring *kiq_ring,
</span> {
 	uint64_t mqd_addr = amdgpu_bo_gpu_offset(ring-&gt;mqd_obj);
 	uint64_t wptr_addr = ring-&gt;wptr_gpu_addr;
<span
class="del">-	uint32_t eng_sel = 0;
</span><span
class="add">+	uint32_t eng_sel, ext_eng_sel;
</span> 
<span
class="del">-	switch (ring-&gt;funcs-&gt;type) {
-	case AMDGPU_RING_TYPE_COMPUTE:
-		eng_sel = 0;
-		break;
-	case AMDGPU_RING_TYPE_GFX:
-		eng_sel = 4;
-		break;
-	case AMDGPU_RING_TYPE_MES:
-		eng_sel = 5;
-		break;
-	default:
-		WARN_ON(1);
</span><span
class="add">+	if (amdgpu_ip_version(kiq_ring-&gt;adev, GC_HWIP, 0) &lt; IP_VERSION(10, 3, 0)) {
+		ext_eng_sel = 0;
+		switch (ring-&gt;funcs-&gt;type) {
+		case AMDGPU_RING_TYPE_COMPUTE:
+			eng_sel = 0;
+			break;
+		case AMDGPU_RING_TYPE_GFX:
+			eng_sel = 4;
+			break;
+		case AMDGPU_RING_TYPE_MES:
+			eng_sel = 5;
+			break;
+		case AMDGPU_RING_TYPE_SDMA:
+			eng_sel = 2 + ring-&gt;me;
+			break;
+		default:
+			eng_sel = 0;
+			WARN_ON(1);
+			break;
+		}
+	} else {
+		switch (ring-&gt;funcs-&gt;type) {
+		case AMDGPU_RING_TYPE_COMPUTE:
+			ext_eng_sel = 0;
+			eng_sel = 0;
+			break;
+		case AMDGPU_RING_TYPE_GFX:
+			ext_eng_sel = 0;
+			eng_sel = 4;
+			break;
+		case AMDGPU_RING_TYPE_MES:
+			ext_eng_sel = 0;
+			eng_sel = 5;
+			break;
+		case AMDGPU_RING_TYPE_SDMA:
+			ext_eng_sel = 1;
+			eng_sel = ring-&gt;me;
+			break;
+		default:
+			eng_sel = 0;
+			ext_eng_sel = 0;
+			WARN_ON(1);
+			break;
+		}
</span> 	}
 
 	amdgpu_ring_write(kiq_ring, PACKET3(PACKET3_MAP_QUEUES, 5));
 	/* Q_sel:0, vmid:0, vidmem: 1, engine:0, num_Q:1*/
 	amdgpu_ring_write(kiq_ring, /* Q_sel: 0, vmid: 0, engine: 0, num_Q: 1 */
<span
class="add">+			  PACKET3_MAP_QUEUES_EXTENDED_ENGINE_SEL(ext_eng_sel) |
</span> 			  PACKET3_MAP_QUEUES_QUEUE_SEL(0) | /* Queue_Sel */
 			  PACKET3_MAP_QUEUES_VMID(0) | /* VMID */
 			  PACKET3_MAP_QUEUES_QUEUE(ring-&gt;queue) |
<span
class="hunk">@@ -3733,11 +3766,35 @@ static void gfx10_kiq_unmap_queues(struct amdgpu_ring *kiq_ring,
</span> 				   enum amdgpu_unmap_queues_action action,
 				   u64 gpu_addr, u64 seq)
 {
<span
class="del">-	uint32_t eng_sel = ring-&gt;funcs-&gt;type == AMDGPU_RING_TYPE_GFX ? 4 : 0;
</span><span
class="add">+	uint32_t eng_sel, ext_eng_sel;
+
+	if (amdgpu_ip_version(kiq_ring-&gt;adev, GC_HWIP, 0) &lt; IP_VERSION(10, 3, 0)) {
+		ext_eng_sel = 0;
+		if (ring-&gt;funcs-&gt;type == AMDGPU_RING_TYPE_GFX)
+			eng_sel = 4;
+		else if (ring-&gt;funcs-&gt;type == AMDGPU_RING_TYPE_COMPUTE)
+			eng_sel = 0;
+		else
+			/* SDMA */
+			eng_sel = 2 + ring-&gt;me;
+	} else {
+		if (ring-&gt;funcs-&gt;type == AMDGPU_RING_TYPE_GFX) {
+			ext_eng_sel = 0;
+			eng_sel = 4;
+		} else if (ring-&gt;funcs-&gt;type == AMDGPU_RING_TYPE_COMPUTE) {
+			ext_eng_sel = 0;
+			eng_sel = 0;
+		} else {
+			/* SDMA */
+			ext_eng_sel = 1;
+			eng_sel = ring-&gt;me;
+		}
+	}
</span> 
 	amdgpu_ring_write(kiq_ring, PACKET3(PACKET3_UNMAP_QUEUES, 4));
 	amdgpu_ring_write(kiq_ring, /* Q_sel: 0, vmid: 0, engine: 0, num_Q: 1 */
 			  PACKET3_UNMAP_QUEUES_ACTION(action) |
<span
class="add">+			  PACKET3_UNMAP_QUEUES_EXTENDED_ENGINE_SEL(ext_eng_sel) |
</span> 			  PACKET3_UNMAP_QUEUES_QUEUE_SEL(0) |
 			  PACKET3_UNMAP_QUEUES_ENGINE_SEL(eng_sel) |
 			  PACKET3_UNMAP_QUEUES_NUM_QUEUES(1));
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/nvd.h b/drivers/gpu/drm/amd/amdgpu/nvd.h
index 631dafb92299..e0fd205cdd3b 100644
--- a/drivers/gpu/drm/amd/amdgpu/nvd.h
+++ b/drivers/gpu/drm/amd/amdgpu/nvd.h
</span><span
class="hunk">@@ -400,6 +400,7 @@
</span>  * 7. WPTR_ADDR_HI [31:0]
  */
 /* CONTROL */
<span
class="add">+#              define PACKET3_MAP_QUEUES_EXTENDED_ENGINE_SEL(x) ((x) &lt;&lt; 2)
</span> #              define PACKET3_MAP_QUEUES_QUEUE_SEL(x)       ((x) &lt;&lt; 4)
 #              define PACKET3_MAP_QUEUES_VMID(x)            ((x) &lt;&lt; 8)
 #              define PACKET3_MAP_QUEUES_QUEUE(x)           ((x) &lt;&lt; 13)
<span
class="hunk">@@ -427,6 +428,7 @@
</span> 		 * 2 - DISABLE_PROCESS_QUEUES
 		 * 3 - PREEMPT_QUEUES_NO_UNMAP
 		 */
<span
class="add">+#              define PACKET3_UNMAP_QUEUES_EXTENDED_ENGINE_SEL(x) ((x) &lt;&lt; 2)
</span> #              define PACKET3_UNMAP_QUEUES_QUEUE_SEL(x)        ((x) &lt;&lt; 4)
 #              define PACKET3_UNMAP_QUEUES_ENGINE_SEL(x)       ((x) &lt;&lt; 26)
 #              define PACKET3_UNMAP_QUEUES_NUM_QUEUES(x)       ((x) &lt;&lt; 29)
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 39/39] drm/amd/display: 3.2.290</title><updated>2024-06-20T16:21:33Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-40-alex.hung@amd.com/"/><id>urn:uuid:04e5b6e8-5d50-ffa1-02e8-bfaf285712ae</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Aric Cyr &lt;aric.cyr@amd.com&gt;

This version brings along the following:

- Enable DCC on DCN401
- Add reg definitions for DCN401 DCC
- Remove duplicate null check
- Remove always true condition
- Validate function returns
- Ensure curve to hw translation succeed
- Use periodic detection for ipx/headless
- Fix 1DLUT setting for NL SDR blending
- Adjust reg field for DSC wait for disconnect
- Remove a redundant check in authenticated_dp
- Add HW cursor visual confirm
- Fix cursor issues with ODMs and magnification
- Wait for double buffer update on ODM changes
- Reset DSC memory status
- Program CURSOR_DST_X_OFFSET in viewport space
- Add null checks before accessing struct elements
- Fix reduced resolution and refresh rate
- Make DML2.1 P-State method force per stream
- Add workaround to restrict max frac urgent for DPM0
- Call dpmm when checking mode support
- resync OTG after DIO FIFO resync
- Always enable HPO for DCN4 dGPU
- Use sw cursor for DCN401 with rotation
- Add Replay general cmd
- Check HDCP returned status
- Check and log for function error codes
- Check and log for function error codes
- Remove useless function call
- Fix uninitialized variables in dcn401
- Fix cursor size issues
- Run DC_LOG_DC after checking link-&gt;link_enc
- Remove redundant checks for pipe_ctx-&gt;stream
- Send DP_TOTAL_LTTPR_CNT during detection if LTTPR is present
- Fix cursor issues with ODMs and HW rotations
- Remove unnecessary variable
- Remove redundant var from display_rq_dig_calc in dml
- Refactor dccg401_get_other_enable_symclk_fe

Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Aric Cyr &lt;aric.cyr@amd.com&gt;
---
 drivers/gpu/drm/amd/display/dc/dc.h | 2 +-
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-40-alex.hung@amd.com/#related">changed</a>, 1 insertion(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dc.h b/drivers/gpu/drm/amd/display/dc/dc.h
index 40f183816e31..900892855436 100644
--- a/drivers/gpu/drm/amd/display/dc/dc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc.h
</span><span
class="hunk">@@ -55,7 +55,7 @@ struct aux_payload;
</span> struct set_config_cmd_payload;
 struct dmub_notification;
 
<span
class="del">-#define DC_VER &#34;3.2.289&#34;
</span><span
class="add">+#define DC_VER &#34;3.2.290&#34;
</span> 
 #define MAX_SURFACES 3
 #define MAX_PLANES 6
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 38/39] drm/amd/display: Enable DCC on DCN401</title><updated>2024-06-20T16:21:24Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-39-alex.hung@amd.com/"/><id>urn:uuid:590ef371-8bc2-41ce-fd35-6e4620b8a5e0</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Aurabindo Pillai &lt;aurabindo.pillai@amd.com&gt;

[WHAT]
Add registers and entry points to enable DCC on DCN4x

Reviewed-by: Rodrigo Siqueira &lt;rodrigo.siqueira@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Aurabindo Pillai &lt;aurabindo.pillai@amd.com&gt;
---
 drivers/gpu/drm/amd/display/dc/core/dc.c      |  12 +
 .../drm/amd/display/dc/core/dc_hw_sequencer.c |  11 +
 drivers/gpu/drm/amd/display/dc/dc.h           |   4 +
 .../drm/amd/display/dc/dml2/dml2_wrapper.c    |   6 +
 .../drm/amd/display/dc/dml2/dml2_wrapper.h    |   2 +-
 .../display/dc/hubbub/dcn30/dcn30_hubbub.c    |   3 +
 .../display/dc/hubbub/dcn31/dcn31_hubbub.c    |   3 +
 .../display/dc/hubbub/dcn401/dcn401_hubbub.c  | 280 ++++++++++++++++++
 .../display/dc/hubbub/dcn401/dcn401_hubbub.h  |   5 +
 .../amd/display/dc/hubp/dcn20/dcn20_hubp.h    |  14 +
 .../amd/display/dc/hubp/dcn401/dcn401_hubp.c  |  21 ++
 .../amd/display/dc/hubp/dcn401/dcn401_hubp.h  |  14 +-
 .../amd/display/dc/hwss/dcn20/dcn20_hwseq.c   |   4 +
 .../amd/display/dc/hwss/dcn401/dcn401_hwseq.c |  25 ++
 .../amd/display/dc/hwss/dcn401/dcn401_hwseq.h |   2 +
 .../amd/display/dc/hwss/dcn401/dcn401_init.c  |   1 +
 .../drm/amd/display/dc/hwss/hw_sequencer.h    |   9 +
 .../gpu/drm/amd/display/dc/inc/core_types.h   |   3 +
 .../gpu/drm/amd/display/dc/inc/hw/dchubbub.h  |   4 +
 drivers/gpu/drm/amd/display/dc/inc/hw/hubp.h  |   1 +
 .../dc/resource/dcn401/dcn401_resource.c      |   9 +
 .../dc/resource/dcn401/dcn401_resource.h      |   2 +
 22 files <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-39-alex.hung@amd.com/#related">changed</a>, 433 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a4ba6f99cd34..85a2ef82afa5 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
</span><span
class="hunk">@@ -1264,6 +1264,9 @@ static void disable_dangling_plane(struct dc *dc, struct dc_state *context)
</span> 				apply_ctx_interdependent_lock(dc, dc-&gt;current_state, old_stream, false);
 				dc-&gt;hwss.post_unlock_program_front_end(dc, dangling_context);
 			}
<span
class="add">+
+			if (dc-&gt;res_pool-&gt;funcs-&gt;prepare_mcache_programming)
+				dc-&gt;res_pool-&gt;funcs-&gt;prepare_mcache_programming(dc, dangling_context);
</span> 			if (dc-&gt;hwss.program_front_end_for_ctx) {
 				dc-&gt;hwss.interdependent_update_lock(dc, dc-&gt;current_state, true);
 				dc-&gt;hwss.program_front_end_for_ctx(dc, dangling_context);
<span
class="hunk">@@ -2037,6 +2040,8 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
</span> 	}
 
 	/* Program all planes within new context*/
<span
class="add">+	if (dc-&gt;res_pool-&gt;funcs-&gt;prepare_mcache_programming)
+		dc-&gt;res_pool-&gt;funcs-&gt;prepare_mcache_programming(dc, context);
</span> 	if (dc-&gt;hwss.program_front_end_for_ctx) {
 		dc-&gt;hwss.interdependent_update_lock(dc, context, true);
 		dc-&gt;hwss.program_front_end_for_ctx(dc, context);
<span
class="hunk">@@ -3884,6 +3889,9 @@ static void commit_planes_for_stream(struct dc *dc,
</span> 				odm_pipe-&gt;ttu_regs.min_ttu_vblank = MAX_TTU;
 	}
 
<span
class="add">+	if (update_type != UPDATE_TYPE_FAST &#38;&#38; dc-&gt;res_pool-&gt;funcs-&gt;prepare_mcache_programming)
+		dc-&gt;res_pool-&gt;funcs-&gt;prepare_mcache_programming(dc, context);
+
</span> 	if ((update_type != UPDATE_TYPE_FAST) &#38;&#38; stream-&gt;update_flags.bits.dsc_changed)
 		if (top_pipe_to_program &#38;&#38;
 			top_pipe_to_program-&gt;stream_res.tg-&gt;funcs-&gt;lock_doublebuffer_enable) {
<span
class="hunk">@@ -3903,6 +3911,10 @@ static void commit_planes_for_stream(struct dc *dc,
</span> 						top_pipe_to_program-&gt;stream_res.tg);
 		}
 
<span
class="add">+	if (dc-&gt;hwss.wait_for_dcc_meta_propagation) {
+		dc-&gt;hwss.wait_for_dcc_meta_propagation(dc, top_pipe_to_program);
+	}
+
</span> 	if (should_lock_all_pipes &#38;&#38; dc-&gt;hwss.interdependent_update_lock) {
 		if (dc-&gt;hwss.subvp_pipe_control_lock)
 			dc-&gt;hwss.subvp_pipe_control_lock(dc, context, true, should_lock_all_pipes, NULL, subvp_prev_use);
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/core/dc_hw_sequencer.c
index 5037474bf95c..87e36d51c56d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_hw_sequencer.c
</span><span
class="hunk">@@ -595,6 +595,12 @@ void hwss_build_fast_sequence(struct dc *dc,
</span> 	if (!plane || !stream)
 		return;
 
<span
class="add">+	if (dc-&gt;hwss.wait_for_dcc_meta_propagation) {
+		block_sequence[*num_steps].params.wait_for_dcc_meta_propagation_params.dc = dc;
+		block_sequence[*num_steps].params.wait_for_dcc_meta_propagation_params.top_pipe_to_program = pipe_ctx;
+		block_sequence[*num_steps].func = HUBP_WAIT_FOR_DCC_META_PROP;
+		(*num_steps)++;
+	}
</span> 	if (dc-&gt;hwss.subvp_pipe_control_lock_fast) {
 		block_sequence[*num_steps].params.subvp_pipe_control_lock_fast_params.dc = dc;
 		block_sequence[*num_steps].params.subvp_pipe_control_lock_fast_params.lock = true;
<span
class="hunk">@@ -835,6 +841,11 @@ void hwss_execute_sequence(struct dc *dc,
</span> 		case DMUB_SUBVP_SAVE_SURF_ADDR:
 			hwss_subvp_save_surf_addr(params);
 			break;
<span
class="add">+		case HUBP_WAIT_FOR_DCC_META_PROP:
+			dc-&gt;hwss.wait_for_dcc_meta_propagation(
+					params-&gt;wait_for_dcc_meta_propagation_params.dc,
+					params-&gt;wait_for_dcc_meta_propagation_params.top_pipe_to_program);
+			break;
</span> 		case DMUB_FAMS2_GLOBAL_CONTROL_LOCK_FAST:
 			dc-&gt;hwss.fams2_global_control_lock_fast(params);
 			break;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dc.h b/drivers/gpu/drm/amd/display/dc/dc.h
index 64241de70f15..40f183816e31 100644
--- a/drivers/gpu/drm/amd/display/dc/dc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc.h
</span><span
class="hunk">@@ -333,6 +333,9 @@ struct dc_dcc_setting {
</span> 		uint32_t dcc_128_128_uncontrained : 1;  //available in ASICs before DCN 3.0
 		uint32_t dcc_256_128_128 : 1;		//available starting with DCN 3.0
 		uint32_t dcc_256_256_unconstrained : 1;  //available in ASICs before DCN 3.0 (the best compression case)
<span
class="add">+		uint32_t dcc_256_256 : 1;  //available in ASICs starting with DCN 4.0x (the best compression case)
+		uint32_t dcc_256_128 : 1;  //available in ASICs starting with DCN 4.0x
+		uint32_t dcc_256_64 : 1;   //available in ASICs starting with DCN 4.0x (the worst compression case)
</span> 	} dcc_controls;
 };
 
<span
class="hunk">@@ -1037,6 +1040,7 @@ struct dc_debug_options {
</span> 	unsigned int static_screen_wait_frames;
 	uint32_t pwm_freq;
 	bool force_chroma_subsampling_1tap;
<span
class="add">+	unsigned int dcc_meta_propagation_delay_us;
</span> 	bool disable_422_left_edge_pixel;
 	bool dml21_force_pstate_method;
 	uint32_t dml21_force_pstate_method_values[MAX_PIPES];
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c
index 60e2bf4ae6de..c58235121474 100644
--- a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c
+++ b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c
</span><span
class="hunk">@@ -821,6 +821,12 @@ void dml2_extract_dram_and_fclk_change_support(struct dml2_context *dml2,
</span> 	*dram_clk_change_support = (unsigned int) dml2-&gt;v20.dml_core_ctx.ms.support.DRAMClockChangeSupport[0];
 }
 
<span
class="add">+void dml2_prepare_mcache_programming(struct dc *in_dc, struct dc_state *context, struct dml2_context *dml2)
+{
+	if (dml2-&gt;architecture == dml2_architecture_21)
+		dml21_prepare_mcache_programming(in_dc, context, dml2);
+}
+
</span> void dml2_copy(struct dml2_context *dst_dml2,
 	struct dml2_context *src_dml2)
 {
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.h b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.h
index 1e891a3297c2..6e3d52eb45c7 100644
--- a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.h
+++ b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.h
</span><span
class="hunk">@@ -303,5 +303,5 @@ bool dml2_validate(const struct dc *in_dc,
</span>  */
 void dml2_extract_dram_and_fclk_change_support(struct dml2_context *dml2,
 	unsigned int *fclk_change_support, unsigned int *dram_clk_change_support);
<span
class="del">-
</span><span
class="add">+void dml2_prepare_mcache_programming(struct dc *in_dc, struct dc_state *context, struct dml2_context *dml2);
</span> #endif //_DML2_WRAPPER_H_
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hubbub/dcn30/dcn30_hubbub.c b/drivers/gpu/drm/amd/display/dc/hubbub/dcn30/dcn30_hubbub.c
index 6a5af3da4b45..fe741100c0f8 100644
--- a/drivers/gpu/drm/amd/display/dc/hubbub/dcn30/dcn30_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/hubbub/dcn30/dcn30_hubbub.c
</span><span
class="hunk">@@ -339,6 +339,7 @@ bool hubbub3_get_dcc_compression_cap(struct hubbub *hubbub,
</span> 		return false;
 
 	switch (dcc_control) {
<span
class="add">+	case dcc_control__256_256:
</span> 	case dcc_control__256_256_xxx:
 		output-&gt;grph.rgb.max_uncompressed_blk_size = 256;
 		output-&gt;grph.rgb.max_compressed_blk_size = 256;
<span
class="hunk">@@ -346,6 +347,7 @@ bool hubbub3_get_dcc_compression_cap(struct hubbub *hubbub,
</span> 		output-&gt;grph.rgb.dcc_controls.dcc_256_256_unconstrained = 1;
 		output-&gt;grph.rgb.dcc_controls.dcc_256_128_128 = 1;
 		break;
<span
class="add">+	case dcc_control__256_128:
</span> 	case dcc_control__128_128_xxx:
 		output-&gt;grph.rgb.max_uncompressed_blk_size = 128;
 		output-&gt;grph.rgb.max_compressed_blk_size = 128;
<span
class="hunk">@@ -353,6 +355,7 @@ bool hubbub3_get_dcc_compression_cap(struct hubbub *hubbub,
</span> 		output-&gt;grph.rgb.dcc_controls.dcc_128_128_uncontrained = 1;
 		output-&gt;grph.rgb.dcc_controls.dcc_256_128_128 = 1;
 		break;
<span
class="add">+	case dcc_control__256_64:
</span> 	case dcc_control__256_64_64:
 		output-&gt;grph.rgb.max_uncompressed_blk_size = 256;
 		output-&gt;grph.rgb.max_compressed_blk_size = 64;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hubbub/dcn31/dcn31_hubbub.c b/drivers/gpu/drm/amd/display/dc/hubbub/dcn31/dcn31_hubbub.c
index b906db6e7355..7fb5523f9722 100644
--- a/drivers/gpu/drm/amd/display/dc/hubbub/dcn31/dcn31_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/hubbub/dcn31/dcn31_hubbub.c
</span><span
class="hunk">@@ -866,6 +866,7 @@ static bool hubbub31_get_dcc_compression_cap(struct hubbub *hubbub,
</span> 		return false;
 
 	switch (dcc_control) {
<span
class="add">+	case dcc_control__256_256:
</span> 	case dcc_control__256_256_xxx:
 		output-&gt;grph.rgb.max_uncompressed_blk_size = 256;
 		output-&gt;grph.rgb.max_compressed_blk_size = 256;
<span
class="hunk">@@ -881,12 +882,14 @@ static bool hubbub31_get_dcc_compression_cap(struct hubbub *hubbub,
</span> 		output-&gt;grph.rgb.dcc_controls.dcc_256_128_128 = 1;
 		break;
 	case dcc_control__256_64_64:
<span
class="add">+	case dcc_control__256_64:
</span> 		output-&gt;grph.rgb.max_uncompressed_blk_size = 256;
 		output-&gt;grph.rgb.max_compressed_blk_size = 64;
 		output-&gt;grph.rgb.independent_64b_blks = true;
 		output-&gt;grph.rgb.dcc_controls.dcc_256_64_64 = 1;
 		break;
 	case dcc_control__256_128_128:
<span
class="add">+	case dcc_control__256_128:
</span> 		output-&gt;grph.rgb.max_uncompressed_blk_size = 256;
 		output-&gt;grph.rgb.max_compressed_blk_size = 128;
 		output-&gt;grph.rgb.independent_64b_blks = false;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hubbub/dcn401/dcn401_hubbub.c b/drivers/gpu/drm/amd/display/dc/hubbub/dcn401/dcn401_hubbub.c
index 054607c944a3..5126d603f0b1 100644
--- a/drivers/gpu/drm/amd/display/dc/hubbub/dcn401/dcn401_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/hubbub/dcn401/dcn401_hubbub.c
</span><span
class="hunk">@@ -824,6 +824,285 @@ void hubbub401_det_request_size(
</span> 		}
 	}
 }
<span
class="add">+bool hubbub401_get_dcc_compression_cap(struct hubbub *hubbub,
+		const struct dc_dcc_surface_param *input,
+		struct dc_surface_dcc_cap *output)
+{
+	struct dc *dc = hubbub-&gt;ctx-&gt;dc;
+	/* DCN4_Programming_Guide_DCHUB.docx, Section 5.11.2.2 */
+	enum dcc_control dcc_control;
+	unsigned int plane0_bpe, plane1_bpe;
+	enum segment_order segment_order_horz, segment_order_vert;
+	enum segment_order p1_segment_order_horz, p1_segment_order_vert;
+	bool req128_horz_wc, req128_vert_wc;
+	unsigned int plane0_width = 0, plane0_height = 0, plane1_width = 0, plane1_height = 0;
+	bool p1_req128_horz_wc, p1_req128_vert_wc, is_dual_plane;
+
+	memset(output, 0, sizeof(*output));
+
+	if (dc-&gt;debug.disable_dcc == DCC_DISABLE)
+		return false;
+
+	switch (input-&gt;format) {
+	default:
+		is_dual_plane = false;
+
+		plane1_width = 0;
+		plane1_height = 0;
+
+		if (input-&gt;surface_size.width &gt; 6144 + 16)
+			plane0_width = 6160;
+		else
+			plane0_width = input-&gt;surface_size.width;
+
+		if (input-&gt;surface_size.height &gt; 6144 + 16)
+			plane0_height = 6160;
+		else
+			plane0_height = input-&gt;surface_size.height;
+
+		break;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCbCr:
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCrCb:
+		is_dual_plane = true;
+
+		if (input-&gt;surface_size.width &gt; 7680 + 16)
+			plane0_width = 7696;
+		else
+			plane0_width = input-&gt;surface_size.width;
+
+		if (input-&gt;surface_size.height &gt; 4320 + 16)
+			plane0_height = 4336;
+		else
+			plane0_height = input-&gt;surface_size.height;
+
+		if (input-&gt;plane1_size.width &gt; 7680 + 16)
+			plane1_width = 7696 / 2;
+		else
+			plane1_width = input-&gt;plane1_size.width;
+
+		if (input-&gt;plane1_size.height &gt; 4320 + 16)
+			plane1_height = 4336 / 2;
+		else
+			plane1_height = input-&gt;plane1_size.height;
+
+		break;
+
+	case SURFACE_PIXEL_FORMAT_GRPH_RGBE_ALPHA:
+		is_dual_plane = true;
+
+		if (input-&gt;surface_size.width &gt; 5120 + 16)
+			plane0_width = 5136;
+		else
+			plane0_width = input-&gt;surface_size.width;
+
+		if (input-&gt;surface_size.height &gt; 5120 + 16)
+			plane0_height = 5136;
+		else
+			plane0_height = input-&gt;surface_size.height;
+
+		if (input-&gt;plane1_size.width &gt; 5120 + 16)
+			plane1_width = 5136;
+		else
+			plane1_width = input-&gt;plane1_size.width;
+
+		if (input-&gt;plane1_size.height &gt; 5120 + 16)
+			plane1_height = 5136;
+		else
+			plane1_height = input-&gt;plane1_size.height;
+
+		break;
+	}
+
+	if (!hubbub-&gt;funcs-&gt;dcc_support_pixel_format_plane0_plane1(input-&gt;format,
+			&#38;plane0_bpe, &#38;plane1_bpe))
+		return false;
+
+	/* Find plane0 DCC Controls */
+	if (!is_dual_plane) {
+
+		if (!hubbub-&gt;funcs-&gt;dcc_support_swizzle_addr3(input-&gt;swizzle_mode_addr3,
+				input-&gt;plane0_pitch, plane0_bpe,
+				&#38;segment_order_horz, &#38;segment_order_vert))
+			return false;
+
+		hubbub401_det_request_size(TO_DCN20_HUBBUB(hubbub)-&gt;detile_buf_size, input-&gt;format,
+				plane0_height, plane0_width, plane0_bpe,
+				plane1_height, plane1_width, plane1_bpe,
+				&#38;req128_horz_wc, &#38;req128_vert_wc, &#38;p1_req128_horz_wc, &#38;p1_req128_vert_wc);
+
+		if (!req128_horz_wc &#38;&#38; !req128_vert_wc) {
+			dcc_control = dcc_control__256_256;
+		} else if (input-&gt;scan == SCAN_DIRECTION_HORIZONTAL) {
+			if (!req128_horz_wc)
+				dcc_control = dcc_control__256_256;
+			else if (segment_order_horz == segment_order__contiguous)
+				dcc_control = dcc_control__256_128;
+			else
+				dcc_control = dcc_control__256_64;
+		} else if (input-&gt;scan == SCAN_DIRECTION_VERTICAL) {
+			if (!req128_vert_wc)
+				dcc_control = dcc_control__256_256;
+			else if (segment_order_vert == segment_order__contiguous)
+				dcc_control = dcc_control__256_128;
+			else
+				dcc_control = dcc_control__256_64;
+		} else {
+			if ((req128_horz_wc &#38;&#38;
+				segment_order_horz == segment_order__non_contiguous) ||
+				(req128_vert_wc &#38;&#38;
+				segment_order_vert == segment_order__non_contiguous))
+				/* access_dir not known, must use most constraining */
+				dcc_control = dcc_control__256_64;
+			else
+				/* req128 is true for either horz and vert
+				 * but segment_order is contiguous
+				 */
+				dcc_control = dcc_control__256_128;
+		}
+
+		if (dc-&gt;debug.disable_dcc == DCC_HALF_REQ_DISALBE &#38;&#38;
+			dcc_control != dcc_control__256_256)
+			return false;
+
+		switch (dcc_control) {
+		case dcc_control__256_256:
+			output-&gt;grph.rgb.dcc_controls.dcc_256_256 = 1;
+			output-&gt;grph.rgb.dcc_controls.dcc_256_128 = 1;
+			output-&gt;grph.rgb.dcc_controls.dcc_256_64 = 1;
+			break;
+		case dcc_control__256_128:
+			output-&gt;grph.rgb.dcc_controls.dcc_256_128 = 1;
+			output-&gt;grph.rgb.dcc_controls.dcc_256_64 = 1;
+			break;
+		case dcc_control__256_64:
+			output-&gt;grph.rgb.dcc_controls.dcc_256_64 = 1;
+			break;
+		default:
+			/* Shouldn&#39;t get here */
+			ASSERT(0);
+			break;
+		}
+	} else {
+		/* For dual plane cases, need to examine both planes together */
+		if (!hubbub-&gt;funcs-&gt;dcc_support_swizzle_addr3(input-&gt;swizzle_mode_addr3,
+				input-&gt;plane0_pitch, plane0_bpe,
+				&#38;segment_order_horz, &#38;segment_order_vert))
+			return false;
+
+		if (!hubbub-&gt;funcs-&gt;dcc_support_swizzle_addr3(input-&gt;swizzle_mode_addr3,
+			input-&gt;plane1_pitch, plane1_bpe,
+			&#38;p1_segment_order_horz, &#38;p1_segment_order_vert))
+			return false;
+
+		hubbub401_det_request_size(TO_DCN20_HUBBUB(hubbub)-&gt;detile_buf_size, input-&gt;format,
+				plane0_height, plane0_width, plane0_bpe,
+				plane1_height, plane1_width, plane1_bpe,
+				&#38;req128_horz_wc, &#38;req128_vert_wc, &#38;p1_req128_horz_wc, &#38;p1_req128_vert_wc);
+
+		/* Determine Plane 0 DCC Controls */
+		if (!req128_horz_wc &#38;&#38; !req128_vert_wc) {
+			dcc_control = dcc_control__256_256;
+		} else if (input-&gt;scan == SCAN_DIRECTION_HORIZONTAL) {
+			if (!req128_horz_wc)
+				dcc_control = dcc_control__256_256;
+			else if (segment_order_horz == segment_order__contiguous)
+				dcc_control = dcc_control__256_128;
+			else
+				dcc_control = dcc_control__256_64;
+		} else if (input-&gt;scan == SCAN_DIRECTION_VERTICAL) {
+			if (!req128_vert_wc)
+				dcc_control = dcc_control__256_256;
+			else if (segment_order_vert == segment_order__contiguous)
+				dcc_control = dcc_control__256_128;
+			else
+				dcc_control = dcc_control__256_64;
+		} else {
+			if ((req128_horz_wc &#38;&#38;
+				segment_order_horz == segment_order__non_contiguous) ||
+				(req128_vert_wc &#38;&#38;
+				segment_order_vert == segment_order__non_contiguous))
+				/* access_dir not known, must use most constraining */
+				dcc_control = dcc_control__256_64;
+			else
+				/* req128 is true for either horz and vert
+				 * but segment_order is contiguous
+				 */
+				dcc_control = dcc_control__256_128;
+		}
+
+		switch (dcc_control) {
+		case dcc_control__256_256:
+			output-&gt;video.luma.dcc_controls.dcc_256_256 = 1;
+			output-&gt;video.luma.dcc_controls.dcc_256_128 = 1;
+			output-&gt;video.luma.dcc_controls.dcc_256_64 = 1;
+			break;
+		case dcc_control__256_128:
+			output-&gt;video.luma.dcc_controls.dcc_256_128 = 1;
+			output-&gt;video.luma.dcc_controls.dcc_256_64 = 1;
+			break;
+		case dcc_control__256_64:
+			output-&gt;video.luma.dcc_controls.dcc_256_64 = 1;
+			break;
+		default:
+			ASSERT(0);
+			break;
+		}
+
+		/* Determine Plane 1 DCC Controls */
+		if (!p1_req128_horz_wc &#38;&#38; !p1_req128_vert_wc) {
+			dcc_control = dcc_control__256_256;
+		} else if (input-&gt;scan == SCAN_DIRECTION_HORIZONTAL) {
+			if (!p1_req128_horz_wc)
+				dcc_control = dcc_control__256_256;
+			else if (p1_segment_order_horz == segment_order__contiguous)
+				dcc_control = dcc_control__256_128;
+			else
+				dcc_control = dcc_control__256_64;
+		} else if (input-&gt;scan == SCAN_DIRECTION_VERTICAL) {
+			if (!p1_req128_vert_wc)
+				dcc_control = dcc_control__256_256;
+			else if (p1_segment_order_vert == segment_order__contiguous)
+				dcc_control = dcc_control__256_128;
+			else
+				dcc_control = dcc_control__256_64;
+		} else {
+			if ((p1_req128_horz_wc &#38;&#38;
+				p1_segment_order_horz == segment_order__non_contiguous) ||
+				(p1_req128_vert_wc &#38;&#38;
+				p1_segment_order_vert == segment_order__non_contiguous))
+				/* access_dir not known, must use most constraining */
+				dcc_control = dcc_control__256_64;
+			else
+				/* req128 is true for either horz and vert
+				 * but segment_order is contiguous
+				 */
+				dcc_control = dcc_control__256_128;
+		}
+
+		switch (dcc_control) {
+		case dcc_control__256_256:
+			output-&gt;video.chroma.dcc_controls.dcc_256_256 = 1;
+			output-&gt;video.chroma.dcc_controls.dcc_256_128 = 1;
+			output-&gt;video.chroma.dcc_controls.dcc_256_64 = 1;
+			break;
+		case dcc_control__256_128:
+			output-&gt;video.chroma.dcc_controls.dcc_256_128 = 1;
+			output-&gt;video.chroma.dcc_controls.dcc_256_64 = 1;
+			break;
+		case dcc_control__256_64:
+			output-&gt;video.chroma.dcc_controls.dcc_256_64 = 1;
+			break;
+		default:
+			ASSERT(0);
+			break;
+		}
+	}
+
+	output-&gt;capable = true;
+	return true;
+}
</span> 
 static void dcn401_program_det_segments(struct hubbub *hubbub, int hubp_inst, unsigned det_buffer_size_seg)
 {
<span
class="hunk">@@ -891,6 +1170,7 @@ static const struct hubbub_funcs hubbub4_01_funcs = {
</span> 	.init_vm_ctx = hubbub2_init_vm_ctx,
 	.dcc_support_swizzle_addr3 = hubbub401_dcc_support_swizzle,
 	.dcc_support_pixel_format_plane0_plane1 = hubbub401_dcc_support_pixel_format,
<span
class="add">+	.get_dcc_compression_cap = hubbub401_get_dcc_compression_cap,
</span> 	.wm_read_state = hubbub401_wm_read_state,
 	.get_dchub_ref_freq = hubbub2_get_dchub_ref_freq,
 	.program_watermarks = hubbub401_program_watermarks,
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hubbub/dcn401/dcn401_hubbub.h b/drivers/gpu/drm/amd/display/dc/hubbub/dcn401/dcn401_hubbub.h
index d8a57f64a70c..f35f19ba3e18 100644
--- a/drivers/gpu/drm/amd/display/dc/hubbub/dcn401/dcn401_hubbub.h
+++ b/drivers/gpu/drm/amd/display/dc/hubbub/dcn401/dcn401_hubbub.h
</span><span
class="hunk">@@ -180,6 +180,11 @@ void hubbub401_det_request_size(
</span> 		bool *p0_req128_vert_wc,
 		bool *p1_req128_horz_wc,
 		bool *p1_req128_vert_wc);
<span
class="add">+bool hubbub401_get_dcc_compression_cap(
+		struct hubbub *hubbub,
+		const struct dc_dcc_surface_param *input,
+		struct dc_surface_dcc_cap *output);
+
</span> void hubbub401_construct(struct dcn20_hubbub *hubbub2,
 	struct dc_context *ctx,
 	const struct dcn_hubbub_registers *hubbub_regs,
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hubp/dcn20/dcn20_hubp.h b/drivers/gpu/drm/amd/display/dc/hubp/dcn20/dcn20_hubp.h
index ecc0a2f37938..18e194507e36 100644
--- a/drivers/gpu/drm/amd/display/dc/hubp/dcn20/dcn20_hubp.h
+++ b/drivers/gpu/drm/amd/display/dc/hubp/dcn20/dcn20_hubp.h
</span><span
class="hunk">@@ -175,6 +175,8 @@
</span> 	uint32_t HUBP_3DLUT_ADDRESS_LOW;\
 	uint32_t HUBP_3DLUT_CONTROL;\
 	uint32_t HUBP_3DLUT_DLG_PARAM;\
<span
class="add">+	uint32_t DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE;\
+	uint32_t DCHUBP_MCACHEID_CONFIG
</span> 
 #define DCN2_HUBP_REG_FIELD_VARIABLE_LIST(type) \
 	DCN_HUBP_REG_FIELD_BASE_LIST(type); \
<span
class="hunk">@@ -269,6 +271,18 @@
</span> 	type HUBP_3DLUT_ADDRESS_HIGH;\
 	type HUBP_3DLUT_ADDRESS_LOW;\
 	type REFCYC_PER_3DLUT_GROUP;\
<span
class="add">+	type VIEWPORT_MCACHE_SPLIT_COORDINATE;\
+	type VIEWPORT_MCACHE_SPLIT_COORDINATE_C;\
+	type MCACHEID_REG_READ_1H_P0;\
+	type MCACHEID_REG_READ_2H_P0;\
+	type MCACHEID_REG_READ_1H_P1;\
+	type MCACHEID_REG_READ_2H_P1;\
+	type MCACHEID_MALL_PREF_1H_P0;\
+	type MCACHEID_MALL_PREF_2H_P0;\
+	type MCACHEID_MALL_PREF_1H_P1;\
+	type MCACHEID_MALL_PREF_2H_P1
+
+
</span> 
 struct dcn_hubp2_registers {
 	DCN401_HUBP_REG_COMMON_VARIABLE_LIST;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.c b/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.c
index 3f9ca9b40949..f0c45a74c2e5 100644
--- a/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.c
+++ b/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.c
</span><span
class="hunk">@@ -626,6 +626,26 @@ void hubp401_set_viewport(
</span> 		  SEC_VIEWPORT_Y_START_C, viewport_c-&gt;y);
 }
 
<span
class="add">+void hubp401_program_mcache_id_and_split_coordinate(
+	struct hubp *hubp,
+	struct dml2_hubp_pipe_mcache_regs *mcache_regs)
+{
+	struct dcn20_hubp *hubp2 = TO_DCN20_HUBP(hubp);
+
+	REG_SET_8(DCHUBP_MCACHEID_CONFIG, 0,
+		MCACHEID_REG_READ_1H_P0, mcache_regs-&gt;main.p0.mcache_id_first,
+		MCACHEID_REG_READ_2H_P0, mcache_regs-&gt;main.p0.mcache_id_second,
+		MCACHEID_REG_READ_1H_P1, mcache_regs-&gt;main.p1.mcache_id_first,
+		MCACHEID_REG_READ_2H_P1, mcache_regs-&gt;main.p1.mcache_id_second,
+		MCACHEID_MALL_PREF_1H_P0, mcache_regs-&gt;mall.p0.mcache_id_first,
+		MCACHEID_MALL_PREF_2H_P0, mcache_regs-&gt;mall.p0.mcache_id_second,
+		MCACHEID_MALL_PREF_1H_P1, mcache_regs-&gt;mall.p1.mcache_id_first,
+		MCACHEID_MALL_PREF_2H_P1, mcache_regs-&gt;mall.p1.mcache_id_second);
+
+	REG_SET_2(DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE, 0,
+		VIEWPORT_MCACHE_SPLIT_COORDINATE, mcache_regs-&gt;main.p0.split_location,
+		VIEWPORT_MCACHE_SPLIT_COORDINATE_C, mcache_regs-&gt;main.p1.split_location);
+}
</span> void hubp401_set_flip_int(struct hubp *hubp)
 {
 	struct dcn20_hubp *hubp2 = TO_DCN20_HUBP(hubp);
<span
class="hunk">@@ -963,6 +983,7 @@ static struct hubp_funcs dcn401_hubp_funcs = {
</span> 	.phantom_hubp_post_enable = hubp32_phantom_hubp_post_enable,
 	.hubp_update_mall_sel = hubp401_update_mall_sel,
 	.hubp_prepare_subvp_buffering = hubp32_prepare_subvp_buffering,
<span
class="add">+	.hubp_program_mcache_id_and_split_coordinate = hubp401_program_mcache_id_and_split_coordinate,
</span> 	.hubp_update_3dlut_fl_bias_scale = hubp401_update_3dlut_fl_bias_scale,
 	.hubp_program_3dlut_fl_mode = hubp401_program_3dlut_fl_mode,
 	.hubp_program_3dlut_fl_format = hubp401_program_3dlut_fl_format,
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.h b/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.h
index e0cec898a2c0..e52fdb5b0cd0 100644
--- a/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.h
+++ b/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.h
</span><span
class="hunk">@@ -243,6 +243,16 @@
</span> 	HUBP_SF(CURSOR0_0_HUBP_3DLUT_ADDRESS_HIGH, HUBP_3DLUT_ADDRESS_HIGH, mask_sh),\
 	HUBP_SF(CURSOR0_0_HUBP_3DLUT_ADDRESS_LOW, HUBP_3DLUT_ADDRESS_LOW, mask_sh),\
 	HUBP_SF(CURSOR0_0_HUBP_3DLUT_DLG_PARAM, REFCYC_PER_3DLUT_GROUP, mask_sh),\
<span
class="add">+	HUBP_SF(HUBP0_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE, VIEWPORT_MCACHE_SPLIT_COORDINATE, mask_sh),\
+	HUBP_SF(HUBP0_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE, VIEWPORT_MCACHE_SPLIT_COORDINATE_C, mask_sh),\
+	HUBP_SF(HUBP0_DCHUBP_MCACHEID_CONFIG, MCACHEID_REG_READ_1H_P0, mask_sh),\
+	HUBP_SF(HUBP0_DCHUBP_MCACHEID_CONFIG, MCACHEID_REG_READ_2H_P0, mask_sh),\
+	HUBP_SF(HUBP0_DCHUBP_MCACHEID_CONFIG, MCACHEID_REG_READ_1H_P1, mask_sh),\
+	HUBP_SF(HUBP0_DCHUBP_MCACHEID_CONFIG, MCACHEID_REG_READ_2H_P1, mask_sh),\
+	HUBP_SF(HUBP0_DCHUBP_MCACHEID_CONFIG, MCACHEID_MALL_PREF_1H_P0, mask_sh),\
+	HUBP_SF(HUBP0_DCHUBP_MCACHEID_CONFIG, MCACHEID_MALL_PREF_2H_P0, mask_sh),\
+	HUBP_SF(HUBP0_DCHUBP_MCACHEID_CONFIG, MCACHEID_MALL_PREF_1H_P1, mask_sh),\
+	HUBP_SF(HUBP0_DCHUBP_MCACHEID_CONFIG, MCACHEID_MALL_PREF_2H_P1, mask_sh)
</span> 
 void hubp401_update_mall_sel(struct hubp *hubp, uint32_t mall_sel, bool c_cursor);
 
<span
class="hunk">@@ -302,7 +312,9 @@ void hubp401_program_surface_config(
</span> void hubp401_set_viewport(struct hubp *hubp,
 		const struct rect *viewport,
 		const struct rect *viewport_c);
<span
class="del">-
</span><span
class="add">+void hubp401_program_mcache_id_and_split_coordinate(
+	struct hubp *hubp,
+	struct dml2_hubp_pipe_mcache_regs *mcache_regs);
</span> void hubp401_set_flip_int(struct hubp *hubp);
 
 bool hubp401_in_blank(struct hubp *hubp);
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn20/dcn20_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn20/dcn20_hwseq.c
index 36797ed7ad8c..2532ad410cb5 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn20/dcn20_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn20/dcn20_hwseq.c
</span><span
class="hunk">@@ -1753,6 +1753,10 @@ static void dcn20_update_dchubp_dpp(
</span> 			&#38;pipe_ctx-&gt;plane_res.scl_data.viewport_c);
 		viewport_changed = true;
 	}
<span
class="add">+		if (hubp-&gt;funcs-&gt;hubp_program_mcache_id_and_split_coordinate)
+			hubp-&gt;funcs-&gt;hubp_program_mcache_id_and_split_coordinate(
+				hubp,
+				&#38;pipe_ctx-&gt;mcache_regs);
</span> 
 	/* Any updates are handled in dc interface, just need to apply existing for plane enable */
 	if ((pipe_ctx-&gt;update_flags.bits.enable || pipe_ctx-&gt;update_flags.bits.opp_changed ||
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
index b5a02a8fc9d8..11570ef06086 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
</span><span
class="hunk">@@ -1336,6 +1336,31 @@ bool dcn401_apply_idle_power_optimizations(struct dc *dc, bool enable)
</span> 	return true;
 }
 
<span
class="add">+void dcn401_wait_for_dcc_meta_propagation(const struct dc *dc,
+		const struct pipe_ctx *top_pipe)
+{
+	bool is_wait_needed = false;
+	const struct pipe_ctx *pipe_ctx = top_pipe;
+
+	/* check if any surfaces are updating address while using flip immediate and dcc */
+	while (pipe_ctx != NULL) {
+		if (pipe_ctx-&gt;plane_state &#38;&#38;
+				pipe_ctx-&gt;plane_state-&gt;dcc.enable &#38;&#38;
+				pipe_ctx-&gt;plane_state-&gt;flip_immediate &#38;&#38;
+				pipe_ctx-&gt;plane_state-&gt;update_flags.bits.addr_update) {
+			is_wait_needed = true;
+			break;
+		}
+
+		/* check next pipe */
+		pipe_ctx = pipe_ctx-&gt;bottom_pipe;
+	}
+
+	if (is_wait_needed &#38;&#38; dc-&gt;debug.dcc_meta_propagation_delay_us &gt; 0) {
+		udelay(dc-&gt;debug.dcc_meta_propagation_delay_us);
+	}
+}
+
</span> void dcn401_prepare_bandwidth(struct dc *dc,
 	struct dc_state *context)
 {
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.h b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.h
index bada43d4b2eb..c1d4287d5a0d 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.h
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.h
</span><span
class="hunk">@@ -61,6 +61,8 @@ bool dcn401_apply_idle_power_optimizations(struct dc *dc, bool enable);
</span> 
 struct ips_ono_region_state dcn401_read_ono_state(struct dc *dc,
 						  uint8_t region);
<span
class="add">+void dcn401_wait_for_dcc_meta_propagation(const struct dc *dc,
+		const struct pipe_ctx *top_pipe_to_program);
</span> 
 void dcn401_prepare_bandwidth(struct dc *dc,
 		struct dc_state *context);
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_init.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_init.c
index 8159fd838dc3..6a768702c7bd 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_init.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_init.c
</span><span
class="hunk">@@ -94,6 +94,7 @@ static const struct hw_sequencer_funcs dcn401_funcs = {
</span> 	.update_dsc_pg = dcn32_update_dsc_pg,
 	.apply_update_flags_for_phantom = dcn32_apply_update_flags_for_phantom,
 	.blank_phantom = dcn32_blank_phantom,
<span
class="add">+	.wait_for_dcc_meta_propagation = dcn401_wait_for_dcc_meta_propagation,
</span> 	.is_pipe_topology_transition_seamless = dcn32_is_pipe_topology_transition_seamless,
 	.fams2_global_control_lock = dcn401_fams2_global_control_lock,
 	.fams2_update_config = dcn401_fams2_update_config,
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/hw_sequencer.h b/drivers/gpu/drm/amd/display/dc/hwss/hw_sequencer.h
index e9b85884edce..d05be65a2256 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/hw_sequencer.h
+++ b/drivers/gpu/drm/amd/display/dc/hwss/hw_sequencer.h
</span><span
class="hunk">@@ -141,6 +141,11 @@ struct subvp_save_surf_addr {
</span> 	uint8_t subvp_index;
 };
 
<span
class="add">+struct wait_for_dcc_meta_propagation_params {
+	const struct dc *dc;
+	const struct pipe_ctx *top_pipe_to_program;
+};
+
</span> struct fams2_global_control_lock_fast_params {
 	struct dc *dc;
 	bool is_required;
<span
class="hunk">@@ -165,6 +170,7 @@ union block_sequence_params {
</span> 	struct set_output_csc_params set_output_csc_params;
 	struct set_ocsc_default_params set_ocsc_default_params;
 	struct subvp_save_surf_addr subvp_save_surf_addr;
<span
class="add">+	struct wait_for_dcc_meta_propagation_params wait_for_dcc_meta_propagation_params;
</span> 	struct fams2_global_control_lock_fast_params fams2_global_control_lock_fast_params;
 };
 
<span
class="hunk">@@ -186,6 +192,7 @@ enum block_sequence_func {
</span> 	MPC_SET_OUTPUT_CSC,
 	MPC_SET_OCSC_DEFAULT,
 	DMUB_SUBVP_SAVE_SURF_ADDR,
<span
class="add">+	HUBP_WAIT_FOR_DCC_META_PROP,
</span> 	DMUB_FAMS2_GLOBAL_CONTROL_LOCK_FAST,
 
 };
<span
class="hunk">@@ -443,6 +450,8 @@ struct hw_sequencer_funcs {
</span> 	bool (*is_pipe_topology_transition_seamless)(struct dc *dc,
 			const struct dc_state *cur_ctx,
 			const struct dc_state *new_ctx);
<span
class="add">+	void (*wait_for_dcc_meta_propagation)(const struct dc *dc,
+		const struct pipe_ctx *top_pipe_to_program);
</span> 	void (*fams2_global_control_lock)(struct dc *dc,
 			struct dc_state *context,
 			bool lock);
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/inc/core_types.h b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
index f58c27ad8b3e..4c8e6436c7e1 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
</span><span
class="hunk">@@ -97,6 +97,9 @@ struct resource_funcs {
</span> 	unsigned int (*calculate_mall_ways_from_bytes)(
 				const struct dc *dc,
 				unsigned int total_size_in_mall_bytes);
<span
class="add">+	void (*prepare_mcache_programming)(
+					struct dc *dc,
+					struct dc_state *context);
</span> 	/**
 	 * @populate_dml_pipes - Populate pipe data struct
 	 *
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/dchubbub.h b/drivers/gpu/drm/amd/display/dc/inc/hw/dchubbub.h
index a73cb8f731b3..dd2b2864876c 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/dchubbub.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/dchubbub.h
</span><span
class="hunk">@@ -40,6 +40,10 @@ enum dcc_control {
</span> 	dcc_control__128_128_xxx,
 	dcc_control__256_64_64,
 	dcc_control__256_128_128,
<span
class="add">+	dcc_control__256_256,
+	dcc_control__256_128,
+	dcc_control__256_64,
+
</span> };
 
 enum segment_order {
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/hubp.h b/drivers/gpu/drm/amd/display/dc/inc/hw/hubp.h
index bcd7b22a1627..16580d624278 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/hubp.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/hubp.h
</span><span
class="hunk">@@ -257,6 +257,7 @@ struct hubp_funcs {
</span> 			unsigned int min_dst_y_next_start_optimized);
 
 	void (*hubp_wait_pipe_read_start)(struct hubp *hubp);
<span
class="add">+	void (*hubp_program_mcache_id_and_split_coordinate)(struct hubp *hubp, struct dml2_hubp_pipe_mcache_regs *mcache_regs);
</span> 	void (*hubp_update_3dlut_fl_bias_scale)(struct hubp *hubp, uint16_t bias, uint16_t scale);
 	void (*hubp_program_3dlut_fl_mode)(struct hubp *hubp,
 			enum hubp_3dlut_fl_mode mode);
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c b/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c
index 74fb21b88f12..4e27d2cee9fb 100644
--- a/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c
</span><span
class="hunk">@@ -1617,6 +1617,14 @@ bool dcn401_validate_bandwidth(struct dc *dc,
</span> 	return out;
 }
 
<span
class="add">+void dcn401_prepare_mcache_programming(struct dc *dc,
+		struct dc_state *context)
+{
+	if (dc-&gt;debug.using_dml21)
+		dml2_prepare_mcache_programming(dc, context,
+				context-&gt;power_source == DC_POWER_SOURCE_DC ? context-&gt;bw_ctx.dml2_dc_power_source : context-&gt;bw_ctx.dml2);
+}
+
</span> static void dcn401_build_pipe_pix_clk_params(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_stream_state *stream = pipe_ctx-&gt;stream;
<span
class="hunk">@@ -1699,6 +1707,7 @@ static struct resource_funcs dcn401_res_pool_funcs = {
</span> 	.patch_unknown_plane_state = dcn401_patch_unknown_plane_state,
 	.update_soc_for_wm_a = dcn30_update_soc_for_wm_a,
 	.add_phantom_pipes = dcn32_add_phantom_pipes,
<span
class="add">+	.prepare_mcache_programming = dcn401_prepare_mcache_programming,
</span> 	.build_pipe_pix_clk_params = dcn401_build_pipe_pix_clk_params,
 	.calculate_mall_ways_from_bytes = dcn32_calculate_mall_ways_from_bytes,
 };
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.h b/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.h
index c04c8b8f2114..26efeada4f41 100644
--- a/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.h
+++ b/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.h
</span><span
class="hunk">@@ -26,6 +26,8 @@ bool dcn401_validate_bandwidth(struct dc *dc,
</span> 		struct dc_state *context,
 		bool fast_validate);
 
<span
class="add">+void dcn401_prepare_mcache_programming(struct dc *dc, struct dc_state *context);
+
</span> /* Following are definitions for run time init of reg offsets */
 
 /* HUBP */
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 37/39] drm/amd: Add reg definitions for DCN401 DCC</title><updated>2024-06-20T16:21:06Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-38-alex.hung@amd.com/"/><id>urn:uuid:a484eb46-bdeb-ef7f-bd19-79dacdf03603</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Aurabindo Pillai &lt;aurabindo.pillai@amd.com&gt;

[WHAT]
Add the necessary register definitions to enable DCC on DCN4x

Reviewed-by: Rodrigo Siqueira &lt;rodrigo.siqueira@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Aurabindo Pillai &lt;aurabindo.pillai@amd.com&gt;
---
 .../include/asic_reg/dcn/dcn_4_1_0_sh_mask.h  | 110 ++++++++++++++++++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-38-alex.hung@amd.com/#related">changed</a>, 110 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/include/asic_reg/dcn/dcn_4_1_0_sh_mask.h b/drivers/gpu/drm/amd/include/asic_reg/dcn/dcn_4_1_0_sh_mask.h
index 0c68f5d818bb..f42a276499cd 100644
--- a/drivers/gpu/drm/amd/include/asic_reg/dcn/dcn_4_1_0_sh_mask.h
+++ b/drivers/gpu/drm/amd/include/asic_reg/dcn/dcn_4_1_0_sh_mask.h
</span><span
class="hunk">@@ -6430,6 +6430,28 @@
</span> //DCHUBBUB_SDPIF_MEM_PWR_STATUS
 #define DCHUBBUB_SDPIF_MEM_PWR_STATUS__DCHUBBUB_SDPIF_MEM_PWR_STATE__SHIFT                                    0x0
 #define DCHUBBUB_SDPIF_MEM_PWR_STATUS__DCHUBBUB_SDPIF_MEM_PWR_STATE_MASK                                      0x00000003L
<span
class="add">+//DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_FLIP_AWAY_MISSING_PIPE0__SHIFT                 0x0
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_FLIP_AWAY_MISSING_PIPE1__SHIFT                 0x1
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_FLIP_AWAY_MISSING_PIPE2__SHIFT                 0x2
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_FLIP_AWAY_MISSING_PIPE3__SHIFT                 0x3
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_ERR_CLEAR_PIPE0__SHIFT            0xc
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_ERR_CLEAR_PIPE1__SHIFT            0xd
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_ERR_CLEAR_PIPE2__SHIFT            0xe
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_ERR_CLEAR_PIPE3__SHIFT            0xf
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_ERR_ENABLE__SHIFT                 0x1c
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_VREADY_MODE__SHIFT                0x1f
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_FLIP_AWAY_MISSING_PIPE0_MASK                   0x00000001L
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_FLIP_AWAY_MISSING_PIPE1_MASK                   0x00000002L
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_FLIP_AWAY_MISSING_PIPE2_MASK                   0x00000004L
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_FLIP_AWAY_MISSING_PIPE3_MASK                   0x00000008L
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_ERR_CLEAR_PIPE0_MASK              0x00001000L
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_ERR_CLEAR_PIPE1_MASK              0x00002000L
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_ERR_CLEAR_PIPE2_MASK              0x00004000L
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_ERR_CLEAR_PIPE3_MASK              0x00008000L
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_ERR_ENABLE_MASK                   0x10000000L
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_VREADY_MODE_MASK                  0x80000000L
+
</span> 
 
 // addressBlock: dcn_dcec_dchubbubl_hubbub_ret_path_dispdec
<span
class="hunk">@@ -7084,6 +7106,11 @@
</span> #define HUBP0_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_Y_START__SHIFT                                          0x10
 #define HUBP0_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_X_START_MASK                                            0x0000FFFFL
 #define HUBP0_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_Y_START_MASK                                            0xFFFF0000L
<span
class="add">+//HUBP0_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE
+#define HUBP0_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE__SHIFT                0x0
+#define HUBP0_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_C__SHIFT              0x10
+#define HUBP0_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_MASK                  0x0000FFFFL
+#define HUBP0_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_C_MASK                0xFFFF0000L
</span> //HUBP0_DCSURF_PRI_VIEWPORT_DIMENSION
 #define HUBP0_DCSURF_PRI_VIEWPORT_DIMENSION__PRI_VIEWPORT_WIDTH__SHIFT                                        0x0
 #define HUBP0_DCSURF_PRI_VIEWPORT_DIMENSION__PRI_VIEWPORT_HEIGHT__SHIFT                                       0x10
<span
class="hunk">@@ -7244,6 +7271,23 @@
</span> #define HUBP0_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_NEXT_S1__SHIFT                                               0xc
 #define HUBP0_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_CURR_S1_MASK                                                 0x00000FFFL
 #define HUBP0_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_NEXT_S1_MASK                                                 0x00FFF000L
<span
class="add">+//HUBP0_DCHUBP_MCACHEID_CONFIG
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P0__SHIFT                                          0x0
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P0__SHIFT                                          0x4
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P1__SHIFT                                          0x8
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P1__SHIFT                                          0xc
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P0__SHIFT                                         0x10
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P0__SHIFT                                         0x14
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P1__SHIFT                                         0x18
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P1__SHIFT                                         0x1c
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P0_MASK                                            0x0000000FL
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P0_MASK                                            0x000000F0L
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P1_MASK                                            0x00000F00L
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P1_MASK                                            0x0000F000L
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P0_MASK                                           0x000F0000L
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P0_MASK                                           0x00F00000L
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P1_MASK                                           0x0F000000L
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P1_MASK                                           0xF0000000L
</span> //HUBP0_HUBP_MEASURE_WIN_CTRL_DCFCLK
 #define HUBP0_HUBP_MEASURE_WIN_CTRL_DCFCLK__HUBP_MEASURE_WIN_EN_DCFCLK__SHIFT                                 0x0
 #define HUBP0_HUBP_MEASURE_WIN_CTRL_DCFCLK__HUBP_MEASURE_WIN_PERIOD_M1_DCFCLK__SHIFT                          0x4
<span
class="hunk">@@ -8013,6 +8057,11 @@
</span> #define HUBP1_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_Y_START__SHIFT                                          0x10
 #define HUBP1_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_X_START_MASK                                            0x0000FFFFL
 #define HUBP1_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_Y_START_MASK                                            0xFFFF0000L
<span
class="add">+//HUBP1_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE
+#define HUBP1_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE__SHIFT                0x0
+#define HUBP1_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_C__SHIFT              0x10
+#define HUBP1_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_MASK                  0x0000FFFFL
+#define HUBP1_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_C_MASK                0xFFFF0000L
</span> //HUBP1_DCSURF_PRI_VIEWPORT_DIMENSION
 #define HUBP1_DCSURF_PRI_VIEWPORT_DIMENSION__PRI_VIEWPORT_WIDTH__SHIFT                                        0x0
 #define HUBP1_DCSURF_PRI_VIEWPORT_DIMENSION__PRI_VIEWPORT_HEIGHT__SHIFT                                       0x10
<span
class="hunk">@@ -8173,6 +8222,23 @@
</span> #define HUBP1_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_NEXT_S1__SHIFT                                               0xc
 #define HUBP1_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_CURR_S1_MASK                                                 0x00000FFFL
 #define HUBP1_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_NEXT_S1_MASK                                                 0x00FFF000L
<span
class="add">+//HUBP1_DCHUBP_MCACHEID_CONFIG
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P0__SHIFT                                          0x0
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P0__SHIFT                                          0x4
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P1__SHIFT                                          0x8
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P1__SHIFT                                          0xc
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P0__SHIFT                                         0x10
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P0__SHIFT                                         0x14
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P1__SHIFT                                         0x18
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P1__SHIFT                                         0x1c
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P0_MASK                                            0x0000000FL
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P0_MASK                                            0x000000F0L
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P1_MASK                                            0x00000F00L
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P1_MASK                                            0x0000F000L
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P0_MASK                                           0x000F0000L
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P0_MASK                                           0x00F00000L
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P1_MASK                                           0x0F000000L
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P1_MASK                                           0xF0000000L
</span> //HUBP1_HUBP_MEASURE_WIN_CTRL_DCFCLK
 #define HUBP1_HUBP_MEASURE_WIN_CTRL_DCFCLK__HUBP_MEASURE_WIN_EN_DCFCLK__SHIFT                                 0x0
 #define HUBP1_HUBP_MEASURE_WIN_CTRL_DCFCLK__HUBP_MEASURE_WIN_PERIOD_M1_DCFCLK__SHIFT                          0x4
<span
class="hunk">@@ -8942,6 +9008,11 @@
</span> #define HUBP2_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_Y_START__SHIFT                                          0x10
 #define HUBP2_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_X_START_MASK                                            0x0000FFFFL
 #define HUBP2_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_Y_START_MASK                                            0xFFFF0000L
<span
class="add">+//HUBP2_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE
+#define HUBP2_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE__SHIFT                0x0
+#define HUBP2_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_C__SHIFT              0x10
+#define HUBP2_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_MASK                  0x0000FFFFL
+#define HUBP2_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_C_MASK                0xFFFF0000L
</span> //HUBP2_DCSURF_PRI_VIEWPORT_DIMENSION
 #define HUBP2_DCSURF_PRI_VIEWPORT_DIMENSION__PRI_VIEWPORT_WIDTH__SHIFT                                        0x0
 #define HUBP2_DCSURF_PRI_VIEWPORT_DIMENSION__PRI_VIEWPORT_HEIGHT__SHIFT                                       0x10
<span
class="hunk">@@ -9102,6 +9173,23 @@
</span> #define HUBP2_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_NEXT_S1__SHIFT                                               0xc
 #define HUBP2_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_CURR_S1_MASK                                                 0x00000FFFL
 #define HUBP2_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_NEXT_S1_MASK                                                 0x00FFF000L
<span
class="add">+//HUBP2_DCHUBP_MCACHEID_CONFIG
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P0__SHIFT                                          0x0
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P0__SHIFT                                          0x4
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P1__SHIFT                                          0x8
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P1__SHIFT                                          0xc
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P0__SHIFT                                         0x10
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P0__SHIFT                                         0x14
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P1__SHIFT                                         0x18
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P1__SHIFT                                         0x1c
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P0_MASK                                            0x0000000FL
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P0_MASK                                            0x000000F0L
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P1_MASK                                            0x00000F00L
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P1_MASK                                            0x0000F000L
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P0_MASK                                           0x000F0000L
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P0_MASK                                           0x00F00000L
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P1_MASK                                           0x0F000000L
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P1_MASK                                           0xF0000000L
</span> //HUBP2_HUBP_MEASURE_WIN_CTRL_DCFCLK
 #define HUBP2_HUBP_MEASURE_WIN_CTRL_DCFCLK__HUBP_MEASURE_WIN_EN_DCFCLK__SHIFT                                 0x0
 #define HUBP2_HUBP_MEASURE_WIN_CTRL_DCFCLK__HUBP_MEASURE_WIN_PERIOD_M1_DCFCLK__SHIFT                          0x4
<span
class="hunk">@@ -9871,6 +9959,11 @@
</span> #define HUBP3_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_Y_START__SHIFT                                          0x10
 #define HUBP3_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_X_START_MASK                                            0x0000FFFFL
 #define HUBP3_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_Y_START_MASK                                            0xFFFF0000L
<span
class="add">+//HUBP3_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE
+#define HUBP3_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE__SHIFT                0x0
+#define HUBP3_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_C__SHIFT              0x10
+#define HUBP3_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_MASK                  0x0000FFFFL
+#define HUBP3_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_C_MASK                0xFFFF0000L
</span> //HUBP3_DCSURF_PRI_VIEWPORT_DIMENSION
 #define HUBP3_DCSURF_PRI_VIEWPORT_DIMENSION__PRI_VIEWPORT_WIDTH__SHIFT                                        0x0
 #define HUBP3_DCSURF_PRI_VIEWPORT_DIMENSION__PRI_VIEWPORT_HEIGHT__SHIFT                                       0x10
<span
class="hunk">@@ -10031,6 +10124,23 @@
</span> #define HUBP3_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_NEXT_S1__SHIFT                                               0xc
 #define HUBP3_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_CURR_S1_MASK                                                 0x00000FFFL
 #define HUBP3_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_NEXT_S1_MASK                                                 0x00FFF000L
<span
class="add">+//HUBP3_DCHUBP_MCACHEID_CONFIG
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P0__SHIFT                                          0x0
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P0__SHIFT                                          0x4
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P1__SHIFT                                          0x8
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P1__SHIFT                                          0xc
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P0__SHIFT                                         0x10
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P0__SHIFT                                         0x14
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P1__SHIFT                                         0x18
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P1__SHIFT                                         0x1c
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P0_MASK                                            0x0000000FL
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P0_MASK                                            0x000000F0L
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P1_MASK                                            0x00000F00L
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P1_MASK                                            0x0000F000L
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P0_MASK                                           0x000F0000L
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P0_MASK                                           0x00F00000L
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P1_MASK                                           0x0F000000L
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P1_MASK                                           0xF0000000L
</span> //HUBP3_HUBP_MEASURE_WIN_CTRL_DCFCLK
 #define HUBP3_HUBP_MEASURE_WIN_CTRL_DCFCLK__HUBP_MEASURE_WIN_EN_DCFCLK__SHIFT                                 0x0
 #define HUBP3_HUBP_MEASURE_WIN_CTRL_DCFCLK__HUBP_MEASURE_WIN_PERIOD_M1_DCFCLK__SHIFT                          0x4
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 36/39] drm/amd/display: Remove duplicate null check</title><updated>2024-06-20T16:20:52Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-37-alex.hung@amd.com/"/><id>urn:uuid:e84b4f6e-1529-9ae1-a779-0048c3e7bfee</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHAT &#38; HOW]
The same display null check was a few lines above.

This fixes 1 DEADCODE issue reported by Coverity.

Reviewed-by: Rodrigo Siqueira &lt;rodrigo.siqueira@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Alex Hung &lt;alex.hung@amd.com&gt;
---
 drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c | 3 ---
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-37-alex.hung@amd.com/#related">changed</a>, 3 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c b/drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c
index 7c9805705fd3..8c137d7c032e 100644
--- a/drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c
+++ b/drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c
</span><span
class="hunk">@@ -513,9 +513,6 @@ enum mod_hdcp_status mod_hdcp_hdcp2_create_session(struct mod_hdcp *hdcp)
</span> 	hdcp_cmd = (struct ta_hdcp_shared_memory *)psp-&gt;hdcp_context.context.mem_context.shared_buf;
 	memset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));
 
<span
class="del">-	if (!display)
-		return MOD_HDCP_STATUS_DISPLAY_NOT_FOUND;
-
</span> 	hdcp_cmd-&gt;in_msg.hdcp2_create_session_v2.display_handle = display-&gt;index;
 
 	if (hdcp-&gt;connection.link.adjust.hdcp2.force_type == MOD_HDCP_FORCE_TYPE_0)
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 35/39] drm/amd/display: Remove always true condition</title><updated>2024-06-20T16:20:37Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-36-alex.hung@amd.com/"/><id>urn:uuid:ef208c76-80cc-c48e-3b18-f8b13c498d5e</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHAT &#38; HOW]
advanced_pstate_switching was initialized to false and never assigned to
another value; as a result !advanced_pstate_switching is always true and
should be removed.

This fixes 2 DEADCODE issues reported by Coverity.

Reviewed-by: Rodrigo Siqueira &lt;rodrigo.siqueira@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Alex Hung &lt;alex.hung@amd.com&gt;
---
 drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c | 4 +---
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-36-alex.hung@amd.com/#related">changed</a>, 1 insertion(+), 3 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c
index 90bb6e718301..60e2bf4ae6de 100644
--- a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c
+++ b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c
</span><span
class="hunk">@@ -442,7 +442,6 @@ static bool optimize_pstate_with_svp_and_drr(struct dml2_context *dml2, struct d
</span> 	bool result = false;
 	int drr_display_index = 0, non_svp_streams = 0;
 	bool force_svp = dml2-&gt;config.svp_pstate.force_enable_subvp;
<span
class="del">-	bool advanced_pstate_switching = false;
</span> 
 	display_state-&gt;bw_ctx.bw.dcn.clk.fw_based_mclk_switching = false;
 	display_state-&gt;bw_ctx.bw.dcn.legacy_svp_drr_stream_index_valid = false;
<span
class="hunk">@@ -451,8 +450,7 @@ static bool optimize_pstate_with_svp_and_drr(struct dml2_context *dml2, struct d
</span> 
 	if (!result) {
 		pstate_optimization_done = true;
<span
class="del">-	} else if (!advanced_pstate_switching ||
-		(s-&gt;mode_support_info.DRAMClockChangeSupport[0] != dml_dram_clock_change_unsupported &#38;&#38; !force_svp)) {
</span><span
class="add">+	} else if (s-&gt;mode_support_info.DRAMClockChangeSupport[0] != dml_dram_clock_change_unsupported &#38;&#38; !force_svp) {
</span> 		pstate_optimization_success = true;
 		pstate_optimization_done = true;
 	}
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 34/39] drm/amd/display: Validate function returns</title><updated>2024-06-20T16:20:27Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-35-alex.hung@amd.com/"/><id>urn:uuid:f830c794-d0e3-dac8-7597-03092e8c8b71</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHAT &#38; HOW]
Function return values must be checked before data can be used
in subsequent functions.

This fixes 4 CHECKED_RETURN issues reported by Coverity.

Reviewed-by: Harry Wentland &lt;harry.wentland@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Alex Hung &lt;alex.hung@amd.com&gt;
---
 drivers/gpu/drm/amd/display/dc/dc_dmub_srv.c               | 7 +++++--
 drivers/gpu/drm/amd/display/dc/hubbub/dcn20/dcn20_hubbub.c | 3 ++-
 .../drm/amd/display/dc/link/protocols/link_dp_training.c   | 3 +--
 3 files <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-35-alex.hung@amd.com/#related">changed</a>, 8 insertions(+), 5 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dc_dmub_srv.c b/drivers/gpu/drm/amd/display/dc/dc_dmub_srv.c
index b2051c4dd7b6..ded13026c8ff 100644
--- a/drivers/gpu/drm/amd/display/dc/dc_dmub_srv.c
+++ b/drivers/gpu/drm/amd/display/dc/dc_dmub_srv.c
</span><span
class="hunk">@@ -245,7 +245,9 @@ bool dc_dmub_srv_cmd_run_list(struct dc_dmub_srv *dc_dmub_srv, unsigned int coun
</span> 			if (status == DMUB_STATUS_POWER_STATE_D3)
 				return false;
 
<span
class="del">-			dmub_srv_wait_for_idle(dmub, 100000);
</span><span
class="add">+			status = dmub_srv_wait_for_idle(dmub, 100000);
+			if (status != DMUB_STATUS_OK)
+				return false;
</span> 
 			/* Requeue the command. */
 			status = dmub_srv_cmd_queue(dmub, &#38;cmd_list[i]);
<span
class="hunk">@@ -517,7 +519,8 @@ void dc_dmub_srv_get_visual_confirm_color_cmd(struct dc *dc, struct pipe_ctx *pi
</span> 	union dmub_rb_cmd cmd = { 0 };
 	unsigned int panel_inst = 0;
 
<span
class="del">-	dc_get_edp_link_panel_inst(dc, pipe_ctx-&gt;stream-&gt;link, &#38;panel_inst);
</span><span
class="add">+	if (!dc_get_edp_link_panel_inst(dc, pipe_ctx-&gt;stream-&gt;link, &#38;panel_inst))
+		return;
</span> 
 	memset(&#38;cmd, 0, sizeof(cmd));
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hubbub/dcn20/dcn20_hubbub.c b/drivers/gpu/drm/amd/display/dc/hubbub/dcn20/dcn20_hubbub.c
index 8901bd80f7d1..5c6f7ddafd6b 100644
--- a/drivers/gpu/drm/amd/display/dc/hubbub/dcn20/dcn20_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/hubbub/dcn20/dcn20_hubbub.c
</span><span
class="hunk">@@ -616,7 +616,8 @@ static bool hubbub2_program_watermarks(
</span> 		hubbub1-&gt;base.ctx-&gt;dc-&gt;clk_mgr-&gt;clks.p_state_change_support == false)
 		safe_to_lower = true;
 
<span
class="del">-	hubbub1_program_pstate_watermarks(hubbub, watermarks, refclk_mhz, safe_to_lower);
</span><span
class="add">+	if (hubbub1_program_pstate_watermarks(hubbub, watermarks, refclk_mhz, safe_to_lower))
+		wm_pending = true;
</span> 
 	REG_SET(DCHUBBUB_ARB_SAT_LEVEL, 0,
 			DCHUBBUB_ARB_SAT_LEVEL, 60 * refclk_mhz);
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_training.c b/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_training.c
index 5a0f574056d4..988999c44475 100644
--- a/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_training.c
+++ b/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_training.c
</span><span
class="hunk">@@ -1663,8 +1663,7 @@ bool perform_link_training_with_retries(
</span> 		if (status == LINK_TRAINING_ABORT) {
 			enum dc_connection_type type = dc_connection_none;
 
<span
class="del">-			link_detect_connection_type(link, &#38;type);
-			if (type == dc_connection_none) {
</span><span
class="add">+			if (link_detect_connection_type(link, &#38;type) &#38;&#38; type == dc_connection_none) {
</span> 				DC_LOG_HW_LINK_TRAINING(&#34;%s: Aborting training because sink unplugged\n&#34;, __func__);
 				break;
 			}
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 33/39] drm/amd/display: Ensure curve to hw translation succeed</title><updated>2024-06-20T16:20:10Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-34-alex.hung@amd.com/"/><id>urn:uuid:c55572f2-4dd4-f759-9418-65831964747a</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHAT &#38; HOW]
Check cm3_helper_translate_curve_to_hw_format runs successfully so the
regamma_params is valid and can be used.

Also revmoed two result assignments.

This fixes 2 CHECKED_RETURN UNUSED_VALUE issues reported by Coverity.

Reviewed-by: Harry Wentland &lt;harry.wentland@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Alex Hung &lt;alex.hung@amd.com&gt;
---
 drivers/gpu/drm/amd/display/dc/hwss/dcn30/dcn30_hwseq.c | 5 ++++-
 drivers/gpu/drm/amd/display/dc/hwss/dcn32/dcn32_hwseq.c | 9 ++++++---
 2 files <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-34-alex.hung@amd.com/#related">changed</a>, 10 insertions(+), 4 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn30/dcn30_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn30/dcn30_hwseq.c
index bcacfd893cf7..eaeeade31ed7 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn30/dcn30_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn30/dcn30_hwseq.c
</span><span
class="hunk">@@ -228,8 +228,11 @@ bool dcn30_set_blend_lut(
</span> 	if (plane_state-&gt;blend_tf.type == TF_TYPE_HWPWL)
 		blend_lut = &#38;plane_state-&gt;blend_tf.pwl;
 	else if (plane_state-&gt;blend_tf.type == TF_TYPE_DISTRIBUTED_POINTS) {
<span
class="del">-		cm3_helper_translate_curve_to_hw_format(
</span><span
class="add">+		result = cm3_helper_translate_curve_to_hw_format(
</span> 				&#38;plane_state-&gt;blend_tf, &#38;dpp_base-&gt;regamma_params, false);
<span
class="add">+		if (!result)
+			return result;
+
</span> 		blend_lut = &#38;dpp_base-&gt;regamma_params;
 	}
 	result = dpp_base-&gt;funcs-&gt;dpp_program_blnd_lut(dpp_base, blend_lut);
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn32/dcn32_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn32/dcn32_hwseq.c
index fe62478fbcde..05d8f81daa06 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn32/dcn32_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn32/dcn32_hwseq.c
</span><span
class="hunk">@@ -483,11 +483,14 @@ bool dcn32_set_mcm_luts(
</span> 	if (plane_state-&gt;blend_tf.type == TF_TYPE_HWPWL)
 		lut_params = &#38;plane_state-&gt;blend_tf.pwl;
 	else if (plane_state-&gt;blend_tf.type == TF_TYPE_DISTRIBUTED_POINTS) {
<span
class="del">-		cm3_helper_translate_curve_to_hw_format(&#38;plane_state-&gt;blend_tf,
</span><span
class="add">+		result = cm3_helper_translate_curve_to_hw_format(&#38;plane_state-&gt;blend_tf,
</span> 				&#38;dpp_base-&gt;regamma_params, false);
<span
class="add">+		if (!result)
+			return result;
+
</span> 		lut_params = &#38;dpp_base-&gt;regamma_params;
 	}
<span
class="del">-	result = mpc-&gt;funcs-&gt;program_1dlut(mpc, lut_params, mpcc_id);
</span><span
class="add">+	mpc-&gt;funcs-&gt;program_1dlut(mpc, lut_params, mpcc_id);
</span> 	lut_params = NULL;
 
 	// Shaper
<span
class="hunk">@@ -501,7 +504,7 @@ bool dcn32_set_mcm_luts(
</span> 		lut_params = &#38;dpp_base-&gt;shaper_params;
 	}
 
<span
class="del">-	result = mpc-&gt;funcs-&gt;program_shaper(mpc, lut_params, mpcc_id);
</span><span
class="add">+	mpc-&gt;funcs-&gt;program_shaper(mpc, lut_params, mpcc_id);
</span> 
 	// 3D
 	if (plane_state-&gt;lut3d_func.state.bits.initialized == 1)
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 32/39] drm/amd/display: Use periodic detection for ipx/headless</title><updated>2024-06-20T16:20:04Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-33-alex.hung@amd.com/"/><id>urn:uuid:7c596d8e-e849-7a09-e5fa-47a2b35fd8a2</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Roman Li &lt;roman.li@amd.com&gt;

[WHY]
Hotplug is not detected in headless (no eDP) mode on dcn35x.
With no display dcn35x goes to IPS2 powersaving state where HPD interrupt
is not handled.

[HOW]
Use idle worker thread for periodic detection of HPD in headless mode.

Reviewed-by: Aurabindo Pillai &lt;aurabindo.pillai@amd.com&gt;
Cc: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
Cc: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Cc: stable@vger.kernel.org
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Roman Li &lt;roman.li@amd.com&gt;
---
 .../gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h |  3 ++
 .../amd/display/amdgpu_dm/amdgpu_dm_crtc.c    | 48 +++++++++++++++----
 .../amd/display/amdgpu_dm/amdgpu_dm_helpers.c |  5 +-
 3 files <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-33-alex.hung@amd.com/#related">changed</a>, 46 insertions(+), 10 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
index dfcbc1970fe6..5fd1b6b44577 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
</span><span
class="hunk">@@ -989,4 +989,7 @@ void *dm_allocate_gpu_mem(struct amdgpu_device *adev,
</span> 						  enum dc_gpu_mem_alloc_type type,
 						  size_t size,
 						  long long *addr);
<span
class="add">+
+bool amdgpu_dm_is_headless(struct amdgpu_device *adev);
+
</span> #endif /* __AMDGPU_DM_H__ */
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crtc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crtc.c
index e16eecb146fd..99014339aaa3 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crtc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crtc.c
</span><span
class="hunk">@@ -162,33 +162,63 @@ static void amdgpu_dm_crtc_set_panel_sr_feature(
</span> 	}
 }
 
<span
class="add">+bool amdgpu_dm_is_headless(struct amdgpu_device *adev)
+{
+	struct drm_connector *connector;
+	struct drm_connector_list_iter iter;
+	struct drm_device *dev;
+	bool is_headless = true;
+
+	if (adev == NULL)
+		return true;
+
+	dev = adev-&gt;dm.ddev;
+
+	drm_connector_list_iter_begin(dev, &#38;iter);
+	drm_for_each_connector_iter(connector, &#38;iter) {
+
+		if (connector-&gt;connector_type == DRM_MODE_CONNECTOR_WRITEBACK)
+			continue;
+
+		if (connector-&gt;status == connector_status_connected) {
+			is_headless = false;
+			break;
+		}
+	}
+	drm_connector_list_iter_end(&#38;iter);
+	return is_headless;
+}
+
</span> static void amdgpu_dm_idle_worker(struct work_struct *work)
 {
 	struct idle_workqueue *idle_work;
 
 	idle_work = container_of(work, struct idle_workqueue, work);
 	idle_work-&gt;dm-&gt;idle_workqueue-&gt;running = true;
<span
class="del">-	fsleep(HPD_DETECTION_PERIOD_uS);
-	mutex_lock(&#38;idle_work-&gt;dm-&gt;dc_lock);
</span><span
class="add">+
</span> 	while (idle_work-&gt;enable) {
<span
class="del">-		if (!idle_work-&gt;dm-&gt;dc-&gt;idle_optimizations_allowed)
</span><span
class="add">+		fsleep(HPD_DETECTION_PERIOD_uS);
+		mutex_lock(&#38;idle_work-&gt;dm-&gt;dc_lock);
+		if (!idle_work-&gt;dm-&gt;dc-&gt;idle_optimizations_allowed) {
+			mutex_unlock(&#38;idle_work-&gt;dm-&gt;dc_lock);
</span> 			break;
<span
class="del">-
</span><span
class="add">+		}
</span> 		dc_allow_idle_optimizations(idle_work-&gt;dm-&gt;dc, false);
 
 		mutex_unlock(&#38;idle_work-&gt;dm-&gt;dc_lock);
 		fsleep(HPD_DETECTION_TIME_uS);
 		mutex_lock(&#38;idle_work-&gt;dm-&gt;dc_lock);
 
<span
class="del">-		if (!amdgpu_dm_psr_is_active_allowed(idle_work-&gt;dm))
</span><span
class="add">+		if (!amdgpu_dm_is_headless(idle_work-&gt;dm-&gt;adev) &#38;&#38;
+		    !amdgpu_dm_psr_is_active_allowed(idle_work-&gt;dm)) {
+			mutex_unlock(&#38;idle_work-&gt;dm-&gt;dc_lock);
</span> 			break;
<span
class="add">+		}
</span> 
<span
class="del">-		dc_allow_idle_optimizations(idle_work-&gt;dm-&gt;dc, true);
</span><span
class="add">+		if (idle_work-&gt;enable)
+			dc_allow_idle_optimizations(idle_work-&gt;dm-&gt;dc, true);
</span> 		mutex_unlock(&#38;idle_work-&gt;dm-&gt;dc_lock);
<span
class="del">-		fsleep(HPD_DETECTION_PERIOD_uS);
-		mutex_lock(&#38;idle_work-&gt;dm-&gt;dc_lock);
</span> 	}
<span
class="del">-	mutex_unlock(&#38;idle_work-&gt;dm-&gt;dc_lock);
</span> 	idle_work-&gt;dm-&gt;idle_workqueue-&gt;running = false;
 }
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c
index 659dd67be1ba..f5e1f2d1c5f2 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c
</span><span
class="hunk">@@ -1239,8 +1239,11 @@ void dm_helpers_enable_periodic_detection(struct dc_context *ctx, bool enable)
</span> {
 	struct amdgpu_device *adev = ctx-&gt;driver_context;
 
<span
class="del">-	if (adev-&gt;dm.idle_workqueue)
</span><span
class="add">+	if (adev-&gt;dm.idle_workqueue) {
</span> 		adev-&gt;dm.idle_workqueue-&gt;enable = enable;
<span
class="add">+		if (enable &#38;&#38; !adev-&gt;dm.idle_workqueue-&gt;running &#38;&#38; amdgpu_dm_is_headless(adev))
+			schedule_work(&#38;adev-&gt;dm.idle_workqueue-&gt;work);
+	}
</span> }
 
 void dm_helpers_dp_mst_update_branch_bandwidth(
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 31/39] drm/amd/display: Fix 1DLUT setting for NL SDR blending</title><updated>2024-06-20T16:19:43Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-32-alex.hung@amd.com/"/><id>urn:uuid:d7374a4f-53fd-d88c-1cf1-1d6b9bc51f00</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Relja Vojvodic &lt;relja.vojvodic@amd.com&gt;

[WHY]
Enabling NL SDR blending caused the 1D LUTs to be set/populated in two
different functions. This caused flickering as the LUT was set differently
by the two functions, one of which should only have been modifying the 1D
LUT if 3D LUT was enabled.

[HOW]
Added check to only modify the 1D LUT in populate_mcm if 3D LUT was
enabled.

Added blend_tf function update for non-main planes if the 3D LUT path
was taken.

Reviewed-by: Ilya Bakoulin &lt;ilya.bakoulin@amd.co&gt;
Cc: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
Cc: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Cc: stable@vger.kernel.org
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Relja Vojvodic &lt;relja.vojvodic@amd.com&gt;
---
 drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c | 4 ++--
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-32-alex.hung@amd.com/#related">changed</a>, 2 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
index 5306c8c170c5..b5a02a8fc9d8 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
</span><span
class="hunk">@@ -502,7 +502,7 @@ void dcn401_populate_mcm_luts(struct dc *dc,
</span> 	dcn401_get_mcm_lut_xable_from_pipe_ctx(dc, pipe_ctx, &#38;shaper_xable, &#38;lut3d_xable, &#38;lut1d_xable);
 
 	/* 1D LUT */
<span
class="del">-	if (mcm_luts.lut1d_func) {
</span><span
class="add">+	if (mcm_luts.lut1d_func &#38;&#38; lut3d_xable != MCM_LUT_DISABLE) {
</span> 		memset(&#38;m_lut_params, 0, sizeof(m_lut_params));
 		if (mcm_luts.lut1d_func-&gt;type == TF_TYPE_HWPWL)
 			m_lut_params.pwl = &#38;mcm_luts.lut1d_func-&gt;pwl;
<span
class="hunk">@@ -674,7 +674,7 @@ bool dcn401_set_mcm_luts(struct pipe_ctx *pipe_ctx,
</span> 	mpc-&gt;funcs-&gt;set_movable_cm_location(mpc, MPCC_MOVABLE_CM_LOCATION_BEFORE, mpcc_id);
 	pipe_ctx-&gt;plane_state-&gt;mcm_location = MPCC_MOVABLE_CM_LOCATION_BEFORE;
 	// 1D LUT
<span
class="del">-	if (!plane_state-&gt;mcm_lut1d_enable) {
</span><span
class="add">+	if (plane_state-&gt;mcm_shaper_3dlut_setting == DC_CM2_SHAPER_3DLUT_SETTING_BYPASS_ALL) {
</span> 		if (plane_state-&gt;blend_tf.type == TF_TYPE_HWPWL)
 			lut_params = &#38;plane_state-&gt;blend_tf.pwl;
 		else if (plane_state-&gt;blend_tf.type == TF_TYPE_DISTRIBUTED_POINTS) {
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 30/39] drm/amd/display: Adjust reg field for DSC wait for disconnect</title><updated>2024-06-20T16:19:30Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-31-alex.hung@amd.com/"/><id>urn:uuid:6a08c2f0-5c1a-4b24-7dd1-496019d85623</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Ryan Seto &lt;ryanseto@amd.com&gt;

[WHY]
DSC was waiting for the wrong field to disconnect cleanly.

[HOW]
Changed field the DSC disconnect was waiting on.

Reviewed-by: Wenjing Liu &lt;wenjing.liu@amd.com&gt;
Cc: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
Cc: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Cc: stable@vger.kernel.org
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Ryan Seto &lt;ryanseto@amd.com&gt;
---
 drivers/gpu/drm/amd/display/dc/dsc/dcn20/dcn20_dsc.h   | 4 +++-
 drivers/gpu/drm/amd/display/dc/dsc/dcn401/dcn401_dsc.c | 2 +-
 drivers/gpu/drm/amd/display/dc/dsc/dcn401/dcn401_dsc.h | 3 ++-
 3 files <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-31-alex.hung@amd.com/#related">changed</a>, 6 insertions(+), 3 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dcn20/dcn20_dsc.h b/drivers/gpu/drm/amd/display/dc/dsc/dcn20/dcn20_dsc.h
index a23308a785bc..1fb90b52b814 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dcn20/dcn20_dsc.h
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dcn20/dcn20_dsc.h
</span><span
class="hunk">@@ -454,7 +454,9 @@
</span> 	type DSCCIF_UPDATE_TAKEN_ACK; \
 	type DSCRM_DSC_FORWARD_EN; \
 	type DSCRM_DSC_OPP_PIPE_SOURCE; \
<span
class="del">-	type DSCRM_DSC_DOUBLE_BUFFER_REG_UPDATE_PENDING
</span><span
class="add">+	type DSCRM_DSC_DOUBLE_BUFFER_REG_UPDATE_PENDING; \
+	type DSCRM_DSC_FORWARD_EN_STATUS
+
</span> 
 struct dcn20_dsc_registers {
 	uint32_t DSC_TOP_CONTROL;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dcn401/dcn401_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dcn401/dcn401_dsc.c
index 52f23bb554af..6acb6699f146 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dcn401/dcn401_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dcn401/dcn401_dsc.c
</span><span
class="hunk">@@ -208,7 +208,7 @@ static void dsc401_wait_disconnect_pending_clear(struct display_stream_compresso
</span> {
 	struct dcn401_dsc *dsc401 = TO_DCN401_DSC(dsc);
 
<span
class="del">-	REG_WAIT(DSCRM_DSC_FORWARD_CONFIG, DSCRM_DSC_DOUBLE_BUFFER_REG_UPDATE_PENDING, 0, 2, 50000);
</span><span
class="add">+	REG_WAIT(DSCRM_DSC_FORWARD_CONFIG, DSCRM_DSC_FORWARD_EN_STATUS, 0, 2, 50000);
</span> }
 
 static void dsc401_disconnect(struct display_stream_compressor *dsc)
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dcn401/dcn401_dsc.h b/drivers/gpu/drm/amd/display/dc/dsc/dcn401/dcn401_dsc.h
index 2143e81ca22a..3c9fa8988974 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dcn401/dcn401_dsc.h
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dcn401/dcn401_dsc.h
</span><span
class="hunk">@@ -196,7 +196,8 @@
</span> 	DSC2_SF(DSCCIF0, DSCCIF_CONFIG0__BITS_PER_COMPONENT, mask_sh), \
 	DSC_SF(DSCCIF0_DSCCIF_CONFIG0, DOUBLE_BUFFER_REG_UPDATE_PENDING, mask_sh), \
 	DSC_SF(DSCRM0_DSCRM_DSC_FORWARD_CONFIG, DSCRM_DSC_FORWARD_EN, mask_sh), \
<span
class="del">-	DSC_SF(DSCRM0_DSCRM_DSC_FORWARD_CONFIG, DSCRM_DSC_OPP_PIPE_SOURCE, mask_sh)
</span><span
class="add">+	DSC_SF(DSCRM0_DSCRM_DSC_FORWARD_CONFIG, DSCRM_DSC_OPP_PIPE_SOURCE, mask_sh), \
+	DSC_SF(DSCRM0_DSCRM_DSC_FORWARD_CONFIG, DSCRM_DSC_FORWARD_EN_STATUS, mask_sh)
</span> 
 struct dcn401_dsc_registers {
 	uint32_t DSC_TOP_CONTROL;
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 29/39] drm/amd/display: Remove a redundant check in authenticated_dp</title><updated>2024-06-20T16:19:16Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-30-alex.hung@amd.com/"/><id>urn:uuid:e334fd85-7399-9526-a3cf-189136850ec7</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Wenjing Liu &lt;wenjing.liu@amd.com&gt;

[WHY]
mod_hdcp_execute_and_set returns (*status == MOD_HDCP_STATUS_SUCCESS).
When it return 0, it is guaranteed that status == MOD_HDCP_STATUS_SUCCESS
will be evaluated as false. Since now we are using goto out already, all 3
if (status == MOD_HDCP_STATUS_SUCCESS) clauses are guaranteed to enter.
Therefore we are removing the if statements due to redundancy.

Reviewed-by: Rodrigo Siqueira &lt;rodrigo.siqueira@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Wenjing Liu &lt;wenjing.liu@amd.com&gt;
---
 .../display/modules/hdcp/hdcp1_execution.c    | 27 +++++++++----------
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-30-alex.hung@amd.com/#related">changed</a>, 12 insertions(+), 15 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/modules/hdcp/hdcp1_execution.c b/drivers/gpu/drm/amd/display/modules/hdcp/hdcp1_execution.c
index d77836cef563..1e495e884484 100644
--- a/drivers/gpu/drm/amd/display/modules/hdcp/hdcp1_execution.c
+++ b/drivers/gpu/drm/amd/display/modules/hdcp/hdcp1_execution.c
</span><span
class="hunk">@@ -432,21 +432,18 @@ static enum mod_hdcp_status authenticated_dp(struct mod_hdcp *hdcp,
</span> 		goto out;
 	}
 
<span
class="del">-	if (status == MOD_HDCP_STATUS_SUCCESS)
-		if (!mod_hdcp_execute_and_set(mod_hdcp_read_bstatus,
-				&#38;input-&gt;bstatus_read, &#38;status,
-				hdcp, &#34;bstatus_read&#34;))
-			goto out;
-	if (status == MOD_HDCP_STATUS_SUCCESS)
-		if (!mod_hdcp_execute_and_set(check_link_integrity_dp,
-				&#38;input-&gt;link_integrity_check, &#38;status,
-				hdcp, &#34;link_integrity_check&#34;))
-			goto out;
-	if (status == MOD_HDCP_STATUS_SUCCESS)
-		if (!mod_hdcp_execute_and_set(check_no_reauthentication_request_dp,
-				&#38;input-&gt;reauth_request_check, &#38;status,
-				hdcp, &#34;reauth_request_check&#34;))
-			goto out;
</span><span
class="add">+	if (!mod_hdcp_execute_and_set(mod_hdcp_read_bstatus,
+			&#38;input-&gt;bstatus_read, &#38;status,
+			hdcp, &#34;bstatus_read&#34;))
+		goto out;
+	if (!mod_hdcp_execute_and_set(check_link_integrity_dp,
+			&#38;input-&gt;link_integrity_check, &#38;status,
+			hdcp, &#34;link_integrity_check&#34;))
+		goto out;
+	if (!mod_hdcp_execute_and_set(check_no_reauthentication_request_dp,
+			&#38;input-&gt;reauth_request_check, &#38;status,
+			hdcp, &#34;reauth_request_check&#34;))
+		goto out;
</span> out:
 	return status;
 }
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 28/39] drm/amd/display: Add HW cursor visual confirm</title><updated>2024-06-20T16:19:01Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-29-alex.hung@amd.com/"/><id>urn:uuid:d6ae407d-4bc8-a6f3-080c-bad258c6effd</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Ryan Seto &lt;ryanseto@amd.com&gt;

[WHY]
Added HW cursor visual confirm

[HOW]
Added visual confirm logic when programming cursor positions.
HW is programmed on cursor updates since cursor can change without flips.

Reviewed-by: Alvin Lee &lt;alvin.lee2@amd.com&gt;
Cc: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
Cc: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Cc: stable@vger.kernel.org
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Ryan Seto &lt;ryanseto@amd.com&gt;
---
 .../gpu/drm/amd/display/dc/core/dc_stream.c   | 29 +++++++++++++++++++
 drivers/gpu/drm/amd/display/dc/dc.h           |  1 +
 2 files <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-29-alex.hung@amd.com/#related">changed</a>, 30 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 9b24f448ce50..de0633f98158 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
</span><span
class="hunk">@@ -416,6 +416,35 @@ bool dc_stream_program_cursor_position(
</span> 		if (reset_idle_optimizations &#38;&#38; !dc-&gt;debug.disable_dmub_reallow_idle)
 			dc_allow_idle_optimizations(dc, true);
 
<span
class="add">+		/* apply/update visual confirm */
+		if (dc-&gt;debug.visual_confirm == VISUAL_CONFIRM_HW_CURSOR) {
+			/* update software state */
+			uint32_t color_value = MAX_TG_COLOR_VALUE;
+			int i;
+
+			for (i = 0; i &lt; dc-&gt;res_pool-&gt;pipe_count; i++) {
+				struct pipe_ctx *pipe_ctx = &#38;dc-&gt;current_state-&gt;res_ctx.pipe_ctx[i];
+
+				/* adjust visual confirm color for all pipes with current stream */
+				if (stream == pipe_ctx-&gt;stream) {
+					if (stream-&gt;cursor_position.enable) {
+						pipe_ctx-&gt;visual_confirm_color.color_r_cr = color_value;
+						pipe_ctx-&gt;visual_confirm_color.color_g_y = 0;
+						pipe_ctx-&gt;visual_confirm_color.color_b_cb = 0;
+					} else {
+						pipe_ctx-&gt;visual_confirm_color.color_r_cr = 0;
+						pipe_ctx-&gt;visual_confirm_color.color_g_y = 0;
+						pipe_ctx-&gt;visual_confirm_color.color_b_cb = color_value;
+					}
+
+					/* programming hardware */
+					if (pipe_ctx-&gt;plane_state)
+						dc-&gt;hwss.update_visual_confirm_color(dc, pipe_ctx,
+								pipe_ctx-&gt;plane_res.hubp-&gt;mpcc_id);
+				}
+			}
+		}
+
</span> 		return true;
 	}
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dc.h b/drivers/gpu/drm/amd/display/dc/dc.h
index e0334b573f2d..64241de70f15 100644
--- a/drivers/gpu/drm/amd/display/dc/dc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc.h
</span><span
class="hunk">@@ -476,6 +476,7 @@ enum visual_confirm {
</span> 	VISUAL_CONFIRM_SUBVP = 14,
 	VISUAL_CONFIRM_MCLK_SWITCH = 16,
 	VISUAL_CONFIRM_FAMS2 = 19,
<span
class="add">+	VISUAL_CONFIRM_HW_CURSOR = 20,
</span> };
 
 enum dc_psr_power_opts {
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 27/39] drm/amd/display: Fix cursor issues with ODMs and magnification</title><updated>2024-06-20T16:18:48Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-28-alex.hung@amd.com/"/><id>urn:uuid:77aa7a9e-8c71-28da-59b1-e05c833145aa</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Nevenko Stupar &lt;nevenko.stupar@amd.com&gt;

[WHY &#38; HOW]
Adjust hot spot positions between ODM slices when cursor
magnification is used.

Reviewed-by: Sridevi Arvindekar &lt;sridevi.arvindekar@amd.com&gt;
Cc: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
Cc: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Cc: stable@vger.kernel.org
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Nevenko Stupar &lt;nevenko.stupar@amd.com&gt;
---
 .../gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c    | 9 +++++++++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-28-alex.hung@amd.com/#related">changed</a>, 9 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
index 79a911e1a09a..5306c8c170c5 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
</span><span
class="hunk">@@ -1177,6 +1177,15 @@ void dcn401_set_cursor_position(struct pipe_ctx *pipe_ctx)
</span> 
 	if (x_pos &lt; 0) {
 		pos_cpy.x_hotspot -= x_pos;
<span
class="add">+		if ((odm_combine_on) &#38;&#38; (hubp-&gt;curs_attr.attribute_flags.bits.ENABLE_MAGNIFICATION)) {
+			if (hubp-&gt;curs_attr.width &lt;= 128) {
+				pos_cpy.x_hotspot /= 2;
+				pos_cpy.x_hotspot += 1;
+			} else {
+				pos_cpy.x_hotspot /= 2;
+				pos_cpy.x_hotspot += 2;
+			}
+		}
</span> 		x_pos = 0;
 	}
 
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 26/39] drm/amd/display: Wait for double buffer update on ODM changes</title><updated>2024-06-20T16:18:27Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-27-alex.hung@amd.com/"/><id>urn:uuid:6e71e977-2a69-8c50-15c1-41b140643a01</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Alvin Lee &lt;alvin.lee2@amd.com&gt;

[WHAT &#38; HOW]
We must wait for ODM double buffer updates to complete
before exiting the pipe update sequence or we may reduce
DISPCLK and hit some transient underflow (pixel rate is
reduced before the pipes have ODM enabled).

Reviewed-by: Samson Tam &lt;samson.tam@amd.com&gt;
Cc: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
Cc: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Cc: stable@vger.kernel.org
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Alvin Lee &lt;alvin.lee2@amd.com&gt;
---
 .../amd/display/dc/hwss/dcn20/dcn20_hwseq.c   | 23 +++++++++++++++++++
 .../amd/display/dc/inc/hw/timing_generator.h  |  1 +
 .../amd/display/dc/optc/dcn10/dcn10_optc.h    |  3 ++-
 .../amd/display/dc/optc/dcn32/dcn32_optc.c    | 13 +++++++++++
 .../amd/display/dc/optc/dcn32/dcn32_optc.h    |  2 ++
 .../amd/display/dc/optc/dcn401/dcn401_optc.c  |  1 +
 .../amd/display/dc/optc/dcn401/dcn401_optc.h  |  1 +
 7 files <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-27-alex.hung@amd.com/#related">changed</a>, 43 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn20/dcn20_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn20/dcn20_hwseq.c
index 4d359bb9b1ec..36797ed7ad8c 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn20/dcn20_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn20/dcn20_hwseq.c
</span><span
class="hunk">@@ -2227,6 +2227,29 @@ void dcn20_post_unlock_program_front_end(
</span> 		}
 	}
 
<span
class="add">+	for (i = 0; i &lt; dc-&gt;res_pool-&gt;pipe_count; i++) {
+		struct pipe_ctx *pipe = &#38;context-&gt;res_ctx.pipe_ctx[i];
+		struct pipe_ctx *old_pipe = &#38;dc-&gt;current_state-&gt;res_ctx.pipe_ctx[i];
+
+		/* When going from a smaller ODM slice count to larger, we must ensure double
+		 * buffer update completes before we return to ensure we don&#39;t reduce DISPCLK
+		 * before we&#39;ve transitioned to 2:1 or 4:1
+		 */
+		if (resource_is_pipe_type(old_pipe, OTG_MASTER) &#38;&#38; resource_is_pipe_type(pipe, OTG_MASTER) &#38;&#38;
+				resource_get_odm_slice_count(old_pipe) &lt; resource_get_odm_slice_count(pipe) &#38;&#38;
+				dc_state_get_pipe_subvp_type(context, pipe) != SUBVP_PHANTOM) {
+			int j = 0;
+			struct timing_generator *tg = pipe-&gt;stream_res.tg;
+
+
+			if (tg-&gt;funcs-&gt;get_double_buffer_pending) {
+				for (j = 0; j &lt; TIMEOUT_FOR_PIPE_ENABLE_US / polling_interval_us
+				&#38;&#38; tg-&gt;funcs-&gt;get_double_buffer_pending(tg); j++)
+					udelay(polling_interval_us);
+			}
+		}
+	}
+
</span> 	if (dc-&gt;res_pool-&gt;hubbub-&gt;funcs-&gt;force_pstate_change_control)
 		dc-&gt;res_pool-&gt;hubbub-&gt;funcs-&gt;force_pstate_change_control(
 				dc-&gt;res_pool-&gt;hubbub, false, false);
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/timing_generator.h b/drivers/gpu/drm/amd/display/dc/inc/hw/timing_generator.h
index cd4826f329c1..0f453452234c 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/timing_generator.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/timing_generator.h
</span><span
class="hunk">@@ -340,6 +340,7 @@ struct timing_generator_funcs {
</span> 	void (*wait_drr_doublebuffer_pending_clear)(struct timing_generator *tg);
 	void (*set_long_vtotal)(struct timing_generator *optc, const struct long_vtotal_params *params);
 	void (*wait_odm_doublebuffer_pending_clear)(struct timing_generator *tg);
<span
class="add">+	bool (*get_double_buffer_pending)(struct timing_generator *tg);
</span> };
 
 #endif
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/optc/dcn10/dcn10_optc.h b/drivers/gpu/drm/amd/display/dc/optc/dcn10/dcn10_optc.h
index e3e70c1db040..369a13244e5e 100644
--- a/drivers/gpu/drm/amd/display/dc/optc/dcn10/dcn10_optc.h
+++ b/drivers/gpu/drm/amd/display/dc/optc/dcn10/dcn10_optc.h
</span><span
class="hunk">@@ -562,7 +562,8 @@ struct dcn_optc_registers {
</span> 	type OTG_CRC_DATA_FORMAT;\
 	type OTG_V_TOTAL_LAST_USED_BY_DRR;\
 	type OTG_DRR_TIMING_DBUF_UPDATE_PENDING;\
<span
class="del">-	type OTG_H_TIMING_DIV_MODE_DB_UPDATE_PENDING;
</span><span
class="add">+	type OTG_H_TIMING_DIV_MODE_DB_UPDATE_PENDING;\
+	type OPTC_DOUBLE_BUFFER_PENDING;\
</span> 
 #define TG_REG_FIELD_LIST_DCN3_2(type) \
 	type OTG_H_TIMING_DIV_MODE_MANUAL;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/optc/dcn32/dcn32_optc.c b/drivers/gpu/drm/amd/display/dc/optc/dcn32/dcn32_optc.c
index 6c837409df42..00094f0e8470 100644
--- a/drivers/gpu/drm/amd/display/dc/optc/dcn32/dcn32_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/optc/dcn32/dcn32_optc.c
</span><span
class="hunk">@@ -297,6 +297,18 @@ static void optc32_set_drr(
</span> 	optc32_setup_manual_trigger(optc);
 }
 
<span
class="add">+bool optc32_get_double_buffer_pending(struct timing_generator *optc)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+	uint32_t update_pending = 0;
+
+	REG_GET(OPTC_INPUT_GLOBAL_CONTROL,
+			OPTC_DOUBLE_BUFFER_PENDING,
+			&#38;update_pending);
+
+	return (update_pending == 1);
+}
+
</span> static struct timing_generator_funcs dcn32_tg_funcs = {
 		.validate_timing = optc1_validate_timing,
 		.program_timing = optc1_program_timing,
<span
class="hunk">@@ -361,6 +373,7 @@ static struct timing_generator_funcs dcn32_tg_funcs = {
</span> 		.setup_manual_trigger = optc2_setup_manual_trigger,
 		.get_hw_timing = optc1_get_hw_timing,
 		.is_two_pixels_per_container = optc1_is_two_pixels_per_container,
<span
class="add">+		.get_double_buffer_pending = optc32_get_double_buffer_pending,
</span> };
 
 void dcn32_timing_generator_init(struct optc *optc1)
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/optc/dcn32/dcn32_optc.h b/drivers/gpu/drm/amd/display/dc/optc/dcn32/dcn32_optc.h
index 0c2c14695561..665d7c52f67c 100644
--- a/drivers/gpu/drm/amd/display/dc/optc/dcn32/dcn32_optc.h
+++ b/drivers/gpu/drm/amd/display/dc/optc/dcn32/dcn32_optc.h
</span><span
class="hunk">@@ -116,6 +116,7 @@
</span> 	SF(ODM0_OPTC_INPUT_CLOCK_CONTROL, OPTC_INPUT_CLK_GATE_DIS, mask_sh),\
 	SF(ODM0_OPTC_INPUT_GLOBAL_CONTROL, OPTC_UNDERFLOW_OCCURRED_STATUS, mask_sh),\
 	SF(ODM0_OPTC_INPUT_GLOBAL_CONTROL, OPTC_UNDERFLOW_CLEAR, mask_sh),\
<span
class="add">+	SF(ODM0_OPTC_INPUT_GLOBAL_CONTROL, OPTC_DOUBLE_BUFFER_PENDING, mask_sh),\
</span> 	SF(VTG0_CONTROL, VTG0_ENABLE, mask_sh),\
 	SF(VTG0_CONTROL, VTG0_FP2, mask_sh),\
 	SF(VTG0_CONTROL, VTG0_VCOUNT_INIT, mask_sh),\
<span
class="hunk">@@ -184,5 +185,6 @@ void optc32_get_odm_combine_segments(struct timing_generator *tg, int *odm_combi
</span> void optc32_set_odm_bypass(struct timing_generator *optc,
 		const struct dc_crtc_timing *dc_crtc_timing);
 void optc32_wait_odm_doublebuffer_pending_clear(struct timing_generator *tg);
<span
class="add">+bool optc32_get_double_buffer_pending(struct timing_generator *optc);
</span> 
 #endif /* __DC_OPTC_DCN32_H__ */
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/optc/dcn401/dcn401_optc.c b/drivers/gpu/drm/amd/display/dc/optc/dcn401/dcn401_optc.c
index fd1c8b45c40e..9f5c2efa7560 100644
--- a/drivers/gpu/drm/amd/display/dc/optc/dcn401/dcn401_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/optc/dcn401/dcn401_optc.c
</span><span
class="hunk">@@ -459,6 +459,7 @@ static struct timing_generator_funcs dcn401_tg_funcs = {
</span> 		.setup_manual_trigger = optc2_setup_manual_trigger,
 		.get_hw_timing = optc1_get_hw_timing,
 		.is_two_pixels_per_container = optc1_is_two_pixels_per_container,
<span
class="add">+		.get_double_buffer_pending = optc32_get_double_buffer_pending,
</span> };
 
 void dcn401_timing_generator_init(struct optc *optc1)
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/optc/dcn401/dcn401_optc.h b/drivers/gpu/drm/amd/display/dc/optc/dcn401/dcn401_optc.h
index 1671fdd5061c..3114ecef332a 100644
--- a/drivers/gpu/drm/amd/display/dc/optc/dcn401/dcn401_optc.h
+++ b/drivers/gpu/drm/amd/display/dc/optc/dcn401/dcn401_optc.h
</span><span
class="hunk">@@ -94,6 +94,7 @@
</span> 	SF(ODM0_OPTC_INPUT_CLOCK_CONTROL, OPTC_INPUT_CLK_ON, mask_sh),\
 	SF(ODM0_OPTC_INPUT_CLOCK_CONTROL, OPTC_INPUT_CLK_GATE_DIS, mask_sh),\
 	SF(ODM0_OPTC_INPUT_GLOBAL_CONTROL, OPTC_UNDERFLOW_OCCURRED_STATUS, mask_sh),\
<span
class="add">+	SF(ODM0_OPTC_INPUT_GLOBAL_CONTROL, OPTC_DOUBLE_BUFFER_PENDING, mask_sh),\
</span> 	SF(ODM0_OPTC_INPUT_GLOBAL_CONTROL, OPTC_UNDERFLOW_CLEAR, mask_sh),\
 	SF(VTG0_CONTROL, VTG0_ENABLE, mask_sh),\
 	SF(VTG0_CONTROL, VTG0_FP2, mask_sh),\
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 25/39] drm/amd/display: Reset DSC memory status</title><updated>2024-06-20T16:18:11Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-26-alex.hung@amd.com/"/><id>urn:uuid:2f32d125-43bd-9c3e-ff54-5f4927bd8053</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Duncan Ma &lt;duncan.ma@amd.com&gt;

[WHY]
When system exits idle state followed by enabling the display,
DSC memory may still be forced in a deep sleep or shutdown state.

Intermittent DSC corruption is seen when display is visible.

[HOW]
When DSC is enabled, reset dsc memory to force and disable status.

Reviewed-by: Nicholas Kazlauskas &lt;nicholas.kazlauskas@amd.com&gt;
Cc: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
Cc: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Cc: stable@vger.kernel.org
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Duncan Ma &lt;duncan.ma@amd.com&gt;
---
 .../drm/amd/display/dc/dsc/dcn20/dcn20_dsc.c  | 24 +++-----
 .../drm/amd/display/dc/dsc/dcn20/dcn20_dsc.h  |  9 +++
 .../drm/amd/display/dc/dsc/dcn35/dcn35_dsc.c  | 58 ++++++++++++++++++-
 3 files <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-26-alex.hung@amd.com/#related">changed</a>, 71 insertions(+), 20 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dcn20/dcn20_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dcn20/dcn20_dsc.c
index d6b2334d5364..75128fd34306 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dcn20/dcn20_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dcn20/dcn20_dsc.c
</span><span
class="hunk">@@ -32,16 +32,6 @@
</span> 
 static void dsc_write_to_registers(struct display_stream_compressor *dsc, const struct dsc_reg_values *reg_vals);
 
<span
class="del">-/* Object I/F functions */
-static void dsc2_read_state(struct display_stream_compressor *dsc, struct dcn_dsc_state *s);
-static bool dsc2_validate_stream(struct display_stream_compressor *dsc, const struct dsc_config *dsc_cfg);
-static void dsc2_set_config(struct display_stream_compressor *dsc, const struct dsc_config *dsc_cfg,
-		struct dsc_optc_config *dsc_optc_cfg);
-static void dsc2_enable(struct display_stream_compressor *dsc, int opp_pipe);
-static void dsc2_disable(struct display_stream_compressor *dsc);
-static void dsc2_disconnect(struct display_stream_compressor *dsc);
-static void dsc2_wait_disconnect_pending_clear(struct display_stream_compressor *dsc);
-
</span> static const struct dsc_funcs dcn20_dsc_funcs = {
 	.dsc_get_enc_caps = dsc2_get_enc_caps,
 	.dsc_read_state = dsc2_read_state,
<span
class="hunk">@@ -156,7 +146,7 @@ void dsc2_get_enc_caps(struct dsc_enc_caps *dsc_enc_caps, int pixel_clock_100Hz)
</span> /* this function read dsc related register fields to be logged later in dcn10_log_hw_state
  * into a dcn_dsc_state struct.
  */
<span
class="del">-static void dsc2_read_state(struct display_stream_compressor *dsc, struct dcn_dsc_state *s)
</span><span
class="add">+void dsc2_read_state(struct display_stream_compressor *dsc, struct dcn_dsc_state *s)
</span> {
 	struct dcn20_dsc *dsc20 = TO_DCN20_DSC(dsc);
 
<span
class="hunk">@@ -173,7 +163,7 @@ static void dsc2_read_state(struct display_stream_compressor *dsc, struct dcn_ds
</span> }
 
 
<span
class="del">-static bool dsc2_validate_stream(struct display_stream_compressor *dsc, const struct dsc_config *dsc_cfg)
</span><span
class="add">+bool dsc2_validate_stream(struct display_stream_compressor *dsc, const struct dsc_config *dsc_cfg)
</span> {
 	struct dsc_optc_config dsc_optc_cfg;
 	struct dcn20_dsc *dsc20 = TO_DCN20_DSC(dsc);
<span
class="hunk">@@ -196,7 +186,7 @@ void dsc_config_log(struct display_stream_compressor *dsc, const struct dsc_conf
</span> 	DC_LOG_DSC(&#34;\tcolor_depth %d&#34;, config-&gt;color_depth);
 }
 
<span
class="del">-static void dsc2_set_config(struct display_stream_compressor *dsc, const struct dsc_config *dsc_cfg,
</span><span
class="add">+void dsc2_set_config(struct display_stream_compressor *dsc, const struct dsc_config *dsc_cfg,
</span> 		struct dsc_optc_config *dsc_optc_cfg)
 {
 	bool is_config_ok;
<span
class="hunk">@@ -233,7 +223,7 @@ bool dsc2_get_packed_pps(struct display_stream_compressor *dsc, const struct dsc
</span> }
 
 
<span
class="del">-static void dsc2_enable(struct display_stream_compressor *dsc, int opp_pipe)
</span><span
class="add">+void dsc2_enable(struct display_stream_compressor *dsc, int opp_pipe)
</span> {
 	struct dcn20_dsc *dsc20 = TO_DCN20_DSC(dsc);
 	int dsc_clock_en;
<span
class="hunk">@@ -258,7 +248,7 @@ static void dsc2_enable(struct display_stream_compressor *dsc, int opp_pipe)
</span> }
 
 
<span
class="del">-static void dsc2_disable(struct display_stream_compressor *dsc)
</span><span
class="add">+void dsc2_disable(struct display_stream_compressor *dsc)
</span> {
 	struct dcn20_dsc *dsc20 = TO_DCN20_DSC(dsc);
 	int dsc_clock_en;
<span
class="hunk">@@ -277,14 +267,14 @@ static void dsc2_disable(struct display_stream_compressor *dsc)
</span> 		DSC_CLOCK_EN, 0);
 }
 
<span
class="del">-static void dsc2_wait_disconnect_pending_clear(struct display_stream_compressor *dsc)
</span><span
class="add">+void dsc2_wait_disconnect_pending_clear(struct display_stream_compressor *dsc)
</span> {
 	struct dcn20_dsc *dsc20 = TO_DCN20_DSC(dsc);
 
 	REG_WAIT(DSCRM_DSC_FORWARD_CONFIG, DSCRM_DSC_DOUBLE_BUFFER_REG_UPDATE_PENDING, 0, 2, 50000);
 }
 
<span
class="del">-static void dsc2_disconnect(struct display_stream_compressor *dsc)
</span><span
class="add">+void dsc2_disconnect(struct display_stream_compressor *dsc)
</span> {
 	struct dcn20_dsc *dsc20 = TO_DCN20_DSC(dsc);
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dcn20/dcn20_dsc.h b/drivers/gpu/drm/amd/display/dc/dsc/dcn20/dcn20_dsc.h
index a136b26c914c..a23308a785bc 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dcn20/dcn20_dsc.h
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dcn20/dcn20_dsc.h
</span><span
class="hunk">@@ -597,5 +597,14 @@ bool dsc2_get_packed_pps(struct display_stream_compressor *dsc,
</span> 		const struct dsc_config *dsc_cfg,
 		uint8_t *dsc_packed_pps);
 
<span
class="add">+void dsc2_read_state(struct display_stream_compressor *dsc, struct dcn_dsc_state *s);
+bool dsc2_validate_stream(struct display_stream_compressor *dsc, const struct dsc_config *dsc_cfg);
+void dsc2_set_config(struct display_stream_compressor *dsc, const struct dsc_config *dsc_cfg,
+		struct dsc_optc_config *dsc_optc_cfg);
+void dsc2_enable(struct display_stream_compressor *dsc, int opp_pipe);
+void dsc2_disable(struct display_stream_compressor *dsc);
+void dsc2_disconnect(struct display_stream_compressor *dsc);
+void dsc2_wait_disconnect_pending_clear(struct display_stream_compressor *dsc);
+
</span> #endif
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dcn35/dcn35_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dcn35/dcn35_dsc.c
index 71d2dff9986d..6f4f5a3c4861 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dcn35/dcn35_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dcn35/dcn35_dsc.c
</span><span
class="hunk">@@ -27,6 +27,20 @@
</span> #include &#34;dcn35_dsc.h&#34;
 #include &#34;reg_helper.h&#34;
 
<span
class="add">+static void dsc35_enable(struct display_stream_compressor *dsc, int opp_pipe);
+
+static const struct dsc_funcs dcn35_dsc_funcs = {
+	.dsc_get_enc_caps = dsc2_get_enc_caps,
+	.dsc_read_state = dsc2_read_state,
+	.dsc_validate_stream = dsc2_validate_stream,
+	.dsc_set_config = dsc2_set_config,
+	.dsc_get_packed_pps = dsc2_get_packed_pps,
+	.dsc_enable = dsc35_enable,
+	.dsc_disable = dsc2_disable,
+	.dsc_disconnect = dsc2_disconnect,
+	.dsc_wait_disconnect_pending_clear = dsc2_wait_disconnect_pending_clear,
+};
+
</span> /* Macro definitios for REG_SET macros*/
 #define CTX \
 	dsc20-&gt;base.ctx
<span
class="hunk">@@ -49,9 +63,47 @@ void dsc35_construct(struct dcn20_dsc *dsc,
</span> 		const struct dcn35_dsc_shift *dsc_shift,
 		const struct dcn35_dsc_mask *dsc_mask)
 {
<span
class="del">-	dsc2_construct(dsc, ctx, inst, dsc_regs,
-		(const struct dcn20_dsc_shift *)(dsc_shift),
-		(const struct dcn20_dsc_mask *)(dsc_mask));
</span><span
class="add">+	dsc-&gt;base.ctx = ctx;
+	dsc-&gt;base.inst = inst;
+	dsc-&gt;base.funcs = &#38;dcn35_dsc_funcs;
+
+	dsc-&gt;dsc_regs = dsc_regs;
+	dsc-&gt;dsc_shift = (const struct dcn20_dsc_shift *)(dsc_shift);
+	dsc-&gt;dsc_mask = (const struct dcn20_dsc_mask *)(dsc_mask);
+
+	dsc-&gt;max_image_width = 5184;
+}
+
+static void dsc35_enable(struct display_stream_compressor *dsc, int opp_pipe)
+{
+	struct dcn20_dsc *dsc20 = TO_DCN20_DSC(dsc);
+	int dsc_clock_en;
+	int dsc_fw_config;
+	int enabled_opp_pipe;
+
+	DC_LOG_DSC(&#34;enable DSC %d at opp pipe %d&#34;, dsc-&gt;inst, opp_pipe);
+
+	// TODO: After an idle exit, the HW default values for power control
+	// are changed intermittently due to unknown reasons. There are cases
+	// when dscc memory are still in shutdown state during enablement.
+	// Reset power control to hw default values.
+	REG_UPDATE_2(DSCC_MEM_POWER_CONTROL,
+		DSCC_MEM_PWR_FORCE, 0,
+		DSCC_MEM_PWR_DIS, 0);
+
+	REG_GET(DSC_TOP_CONTROL, DSC_CLOCK_EN, &#38;dsc_clock_en);
+	REG_GET_2(DSCRM_DSC_FORWARD_CONFIG, DSCRM_DSC_FORWARD_EN, &#38;dsc_fw_config, DSCRM_DSC_OPP_PIPE_SOURCE, &#38;enabled_opp_pipe);
+	if ((dsc_clock_en || dsc_fw_config) &#38;&#38; enabled_opp_pipe != opp_pipe) {
+		DC_LOG_DSC(&#34;ERROR: DSC %d at opp pipe %d already enabled!&#34;, dsc-&gt;inst, enabled_opp_pipe);
+		ASSERT(0);
+	}
+
+	REG_UPDATE(DSC_TOP_CONTROL,
+		DSC_CLOCK_EN, 1);
+
+	REG_UPDATE_2(DSCRM_DSC_FORWARD_CONFIG,
+		DSCRM_DSC_FORWARD_EN, 1,
+		DSCRM_DSC_OPP_PIPE_SOURCE, opp_pipe);
</span> }
 
 void dsc35_set_fgcg(struct dcn20_dsc *dsc20, bool enable)
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 24/39] drm/amd/display: Program CURSOR_DST_X_OFFSET in viewport space</title><updated>2024-06-20T16:17:57Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-25-alex.hung@amd.com/"/><id>urn:uuid:68a00aa2-9dab-6586-cb2b-4180d5e15cc6</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Alvin Lee &lt;alvin.lee2@amd.com&gt;

[WHAT &#38; HOW]
According to register specifications, the CURSOR_DST_X_OFFSET
is relative to the start of the data viewport, not RECOUT space.
In this case we must transform the cursor coordinates passed to
hubp401_cursor_set_position into viewport space to program this
register. This fixes an underflow issue that occurs in scaled
mode with low refresh rate.

Reviewed-by: Nevenko Stupar &lt;nevenko.stupar@amd.com&gt;
Cc: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
Cc: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Cc: stable@vger.kernel.org
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Alvin Lee &lt;alvin.lee2@amd.com&gt;
---
 .../gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.c | 12 ++++++++++--
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-25-alex.hung@amd.com/#related">changed</a>, 10 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.c b/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.c
index a893160ae775..3f9ca9b40949 100644
--- a/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.c
+++ b/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.c
</span><span
class="hunk">@@ -656,7 +656,9 @@ void hubp401_cursor_set_position(
</span> 	int y_pos = pos-&gt;y - param-&gt;recout.y;
 	int rec_x_offset = x_pos - pos-&gt;x_hotspot;
 	int rec_y_offset = y_pos - pos-&gt;y_hotspot;
<span
class="del">-	uint32_t dst_x_offset;
</span><span
class="add">+	int dst_x_offset;
+	int x_pos_viewport = x_pos * param-&gt;viewport.width / param-&gt;recout.width;
+	int x_hot_viewport = pos-&gt;x_hotspot * param-&gt;viewport.width / param-&gt;recout.width;
</span> 	uint32_t cur_en = pos-&gt;enable ? 1 : 0;
 
 	hubp-&gt;curs_pos = *pos;
<span
class="hunk">@@ -668,7 +670,13 @@ void hubp401_cursor_set_position(
</span> 	if (hubp-&gt;curs_attr.address.quad_part == 0)
 		return;
 
<span
class="del">-	dst_x_offset = (rec_x_offset &gt;= 0) ? rec_x_offset : 0;
</span><span
class="add">+	/* Translate the x position of the cursor from rect
+	 * space into viewport space. CURSOR_DST_X_OFFSET
+	 * is the offset relative to viewport start position.
+	 */
+	dst_x_offset = x_pos_viewport - x_hot_viewport *
+			(1 + hubp-&gt;curs_attr.attribute_flags.bits.ENABLE_MAGNIFICATION);
+	dst_x_offset = (dst_x_offset &gt;= 0) ? dst_x_offset : 0;
</span> 	dst_x_offset *= param-&gt;ref_clk_khz;
 	dst_x_offset /= param-&gt;pixel_clk_khz;
 
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 23/39] drm/amd/display: Add null checks before accessing struct elements</title><updated>2024-06-20T16:17:45Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-24-alex.hung@amd.com/"/><id>urn:uuid:926d864f-e146-2f2c-013f-1c2391a82f97</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHAT]
1. is_pwrseq0 needs to check link before accessing link-&gt;link_index.
2. context is checked before accessing its bw_ctx.dml2
3. clk_mgr_base-&gt;bw_params is checked before clk_table.num_entries_per_cl

This fixes 4 REVERSE_INULL issues reported by Coverity.

Reviewed-by: Rodrigo Siqueira &lt;rodrigo.siqueira@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Alex Hung &lt;alex.hung@amd.com&gt;
---
 .../drm/amd/display/dc/clk_mgr/dcn32/dcn32_clk_mgr.c   | 10 ++++++----
 .../drm/amd/display/dc/clk_mgr/dcn401/dcn401_clk_mgr.c | 10 ++++++----
 drivers/gpu/drm/amd/display/dc/dml/dcn20/dcn20_fpu.c   |  2 +-
 drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c     |  4 +++-
 4 files <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-24-alex.hung@amd.com/#related">changed</a>, 16 insertions(+), 10 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn32/dcn32_clk_mgr.c b/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn32/dcn32_clk_mgr.c
index 06f0c41ad6f1..3b10b24f5e23 100644
--- a/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn32/dcn32_clk_mgr.c
+++ b/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn32/dcn32_clk_mgr.c
</span><span
class="hunk">@@ -163,9 +163,14 @@ void dcn32_init_clocks(struct clk_mgr *clk_mgr_base)
</span> {
 	struct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);
 	unsigned int num_levels;
<span
class="del">-	struct clk_limit_num_entries *num_entries_per_clk = &#38;clk_mgr_base-&gt;bw_params-&gt;clk_table.num_entries_per_clk;
</span><span
class="add">+	struct clk_limit_num_entries *num_entries_per_clk;
</span> 	unsigned int i;
 
<span
class="add">+	if (!clk_mgr_base-&gt;bw_params)
+		return;
+
+	num_entries_per_clk = &#38;clk_mgr_base-&gt;bw_params-&gt;clk_table.num_entries_per_clk;
+
</span> 	memset(&#38;(clk_mgr_base-&gt;clks), 0, sizeof(struct dc_clocks));
 	clk_mgr_base-&gt;clks.p_state_change_support = true;
 	clk_mgr_base-&gt;clks.prev_p_state_change_support = true;
<span
class="hunk">@@ -173,9 +178,6 @@ void dcn32_init_clocks(struct clk_mgr *clk_mgr_base)
</span> 	clk_mgr-&gt;smu_present = false;
 	clk_mgr-&gt;dpm_present = false;
 
<span
class="del">-	if (!clk_mgr_base-&gt;bw_params)
-		return;
-
</span> 	if (!clk_mgr_base-&gt;force_smu_not_present &#38;&#38; dcn30_smu_get_smu_version(clk_mgr, &#38;clk_mgr-&gt;smu_ver))
 		clk_mgr-&gt;smu_present = true;
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn401/dcn401_clk_mgr.c b/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn401/dcn401_clk_mgr.c
index 70f06a7c882e..606b2411eee9 100644
--- a/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn401/dcn401_clk_mgr.c
+++ b/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn401/dcn401_clk_mgr.c
</span><span
class="hunk">@@ -207,9 +207,14 @@ static void dcn401_build_wm_range_table(struct clk_mgr *clk_mgr)
</span> void dcn401_init_clocks(struct clk_mgr *clk_mgr_base)
 {
 	struct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);
<span
class="del">-	struct clk_limit_num_entries *num_entries_per_clk = &#38;clk_mgr_base-&gt;bw_params-&gt;clk_table.num_entries_per_clk;
</span><span
class="add">+	struct clk_limit_num_entries *num_entries_per_clk;
</span> 	unsigned int i;
 
<span
class="add">+	if (!clk_mgr_base-&gt;bw_params)
+		return;
+
+	num_entries_per_clk = &#38;clk_mgr_base-&gt;bw_params-&gt;clk_table.num_entries_per_clk;
+
</span> 	memset(&#38;(clk_mgr_base-&gt;clks), 0, sizeof(struct dc_clocks));
 	clk_mgr_base-&gt;clks.p_state_change_support = true;
 	clk_mgr_base-&gt;clks.prev_p_state_change_support = true;
<span
class="hunk">@@ -217,9 +222,6 @@ void dcn401_init_clocks(struct clk_mgr *clk_mgr_base)
</span> 	clk_mgr-&gt;smu_present = false;
 	clk_mgr-&gt;dpm_present = false;
 
<span
class="del">-	if (!clk_mgr_base-&gt;bw_params)
-		return;
-
</span> 	if (!clk_mgr_base-&gt;force_smu_not_present &#38;&#38; dcn30_smu_get_smu_version(clk_mgr, &#38;clk_mgr-&gt;smu_ver))
 		clk_mgr-&gt;smu_present = true;
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml/dcn20/dcn20_fpu.c b/drivers/gpu/drm/amd/display/dc/dml/dcn20/dcn20_fpu.c
index 54dd7e164635..8a8efe408a9d 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/dcn20/dcn20_fpu.c
+++ b/drivers/gpu/drm/amd/display/dc/dml/dcn20/dcn20_fpu.c
</span><span
class="hunk">@@ -1084,7 +1084,7 @@ static enum dcn_zstate_support_state  decide_zstate_support(struct dc *dc, struc
</span> 		struct dc_stream_status *stream_status = &#38;context-&gt;stream_status[0];
 		int minmum_z8_residency = dc-&gt;debug.minimum_z8_residency_time &gt; 0 ? dc-&gt;debug.minimum_z8_residency_time : 1000;
 		bool allow_z8 = context-&gt;bw_ctx.dml.vba.StutterPeriod &gt; (double)minmum_z8_residency;
<span
class="del">-		bool is_pwrseq0 = link-&gt;link_index == 0;
</span><span
class="add">+		bool is_pwrseq0 = (link &#38;&#38; link-&gt;link_index == 0);
</span> 		bool is_psr = (link &#38;&#38; (link-&gt;psr_settings.psr_version == DC_PSR_VERSION_1 ||
 						link-&gt;psr_settings.psr_version == DC_PSR_VERSION_SU_1) &#38;&#38; !link-&gt;panel_config.psr.disable_psr);
 		bool is_replay = link &#38;&#38; link-&gt;replay_settings.replay_feature_enabled;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c
index f4038ac2e476..90bb6e718301 100644
--- a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c
+++ b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c
</span><span
class="hunk">@@ -687,12 +687,14 @@ static bool dml2_validate_and_build_resource(const struct dc *in_dc, struct dc_s
</span> 
 static bool dml2_validate_only(struct dc_state *context)
 {
<span
class="del">-	struct dml2_context *dml2 = context-&gt;bw_ctx.dml2;
</span><span
class="add">+	struct dml2_context *dml2;
</span> 	unsigned int result = 0;
 
 	if (!context || context-&gt;stream_count == 0)
 		return true;
 
<span
class="add">+	dml2 = context-&gt;bw_ctx.dml2;
+
</span> 	/* Zero out before each call before proceeding */
 	memset(&#38;dml2-&gt;v20.scratch, 0, sizeof(struct dml2_wrapper_scratch));
 	memset(&#38;dml2-&gt;v20.dml_core_ctx.policy, 0, sizeof(struct dml_mode_eval_policy_st));
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 22/39] drm/amd/display: Fix reduced resolution and refresh rate</title><updated>2024-06-20T16:17:30Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-23-alex.hung@amd.com/"/><id>urn:uuid:fd1771f9-c103-d1a9-9dc8-7d95f6ce1b62</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Daniel Sa &lt;daniel.sa@amd.com&gt;

[WHY]
Some monitors are forced to a lower resolution and refresh rate after
system restarts.

[HOW]
Some monitors may give invalid LTTPR information when queried such as
indicating they have one DP lane instead of 4. If given an invalid DPCD
version, skip over getting lttpr link rate and lane counts.

Reviewed-by: Wenjing Liu &lt;wenjing.liu@amd.com&gt;
Cc: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
Cc: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Cc: stable@vger.kernel.org
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Daniel Sa &lt;daniel.sa@amd.com&gt;
---
 .../dc/link/protocols/link_dp_capability.c    | 21 ++++++++++---------
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-23-alex.hung@amd.com/#related">changed</a>, 11 insertions(+), 10 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_capability.c b/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_capability.c
index f1cac74dd7f7..46bb7a855bc2 100644
--- a/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_capability.c
+++ b/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_capability.c
</span><span
class="hunk">@@ -409,9 +409,6 @@ static enum dc_link_rate get_lttpr_max_link_rate(struct dc_link *link)
</span> 	case LINK_RATE_HIGH3:
 		lttpr_max_link_rate = link-&gt;dpcd_caps.lttpr_caps.max_link_rate;
 		break;
<span
class="del">-	default:
-		// Assume all LTTPRs support up to HBR3 to improve misbehaving sink interop
-		lttpr_max_link_rate = LINK_RATE_HIGH3;
</span> 	}
 
 	if (link-&gt;dpcd_caps.lttpr_caps.supported_128b_132b_rates.bits.UHBR20)
<span
class="hunk">@@ -2137,15 +2134,19 @@ struct dc_link_settings dp_get_max_link_cap(struct dc_link *link)
</span> 	 * notes: repeaters do not snoop in the DPRX Capabilities addresses (3.6.3).
 	 */
 	if (dp_is_lttpr_present(link)) {
<span
class="del">-		if (link-&gt;dpcd_caps.lttpr_caps.max_lane_count &lt; max_link_cap.lane_count)
-			max_link_cap.lane_count = link-&gt;dpcd_caps.lttpr_caps.max_lane_count;
-		lttpr_max_link_rate = get_lttpr_max_link_rate(link);
</span> 
<span
class="del">-		if (lttpr_max_link_rate &lt; max_link_cap.link_rate)
-			max_link_cap.link_rate = lttpr_max_link_rate;
</span><span
class="add">+		/* Some LTTPR devices do not report valid DPCD revisions, if so, do not take it&#39;s link cap into consideration. */
+		if (link-&gt;dpcd_caps.lttpr_caps.revision.raw &gt;= DPCD_REV_14) {
+			if (link-&gt;dpcd_caps.lttpr_caps.max_lane_count &lt; max_link_cap.lane_count)
+				max_link_cap.lane_count = link-&gt;dpcd_caps.lttpr_caps.max_lane_count;
+			lttpr_max_link_rate = get_lttpr_max_link_rate(link);
</span> 
<span
class="del">-		if (!link-&gt;dpcd_caps.lttpr_caps.supported_128b_132b_rates.bits.UHBR13_5)
-			is_uhbr13_5_supported = false;
</span><span
class="add">+			if (lttpr_max_link_rate &lt; max_link_cap.link_rate)
+				max_link_cap.link_rate = lttpr_max_link_rate;
+
+			if (!link-&gt;dpcd_caps.lttpr_caps.supported_128b_132b_rates.bits.UHBR13_5)
+				is_uhbr13_5_supported = false;
+		}
</span> 
 		DC_LOG_HW_LINK_TRAINING(&#34;%s\n Training with LTTPR,  max_lane count %d max_link rate %d \n&#34;,
 						__func__,
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 21/39] drm/amd/display: Make DML2.1 P-State method force per stream</title><updated>2024-06-20T16:17:17Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-22-alex.hung@amd.com/"/><id>urn:uuid:ee292633-0df9-b645-db1e-ec0229a4fddb</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Dillon Varone &lt;dillon.varone@amd.com&gt;

[WHY &#38; HOW]
Currently the force only works for a single display, make it so it can
be forced per stream.

Reviewed-by: Alvin Lee &lt;alvin.lee2@amd.com&gt;
Cc: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
Cc: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Cc: stable@vger.kernel.org
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Dillon Varone &lt;dillon.varone@amd.com&gt;
---
 drivers/gpu/drm/amd/display/dc/dc.h                            | 2 +-
 .../drm/amd/display/dc/dml2/dml21/dml21_translation_helper.c   | 2 +-
 drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c      | 3 ++-
 drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.h             | 2 +-
 4 files <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-22-alex.hung@amd.com/#related">changed</a>, 5 insertions(+), 4 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dc.h b/drivers/gpu/drm/amd/display/dc/dc.h
index d0d1af451b64..e0334b573f2d 100644
--- a/drivers/gpu/drm/amd/display/dc/dc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc.h
</span><span
class="hunk">@@ -1038,7 +1038,7 @@ struct dc_debug_options {
</span> 	bool force_chroma_subsampling_1tap;
 	bool disable_422_left_edge_pixel;
 	bool dml21_force_pstate_method;
<span
class="del">-	uint32_t dml21_force_pstate_method_value;
</span><span
class="add">+	uint32_t dml21_force_pstate_method_values[MAX_PIPES];
</span> 	uint32_t dml21_disable_pstate_method_mask;
 	union dmub_fams2_global_feature_config fams2_config;
 	bool enable_legacy_clock_update;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_translation_helper.c b/drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_translation_helper.c
index d5ead0205053..06387b8b0aee 100644
--- a/drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_translation_helper.c
+++ b/drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_translation_helper.c
</span><span
class="hunk">@@ -1000,7 +1000,7 @@ bool dml21_map_dc_state_into_dml_display_cfg(const struct dc *in_dc, struct dc_s
</span> 				/* apply forced pstate policy */
 				if (dml_ctx-&gt;config.pmo.force_pstate_method_enable) {
 					dml_dispcfg-&gt;plane_descriptors[disp_cfg_plane_location].overrides.uclk_pstate_change_strategy =
<span
class="del">-							dml21_force_pstate_method_to_uclk_state_change_strategy(dml_ctx-&gt;config.pmo.force_pstate_method_value);
</span><span
class="add">+							dml21_force_pstate_method_to_uclk_state_change_strategy(dml_ctx-&gt;config.pmo.force_pstate_method_values[stream_index]);
</span> 				}
 			}
 		}
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c b/drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c
index 9c28304568d2..c310354cd5fc 100644
--- a/drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c
+++ b/drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c
</span><span
class="hunk">@@ -47,7 +47,8 @@ static void dml21_apply_debug_options(const struct dc *in_dc, struct dml2_contex
</span> 	/* UCLK P-State options */
 	if (in_dc-&gt;debug.dml21_force_pstate_method) {
 		dml_ctx-&gt;config.pmo.force_pstate_method_enable = true;
<span
class="del">-		dml_ctx-&gt;config.pmo.force_pstate_method_value = in_dc-&gt;debug.dml21_force_pstate_method_value;
</span><span
class="add">+		for (int i = 0; i &lt; MAX_PIPES; i++)
+			dml_ctx-&gt;config.pmo.force_pstate_method_values[i] = in_dc-&gt;debug.dml21_force_pstate_method_values[i];
</span> 	} else {
 		dml_ctx-&gt;config.pmo.force_pstate_method_enable = false;
 	}
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.h b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.h
index 79bf2d757804..1e891a3297c2 100644
--- a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.h
+++ b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.h
</span><span
class="hunk">@@ -230,7 +230,7 @@ struct dml2_configuration_options {
</span> 	struct socbb_ip_params_external *external_socbb_ip_params;
 	struct {
 		bool force_pstate_method_enable;
<span
class="del">-		enum dml2_force_pstate_methods force_pstate_method_value;
</span><span
class="add">+		enum dml2_force_pstate_methods force_pstate_method_values[MAX_PIPES];
</span> 	} pmo;
 	bool map_dc_pipes_with_callbacks;
 
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 20/39] drm/amd/display: Add workaround to restrict max frac urgent for DPM0</title><updated>2024-06-20T16:16:58Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-21-alex.hung@amd.com/"/><id>urn:uuid:cea32db8-77c9-210f-8a86-031b52d84fca</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Sung-huai Wang &lt;danny.wang@amd.com&gt;

[WHY]
Underflow occurs on some platforms when urgent BW is close to
the maximum in DPM0.

[HOW]
It does not occur at DPM1, so as a workaround restrict the maximum
amount and increase the lowest state index for clock states until
we&#39;re out of DPM0.
Adds DML2 config options to specify this pe platform as required.

Reviewed-by: Nicholas Kazlauskas &lt;nicholas.kazlauskas@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Sung-huai Wang &lt;danny.wang@amd.com&gt;
---
 .../gpu/drm/amd/display/dc/dml2/dml2_wrapper.c    | 15 +++++++++++++++
 .../gpu/drm/amd/display/dc/dml2/dml2_wrapper.h    |  2 ++
 .../display/dc/resource/dcn35/dcn35_resource.c    |  3 ++-
 3 files <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-21-alex.hung@amd.com/#related">changed</a>, 19 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c
index f6310408dbba..f4038ac2e476 100644
--- a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c
+++ b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c
</span><span
class="hunk">@@ -628,6 +628,21 @@ static bool dml2_validate_and_build_resource(const struct dc *in_dc, struct dc_s
</span> 
 	if (result) {
 		unsigned int lowest_state_idx = s-&gt;mode_support_params.out_lowest_state_idx;
<span
class="add">+		double min_fclk_mhz_for_urgent_workaround = (double)dml2-&gt;config.min_fclk_for_urgent_workaround_khz / 1000.0;
+		double max_frac_urgent = (double)dml2-&gt;config.max_frac_urgent_for_min_fclk_x1000 / 1000.0;
+
+		if (min_fclk_mhz_for_urgent_workaround &gt; 0.0 &#38;&#38; max_frac_urgent &gt; 0.0 &#38;&#38;
+		    (dml2-&gt;v20.dml_core_ctx.mp.FractionOfUrgentBandwidth &gt; max_frac_urgent ||
+		     dml2-&gt;v20.dml_core_ctx.mp.FractionOfUrgentBandwidthImmediateFlip &gt; max_frac_urgent)) {
+			unsigned int forced_lowest_state_idx = lowest_state_idx;
+
+			while (forced_lowest_state_idx &lt; dml2-&gt;v20.dml_core_ctx.states.num_states &#38;&#38;
+			       dml2-&gt;v20.dml_core_ctx.states.state_array[forced_lowest_state_idx].fabricclk_mhz &lt;= min_fclk_mhz_for_urgent_workaround) {
+				forced_lowest_state_idx += 1;
+			}
+			lowest_state_idx = forced_lowest_state_idx;
+		}
+
</span> 		out_clks.dispclk_khz = (unsigned int)dml2-&gt;v20.dml_core_ctx.mp.Dispclk_calculated * 1000;
 		out_clks.p_state_supported = s-&gt;mode_support_info.DRAMClockChangeSupport[0] != dml_dram_clock_change_unsupported;
 		if (in_dc-&gt;config.use_default_clock_table &#38;&#38;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.h b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.h
index 20b3970c0857..79bf2d757804 100644
--- a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.h
+++ b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.h
</span><span
class="hunk">@@ -237,6 +237,8 @@ struct dml2_configuration_options {
</span> 	bool use_clock_dc_limits;
 	bool gpuvm_enable;
 	struct dml2_soc_bb *bb_from_dmub;
<span
class="add">+	int max_frac_urgent_for_min_fclk_x1000;
+	int min_fclk_for_urgent_workaround_khz;
</span> };
 
 /*
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/resource/dcn35/dcn35_resource.c b/drivers/gpu/drm/amd/display/dc/resource/dcn35/dcn35_resource.c
index 67ab8c1962ff..1ce0f9ecff9c 100644
--- a/drivers/gpu/drm/amd/display/dc/resource/dcn35/dcn35_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/resource/dcn35/dcn35_resource.c
</span><span
class="hunk">@@ -2152,8 +2152,9 @@ static bool dcn35_resource_construct(
</span> 	dc-&gt;dml2_options.callbacks.can_support_mclk_switch_using_fw_based_vblank_stretch = &#38;dcn30_can_support_mclk_switch_using_fw_based_vblank_stretch;
 
 	dc-&gt;dml2_options.max_segments_per_hubp = 24;
<span
class="del">-
</span> 	dc-&gt;dml2_options.det_segment_size = DCN3_2_DET_SEG_SIZE;/*todo*/
<span
class="add">+	dc-&gt;dml2_options.max_frac_urgent_for_min_fclk_x1000 = 900;
+	dc-&gt;dml2_options.min_fclk_for_urgent_workaround_khz = 400 * 1000;
</span> 
 	if (dc-&gt;config.sdpif_request_limit_words_per_umc == 0)
 		dc-&gt;config.sdpif_request_limit_words_per_umc = 16;/*todo*/
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 19/39] drm/amd/display: Call dpmm when checking mode support</title><updated>2024-06-20T16:16:43Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-20-alex.hung@amd.com/"/><id>urn:uuid:2ca41a04-7c67-ee13-28ae-28b0314ee6e5</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: George Shen &lt;george.shen@amd.com&gt;

[WHY]
In check_mode_supported, we should validate that the required clocks
can be successfully mapped to DPM levels.

This ensures we only apply dynamic ODM optimizations to modes that
are supported without dynamic ODM optimizations to begin with.

[HOW]
Call dpmm to check that the display config can successfully be
mapped to a DPM level.

Reviewed-by: Chaitanya Dhere &lt;chaitanya.dhere@amd.com&gt;
Cc: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
Cc: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Cc: stable@vger.kernel.org
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: George Shen &lt;george.shen@amd.com&gt;
---
 .../amd/display/dc/dml2/dml21/dml21_wrapper.c   |  1 +
 .../dc/dml2/dml21/src/dml2_top/dml_top.c        | 17 +++++++++++++++++
 .../dml21/src/inc/dml2_internal_shared_types.h  |  1 +
 3 files <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-20-alex.hung@amd.com/#related">changed</a>, 19 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c b/drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c
index b442e1f9f204..9c28304568d2 100644
--- a/drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c
+++ b/drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c
</span><span
class="hunk">@@ -257,6 +257,7 @@ static bool dml21_check_mode_support(const struct dc *in_dc, struct dc_state *co
</span> 
 	mode_support-&gt;dml2_instance = dml_init-&gt;dml2_instance;
 	dml21_map_dc_state_into_dml_display_cfg(in_dc, context, dml_ctx);
<span
class="add">+	dml_ctx-&gt;v21.mode_programming.dml2_instance-&gt;scratch.build_mode_programming_locals.mode_programming_params.programming = dml_ctx-&gt;v21.mode_programming.programming;
</span> 	is_supported = dml2_check_mode_supported(mode_support);
 	if (!is_supported)
 		return false;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml_top.c b/drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml_top.c
index 6f334fdc6eb8..2fb3e2f45e07 100644
--- a/drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml_top.c
+++ b/drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml_top.c
</span><span
class="hunk">@@ -96,10 +96,15 @@ bool dml2_check_mode_supported(struct dml2_check_mode_supported_in_out *in_out)
</span> {
 	struct dml2_instance *dml = (struct dml2_instance *)in_out-&gt;dml2_instance;
 	struct dml2_check_mode_supported_locals *l = &#38;dml-&gt;scratch.check_mode_supported_locals;
<span
class="add">+	/* Borrow the build_mode_programming_locals programming struct for DPMM call. */
+	struct dml2_display_cfg_programming *dpmm_programming = dml-&gt;scratch.build_mode_programming_locals.mode_programming_params.programming;
</span> 
 	bool result = false;
 	bool mcache_success = false;
 
<span
class="add">+	if (dpmm_programming)
+		memset(dpmm_programming, 0, sizeof(struct dml2_display_cfg_programming));
+
</span> 	setup_unoptimized_display_config_with_meta(dml, &#38;l-&gt;base_display_config_with_meta, in_out-&gt;display_config);
 
 	l-&gt;mode_support_params.instance = &#38;dml-&gt;core_instance;
<span
class="hunk">@@ -122,6 +127,18 @@ bool dml2_check_mode_supported(struct dml2_check_mode_supported_in_out *in_out)
</span> 		mcache_success = dml2_top_optimization_perform_optimization_phase(&#38;l-&gt;optimization_phase_locals, &#38;mcache_phase);
 	}
 
<span
class="add">+	/*
+	 * Call DPMM to map all requirements to minimum clock state
+	 */
+	if (result &#38;&#38; dpmm_programming) {
+		l-&gt;dppm_map_mode_params.min_clk_table = &#38;dml-&gt;min_clk_table;
+		l-&gt;dppm_map_mode_params.display_cfg = &#38;l-&gt;base_display_config_with_meta;
+		l-&gt;dppm_map_mode_params.programming = dpmm_programming;
+		l-&gt;dppm_map_mode_params.soc_bb = &#38;dml-&gt;soc_bbox;
+		l-&gt;dppm_map_mode_params.ip = &#38;dml-&gt;core_instance.clean_me_up.mode_lib.ip;
+		result = dml-&gt;dpmm_instance.map_mode_to_soc_dpm(&#38;l-&gt;dppm_map_mode_params);
+	}
+
</span> 	in_out-&gt;is_supported = mcache_success;
 	result = result &#38;&#38; in_out-&gt;is_supported;
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml2/dml21/src/inc/dml2_internal_shared_types.h b/drivers/gpu/drm/amd/display/dc/dml2/dml21/src/inc/dml2_internal_shared_types.h
index dd90c5df5a5a..5632cdacb7f4 100644
--- a/drivers/gpu/drm/amd/display/dc/dml2/dml21/src/inc/dml2_internal_shared_types.h
+++ b/drivers/gpu/drm/amd/display/dc/dml2/dml21/src/inc/dml2_internal_shared_types.h
</span><span
class="hunk">@@ -870,6 +870,7 @@ struct dml2_check_mode_supported_locals {
</span> 	struct dml2_optimization_phase_locals optimization_phase_locals;
 	struct display_configuation_with_meta base_display_config_with_meta;
 	struct display_configuation_with_meta optimized_display_config_with_meta;
<span
class="add">+	struct dml2_dpmm_map_mode_to_soc_dpm_params_in_out dppm_map_mode_params;
</span> };
 
 struct optimization_init_function_params {
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 18/39] drm/amd/display: resync OTG after DIO FIFO resync</title><updated>2024-06-20T16:16:32Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-19-alex.hung@amd.com/"/><id>urn:uuid:eb71e35f-7f9d-51bd-2c0e-ce5006b1004f</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: TungYu Lu &lt;tungyu.lu@amd.com&gt;

[WHY]
Tiled displays showed not aligned on 8K60hz when system resumed
from S3/S4.

[HOW]
Do dc_trigger_sync to re-sync pipes to ensure OTG become synced.

Reviewed-by: Alvin Lee &lt;alvin.lee2@amd.com&gt;
Cc: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
Cc: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Cc: stable@vger.kernel.org
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: TungYu Lu &lt;tungyu.lu@amd.com&gt;
---
 drivers/gpu/drm/amd/display/dc/hwss/dcn32/dcn32_hwseq.c | 2 ++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-19-alex.hung@amd.com/#related">changed</a>, 2 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn32/dcn32_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn32/dcn32_hwseq.c
index bdbb4a71651f..fe62478fbcde 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn32/dcn32_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn32/dcn32_hwseq.c
</span><span
class="hunk">@@ -1254,6 +1254,8 @@ void dcn32_resync_fifo_dccg_dio(struct dce_hwseq *hws, struct dc *dc, struct dc_
</span> 			pipe-&gt;stream_res.tg-&gt;funcs-&gt;enable_crtc(pipe-&gt;stream_res.tg);
 		}
 	}
<span
class="add">+
+	dc_trigger_sync(dc, dc-&gt;current_state);
</span> }
 
 void dcn32_unblank_stream(struct pipe_ctx *pipe_ctx,
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 17/39] drm/amd/display: Always enable HPO for DCN4 dGPU</title><updated>2024-06-20T16:16:16Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-18-alex.hung@amd.com/"/><id>urn:uuid:dfefd8b8-a578-050c-ea37-4b4f14a0830c</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: &#34;Leo (Hanghong) Ma&#34; &lt;hanghong.ma@amd.com&gt;

[WHY &#38;&#38; HOW]
Some DP EDID CTS tests fail due to HPO disable, and we should keep it
enable on DCN4 dGPU.

Reviewed-by: Wenjing Liu &lt;wenjing.liu@amd.com&gt;
Cc: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
Cc: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Cc: stable@vger.kernel.org
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Leo (Hanghong) Ma &lt;hanghong.ma@amd.com&gt;
---
 drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c | 2 ++
 drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_init.c  | 1 -
 2 files <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-18-alex.hung@amd.com/#related">changed</a>, 2 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
index 42753f56d31d..79a911e1a09a 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
</span><span
class="hunk">@@ -408,6 +408,8 @@ void dcn401_init_hw(struct dc *dc)
</span> 		REG_UPDATE(DCFCLK_CNTL, DCFCLK_GATE_DIS, 0);
 	}
 
<span
class="add">+	dcn401_setup_hpo_hw_control(hws, true);
+
</span> 	if (!dcb-&gt;funcs-&gt;is_accelerated_mode(dcb) &#38;&#38; dc-&gt;res_pool-&gt;hubbub-&gt;funcs-&gt;init_watermarks)
 		dc-&gt;res_pool-&gt;hubbub-&gt;funcs-&gt;init_watermarks(dc-&gt;res_pool-&gt;hubbub);
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_init.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_init.c
index 1cf0608e1980..8159fd838dc3 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_init.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_init.c
</span><span
class="hunk">@@ -137,7 +137,6 @@ static const struct hwseq_private_funcs dcn401_private_funcs = {
</span> 	.program_mall_pipe_config = dcn32_program_mall_pipe_config,
 	.update_force_pstate = dcn32_update_force_pstate,
 	.update_mall_sel = dcn32_update_mall_sel,
<span
class="del">-	.setup_hpo_hw_control = dcn401_setup_hpo_hw_control,
</span> 	.calculate_dccg_k1_k2_values = NULL,
 	.apply_single_controller_ctx_to_hw = dce110_apply_single_controller_ctx_to_hw,
 	.reset_back_end_for_pipe = dcn20_reset_back_end_for_pipe,
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 16/39] drm/amd/display: Use sw cursor for DCN401 with rotation</title><updated>2024-06-20T16:16:02Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-17-alex.hung@amd.com/"/><id>urn:uuid:69cd8cbd-9824-6f3a-e1ac-1ed7b624a02a</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Aurabindo Pillai &lt;aurabindo.pillai@amd.com&gt;

[WHAT &#38; HOW]
On DCN401, the cursor composition to the plane happens after scaler.
So the cursor isn&#39;t stretched with the rest of the surface. Temporarily
disable hardware cursor in case when hardware rotation is enabled
such that userspace falls back to software cursor.

Reviewed-by: Sun peng Li &lt;sunpeng.li@amd.com&gt;
Reviewed-by: Rodrigo Siqueira &lt;rodrigo.siqueira@amd.com&gt;
Cc: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
Cc: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Cc: stable@vger.kernel.org
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Aurabindo Pillai &lt;aurabindo.pillai@amd.com&gt;
---
 .../gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c | 34 ++++++++++++++++---
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-17-alex.hung@amd.com/#related">changed</a>, 29 insertions(+), 5 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index 590e899ae3d0..89e371f870b8 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
</span><span
class="hunk">@@ -11093,8 +11093,12 @@ static int dm_crtc_get_cursor_mode(struct amdgpu_device *adev,
</span> 	int cursor_scale_w, cursor_scale_h;
 	int i;
 
<span
class="del">-	/* Overlay cursor not supported on HW before DCN */
-	if (amdgpu_ip_version(adev, DCE_HWIP, 0) == 0) {
</span><span
class="add">+	/* Overlay cursor not supported on HW before DCN
+	 * DCN401 does not have the cursor-on-scaled-plane or cursor-on-yuv-plane restrictions
+	 * as previous DCN generations, so enable native mode on DCN401 in addition to DCE
+	 */
+	if (amdgpu_ip_version(adev, DCE_HWIP, 0) == 0 ||
+	    amdgpu_ip_version(adev, DCE_HWIP, 0) == IP_VERSION(4, 0, 1)) {
</span> 		*cursor_mode = DM_CURSOR_NATIVE_MODE;
 		return 0;
 	}
<span
class="hunk">@@ -11237,7 +11241,7 @@ static int amdgpu_dm_atomic_check(struct drm_device *dev,
</span> 	struct drm_crtc *crtc;
 	struct drm_crtc_state *old_crtc_state, *new_crtc_state;
 	struct drm_plane *plane;
<span
class="del">-	struct drm_plane_state *old_plane_state, *new_plane_state;
</span><span
class="add">+	struct drm_plane_state *old_plane_state, *new_plane_state, *new_cursor_state;
</span> 	enum dc_status status;
 	int ret, i;
 	bool lock_and_validation_needed = false;
<span
class="hunk">@@ -11465,19 +11469,39 @@ static int amdgpu_dm_atomic_check(struct drm_device *dev,
</span> 			drm_dbg_atomic(dev, &#34;MPO enablement requested on crtc:[%p]\n&#34;, crtc);
 	}
 
<span
class="del">-	/* Check cursor planes restrictions */
</span><span
class="add">+	/* Check cursor restrictions */
</span> 	for_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {
 		enum amdgpu_dm_cursor_mode required_cursor_mode;
<span
class="add">+		int is_rotated, is_scaled;
</span> 
 		/* Overlay cusor not subject to native cursor restrictions */
 		dm_new_crtc_state = to_dm_crtc_state(new_crtc_state);
 		if (dm_new_crtc_state-&gt;cursor_mode == DM_CURSOR_OVERLAY_MODE)
 			continue;
 
<span
class="add">+		/* Check if rotation or scaling is enabled on DCN401 */
+		if ((drm_plane_mask(crtc-&gt;cursor) &#38; new_crtc_state-&gt;plane_mask) &#38;&#38;
+		    amdgpu_ip_version(adev, DCE_HWIP, 0) == IP_VERSION(4, 0, 1)) {
+			new_cursor_state = drm_atomic_get_new_plane_state(state, crtc-&gt;cursor);
+
+			is_rotated = new_cursor_state &#38;&#38;
+				((new_cursor_state-&gt;rotation &#38; DRM_MODE_ROTATE_MASK) != DRM_MODE_ROTATE_0);
+			is_scaled = new_cursor_state &#38;&#38; ((new_cursor_state-&gt;src_w &gt;&gt; 16 != new_cursor_state-&gt;crtc_w) ||
+				(new_cursor_state-&gt;src_h &gt;&gt; 16 != new_cursor_state-&gt;crtc_h));
+
+			if (is_rotated || is_scaled) {
+				drm_dbg_driver(
+					crtc-&gt;dev,
+					&#34;[CRTC:%d:%s] cannot enable hardware cursor due to rotation/scaling\n&#34;,
+					crtc-&gt;base.id, crtc-&gt;name);
+				ret = -EINVAL;
+				goto fail;
+			}
+		}
+
</span> 		/* If HW can only do native cursor, check restrictions again */
 		ret = dm_crtc_get_cursor_mode(adev, state, dm_new_crtc_state,
 					      &#38;required_cursor_mode);
<span
class="del">-
</span> 		if (ret) {
 			drm_dbg_driver(crtc-&gt;dev,
 				       &#34;[CRTC:%d:%s] Checking cursor mode failed\n&#34;,
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 15/39] drm/amd/display: Add Replay general cmd</title><updated>2024-06-20T16:15:47Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-16-alex.hung@amd.com/"/><id>urn:uuid:4568bbb3-4a6e-70f0-07bc-65b13c18cab6</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Joan Lee &lt;joan.lee@amd.com&gt;

[WHY &#38; HOW]
Driver side adding replay general cmd interface.
Replay general command will config at most two uint_32 parameters,
with a replay general command subtype to set relative configurations.

Reviewed-by: Nicholas Kazlauskas &lt;nicholas.kazlauskas@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Joan Lee &lt;joan.lee@amd.com&gt;
---
 drivers/gpu/drm/amd/display/dc/dc_types.h      |  1 +
 .../gpu/drm/amd/display/dc/dce/dmub_replay.c   | 18 +++++++++++++++++-
 2 files <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-16-alex.hung@amd.com/#related">changed</a>, 18 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dc_types.h b/drivers/gpu/drm/amd/display/dc/dc_types.h
index 21f4af9ab096..c550e8997033 100644
--- a/drivers/gpu/drm/amd/display/dc/dc_types.h
+++ b/drivers/gpu/drm/amd/display/dc/dc_types.h
</span><span
class="hunk">@@ -1036,6 +1036,7 @@ enum replay_FW_Message_type {
</span> 	Replay_Set_Residency_Frameupdate_Timer,
 	Replay_Set_Pseudo_VTotal,
 	Replay_Disabled_Adaptive_Sync_SDP,
<span
class="add">+	Replay_Set_General_Cmd,
</span> };
 
 union replay_error_status {
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dce/dmub_replay.c b/drivers/gpu/drm/amd/display/dc/dce/dmub_replay.c
index 5437ebd8bc21..2a21bcf5224f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dmub_replay.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dmub_replay.c
</span><span
class="hunk">@@ -346,13 +346,29 @@ static void dmub_replay_send_cmd(struct dmub_replay *dmub,
</span> 		cmd.replay_disabled_adaptive_sync_sdp.header.sub_type =
 			DMUB_CMD__REPLAY_DISABLED_ADAPTIVE_SYNC_SDP;
 		cmd.replay_disabled_adaptive_sync_sdp.header.payload_bytes =
<span
class="del">-			sizeof(struct dmub_rb_cmd_replay_set_pseudo_vtotal);
</span><span
class="add">+			sizeof(struct dmub_rb_cmd_replay_disabled_adaptive_sync_sdp);
</span> 		//Cmd Body
 		cmd.replay_disabled_adaptive_sync_sdp.data.panel_inst =
 			cmd_element-&gt;disabled_adaptive_sync_sdp_data.panel_inst;
 		cmd.replay_disabled_adaptive_sync_sdp.data.force_disabled =
 			cmd_element-&gt;disabled_adaptive_sync_sdp_data.force_disabled;
 		break;
<span
class="add">+	case Replay_Set_General_Cmd:
+		//Header
+		cmd.replay_set_general_cmd.header.sub_type =
+			DMUB_CMD__REPLAY_SET_GENERAL_CMD;
+		cmd.replay_set_general_cmd.header.payload_bytes =
+			sizeof(struct dmub_rb_cmd_replay_set_general_cmd);
+		//Cmd Body
+		cmd.replay_set_general_cmd.data.panel_inst =
+			cmd_element-&gt;set_general_cmd_data.panel_inst;
+		cmd.replay_set_general_cmd.data.subtype =
+			cmd_element-&gt;set_general_cmd_data.subtype;
+		cmd.replay_set_general_cmd.data.param1 =
+			cmd_element-&gt;set_general_cmd_data.param1;
+		cmd.replay_set_general_cmd.data.param2 =
+			cmd_element-&gt;set_general_cmd_data.param2;
+		break;
</span> 	case Replay_Msg_Not_Support:
 	default:
 		return;
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 14/39] drm/amd/display: Check HDCP returned status</title><updated>2024-06-20T16:15:33Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-15-alex.hung@amd.com/"/><id>urn:uuid:d64ed7d9-8fb7-abd3-50ec-2045bd03ad69</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHAT &#38; HOW]
Check mod_hdcp_execute_and_set() return values in authenticated_dp.

This fixes 3 CHECKED_RETURN issues reported by Coverity.

Reviewed-by: Rodrigo Siqueira &lt;rodrigo.siqueira@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Alex Hung &lt;alex.hung@amd.com&gt;
---
 .../amd/display/modules/hdcp/hdcp1_execution.c    | 15 +++++++++------
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-15-alex.hung@amd.com/#related">changed</a>, 9 insertions(+), 6 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/modules/hdcp/hdcp1_execution.c b/drivers/gpu/drm/amd/display/modules/hdcp/hdcp1_execution.c
index 182e7532dda8..d77836cef563 100644
--- a/drivers/gpu/drm/amd/display/modules/hdcp/hdcp1_execution.c
+++ b/drivers/gpu/drm/amd/display/modules/hdcp/hdcp1_execution.c
</span><span
class="hunk">@@ -433,17 +433,20 @@ static enum mod_hdcp_status authenticated_dp(struct mod_hdcp *hdcp,
</span> 	}
 
 	if (status == MOD_HDCP_STATUS_SUCCESS)
<span
class="del">-		mod_hdcp_execute_and_set(mod_hdcp_read_bstatus,
</span><span
class="add">+		if (!mod_hdcp_execute_and_set(mod_hdcp_read_bstatus,
</span> 				&#38;input-&gt;bstatus_read, &#38;status,
<span
class="del">-				hdcp, &#34;bstatus_read&#34;);
</span><span
class="add">+				hdcp, &#34;bstatus_read&#34;))
+			goto out;
</span> 	if (status == MOD_HDCP_STATUS_SUCCESS)
<span
class="del">-		mod_hdcp_execute_and_set(check_link_integrity_dp,
</span><span
class="add">+		if (!mod_hdcp_execute_and_set(check_link_integrity_dp,
</span> 				&#38;input-&gt;link_integrity_check, &#38;status,
<span
class="del">-				hdcp, &#34;link_integrity_check&#34;);
</span><span
class="add">+				hdcp, &#34;link_integrity_check&#34;))
+			goto out;
</span> 	if (status == MOD_HDCP_STATUS_SUCCESS)
<span
class="del">-		mod_hdcp_execute_and_set(check_no_reauthentication_request_dp,
</span><span
class="add">+		if (!mod_hdcp_execute_and_set(check_no_reauthentication_request_dp,
</span> 				&#38;input-&gt;reauth_request_check, &#38;status,
<span
class="del">-				hdcp, &#34;reauth_request_check&#34;);
</span><span
class="add">+				hdcp, &#34;reauth_request_check&#34;))
+			goto out;
</span> out:
 	return status;
 }
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 13/39] drm/amd/display: Check and log for function error codes</title><updated>2024-06-20T16:15:19Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-14-alex.hung@amd.com/"/><id>urn:uuid:d9bd6c9d-9153-8305-4b08-84e16ff7cfdc</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHAT &#38; HOW]
dm_dmub_hw_init and drm_dp_mst_topology_mgr_set_mst can return error
codes and errors should be reported.

This fixes 2 CHECKED_RETURN issues reported by Coverity.

Reviewed-by: Rodrigo Siqueira &lt;rodrigo.siqueira@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Alex Hung &lt;alex.hung@amd.com&gt;
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c         | 5 ++++-
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c | 5 ++++-
 2 files <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-14-alex.hung@amd.com/#related">changed</a>, 8 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index 60404385d4d0..590e899ae3d0 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
</span><span
class="hunk">@@ -1302,6 +1302,7 @@ static void dm_dmub_hw_resume(struct amdgpu_device *adev)
</span> 	struct dmub_srv *dmub_srv = adev-&gt;dm.dmub_srv;
 	enum dmub_status status;
 	bool init;
<span
class="add">+	int r;
</span> 
 	if (!dmub_srv) {
 		/* DMUB isn&#39;t supported on the ASIC. */
<span
class="hunk">@@ -1319,7 +1320,9 @@ static void dm_dmub_hw_resume(struct amdgpu_device *adev)
</span> 			DRM_WARN(&#34;Wait for DMUB auto-load failed: %d\n&#34;, status);
 	} else {
 		/* Perform the full hardware initialization. */
<span
class="del">-		dm_dmub_hw_init(adev);
</span><span
class="add">+		r = dm_dmub_hw_init(adev);
+		if (r)
+			DRM_ERROR(&#34;DMUB interface failed to initialize: status=%d\n&#34;, r);
</span> 	}
 }
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index 717d97191dda..62cb59f00929 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
</span><span
class="hunk">@@ -3795,6 +3795,7 @@ static int trigger_hpd_mst_set(void *data, u64 val)
</span> 	struct amdgpu_dm_connector *aconnector;
 	struct drm_connector *connector;
 	struct dc_link *link = NULL;
<span
class="add">+	int ret;
</span> 
 	if (val == 1) {
 		drm_connector_list_iter_begin(dev, &#38;iter);
<span
class="hunk">@@ -3806,7 +3807,9 @@ static int trigger_hpd_mst_set(void *data, u64 val)
</span> 				dc_link_detect(aconnector-&gt;dc_link, DETECT_REASON_HPD);
 				mutex_unlock(&#38;adev-&gt;dm.dc_lock);
 
<span
class="del">-				drm_dp_mst_topology_mgr_set_mst(&#38;aconnector-&gt;mst_mgr, true);
</span><span
class="add">+				ret = drm_dp_mst_topology_mgr_set_mst(&#38;aconnector-&gt;mst_mgr, true);
+				if (ret &lt; 0)
+					DRM_ERROR(&#34;DM_MST: Failed to set the device into MST mode!&#34;);
</span> 			}
 		}
 	} else if (val == 0) {
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 12/39] drm/amd/display: Check and log for function error codes</title><updated>2024-06-20T16:15:10Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-13-alex.hung@amd.com/"/><id>urn:uuid:d0572357-1602-7424-e947-41c8502ff5bf</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHAT &#38; HOW]
BIOS_CMD_TABLE_REVISION and link_transmitter_control can return error
codes and errors should be reported.

This fixes 3 CHECKED_RETURN issues reported by Coverity.

Reviewed-by: Rodrigo Siqueira &lt;rodrigo.siqueira@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Alex Hung &lt;alex.hung@amd.com&gt;
---
 drivers/gpu/drm/amd/display/dc/bios/command_table2.c      | 3 ++-
 drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c     | 5 ++++-
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_link_encoder.c | 8 +++++++-
 3 files <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-13-alex.hung@amd.com/#related">changed</a>, 13 insertions(+), 3 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/bios/command_table2.c b/drivers/gpu/drm/amd/display/dc/bios/command_table2.c
index cc000833d300..4254bdfefe38 100644
--- a/drivers/gpu/drm/amd/display/dc/bios/command_table2.c
+++ b/drivers/gpu/drm/amd/display/dc/bios/command_table2.c
</span><span
class="hunk">@@ -227,7 +227,8 @@ static void init_transmitter_control(struct bios_parser *bp)
</span> 	uint8_t frev;
 	uint8_t crev = 0;
 
<span
class="del">-	BIOS_CMD_TABLE_REVISION(dig1transmittercontrol, frev, crev);
</span><span
class="add">+	if (!BIOS_CMD_TABLE_REVISION(dig1transmittercontrol, frev, crev))
+		BREAK_TO_DEBUGGER();
</span> 
 	switch (crev) {
 	case 6:
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c b/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c
index 136bd93c3b65..4a9d07c31bc5 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c
</span><span
class="hunk">@@ -1361,7 +1361,10 @@ void dce110_link_encoder_dp_set_lane_settings(
</span> 		cntl.lane_settings = training_lane_set.raw;
 
 		/* call VBIOS table to set voltage swing and pre-emphasis */
<span
class="del">-		link_transmitter_control(enc110, &#38;cntl);
</span><span
class="add">+		if (link_transmitter_control(enc110, &#38;cntl) != BP_RESULT_OK) {
+			DC_LOG_ERROR(&#34;%s: Failed to execute VBIOS command table!\n&#34;, __func__);
+			BREAK_TO_DEBUGGER();
+		}
</span> 	}
 }
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_link_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_link_encoder.c
index 4d0eed7598b2..e0558a78b11c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_link_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_link_encoder.c
</span><span
class="hunk">@@ -1104,6 +1104,7 @@ void dcn10_link_encoder_dp_set_lane_settings(
</span> 	union dpcd_training_lane_set training_lane_set = { { 0 } };
 	int32_t lane = 0;
 	struct bp_transmitter_control cntl = { 0 };
<span
class="add">+	enum bp_result result;
</span> 
 	if (!link_settings) {
 		BREAK_TO_DEBUGGER();
<span
class="hunk">@@ -1138,7 +1139,12 @@ void dcn10_link_encoder_dp_set_lane_settings(
</span> 		cntl.lane_settings = training_lane_set.raw;
 
 		/* call VBIOS table to set voltage swing and pre-emphasis */
<span
class="del">-		link_transmitter_control(enc10, &#38;cntl);
</span><span
class="add">+		result = link_transmitter_control(enc10, &#38;cntl);
+
+		if (result != BP_RESULT_OK) {
+			DC_LOG_ERROR(&#34;%s: Failed to execute VBIOS command table!\n&#34;, __func__);
+			BREAK_TO_DEBUGGER();
+		}
</span> 	}
 }
 
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 11/39] drm/amd/display: Remove useless function call</title><updated>2024-06-20T16:14:46Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-12-alex.hung@amd.com/"/><id>urn:uuid:7f9b0036-a26f-1f53-e132-6acdea120abf</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHAT &#38; HOW]
clk_mgr_helper_get_active_display_cnt returns display count and itself
alone has no use.

This fixes 1 CHECKED_RETURN issue reported by Coverity.

Reviewed-by: Rodrigo Siqueira &lt;rodrigo.siqueira@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Alex Hung &lt;alex.hung@amd.com&gt;
---
 drivers/gpu/drm/amd/display/dc/clk_mgr/dcn201/dcn201_clk_mgr.c | 2 --
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-12-alex.hung@amd.com/#related">changed</a>, 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn201/dcn201_clk_mgr.c b/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn201/dcn201_clk_mgr.c
index f77840dd051e..7920f6f1aa62 100644
--- a/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn201/dcn201_clk_mgr.c
+++ b/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn201/dcn201_clk_mgr.c
</span><span
class="hunk">@@ -113,8 +113,6 @@ static void dcn201_update_clocks(struct clk_mgr *clk_mgr_base,
</span> 		dcn2_read_clocks_from_hw_dentist(clk_mgr_base);
 	}
 
<span
class="del">-	clk_mgr_helper_get_active_display_cnt(dc, context);
-
</span> 	if (should_set_clock(safe_to_lower, new_clocks-&gt;phyclk_khz, clk_mgr_base-&gt;clks.phyclk_khz))
 		clk_mgr_base-&gt;clks.phyclk_khz = new_clocks-&gt;phyclk_khz;
 
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 10/39] drm/amd/display: Fix uninitialized variables in dcn401</title><updated>2024-06-20T16:14:37Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-11-alex.hung@amd.com/"/><id>urn:uuid:3f342d4d-3fc3-499c-ba2f-63483ebd665a</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHAT &#38; HOW]
surf_linear_128_l/c are used in CalculateBytePerPixelAndBlockSizes
before they are assigned, so initializing them before passing them into
the function.

This fixes 2 UNINIT issues reported by Coverity.

Reviewed-by: Rodrigo Siqueira &lt;rodrigo.siqueira@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Alex Hung &lt;alex.hung@amd.com&gt;
---
 .../dc/dml2/dml21/src/dml2_core/dml2_core_dcn4_calcs.c        | 4 ++--
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-11-alex.hung@amd.com/#related">changed</a>, 2 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4_calcs.c b/drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4_calcs.c
index be73784e21eb..6f4026e396e0 100644
--- a/drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4_calcs.c
+++ b/drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4_calcs.c
</span><span
class="hunk">@@ -11521,8 +11521,8 @@ void dml2_core_calcs_get_dpte_row_height(
</span> 	unsigned int MacroTileWidthC;
 	unsigned int MacroTileHeightY;
 	unsigned int MacroTileHeightC;
<span
class="del">-	bool surf_linear_128_l;
-	bool surf_linear_128_c;
</span><span
class="add">+	bool surf_linear_128_l = false;
+	bool surf_linear_128_c = false;
</span> 
 	CalculateBytePerPixelAndBlockSizes(
 		SourcePixelFormat,
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 09/39] drm/amd/display: Fix cursor size issues</title><updated>2024-06-20T16:14:20Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-10-alex.hung@amd.com/"/><id>urn:uuid:4d0d930d-ac2c-622c-66dd-9e52574975e2</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Nevenko Stupar &lt;nevenko.stupar@amd.com&gt;

[WHY &#38; HOW]
Fix the cursor size between ODM slices.

Reviewed-by: Sridevi Arvindekar &lt;sridevi.arvindekar@amd.com&gt;
Cc: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
Cc: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Cc: stable@vger.kernel.org
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Nevenko Stupar &lt;nevenko.stupar@amd.com&gt;
---
 .../drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c  | 14 ++++++++++++++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-10-alex.hung@amd.com/#related">changed</a>, 14 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
index 0cf55f557c3c..42753f56d31d 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
</span><span
class="hunk">@@ -1169,6 +1169,20 @@ void dcn401_set_cursor_position(struct pipe_ctx *pipe_ctx)
</span> 		x_pos -= (prev_odm_width + prev_odm_offset);
 	}
 
<span
class="add">+	/* If the position is negative then we need to add to the hotspot
+	 * to fix cursor size between ODM slices
+	 */
+
+	if (x_pos &lt; 0) {
+		pos_cpy.x_hotspot -= x_pos;
+		x_pos = 0;
+	}
+
+	if (y_pos &lt; 0) {
+		pos_cpy.y_hotspot -= y_pos;
+		y_pos = 0;
+	}
+
</span> 	pos_cpy.x = (uint32_t)x_pos;
 	pos_cpy.y = (uint32_t)y_pos;
 
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title
type="html">[PATCH 08/39] drm/amd/display: Run DC_LOG_DC after checking link-&gt;link_enc</title><updated>2024-06-20T16:14:03Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-9-alex.hung@amd.com/"/><id>urn:uuid:0058c586-93b8-de40-9e02-0db56f17d04c</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHAT]
The DC_LOG_DC should be run after link-&gt;link_enc is checked, not before.

This fixes 1 REVERSE_INULL issue reported by Coverity.

Reviewed-by: Rodrigo Siqueira &lt;rodrigo.siqueira@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Alex Hung &lt;alex.hung@amd.com&gt;
---
 drivers/gpu/drm/amd/display/dc/link/link_factory.c | 6 +++---
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-9-alex.hung@amd.com/#related">changed</a>, 3 insertions(+), 3 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/link/link_factory.c b/drivers/gpu/drm/amd/display/dc/link/link_factory.c
index 8073fdae9cb1..8246006857b3 100644
--- a/drivers/gpu/drm/amd/display/dc/link/link_factory.c
+++ b/drivers/gpu/drm/amd/display/dc/link/link_factory.c
</span><span
class="hunk">@@ -610,14 +610,14 @@ static bool construct_phy(struct dc_link *link,
</span> 	link-&gt;link_enc =
 		link-&gt;dc-&gt;res_pool-&gt;funcs-&gt;link_enc_create(dc_ctx, &#38;enc_init_data);
 
<span
class="del">-	DC_LOG_DC(&#34;BIOS object table - DP_IS_USB_C: %d&#34;, link-&gt;link_enc-&gt;features.flags.bits.DP_IS_USB_C);
-	DC_LOG_DC(&#34;BIOS object table - IS_DP2_CAPABLE: %d&#34;, link-&gt;link_enc-&gt;features.flags.bits.IS_DP2_CAPABLE);
-
</span> 	if (!link-&gt;link_enc) {
 		DC_ERROR(&#34;Failed to create link encoder!\n&#34;);
 		goto link_enc_create_fail;
 	}
 
<span
class="add">+	DC_LOG_DC(&#34;BIOS object table - DP_IS_USB_C: %d&#34;, link-&gt;link_enc-&gt;features.flags.bits.DP_IS_USB_C);
+	DC_LOG_DC(&#34;BIOS object table - IS_DP2_CAPABLE: %d&#34;, link-&gt;link_enc-&gt;features.flags.bits.IS_DP2_CAPABLE);
+
</span> 	/* Update link encoder tracking variables. These are used for the dynamic
 	 * assignment of link encoders to streams.
 	 */
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title
type="html">[PATCH 07/39] drm/amd/display: Remove redundant checks for pipe_ctx-&gt;stream</title><updated>2024-06-20T16:13:46Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-8-alex.hung@amd.com/"/><id>urn:uuid:26381f33-34dd-a48b-c91b-8057c3c23899</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHAT &#38; HOW]
The null checks for pipe_ctx-&gt;stream and pipe_ctx-&gt;stream_res.tg
are redundant as they were already dereferenced previously, as
reported by Coverity; therefore the null checks are removed.

This fixes 6 REVERSE_INULL issues reported by Coverity.

Reviewed-by: Rodrigo Siqueira &lt;rodrigo.siqueira@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Alex Hung &lt;alex.hung@amd.com&gt;
---
 drivers/gpu/drm/amd/display/dc/hwss/dcn20/dcn20_hwseq.c    | 7 +++----
 drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c  | 4 ++--
 .../gpu/drm/amd/display/dc/link/accessories/link_dp_cts.c  | 2 +-
 3 files <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-8-alex.hung@amd.com/#related">changed</a>, 6 insertions(+), 7 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn20/dcn20_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn20/dcn20_hwseq.c
index 82d1ded09561..4d359bb9b1ec 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn20/dcn20_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn20/dcn20_hwseq.c
</span><span
class="hunk">@@ -974,8 +974,8 @@ enum dc_status dcn20_enable_stream_timing(
</span> 	/* TODO enable stream if timing changed */
 	/* TODO unblank stream if DP */
 
<span
class="del">-	if (pipe_ctx-&gt;stream &#38;&#38; dc_state_get_pipe_subvp_type(context, pipe_ctx) == SUBVP_PHANTOM) {
-		if (pipe_ctx-&gt;stream_res.tg &#38;&#38; pipe_ctx-&gt;stream_res.tg-&gt;funcs-&gt;phantom_crtc_post_enable)
</span><span
class="add">+	if (dc_state_get_pipe_subvp_type(context, pipe_ctx) == SUBVP_PHANTOM) {
+		if (pipe_ctx-&gt;stream_res.tg-&gt;funcs-&gt;phantom_crtc_post_enable)
</span> 			pipe_ctx-&gt;stream_res.tg-&gt;funcs-&gt;phantom_crtc_post_enable(pipe_ctx-&gt;stream_res.tg);
 	}
 
<span
class="hunk">@@ -1827,8 +1827,7 @@ static void dcn20_update_dchubp_dpp(
</span> 	if (pipe_ctx-&gt;update_flags.bits.enable)
 		hubp-&gt;funcs-&gt;set_blank(hubp, false);
 	/* If the stream paired with this plane is phantom, the plane is also phantom */
<span
class="del">-	if (pipe_ctx-&gt;stream &#38;&#38; pipe_mall_type == SUBVP_PHANTOM
-			&#38;&#38; hubp-&gt;funcs-&gt;phantom_hubp_post_enable)
</span><span
class="add">+	if (pipe_mall_type == SUBVP_PHANTOM &#38;&#38; hubp-&gt;funcs-&gt;phantom_hubp_post_enable)
</span> 		hubp-&gt;funcs-&gt;phantom_hubp_post_enable(hubp);
 }
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
index 8d0da56e4cc5..0cf55f557c3c 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
</span><span
class="hunk">@@ -916,8 +916,8 @@ enum dc_status dcn401_enable_stream_timing(
</span> 	/* TODO enable stream if timing changed */
 	/* TODO unblank stream if DP */
 
<span
class="del">-	if (pipe_ctx-&gt;stream &#38;&#38; dc_state_get_pipe_subvp_type(context, pipe_ctx) == SUBVP_PHANTOM) {
-		if (pipe_ctx-&gt;stream_res.tg &#38;&#38; pipe_ctx-&gt;stream_res.tg-&gt;funcs-&gt;phantom_crtc_post_enable)
</span><span
class="add">+	if (dc_state_get_pipe_subvp_type(context, pipe_ctx) == SUBVP_PHANTOM) {
+		if (pipe_ctx-&gt;stream_res.tg-&gt;funcs-&gt;phantom_crtc_post_enable)
</span> 			pipe_ctx-&gt;stream_res.tg-&gt;funcs-&gt;phantom_crtc_post_enable(pipe_ctx-&gt;stream_res.tg);
 	}
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/link/accessories/link_dp_cts.c b/drivers/gpu/drm/amd/display/dc/link/accessories/link_dp_cts.c
index 8d1a1cc94a8b..555c1c484cfd 100644
--- a/drivers/gpu/drm/amd/display/dc/link/accessories/link_dp_cts.c
+++ b/drivers/gpu/drm/amd/display/dc/link/accessories/link_dp_cts.c
</span><span
class="hunk">@@ -853,7 +853,7 @@ bool dp_set_test_pattern(
</span> 				CRTC_STATE_VACTIVE);
 
 		if (pipe_ctx-&gt;stream_res.tg-&gt;funcs-&gt;lock_doublebuffer_disable) {
<span
class="del">-			if (pipe_ctx-&gt;stream &#38;&#38; should_use_dmub_lock(pipe_ctx-&gt;stream-&gt;link)) {
</span><span
class="add">+			if (should_use_dmub_lock(pipe_ctx-&gt;stream-&gt;link)) {
</span> 				union dmub_hw_lock_flags hw_locks = { 0 };
 				struct dmub_hw_lock_inst_flags inst_flags = { 0 };
 
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 06/39] drm/amd/display: Send DP_TOTAL_LTTPR_CNT during detection if LTTPR is present</title><updated>2024-06-20T16:13:33Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-7-alex.hung@amd.com/"/><id>urn:uuid:b9e3a8b7-08e5-2c81-da5d-916a8c9aac6d</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Michael Strauss &lt;michael.strauss@amd.com&gt;

[WHY]
New register field added in DP2.1 SCR, needed for auxless ALPM

[HOW]
Echo value read from 0xF0007 back to sink

Reviewed-by: Wenjing Liu &lt;wenjing.liu@amd.com&gt;
Cc: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
Cc: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Cc: stable@vger.kernel.org
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Michael Strauss &lt;michael.strauss@amd.com&gt;
---
 .../amd/display/dc/link/protocols/link_dp_capability.c | 10 +++++++++-
 drivers/gpu/drm/amd/display/include/dpcd_defs.h        |  5 +++++
 2 files <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-7-alex.hung@amd.com/#related">changed</a>, 14 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_capability.c b/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_capability.c
index 00974c50e11f..f1cac74dd7f7 100644
--- a/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_capability.c
+++ b/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_capability.c
</span><span
class="hunk">@@ -1605,9 +1605,17 @@ static bool retrieve_link_cap(struct dc_link *link)
</span> 			return false;
 	}
 
<span
class="del">-	if (dp_is_lttpr_present(link))
</span><span
class="add">+	if (dp_is_lttpr_present(link)) {
</span> 		configure_lttpr_mode_transparent(link);
 
<span
class="add">+		// Echo TOTAL_LTTPR_CNT back downstream
+		core_link_write_dpcd(
+				link,
+				DP_TOTAL_LTTPR_CNT,
+				&#38;link-&gt;dpcd_caps.lttpr_caps.phy_repeater_cnt,
+				sizeof(link-&gt;dpcd_caps.lttpr_caps.phy_repeater_cnt));
+	}
+
</span> 	/* Read DP tunneling information. */
 	status = dpcd_get_tunneling_device_data(link);
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/include/dpcd_defs.h b/drivers/gpu/drm/amd/display/include/dpcd_defs.h
index 914f28e9f224..aee5170f5fb2 100644
--- a/drivers/gpu/drm/amd/display/include/dpcd_defs.h
+++ b/drivers/gpu/drm/amd/display/include/dpcd_defs.h
</span><span
class="hunk">@@ -177,4 +177,9 @@ enum dpcd_psr_sink_states {
</span> #define DP_SINK_PR_PIXEL_DEVIATION_PER_LINE     0x379
 #define DP_SINK_PR_MAX_NUMBER_OF_DEVIATION_LINE 0x37A
 
<span
class="add">+/* Remove once drm_dp_helper.h is updated upstream */
+#ifndef DP_TOTAL_LTTPR_CNT
+#define DP_TOTAL_LTTPR_CNT                                  0xF000A /* 2.1 */
+#endif
+
</span> #endif /* __DAL_DPCD_DEFS_H__ */
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 05/39] drm/amd/display: Fix cursor issues with ODMs and HW rotations</title><updated>2024-06-20T16:13:25Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-6-alex.hung@amd.com/"/><id>urn:uuid:e02b6b30-0551-ea75-ae38-5f25456622f8</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Nevenko Stupar &lt;nevenko.stupar@amd.com&gt;

[WHY &#38; HOW]
Current code for cursor positions does not work properly
with different ODM options and HW rotations like ODM
2to1, 3to1 and 4to1, and has different issues depending on
angle of HW rotations.

[HOW]
Fixed these issues so to work properly when ODM is used with HW rotations.

Reviewed-by: Sridevi Arvindekar &lt;sridevi.arvindekar@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Nevenko Stupar &lt;nevenko.stupar@amd.com&gt;
---
 .../amd/display/dc/dpp/dcn401/dcn401_dpp_cm.c |  50 -------
 .../amd/display/dc/hubp/dcn401/dcn401_hubp.c  |  38 -----
 .../amd/display/dc/hwss/dcn401/dcn401_hwseq.c | 135 +++---------------
 3 files <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-6-alex.hung@amd.com/#related">changed</a>, 19 insertions(+), 204 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dpp/dcn401/dcn401_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dpp/dcn401/dcn401_dpp_cm.c
index aef73bd1221a..d0f8c9ff5232 100644
--- a/drivers/gpu/drm/amd/display/dc/dpp/dcn401/dcn401_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dpp/dcn401/dcn401_dpp_cm.c
</span><span
class="hunk">@@ -153,58 +153,8 @@ void dpp401_set_cursor_position(
</span> 	uint32_t height)
 {
 	struct dcn401_dpp *dpp = TO_DCN401_DPP(dpp_base);
<span
class="del">-	int x_pos = pos-&gt;x - param-&gt;recout.x;
-	int y_pos = pos-&gt;y - param-&gt;recout.y;
-	int x_hotspot = pos-&gt;x_hotspot;
-	int y_hotspot = pos-&gt;y_hotspot;
-	int rec_x_offset = x_pos - pos-&gt;x_hotspot;
-	int rec_y_offset = y_pos - pos-&gt;y_hotspot;
-	int cursor_height = (int)height;
-	int cursor_width = (int)width;
</span> 	uint32_t cur_en = pos-&gt;enable ? 1 : 0;
 
<span
class="del">-	// Transform cursor width / height and hotspots for offset calculations
-	if (param-&gt;rotation == ROTATION_ANGLE_90 || param-&gt;rotation == ROTATION_ANGLE_270) {
-		swap(cursor_height, cursor_width);
-		swap(x_hotspot, y_hotspot);
-
-		if (param-&gt;rotation == ROTATION_ANGLE_90) {
-			// hotspot = (-y, x)
-			rec_x_offset = x_pos - (cursor_width - x_hotspot);
-			rec_y_offset = y_pos - y_hotspot;
-		} else if (param-&gt;rotation == ROTATION_ANGLE_270) {
-			// hotspot = (y, -x)
-			rec_x_offset = x_pos - x_hotspot;
-			rec_y_offset = y_pos - (cursor_height - y_hotspot);
-		}
-	} else if (param-&gt;rotation == ROTATION_ANGLE_180) {
-		// hotspot = (-x, -y)
-		if (!param-&gt;mirror)
-			rec_x_offset = x_pos - (cursor_width - x_hotspot);
-
-		rec_y_offset = y_pos - (cursor_height - y_hotspot);
-	}
-
-	if (param-&gt;rotation == ROTATION_ANGLE_0 &#38;&#38; !param-&gt;mirror) {
-		if (rec_x_offset &gt;= (int)param-&gt;recout.width)
-			cur_en = 0;  /* not visible beyond right edge*/
-
-		if (rec_y_offset &gt;= (int)param-&gt;recout.height)
-			cur_en = 0;  /* not visible beyond bottom edge*/
-	} else {
-		if (rec_x_offset &gt; (int)param-&gt;recout.width)
-			cur_en = 0;  /* not visible beyond right edge*/
-
-		if (rec_y_offset &gt; (int)param-&gt;recout.height)
-			cur_en = 0;  /* not visible beyond bottom edge*/
-	}
-
-	if (rec_x_offset + cursor_width &lt;= 0)
-		cur_en = 0;  /* not visible beyond left edge*/
-
-	if (rec_y_offset + cursor_height &lt;= 0)
-		cur_en = 0;  /* not visible beyond top edge*/
-
</span> 	REG_UPDATE(CURSOR0_CONTROL, CUR0_ENABLE, cur_en);
 
 	dpp_base-&gt;pos.cur0_ctl.bits.cur0_enable = cur_en;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.c b/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.c
index 6692d57d5cce..a893160ae775 100644
--- a/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.c
+++ b/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.c
</span><span
class="hunk">@@ -654,12 +654,8 @@ void hubp401_cursor_set_position(
</span> 	struct dcn20_hubp *hubp2 = TO_DCN20_HUBP(hubp);
 	int x_pos = pos-&gt;x - param-&gt;recout.x;
 	int y_pos = pos-&gt;y - param-&gt;recout.y;
<span
class="del">-	int x_hotspot = pos-&gt;x_hotspot;
-	int y_hotspot = pos-&gt;y_hotspot;
</span> 	int rec_x_offset = x_pos - pos-&gt;x_hotspot;
 	int rec_y_offset = y_pos - pos-&gt;y_hotspot;
<span
class="del">-	int cursor_height = (int)hubp-&gt;curs_attr.height;
-	int cursor_width = (int)hubp-&gt;curs_attr.width;
</span> 	uint32_t dst_x_offset;
 	uint32_t cur_en = pos-&gt;enable ? 1 : 0;
 
<span
class="hunk">@@ -672,28 +668,6 @@ void hubp401_cursor_set_position(
</span> 	if (hubp-&gt;curs_attr.address.quad_part == 0)
 		return;
 
<span
class="del">-	// Transform cursor width / height and hotspots for offset calculations
-	if (param-&gt;rotation == ROTATION_ANGLE_90 || param-&gt;rotation == ROTATION_ANGLE_270) {
-		swap(cursor_height, cursor_width);
-		swap(x_hotspot, y_hotspot);
-
-		if (param-&gt;rotation == ROTATION_ANGLE_90) {
-			// hotspot = (-y, x)
-			rec_x_offset = x_pos - (cursor_width - x_hotspot);
-			rec_y_offset = y_pos - y_hotspot;
-		} else if (param-&gt;rotation == ROTATION_ANGLE_270) {
-			// hotspot = (y, -x)
-			rec_x_offset = x_pos - x_hotspot;
-			rec_y_offset = y_pos - (cursor_height - y_hotspot);
-		}
-	} else if (param-&gt;rotation == ROTATION_ANGLE_180) {
-		// hotspot = (-x, -y)
-		if (!param-&gt;mirror)
-			rec_x_offset = x_pos - (cursor_width - x_hotspot);
-
-		rec_y_offset = y_pos - (cursor_height - y_hotspot);
-	}
-
</span> 	dst_x_offset = (rec_x_offset &gt;= 0) ? rec_x_offset : 0;
 	dst_x_offset *= param-&gt;ref_clk_khz;
 	dst_x_offset /= param-&gt;pixel_clk_khz;
<span
class="hunk">@@ -705,18 +679,6 @@ void hubp401_cursor_set_position(
</span> 			dc_fixpt_from_int(dst_x_offset),
 			param-&gt;h_scale_ratio));
 
<span
class="del">-	if (rec_x_offset &gt;= (int)param-&gt;recout.width)
-		cur_en = 0;  /* not visible beyond right edge*/
-
-	if (rec_x_offset + cursor_width &lt;= 0)
-		cur_en = 0;  /* not visible beyond left edge*/
-
-	if (rec_y_offset &gt;= (int)param-&gt;recout.height)
-		cur_en = 0;  /* not visible beyond bottom edge*/
-
-	if (rec_y_offset + cursor_height &lt;= 0)
-		cur_en = 0;  /* not visible beyond top edge*/
-
</span> 	if (cur_en &#38;&#38; REG_READ(CURSOR_SURFACE_ADDRESS) == 0)
 		hubp-&gt;funcs-&gt;set_cursor_attributes(hubp, &#38;hubp-&gt;curs_attr);
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
index 7a456618f313..8d0da56e4cc5 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
</span><span
class="hunk">@@ -1099,31 +1099,21 @@ void dcn401_set_cursor_position(struct pipe_ctx *pipe_ctx)
</span> 		.h_scale_ratio = pipe_ctx-&gt;plane_res.scl_data.ratios.horz,
 		.v_scale_ratio = pipe_ctx-&gt;plane_res.scl_data.ratios.vert,
 		.rotation = pipe_ctx-&gt;plane_state-&gt;rotation,
<span
class="del">-		.mirror = pipe_ctx-&gt;plane_state-&gt;horizontal_mirror
</span><span
class="add">+		.mirror = pipe_ctx-&gt;plane_state-&gt;horizontal_mirror,
+		.stream = pipe_ctx-&gt;stream
</span> 	};
<span
class="del">-	bool pipe_split_on = false;
</span> 	bool odm_combine_on = (pipe_ctx-&gt;next_odm_pipe != NULL) ||
 		(pipe_ctx-&gt;prev_odm_pipe != NULL);
 	int prev_odm_width = 0;
 	int prev_odm_offset = 0;
<span
class="del">-	int next_odm_width = 0;
-	int next_odm_offset = 0;
-	struct pipe_ctx *next_odm_pipe = NULL;
</span> 	struct pipe_ctx *prev_odm_pipe = NULL;
 
 	int x_pos = pos_cpy.x;
 	int y_pos = pos_cpy.y;
<span
class="add">+	int recout_x_pos = 0;
+	int recout_y_pos = 0;
</span> 
<span
class="del">-	if ((pipe_ctx-&gt;top_pipe != NULL) || (pipe_ctx-&gt;bottom_pipe != NULL)) {
-		if ((pipe_ctx-&gt;plane_state-&gt;src_rect.width != pipe_ctx-&gt;plane_res.scl_data.viewport.width) ||
-			(pipe_ctx-&gt;plane_state-&gt;src_rect.height != pipe_ctx-&gt;plane_res.scl_data.viewport.height)) {
-			pipe_split_on = true;
-		}
-	}
-
-
-	/**
-	 * DCN4 moved cursor composition after Scaler, so in HW it is in
</span><span
class="add">+	/* DCN4 moved cursor composition after Scaler, so in HW it is in
</span> 	 * recout space and for HW Cursor position programming need to
 	 * translate to recout space.
 	 *
<span
class="hunk">@@ -1148,8 +1138,7 @@ void dcn401_set_cursor_position(struct pipe_ctx *pipe_ctx)
</span> 	y_pos = pipe_ctx-&gt;stream-&gt;dst.y + y_pos * pipe_ctx-&gt;stream-&gt;dst.height /
 		pipe_ctx-&gt;stream-&gt;src.height;
 
<span
class="del">-	/**
-	 * If the cursor&#39;s source viewport is clipped then we need to
</span><span
class="add">+	/* If the cursor&#39;s source viewport is clipped then we need to
</span> 	 * translate the cursor to appear in the correct position on
 	 * the screen.
 	 *
<span
class="hunk">@@ -1169,38 +1158,15 @@ void dcn401_set_cursor_position(struct pipe_ctx *pipe_ctx)
</span> 	 * next/prev_odm_offset is to account for scaled modes that have underscan
 	 */
 	if (odm_combine_on) {
<span
class="del">-		next_odm_pipe = pipe_ctx-&gt;next_odm_pipe;
</span> 		prev_odm_pipe = pipe_ctx-&gt;prev_odm_pipe;
 
<span
class="del">-		while (next_odm_pipe != NULL) {
-			next_odm_width += next_odm_pipe-&gt;plane_res.scl_data.recout.width;
-			next_odm_offset += next_odm_pipe-&gt;plane_res.scl_data.recout.x;
-			next_odm_pipe = next_odm_pipe-&gt;next_odm_pipe;
-		}
</span> 		while (prev_odm_pipe != NULL) {
 			prev_odm_width += prev_odm_pipe-&gt;plane_res.scl_data.recout.width;
 			prev_odm_offset += prev_odm_pipe-&gt;plane_res.scl_data.recout.x;
 			prev_odm_pipe = prev_odm_pipe-&gt;prev_odm_pipe;
 		}
 
<span
class="del">-		if (param.rotation == ROTATION_ANGLE_0) {
-			x_pos -= (prev_odm_width + prev_odm_offset);
-		}
-	}
-
-	/**
-	 * If the position is negative then we need to add to the hotspot
-	 * to shift the cursor outside the plane.
-	 */
-
-	if (x_pos &lt; 0) {
-		pos_cpy.x_hotspot -= x_pos;
-		x_pos = 0;
-	}
-
-	if (y_pos &lt; 0) {
-		pos_cpy.y_hotspot -= y_pos;
-		y_pos = 0;
</span><span
class="add">+		x_pos -= (prev_odm_width + prev_odm_offset);
</span> 	}
 
 	pos_cpy.x = (uint32_t)x_pos;
<span
class="hunk">@@ -1209,86 +1175,23 @@ void dcn401_set_cursor_position(struct pipe_ctx *pipe_ctx)
</span> 	if (pos_cpy.enable &#38;&#38; dcn401_can_pipe_disable_cursor(pipe_ctx))
 		pos_cpy.enable = false;
 
<span
class="del">-	if (param.rotation == ROTATION_ANGLE_270) {
-		// Swap axis and mirror vertically
-		uint32_t temp_x = pos_cpy.x;
</span><span
class="add">+	x_pos = pos_cpy.x - param.recout.x;
+	y_pos = pos_cpy.y - param.recout.y;
</span> 
<span
class="del">-		int recout_height =
-			pipe_ctx-&gt;plane_res.scl_data.recout.height;
-		int recout_y =
-			pipe_ctx-&gt;plane_res.scl_data.recout.y;
</span><span
class="add">+	recout_x_pos = x_pos - pos_cpy.x_hotspot;
+	recout_y_pos = y_pos - pos_cpy.y_hotspot;
</span> 
<span
class="del">-		/**
-		 * Display groups that are 1xnY, have pos_cpy.x &gt; 2 * recout.height
-		 * For pipe split cases:
-		 * - apply offset of recout.y to normalize pos_cpy.x
-		 * - calculate the pos_cpy.y as before
-		 * - shift pos_cpy.y back by same offset to get final value
-		 * - since we iterate through both pipes, use the lower
-		 *   recout.y for offset
-		 * For non pipe split cases, use the same calculation for
-		 *  pos_cpy.y as the 180 degree rotation case below,
-		 *  but use pos_cpy.x as our input because we are rotating
-		 *  270 degrees
-		 */
-		if (pipe_split_on || odm_combine_on) {
-			int pos_cpy_x_offset;
-			int other_pipe_recout_y;
-
-			if (pipe_split_on) {
-				if (pipe_ctx-&gt;bottom_pipe) {
-					other_pipe_recout_y =
-						pipe_ctx-&gt;bottom_pipe-&gt;plane_res.scl_data.recout.y;
-				} else {
-					other_pipe_recout_y =
-						pipe_ctx-&gt;top_pipe-&gt;plane_res.scl_data.recout.y;
-				}
-				pos_cpy_x_offset = (recout_y &gt; other_pipe_recout_y) ?
-					other_pipe_recout_y : recout_y;
-				pos_cpy.x -= pos_cpy_x_offset;
-				if (pos_cpy.x &gt; recout_height) {
-					pos_cpy.x = pos_cpy.x - recout_height;
-					pos_cpy.y = recout_height - pos_cpy.x;
-				} else {
-					pos_cpy.y = 2 * recout_height - pos_cpy.x;
-				}
-				pos_cpy.y += pos_cpy_x_offset;
</span><span
class="add">+	if (recout_x_pos &gt;= (int)param.recout.width)
+		pos_cpy.enable = false;  /* not visible beyond right edge*/
</span> 
<span
class="del">-			} else {
-				pos_cpy.x = pipe_ctx-&gt;plane_res.scl_data.recout.width + next_odm_width + next_odm_offset - pos_cpy.y;
-				pos_cpy.y = temp_x;
-			}
-		}
-	} else if (param.rotation == ROTATION_ANGLE_180) {
-		// Mirror horizontally and vertically
-		int recout_width =
-			pipe_ctx-&gt;plane_res.scl_data.recout.width;
-		int recout_x =
-			pipe_ctx-&gt;plane_res.scl_data.recout.x;
-
-		if (!param.mirror) {
-			if (odm_combine_on) {
-				pos_cpy.x = pipe_ctx-&gt;plane_res.scl_data.recout.width + next_odm_width - pos_cpy.x;
-			} else if (pipe_split_on) {
-				if (pos_cpy.x &gt;= recout_width + recout_x) {
-					pos_cpy.x = 2 * recout_width
-						- pos_cpy.x + 2 * recout_x;
-				} else {
-					uint32_t temp_x = pos_cpy.x;
-
-					pos_cpy.x = 2 * recout_x - pos_cpy.x;
-					if (temp_x &gt;= recout_x +
-						(int)hubp-&gt;curs_attr.width || pos_cpy.x
-						&lt;= (int)hubp-&gt;curs_attr.width +
-						pipe_ctx-&gt;plane_state-&gt;src_rect.x) {
-						pos_cpy.x = temp_x + recout_width;
-					}
-				}
-			}
</span><span
class="add">+	if (recout_y_pos &gt;= (int)param.recout.height)
+		pos_cpy.enable = false;  /* not visible beyond bottom edge*/
</span> 
<span
class="del">-		}
</span><span
class="add">+	if (recout_x_pos + (int)hubp-&gt;curs_attr.width &lt;= 0)
+		pos_cpy.enable = false;  /* not visible beyond left edge*/
</span> 
<span
class="del">-	}
</span><span
class="add">+	if (recout_y_pos + (int)hubp-&gt;curs_attr.height &lt;= 0)
+		pos_cpy.enable = false;  /* not visible beyond top edge*/
</span> 
 	hubp-&gt;funcs-&gt;set_cursor_position(hubp, &#38;pos_cpy, &#38;param);
 	dpp-&gt;funcs-&gt;set_cursor_position(dpp, &#38;pos_cpy, &#38;param, hubp-&gt;curs_attr.width, hubp-&gt;curs_attr.height);
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 04/39] drm/amd/display: Remove unnecessary variable</title><updated>2024-06-20T16:13:03Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-5-alex.hung@amd.com/"/><id>urn:uuid:afa1980a-d8c7-804a-9787-36cbf1017d20</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Ivan Lipski &lt;ivlipski@amd.com&gt;

[WHY]
Coverity analysis flagged this code as DEADCODE because
the condition &#39;(!need_recovery)&#39; is never true.

The variable &#39;need_recovery&#39; is initialized as &#39;true&#39;,
is not assigned to &#39;false&#39; anywhere before the
conditional statement.

Since the variable is only used for the conditional check,
but the check can never be true, the variable itself is
redundant.

[HOW]
Removed the variable &#39;need_recovery&#39;.

Reviewed-by: Alex Hung &lt;alex.hung@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Ivan Lipski &lt;ivlipski@amd.com&gt;
---
 .../drm/amd/display/dc/hwss/dcn10/dcn10_hwseq.c | 17 -----------------
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-5-alex.hung@amd.com/#related">changed</a>, 17 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn10/dcn10_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn10/dcn10_hwseq.c
index 35151dd056cb..4ef329a4d764 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn10/dcn10_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn10/dcn10_hwseq.c
</span><span
class="hunk">@@ -1134,26 +1134,9 @@ static bool dcn10_hw_wa_force_recovery(struct dc *dc)
</span> {
 	struct hubp *hubp ;
 	unsigned int i;
<span
class="del">-	bool need_recover = true;
</span> 
 	if (!dc-&gt;debug.recovery_enabled)
 		return false;
<span
class="del">-
-	for (i = 0; i &lt; dc-&gt;res_pool-&gt;pipe_count; i++) {
-		struct pipe_ctx *pipe_ctx =
-			&#38;dc-&gt;current_state-&gt;res_ctx.pipe_ctx[i];
-		if (pipe_ctx != NULL) {
-			hubp = pipe_ctx-&gt;plane_res.hubp;
-			if (hubp != NULL &#38;&#38; hubp-&gt;funcs-&gt;hubp_get_underflow_status) {
-				if (hubp-&gt;funcs-&gt;hubp_get_underflow_status(hubp) != 0) {
-					/* one pipe underflow, we will reset all the pipes*/
-					need_recover = true;
-				}
-			}
-		}
-	}
-	if (!need_recover)
-		return false;
</span> 	/*
 	DCHUBP_CNTL:HUBP_BLANK_EN=1
 	DCHUBBUB_SOFT_RESET:DCHUBBUB_GLOBAL_SOFT_RESET=1
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 03/39] drm/amd/display: Remove redundant var from display_rq_dig_calc in dml</title><updated>2024-06-20T16:13:01Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-4-alex.hung@amd.com/"/><id>urn:uuid:e6e3474c-96dd-6bd9-a368-d0189987ffb9</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Ivan Lipski &lt;ivlipski@amd.com&gt;

[WHY]
Coverity analysis flagged these files as containing DEADCODE, i. e.
redundant or unreachabale. In these files, variable &#39;mode_422&#39; is
always the same file (0 or false), so any code logic with it is
redundant.

[HOW]
Removed &#39;mode_422&#39; variable and all code with it from
&#39;display_rq_dlg_calc_&#39; functions in dml.

Reviewed-by: Alex Hung &lt;alex.hung@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Ivan Lipski &lt;ivlipski@amd.com&gt;
---
 .../display/dc/dml/dcn20/display_rq_dlg_calc_20.c  | 14 +++-----------
 .../dc/dml/dcn20/display_rq_dlg_calc_20v2.c        | 14 +++-----------
 .../display/dc/dml/dcn21/display_rq_dlg_calc_21.c  | 14 +++-----------
 .../display/dc/dml/dcn30/display_rq_dlg_calc_30.c  | 14 +++-----------
 .../display/dc/dml/dcn31/display_rq_dlg_calc_31.c  | 14 +++-----------
 .../dc/dml/dcn314/display_rq_dlg_calc_314.c        | 14 +++-----------
 6 files <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-4-alex.hung@amd.com/#related">changed</a>, 18 insertions(+), 66 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml/dcn20/display_rq_dlg_calc_20.c b/drivers/gpu/drm/amd/display/dc/dml/dcn20/display_rq_dlg_calc_20.c
index 07146569e335..7c56ad0f8812 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/dcn20/display_rq_dlg_calc_20.c
+++ b/drivers/gpu/drm/amd/display/dc/dml/dcn20/display_rq_dlg_calc_20.c
</span><span
class="hunk">@@ -688,12 +688,11 @@ static void get_surf_rq_param(struct display_mode_lib *mode_lib,
</span> 		const display_pipe_source_params_st *pipe_src_param,
 		bool is_chroma)
 {
<span
class="del">-	bool mode_422 = false;
</span> 	unsigned int vp_width = 0;
 	unsigned int vp_height = 0;
 	unsigned int data_pitch = 0;
 	unsigned int meta_pitch = 0;
<span
class="del">-	unsigned int ppe = mode_422 ? 2 : 1;
</span><span
class="add">+	unsigned int ppe = 1;
</span> 
 	// TODO check if ppe apply for both luma and chroma in 422 case
 	if (is_chroma) {
<span
class="hunk">@@ -825,7 +824,6 @@ static void dml20_rq_dlg_get_dlg_params(struct display_mode_lib *mode_lib,
</span> 	double min_dst_y_ttu_vblank;
 	unsigned int dlg_vblank_start;
 	bool dual_plane;
<span
class="del">-	bool mode_422;
</span> 	unsigned int access_dir;
 	unsigned int vp_height_l;
 	unsigned int vp_width_l;
<span
class="hunk">@@ -971,7 +969,6 @@ static void dml20_rq_dlg_get_dlg_params(struct display_mode_lib *mode_lib,
</span> 	// Source
 //             dcc_en              = src.dcc;
 	dual_plane = is_dual_plane((enum source_format_class)(src-&gt;source_format));
<span
class="del">-	mode_422 = false; // TODO
</span> 	access_dir = (src-&gt;source_scan == dm_vert); // vp access direction: horizontal or vertical accessed
 //      bytes_per_element_l = get_bytes_per_element(source_format_class(src.source_format), 0);
 //      bytes_per_element_c = get_bytes_per_element(source_format_class(src.source_format), 1);
<span
class="hunk">@@ -1148,13 +1145,8 @@ static void dml20_rq_dlg_get_dlg_params(struct display_mode_lib *mode_lib,
</span> 	dpte_row_height_l = rq_dlg_param-&gt;rq_l.dpte_row_height;
 	dpte_row_height_c = rq_dlg_param-&gt;rq_c.dpte_row_height;
 
<span
class="del">-	if (mode_422) {
-		swath_width_pixels_ub_l = swath_width_ub_l * 2;  // *2 for 2 pixel per element
-		swath_width_pixels_ub_c = swath_width_ub_c * 2;
-	} else {
-		swath_width_pixels_ub_l = swath_width_ub_l * 1;
-		swath_width_pixels_ub_c = swath_width_ub_c * 1;
-	}
</span><span
class="add">+	swath_width_pixels_ub_l = swath_width_ub_l;
+	swath_width_pixels_ub_c = swath_width_ub_c;
</span> 
 	if (htaps_l &lt;= 1)
 		min_hratio_fact_l = 2.0;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml/dcn20/display_rq_dlg_calc_20v2.c b/drivers/gpu/drm/amd/display/dc/dml/dcn20/display_rq_dlg_calc_20v2.c
index f4bba1f2aeb6..3d95bfa5aca2 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/dcn20/display_rq_dlg_calc_20v2.c
+++ b/drivers/gpu/drm/amd/display/dc/dml/dcn20/display_rq_dlg_calc_20v2.c
</span><span
class="hunk">@@ -688,12 +688,11 @@ static void get_surf_rq_param(struct display_mode_lib *mode_lib,
</span> 		const display_pipe_source_params_st *pipe_src_param,
 		bool is_chroma)
 {
<span
class="del">-	bool mode_422 = false;
</span> 	unsigned int vp_width = 0;
 	unsigned int vp_height = 0;
 	unsigned int data_pitch = 0;
 	unsigned int meta_pitch = 0;
<span
class="del">-	unsigned int ppe = mode_422 ? 2 : 1;
</span><span
class="add">+	unsigned int ppe = 1;
</span> 
 	// TODO check if ppe apply for both luma and chroma in 422 case
 	if (is_chroma) {
<span
class="hunk">@@ -825,7 +824,6 @@ static void dml20v2_rq_dlg_get_dlg_params(struct display_mode_lib *mode_lib,
</span> 	double min_dst_y_ttu_vblank;
 	unsigned int dlg_vblank_start;
 	bool dual_plane;
<span
class="del">-	bool mode_422;
</span> 	unsigned int access_dir;
 	unsigned int vp_height_l;
 	unsigned int vp_width_l;
<span
class="hunk">@@ -972,7 +970,6 @@ static void dml20v2_rq_dlg_get_dlg_params(struct display_mode_lib *mode_lib,
</span> 	// Source
 //             dcc_en              = src.dcc;
 	dual_plane = is_dual_plane((enum source_format_class)(src-&gt;source_format));
<span
class="del">-	mode_422 = false; // TODO
</span> 	access_dir = (src-&gt;source_scan == dm_vert); // vp access direction: horizontal or vertical accessed
 //      bytes_per_element_l = get_bytes_per_element(source_format_class(src.source_format), 0);
 //      bytes_per_element_c = get_bytes_per_element(source_format_class(src.source_format), 1);
<span
class="hunk">@@ -1149,13 +1146,8 @@ static void dml20v2_rq_dlg_get_dlg_params(struct display_mode_lib *mode_lib,
</span> 	dpte_row_height_l = rq_dlg_param-&gt;rq_l.dpte_row_height;
 	dpte_row_height_c = rq_dlg_param-&gt;rq_c.dpte_row_height;
 
<span
class="del">-	if (mode_422) {
-		swath_width_pixels_ub_l = swath_width_ub_l * 2;  // *2 for 2 pixel per element
-		swath_width_pixels_ub_c = swath_width_ub_c * 2;
-	} else {
-		swath_width_pixels_ub_l = swath_width_ub_l * 1;
-		swath_width_pixels_ub_c = swath_width_ub_c * 1;
-	}
</span><span
class="add">+	swath_width_pixels_ub_l = swath_width_ub_l;
+	swath_width_pixels_ub_c = swath_width_ub_c;
</span> 
 	if (htaps_l &lt;= 1)
 		min_hratio_fact_l = 2.0;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml/dcn21/display_rq_dlg_calc_21.c b/drivers/gpu/drm/amd/display/dc/dml/dcn21/display_rq_dlg_calc_21.c
index c229a9edf82a..98502a4f0567 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/dcn21/display_rq_dlg_calc_21.c
+++ b/drivers/gpu/drm/amd/display/dc/dml/dcn21/display_rq_dlg_calc_21.c
</span><span
class="hunk">@@ -694,12 +694,11 @@ static void get_surf_rq_param(
</span> 		const display_pipe_params_st *pipe_param,
 		bool is_chroma)
 {
<span
class="del">-	bool mode_422 = false;
</span> 	unsigned int vp_width = 0;
 	unsigned int vp_height = 0;
 	unsigned int data_pitch = 0;
 	unsigned int meta_pitch = 0;
<span
class="del">-	unsigned int ppe = mode_422 ? 2 : 1;
</span><span
class="add">+	unsigned int ppe = 1;
</span> 
 	// FIXME check if ppe apply for both luma and chroma in 422 case
 	if (is_chroma) {
<span
class="hunk">@@ -868,7 +867,6 @@ static void dml_rq_dlg_get_dlg_params(
</span> 	double min_dst_y_ttu_vblank;
 	unsigned int dlg_vblank_start;
 	bool dual_plane;
<span
class="del">-	bool mode_422;
</span> 	unsigned int access_dir;
 	unsigned int vp_height_l;
 	unsigned int vp_width_l;
<span
class="hunk">@@ -1020,7 +1018,6 @@ static void dml_rq_dlg_get_dlg_params(
</span> 	// Source
 	//             dcc_en              = src.dcc;
 	dual_plane = is_dual_plane((enum source_format_class) (src-&gt;source_format));
<span
class="del">-	mode_422 = false; // FIXME
</span> 	access_dir = (src-&gt;source_scan == dm_vert); // vp access direction: horizontal or vertical accessed
 						    //      bytes_per_element_l = get_bytes_per_element(source_format_class(src.source_format), 0);
 						    //      bytes_per_element_c = get_bytes_per_element(source_format_class(src.source_format), 1);
<span
class="hunk">@@ -1197,13 +1194,8 @@ static void dml_rq_dlg_get_dlg_params(
</span> 	dpte_row_height_l = rq_dlg_param-&gt;rq_l.dpte_row_height;
 	dpte_row_height_c = rq_dlg_param-&gt;rq_c.dpte_row_height;
 
<span
class="del">-	if (mode_422) {
-		swath_width_pixels_ub_l = swath_width_ub_l * 2;  // *2 for 2 pixel per element
-		swath_width_pixels_ub_c = swath_width_ub_c * 2;
-	} else {
-		swath_width_pixels_ub_l = swath_width_ub_l * 1;
-		swath_width_pixels_ub_c = swath_width_ub_c * 1;
-	}
</span><span
class="add">+	swath_width_pixels_ub_l = swath_width_ub_l;
+	swath_width_pixels_ub_c = swath_width_ub_c;
</span> 
 	if (hratio_l &lt;= 1)
 		min_hratio_fact_l = 2.0;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml/dcn30/display_rq_dlg_calc_30.c b/drivers/gpu/drm/amd/display/dc/dml/dcn30/display_rq_dlg_calc_30.c
index f3ee7baac786..b28fcc8608ff 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/dcn30/display_rq_dlg_calc_30.c
+++ b/drivers/gpu/drm/amd/display/dc/dml/dcn30/display_rq_dlg_calc_30.c
</span><span
class="hunk">@@ -660,13 +660,12 @@ static void get_surf_rq_param(struct display_mode_lib *mode_lib,
</span> 	bool is_chroma,
 	bool is_alpha)
 {
<span
class="del">-	bool mode_422 = 0;
</span> 	unsigned int vp_width = 0;
 	unsigned int vp_height = 0;
 	unsigned int data_pitch = 0;
 	unsigned int meta_pitch = 0;
 	unsigned int surface_height = 0;
<span
class="del">-	unsigned int ppe = mode_422 ? 2 : 1;
</span><span
class="add">+	unsigned int ppe = 1;
</span> 
 	// FIXME check if ppe apply for both luma and chroma in 422 case
 	if (is_chroma | is_alpha) {
<span
class="hunk">@@ -934,7 +933,6 @@ static void dml_rq_dlg_get_dlg_params(struct display_mode_lib *mode_lib,
</span> 	double min_dst_y_ttu_vblank = 0;
 	unsigned int dlg_vblank_start = 0;
 	bool dual_plane = false;
<span
class="del">-	bool mode_422 = false;
</span> 	unsigned int access_dir = 0;
 	unsigned int vp_height_l = 0;
 	unsigned int vp_width_l = 0;
<span
class="hunk">@@ -1083,7 +1081,6 @@ static void dml_rq_dlg_get_dlg_params(struct display_mode_lib *mode_lib,
</span> 	// Source
 	//			 dcc_en			  = src.dcc;
 	dual_plane = is_dual_plane((enum source_format_class)(src-&gt;source_format));
<span
class="del">-	mode_422 = false; // TODO
</span> 	access_dir = (src-&gt;source_scan == dm_vert); // vp access direction: horizontal or vertical accessed
 	vp_height_l = src-&gt;viewport_height;
 	vp_width_l = src-&gt;viewport_width;
<span
class="hunk">@@ -1301,13 +1298,8 @@ static void dml_rq_dlg_get_dlg_params(struct display_mode_lib *mode_lib,
</span> 	dpte_row_height_l = rq_dlg_param.rq_l.dpte_row_height;
 	dpte_row_height_c = rq_dlg_param.rq_c.dpte_row_height;
 
<span
class="del">-	if (mode_422) {
-		swath_width_pixels_ub_l = swath_width_ub_l * 2;  // *2 for 2 pixel per element
-		swath_width_pixels_ub_c = swath_width_ub_c * 2;
-	} else {
-		swath_width_pixels_ub_l = swath_width_ub_l * 1;
-		swath_width_pixels_ub_c = swath_width_ub_c * 1;
-	}
</span><span
class="add">+	swath_width_pixels_ub_l = swath_width_ub_l;
+	swath_width_pixels_ub_c = swath_width_ub_c;
</span> 
 	if (hratio_l &lt;= 1)
 		min_hratio_fact_l = 2.0;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml/dcn31/display_rq_dlg_calc_31.c b/drivers/gpu/drm/amd/display/dc/dml/dcn31/display_rq_dlg_calc_31.c
index b6d954d9aa00..b57b095cd4a8 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/dcn31/display_rq_dlg_calc_31.c
+++ b/drivers/gpu/drm/amd/display/dc/dml/dcn31/display_rq_dlg_calc_31.c
</span><span
class="hunk">@@ -655,13 +655,12 @@ static void get_surf_rq_param(
</span> 		bool is_chroma,
 		bool is_alpha)
 {
<span
class="del">-	bool mode_422 = 0;
</span> 	unsigned int vp_width = 0;
 	unsigned int vp_height = 0;
 	unsigned int data_pitch = 0;
 	unsigned int meta_pitch = 0;
 	unsigned int surface_height = 0;
<span
class="del">-	unsigned int ppe = mode_422 ? 2 : 1;
</span><span
class="add">+	unsigned int ppe = 1;
</span> 
 	// FIXME check if ppe apply for both luma and chroma in 422 case
 	if (is_chroma | is_alpha) {
<span
class="hunk">@@ -888,7 +887,6 @@ static void dml_rq_dlg_get_dlg_params(
</span> 	double min_ttu_vblank;
 	unsigned int dlg_vblank_start;
 	bool dual_plane;
<span
class="del">-	bool mode_422;
</span> 	unsigned int access_dir;
 	unsigned int vp_height_l;
 	unsigned int vp_width_l;
<span
class="hunk">@@ -1004,7 +1002,6 @@ static void dml_rq_dlg_get_dlg_params(
</span> 	// Prefetch Calc
 	// Source
 	dual_plane = is_dual_plane((enum source_format_class) (src-&gt;source_format));
<span
class="del">-	mode_422 = 0;
</span> 	access_dir = (src-&gt;source_scan == dm_vert);	// vp access direction: horizontal or vertical accessed
 	vp_height_l = src-&gt;viewport_height;
 	vp_width_l = src-&gt;viewport_width;
<span
class="hunk">@@ -1142,13 +1139,8 @@ static void dml_rq_dlg_get_dlg_params(
</span> 	dpte_row_height_l = rq_dlg_param-&gt;rq_l.dpte_row_height;
 	dpte_row_height_c = rq_dlg_param-&gt;rq_c.dpte_row_height;
 
<span
class="del">-	if (mode_422) {
-		swath_width_pixels_ub_l = swath_width_ub_l * 2;  // *2 for 2 pixel per element
-		swath_width_pixels_ub_c = swath_width_ub_c * 2;
-	} else {
-		swath_width_pixels_ub_l = swath_width_ub_l * 1;
-		swath_width_pixels_ub_c = swath_width_ub_c * 1;
-	}
</span><span
class="add">+	swath_width_pixels_ub_l = swath_width_ub_l;
+	swath_width_pixels_ub_c = swath_width_ub_c;
</span> 
 	if (hratio_l &lt;= 1)
 		min_hratio_fact_l = 2.0;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml/dcn314/display_rq_dlg_calc_314.c b/drivers/gpu/drm/amd/display/dc/dml/dcn314/display_rq_dlg_calc_314.c
index 94975b0fa398..61b3bebf24c9 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/dcn314/display_rq_dlg_calc_314.c
+++ b/drivers/gpu/drm/amd/display/dc/dml/dcn314/display_rq_dlg_calc_314.c
</span><span
class="hunk">@@ -743,13 +743,12 @@ static void get_surf_rq_param(
</span> 		bool is_chroma,
 		bool is_alpha)
 {
<span
class="del">-	bool mode_422 = 0;
</span> 	unsigned int vp_width = 0;
 	unsigned int vp_height = 0;
 	unsigned int data_pitch = 0;
 	unsigned int meta_pitch = 0;
 	unsigned int surface_height = 0;
<span
class="del">-	unsigned int ppe = mode_422 ? 2 : 1;
</span><span
class="add">+	unsigned int ppe = 1;
</span> 
 	// FIXME check if ppe apply for both luma and chroma in 422 case
 	if (is_chroma | is_alpha) {
<span
class="hunk">@@ -973,7 +972,6 @@ static void dml_rq_dlg_get_dlg_params(
</span> 	double min_ttu_vblank;
 	unsigned int dlg_vblank_start;
 	bool dual_plane;
<span
class="del">-	bool mode_422;
</span> 	unsigned int access_dir;
 	unsigned int vp_height_l;
 	unsigned int vp_width_l;
<span
class="hunk">@@ -1091,7 +1089,6 @@ static void dml_rq_dlg_get_dlg_params(
</span> 	// Prefetch Calc
 	// Source
 	dual_plane = is_dual_plane((enum source_format_class) (src-&gt;source_format));
<span
class="del">-	mode_422 = 0;
</span> 	access_dir = (src-&gt;source_scan == dm_vert);	// vp access direction: horizontal or vertical accessed
 	vp_height_l = src-&gt;viewport_height;
 	vp_width_l = src-&gt;viewport_width;
<span
class="hunk">@@ -1230,13 +1227,8 @@ static void dml_rq_dlg_get_dlg_params(
</span> 	dpte_row_height_l = rq_dlg_param-&gt;rq_l.dpte_row_height;
 	dpte_row_height_c = rq_dlg_param-&gt;rq_c.dpte_row_height;
 
<span
class="del">-	if (mode_422) {
-		swath_width_pixels_ub_l = swath_width_ub_l * 2;  // *2 for 2 pixel per element
-		swath_width_pixels_ub_c = swath_width_ub_c * 2;
-	} else {
-		swath_width_pixels_ub_l = swath_width_ub_l * 1;
-		swath_width_pixels_ub_c = swath_width_ub_c * 1;
-	}
</span><span
class="add">+	swath_width_pixels_ub_l = swath_width_ub_l;
+	swath_width_pixels_ub_c = swath_width_ub_c;
</span> 
 	if (hratio_l &lt;= 1)
 		min_hratio_fact_l = 2.0;
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 02/39] drm/amd/display: Refactor dccg401_get_other_enable_symclk_fe</title><updated>2024-06-20T16:12:44Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-3-alex.hung@amd.com/"/><id>urn:uuid:c63320da-db21-caaa-4c3a-a7f0302b4519</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Relja Vojvodic &lt;relja.vojvodic@amd.com&gt;

[WHY]
Function was used to check the number of FEs connected to the current BE.
This was then used to determine if the symclk could be disabled, if all
FEs were disconnected. However, the function would skip over the primary
FE and return 0 when the primary FE was still connected. This caused black
screens on driver disable with an MST daisy chain hooked up.

[HOW]
Refactored the function to correctly return the number of FEs connected to
the input BE. Also renamed it for clarity.

Reviewed-by: Wenjing Liu &lt;wenjing.liu@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Relja Vojvodic &lt;relja.vojvodic@amd.com&gt;
---
 .../amd/display/dc/dccg/dcn401/dcn401_dccg.c  | 57 +++++++------------
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-3-alex.hung@amd.com/#related">changed</a>, 22 insertions(+), 35 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn401/dcn401_dccg.c b/drivers/gpu/drm/amd/display/dc/dccg/dcn401/dcn401_dccg.c
index 6a467c49b4a4..07f1f396ba52 100644
--- a/drivers/gpu/drm/amd/display/dc/dccg/dcn401/dcn401_dccg.c
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn401/dcn401_dccg.c
</span><span
class="hunk">@@ -853,43 +853,30 @@ static void dccg401_enable_symclk_se(struct dccg *dccg, uint32_t stream_enc_inst
</span> }
 
 /*get other front end connected to this backend*/
<span
class="del">-static uint8_t dccg401_get_other_enabled_symclk_fe(struct dccg *dccg, uint32_t stream_enc_inst, uint32_t link_enc_inst)
</span><span
class="add">+static uint8_t dccg401_get_number_enabled_symclk_fe_connected_to_be(struct dccg *dccg, uint32_t link_enc_inst)
</span> {
 	uint8_t num_enabled_symclk_fe = 0;
<span
class="del">-	uint32_t be_clk_en = 0, fe_clk_en[4] = {0}, be_clk_sel[4] = {0};
</span><span
class="add">+	uint32_t fe_clk_en[4] = {0}, be_clk_sel[4] = {0};
</span> 	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
<span
class="add">+	uint8_t i;
</span> 
<span
class="del">-	switch (link_enc_inst) {
-	case 0:
-		REG_GET_3(SYMCLKA_CLOCK_ENABLE, SYMCLKA_CLOCK_ENABLE, &#38;be_clk_en,
-				SYMCLKA_FE_EN, &#38;fe_clk_en[0],
-				SYMCLKA_FE_SRC_SEL, &#38;be_clk_sel[0]);
-				break;
-	case 1:
-		REG_GET_3(SYMCLKB_CLOCK_ENABLE, SYMCLKB_CLOCK_ENABLE, &#38;be_clk_en,
-				SYMCLKB_FE_EN, &#38;fe_clk_en[1],
-				SYMCLKB_FE_SRC_SEL, &#38;be_clk_sel[1]);
-				break;
-	case 2:
-			REG_GET_3(SYMCLKC_CLOCK_ENABLE, SYMCLKC_CLOCK_ENABLE, &#38;be_clk_en,
-				SYMCLKC_FE_EN, &#38;fe_clk_en[2],
-				SYMCLKC_FE_SRC_SEL, &#38;be_clk_sel[2]);
-				break;
-	case 3:
-			REG_GET_3(SYMCLKD_CLOCK_ENABLE, SYMCLKD_CLOCK_ENABLE, &#38;be_clk_en,
-				SYMCLKD_FE_EN, &#38;fe_clk_en[3],
-				SYMCLKD_FE_SRC_SEL, &#38;be_clk_sel[3]);
-				break;
-	}
-	if (be_clk_en) {
-	/* for DPMST, this backend could be used by multiple front end.
-	only disable the backend if this stream_enc_ins is the last active stream enc connected to this back_end*/
-		uint8_t i;
-		for (i = 0; i != link_enc_inst &#38;&#38; i &lt; ARRAY_SIZE(fe_clk_en); i++) {
-			if (fe_clk_en[i] &#38;&#38; be_clk_sel[i] == link_enc_inst)
-				num_enabled_symclk_fe++;
-		}
</span><span
class="add">+	REG_GET_2(SYMCLKA_CLOCK_ENABLE, SYMCLKA_FE_EN, &#38;fe_clk_en[0],
+			SYMCLKA_FE_SRC_SEL, &#38;be_clk_sel[0]);
+
+	REG_GET_2(SYMCLKB_CLOCK_ENABLE, SYMCLKB_FE_EN, &#38;fe_clk_en[1],
+			SYMCLKB_FE_SRC_SEL, &#38;be_clk_sel[1]);
+
+	REG_GET_2(SYMCLKC_CLOCK_ENABLE, SYMCLKC_FE_EN, &#38;fe_clk_en[2],
+			SYMCLKC_FE_SRC_SEL, &#38;be_clk_sel[2]);
+
+	REG_GET_2(SYMCLKD_CLOCK_ENABLE,	SYMCLKD_FE_EN, &#38;fe_clk_en[3],
+			SYMCLKD_FE_SRC_SEL, &#38;be_clk_sel[3]);
+
+	for (i = 0; i &lt; ARRAY_SIZE(fe_clk_en); i++) {
+		if (fe_clk_en[i] &#38;&#38; be_clk_sel[i] == link_enc_inst)
+			num_enabled_symclk_fe++;
</span> 	}
<span
class="add">+
</span> 	return num_enabled_symclk_fe;
 }
 
<span
class="hunk">@@ -921,9 +908,9 @@ static void dccg401_disable_symclk_se(struct dccg *dccg, uint32_t stream_enc_ins
</span> 		break;
 	}
 
<span
class="del">-	/*check other enabled symclk fe */
-	num_enabled_symclk_fe = dccg401_get_other_enabled_symclk_fe(dccg, stream_enc_inst, link_enc_inst);
-	/*only turn off backend clk if other front end attachecd to this backend are all off,
</span><span
class="add">+	/*check other enabled symclk fe connected to this be */
+	num_enabled_symclk_fe = dccg401_get_number_enabled_symclk_fe_connected_to_be(dccg, link_enc_inst);
+	/*only turn off backend clk if other front ends attached to this backend are all off,
</span> 	 for mst, only turn off the backend if this is the last front end*/
 	if (num_enabled_symclk_fe == 0) {
 		switch (link_enc_inst) {
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 01/39] drm/amd/display: Temporarily disable HPO PG on DCN35</title><updated>2024-06-20T16:12:26Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-2-alex.hung@amd.com/"/><id>urn:uuid:c55238cc-7747-55e7-32e9-6efebb72d7ba</id><thr:in-reply-to
ref="urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb"
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Nicholas Susanto &lt;nicholas.susanto@amd.com&gt;

[WHY]
On hotpluggin a 4k144 HDMI FRL setup, display fails FRL link training
and falls back to TMDS which is caused by driver not ungating HPO before
doing FRL link training.

[HOW]
Enable debug flag to disable HPO power gate in DCN35

Reviewed-by: Nicholas Kazlauskas &lt;nicholas.kazlauskas@amd.com&gt;
Reviewed-by: Charlene Liu &lt;charlene.liu@amd.com&gt;
Acked-by: Alex Hung &lt;alex.hung@amd.com&gt;
Signed-off-by: Nicholas Susanto &lt;nicholas.susanto@amd.com&gt;
---
 drivers/gpu/drm/amd/display/dc/resource/dcn35/dcn35_resource.c | 2 +-
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-2-alex.hung@amd.com/#related">changed</a>, 1 insertion(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/resource/dcn35/dcn35_resource.c b/drivers/gpu/drm/amd/display/dc/resource/dcn35/dcn35_resource.c
index 0094ef223c5d..67ab8c1962ff 100644
--- a/drivers/gpu/drm/amd/display/dc/resource/dcn35/dcn35_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/resource/dcn35/dcn35_resource.c
</span><span
class="hunk">@@ -721,7 +721,7 @@ static const struct dc_debug_options debug_defaults_drv = {
</span> 	.disable_dpp_power_gate = true,
 	.disable_hubp_power_gate = true,
 	.disable_optc_power_gate = true, /*should the same as above two*/
<span
class="del">-	.disable_hpo_power_gate = false, /*dmubfw force domain25 on*/
</span><span
class="add">+	.disable_hpo_power_gate = true, /*dmubfw force domain25 on*/
</span> 	.disable_clock_gate = false,
 	.disable_dsc_power_gate = true,
 	.vsr_support = true,
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Alex Hung</name><email>alex.hung@amd.com</email></author><title>[PATCH 00/39] DC Patches June 20, 2024</title><updated>2024-06-20T16:12:24Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620161145.2489774-1-alex.hung@amd.com/"/><id>urn:uuid:4a4b4c3b-56cc-5a09-759a-4ed6f9dbc7fb</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This DC patchset brings improvements in multiple areas. In summary, we highlight:

* Enable DCC on DCN401
* Fix cursor issues
* Misc Coverity fixes

Cc: Daniel Wheeler &lt;daniel.wheeler@amd.com&gt;

Alex Hung (12):
  drm/amd/display: Remove redundant checks for pipe_ctx-&gt;stream
  drm/amd/display: Run DC_LOG_DC after checking link-&gt;link_enc
  drm/amd/display: Fix uninitialized variables in dcn401
  drm/amd/display: Remove useless function call
  drm/amd/display: Check and log for function error codes
  drm/amd/display: Check and log for function error codes
  drm/amd/display: Check HDCP returned status
  drm/amd/display: Add null checks before accessing struct elements
  drm/amd/display: Ensure curve to hw translation succeed
  drm/amd/display: Validate function returns
  drm/amd/display: Remove always true condition
  drm/amd/display: Remove duplicate null check

Alvin Lee (2):
  drm/amd/display: Program CURSOR_DST_X_OFFSET in viewport space
  drm/amd/display: Wait for double buffer update on ODM changes

Aric Cyr (1):
  drm/amd/display: 3.2.290

Aurabindo Pillai (3):
  drm/amd/display: Use sw cursor for DCN401 with rotation
  drm/amd: Add reg definitions for DCN401 DCC
  drm/amd/display: Enable DCC on DCN401

Daniel Sa (1):
  drm/amd/display: Fix reduced resolution and refresh rate

Dillon Varone (1):
  drm/amd/display: Make DML2.1 P-State method force per stream

Duncan Ma (1):
  drm/amd/display: Reset DSC memory status

George Shen (1):
  drm/amd/display: Call dpmm when checking mode support

Ivan Lipski (2):
  drm/amd/display: Remove redundant var from display_rq_dig_calc in dml
  drm/amd/display: Remove unnecessary variable

Joan Lee (1):
  drm/amd/display: Add Replay general cmd

Leo (Hanghong) Ma (1):
  drm/amd/display: Always enable HPO for DCN4 dGPU

Michael Strauss (1):
  drm/amd/display: Send DP_TOTAL_LTTPR_CNT during detection if LTTPR is
    present

Nevenko Stupar (3):
  drm/amd/display: Fix cursor issues with ODMs and HW rotations
  drm/amd/display: Fix cursor size issues
  drm/amd/display: Fix cursor issues with ODMs and magnification

Nicholas Susanto (1):
  drm/amd/display: Temporarily disable HPO PG on DCN35

Relja Vojvodic (2):
  drm/amd/display: Refactor dccg401_get_other_enable_symclk_fe
  drm/amd/display: Fix 1DLUT setting for NL SDR blending

Roman Li (1):
  drm/amd/display: Use periodic detection for ipx/headless

Ryan Seto (2):
  drm/amd/display: Add HW cursor visual confirm
  drm/amd/display: Adjust reg field for DSC wait for disconnect

Sung-huai Wang (1):
  drm/amd/display: Add workaround to restrict max frac urgent for DPM0

TungYu Lu (1):
  drm/amd/display: resync OTG after DIO FIFO resync

Wenjing Liu (1):
  drm/amd/display: Remove a redundant check in authenticated_dp

 .../gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c |  39 ++-
 .../gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h |   3 +
 .../amd/display/amdgpu_dm/amdgpu_dm_crtc.c    |  48 ++-
 .../amd/display/amdgpu_dm/amdgpu_dm_debugfs.c |   5 +-
 .../amd/display/amdgpu_dm/amdgpu_dm_helpers.c |   5 +-
 .../drm/amd/display/dc/bios/command_table2.c  |   3 +-
 .../dc/clk_mgr/dcn201/dcn201_clk_mgr.c        |   2 -
 .../display/dc/clk_mgr/dcn32/dcn32_clk_mgr.c  |  10 +-
 .../dc/clk_mgr/dcn401/dcn401_clk_mgr.c        |  10 +-
 drivers/gpu/drm/amd/display/dc/core/dc.c      |  12 +
 .../drm/amd/display/dc/core/dc_hw_sequencer.c |  11 +
 .../gpu/drm/amd/display/dc/core/dc_stream.c   |  29 ++
 drivers/gpu/drm/amd/display/dc/dc.h           |   9 +-
 drivers/gpu/drm/amd/display/dc/dc_dmub_srv.c  |   7 +-
 drivers/gpu/drm/amd/display/dc/dc_types.h     |   1 +
 .../amd/display/dc/dccg/dcn401/dcn401_dccg.c  |  57 ++--
 .../drm/amd/display/dc/dce/dce_link_encoder.c |   5 +-
 .../gpu/drm/amd/display/dc/dce/dmub_replay.c  |  18 +-
 .../amd/display/dc/dcn10/dcn10_link_encoder.c |   8 +-
 .../drm/amd/display/dc/dml/dcn20/dcn20_fpu.c  |   2 +-
 .../dc/dml/dcn20/display_rq_dlg_calc_20.c     |  14 +-
 .../dc/dml/dcn20/display_rq_dlg_calc_20v2.c   |  14 +-
 .../dc/dml/dcn21/display_rq_dlg_calc_21.c     |  14 +-
 .../dc/dml/dcn30/display_rq_dlg_calc_30.c     |  14 +-
 .../dc/dml/dcn31/display_rq_dlg_calc_31.c     |  14 +-
 .../dc/dml/dcn314/display_rq_dlg_calc_314.c   |  14 +-
 .../dc/dml2/dml21/dml21_translation_helper.c  |   2 +-
 .../amd/display/dc/dml2/dml21/dml21_wrapper.c |   4 +-
 .../src/dml2_core/dml2_core_dcn4_calcs.c      |   4 +-
 .../dc/dml2/dml21/src/dml2_top/dml_top.c      |  17 ++
 .../src/inc/dml2_internal_shared_types.h      |   1 +
 .../drm/amd/display/dc/dml2/dml2_wrapper.c    |  29 +-
 .../drm/amd/display/dc/dml2/dml2_wrapper.h    |   6 +-
 .../amd/display/dc/dpp/dcn401/dcn401_dpp_cm.c |  50 ----
 .../drm/amd/display/dc/dsc/dcn20/dcn20_dsc.c  |  24 +-
 .../drm/amd/display/dc/dsc/dcn20/dcn20_dsc.h  |  13 +-
 .../drm/amd/display/dc/dsc/dcn35/dcn35_dsc.c  |  58 +++-
 .../amd/display/dc/dsc/dcn401/dcn401_dsc.c    |   2 +-
 .../amd/display/dc/dsc/dcn401/dcn401_dsc.h    |   3 +-
 .../display/dc/hubbub/dcn20/dcn20_hubbub.c    |   3 +-
 .../display/dc/hubbub/dcn30/dcn30_hubbub.c    |   3 +
 .../display/dc/hubbub/dcn31/dcn31_hubbub.c    |   3 +
 .../display/dc/hubbub/dcn401/dcn401_hubbub.c  | 280 ++++++++++++++++++
 .../display/dc/hubbub/dcn401/dcn401_hubbub.h  |   5 +
 .../amd/display/dc/hubp/dcn20/dcn20_hubp.h    |  14 +
 .../amd/display/dc/hubp/dcn401/dcn401_hubp.c  |  71 ++---
 .../amd/display/dc/hubp/dcn401/dcn401_hubp.h  |  14 +-
 .../amd/display/dc/hwss/dcn10/dcn10_hwseq.c   |  17 --
 .../amd/display/dc/hwss/dcn20/dcn20_hwseq.c   |  34 ++-
 .../amd/display/dc/hwss/dcn30/dcn30_hwseq.c   |   5 +-
 .../amd/display/dc/hwss/dcn32/dcn32_hwseq.c   |  11 +-
 .../amd/display/dc/hwss/dcn401/dcn401_hwseq.c | 169 ++++-------
 .../amd/display/dc/hwss/dcn401/dcn401_hwseq.h |   2 +
 .../amd/display/dc/hwss/dcn401/dcn401_init.c  |   2 +-
 .../drm/amd/display/dc/hwss/hw_sequencer.h    |   9 +
 .../gpu/drm/amd/display/dc/inc/core_types.h   |   3 +
 .../gpu/drm/amd/display/dc/inc/hw/dchubbub.h  |   4 +
 drivers/gpu/drm/amd/display/dc/inc/hw/hubp.h  |   1 +
 .../amd/display/dc/inc/hw/timing_generator.h  |   1 +
 .../display/dc/link/accessories/link_dp_cts.c |   2 +-
 .../drm/amd/display/dc/link/link_factory.c    |   6 +-
 .../dc/link/protocols/link_dp_capability.c    |  31 +-
 .../dc/link/protocols/link_dp_training.c      |   3 +-
 .../amd/display/dc/optc/dcn10/dcn10_optc.h    |   3 +-
 .../amd/display/dc/optc/dcn32/dcn32_optc.c    |  13 +
 .../amd/display/dc/optc/dcn32/dcn32_optc.h    |   2 +
 .../amd/display/dc/optc/dcn401/dcn401_optc.c  |   1 +
 .../amd/display/dc/optc/dcn401/dcn401_optc.h  |   1 +
 .../dc/resource/dcn35/dcn35_resource.c        |   5 +-
 .../dc/resource/dcn401/dcn401_resource.c      |   9 +
 .../dc/resource/dcn401/dcn401_resource.h      |   2 +
 .../gpu/drm/amd/display/include/dpcd_defs.h   |   5 +
 .../display/modules/hdcp/hdcp1_execution.c    |  24 +-
 .../drm/amd/display/modules/hdcp/hdcp_psp.c   |   3 -
 .../include/asic_reg/dcn/dcn_4_1_0_sh_mask.h  | 110 +++++++
 75 files changed, 1021 insertions(+), 431 deletions(-)

-- 
2.34.1

</pre></div></content></entry><entry><author><name>Thomas Zimmermann</name><email>tzimmermann@suse.de</email></author><title>[PATCH 2/2] drm/amdgpu: Convert to ttm_bo_vmap() et al</title><updated>2024-06-20T14:52:51Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620145238.25295-3-tzimmermann@suse.de/"/><id>urn:uuid:f8d362fd-fcd8-0bfa-fdd9-13610474d964</id><thr:in-reply-to
ref="urn:uuid:768ed581-7ccd-148b-feb8-fa5097260af5"
href="http://lore.kernel.org/amd-gfx/20240620145238.25295-1-tzimmermann@suse.de/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Replace each call to ttm_bo_kmap() with a call to ttm_bo_vmap().
Same for ttm_bo_kunmap() and ttm_bo_vunmap(). There&#39;s now one less
driver depending on the deprecated ttm_bo_kmap().

Also allows for dropping struct ttm_bo_kmap_obj in favor of struct
iosys_map, which is the preferred representation of BO memory mappings.
Manual type conversion in amdgpu_bo_kptr() is required to make the
returned pointer usable within amdgpu. In a follow-up patch, amdgpu
should be convert to use struct iosys_map directly.

Signed-off-by: Thomas Zimmermann &lt;tzimmermann@suse.de&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_object.c | 16 ++++++++++------
 drivers/gpu/drm/amd/amdgpu/amdgpu_object.h |  4 +++-
 2 files <a href="http://lore.kernel.org/amd-gfx/20240620145238.25295-3-tzimmermann@suse.de/#related">changed</a>, 13 insertions(+), 7 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
index d58b11ea0ead5..baa60e25c13e1 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
</span><span
class="hunk">@@ -62,7 +62,7 @@ static void amdgpu_bo_destroy(struct ttm_buffer_object *tbo)
</span> 	 * BO memory pages should be unmapped at this point. Call
 	 * amdgpu_bo_kunmap() before releasing the BO.
 	 */
<span
class="del">-	if (drm_WARN_ON_ONCE(bo-&gt;tbo.base.dev, bo-&gt;kmap.bo))
</span><span
class="add">+	if (drm_WARN_ON_ONCE(bo-&gt;tbo.base.dev, !iosys_map_is_null(&#38;bo-&gt;map)))
</span> 		amdgpu_bo_kunmap(bo);
 
 	if (bo-&gt;tbo.base.import_attach)
<span
class="hunk">@@ -802,7 +802,7 @@ int amdgpu_bo_kmap(struct amdgpu_bo *bo, void **ptr)
</span> 		return 0;
 	}
 
<span
class="del">-	r = ttm_bo_kmap(&#38;bo-&gt;tbo, 0, PFN_UP(bo-&gt;tbo.base.size), &#38;bo-&gt;kmap);
</span><span
class="add">+	r = ttm_bo_vmap(&#38;bo-&gt;tbo, &#38;bo-&gt;map);
</span> 	if (r)
 		return r;
 
<span
class="hunk">@@ -823,9 +823,12 @@ int amdgpu_bo_kmap(struct amdgpu_bo *bo, void **ptr)
</span>  */
 void *amdgpu_bo_kptr(struct amdgpu_bo *bo)
 {
<span
class="del">-	bool is_iomem;
</span><span
class="add">+	if (iosys_map_is_null(&#38;bo-&gt;map))
+		return NULL;
+	if (bo-&gt;map.is_iomem)
+		return (void __force *)bo-&gt;map.vaddr_iomem;
</span> 
<span
class="del">-	return ttm_kmap_obj_virtual(&#38;bo-&gt;kmap, &#38;is_iomem);
</span><span
class="add">+	return bo-&gt;map.vaddr;
</span> }
 
 /**
<span
class="hunk">@@ -836,8 +839,9 @@ void *amdgpu_bo_kptr(struct amdgpu_bo *bo)
</span>  */
 void amdgpu_bo_kunmap(struct amdgpu_bo *bo)
 {
<span
class="del">-	if (bo-&gt;kmap.bo)
-		ttm_bo_kunmap(&#38;bo-&gt;kmap);
</span><span
class="add">+	if (iosys_map_is_null(&#38;bo-&gt;map))
+		return;
+	ttm_bo_vunmap(&#38;bo-&gt;tbo, &#38;bo-&gt;map);
</span> }
 
 /**
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h
index bc42ccbde659a..553a92303339f 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h
</span><span
class="hunk">@@ -28,6 +28,8 @@
</span> #ifndef __AMDGPU_OBJECT_H__
 #define __AMDGPU_OBJECT_H__
 
<span
class="add">+#include &lt;linux/iosys-map.h&gt;
+
</span> #include &lt;drm/amdgpu_drm.h&gt;
 #include &#34;amdgpu.h&#34;
 #include &#34;amdgpu_res_cursor.h&#34;
<span
class="hunk">@@ -99,7 +101,7 @@ struct amdgpu_bo {
</span> 	struct ttm_place		placements[AMDGPU_BO_MAX_PLACEMENTS];
 	struct ttm_placement		placement;
 	struct ttm_buffer_object	tbo;
<span
class="del">-	struct ttm_bo_kmap_obj		kmap;
</span><span
class="add">+	struct iosys_map		map;
</span> 	u64				flags;
 	/* per VM structure for page tables and with virtual addresses */
 	struct amdgpu_vm_bo_base	*vm_bo;
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Thomas Zimmermann</name><email>tzimmermann@suse.de</email></author><title>[RFC PATCH 0/2] drm/amdgpu: Convert to ttm_bo_vmap()</title><updated>2024-06-20T14:52:47Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620145238.25295-1-tzimmermann@suse.de/"/><id>urn:uuid:768ed581-7ccd-148b-feb8-fa5097260af5</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Convert amdgpu to use ttm_bo_vmap() instead of ttm_bo_kmap(). The
latter is deprecated. Passing ttm_bo_vmap()&#39;s locking validation 
requires to remove the implicit unmap from the BO release path.

Smoke-tested with an Radeon RX 460.

There&#39;s similar patchset for xe at [1], which requires additional
changes.

[1] <a
href="https://lore.kernel.org/dri-devel/20240614133556.11378-1-tzimmermann@suse.de/">https://lore.kernel.org/dri-devel/20240614133556.11378-1-tzimmermann@suse.de/</a>

Thomas Zimmermann (2):
  drm/amdgpu: Unmap BO memory before calling amdgpu_bo_unref()
  drm/amdgpu: Convert to ttm_bo_vmap() et al

 drivers/gpu/drm/amd/amdgpu/amdgpu_object.c | 25 ++++++++++++++--------
 drivers/gpu/drm/amd/amdgpu/amdgpu_object.h |  4 +++-
 2 files changed, 19 insertions(+), 10 deletions(-)

-- 
2.45.2

</pre></div></content></entry><entry><author><name>Thomas Zimmermann</name><email>tzimmermann@suse.de</email></author><title>[PATCH 1/2] drm/amdgpu: Unmap BO memory before calling amdgpu_bo_unref()</title><updated>2024-06-20T14:52:52Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620145238.25295-2-tzimmermann@suse.de/"/><id>urn:uuid:7d6bfb04-bdbb-39b3-9a6b-99036d3de903</id><thr:in-reply-to
ref="urn:uuid:768ed581-7ccd-148b-feb8-fa5097260af5"
href="http://lore.kernel.org/amd-gfx/20240620145238.25295-1-tzimmermann@suse.de/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Prepares for using ttm_bo_vmap() and ttm_bo_vunmap() in amdgpu. Both
require the caller to hold the GEM reservation lock, which is not the
case while releasing a buffer object. Hence, push a possible call to
unmap out from the buffer-object release code. Warn if a buffer object
with mapped pages is supposed to be released.

Signed-off-by: Thomas Zimmermann &lt;tzimmermann@suse.de&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_object.c | 11 +++++++----
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620145238.25295-2-tzimmermann@suse.de/#related">changed</a>, 7 insertions(+), 4 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
index a1b7438c43dc8..d58b11ea0ead5 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
</span><span
class="hunk">@@ -58,7 +58,12 @@ static void amdgpu_bo_destroy(struct ttm_buffer_object *tbo)
</span> {
 	struct amdgpu_bo *bo = ttm_to_amdgpu_bo(tbo);
 
<span
class="del">-	amdgpu_bo_kunmap(bo);
</span><span
class="add">+	/*
+	 * BO memory pages should be unmapped at this point. Call
+	 * amdgpu_bo_kunmap() before releasing the BO.
+	 */
+	if (drm_WARN_ON_ONCE(bo-&gt;tbo.base.dev, bo-&gt;kmap.bo))
+		amdgpu_bo_kunmap(bo);
</span> 
 	if (bo-&gt;tbo.base.import_attach)
 		drm_prime_gem_destroy(&#38;bo-&gt;tbo.base, bo-&gt;tbo.sg);
<span
class="hunk">@@ -450,9 +455,7 @@ void amdgpu_bo_free_kernel(struct amdgpu_bo **bo, u64 *gpu_addr,
</span> 	WARN_ON(amdgpu_ttm_adev((*bo)-&gt;tbo.bdev)-&gt;in_suspend);
 
 	if (likely(amdgpu_bo_reserve(*bo, true) == 0)) {
<span
class="del">-		if (cpu_addr)
-			amdgpu_bo_kunmap(*bo);
-
</span><span
class="add">+		amdgpu_bo_kunmap(*bo);
</span> 		amdgpu_bo_unpin(*bo);
 		amdgpu_bo_unreserve(*bo);
 	}
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Min, Frank</name><email>Frank.Min@amd.com</email></author><title>[PATCH] drm/amdgpu: update gfxhub client id for gfx12</title><updated>2024-06-20T14:15:09Z</updated><link
href="http://lore.kernel.org/amd-gfx/SA3PR12MB7902C19B353CA08B038A7F08E9C82@SA3PR12MB7902.namprd12.prod.outlook.com/"/><id>urn:uuid:da4a951e-7704-5ada-4a41-d0192ca9a982</id><thr:in-reply-to
ref="urn:uuid:71a2e136-d582-00f9-e2d7-9b2e1db8b842"
href="http://lore.kernel.org/amd-gfx/SA1PR12MB5659B0EAF1A7F230F5875C73E9C82@SA1PR12MB5659.namprd12.prod.outlook.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[AMD Official Use Only - AMD Internal Distribution Only]

From: Frank Min &lt;Frank.Min@amd.com&gt;

update gfxhub client id for gfx12

Signed-off-by: Frank Min &lt;Frank.Min@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/gfxhub_v12_0.c | 22 +++++++++++++++++++++-
 1 file <a href="http://lore.kernel.org/amd-gfx/SA3PR12MB7902C19B353CA08B038A7F08E9C82@SA3PR12MB7902.namprd12.prod.outlook.com/#related">changed</a>, 21 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gfxhub_v12_0.c b/drivers/gpu/drm/amd/amdgpu/gfxhub_v12_0.c
index 7ea64f1e1e48..7609b9cecae8 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfxhub_v12_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfxhub_v12_0.c
</span><span
class="hunk">@@ -35,7 +35,27 @@
</span> #define regGRBM_GFX_INDEX_DEFAULT      0xe0000000

 static const char *gfxhub_client_ids[] = {
<span
class="del">-       /* TODO */
</span><span
class="add">+       &#34;CB&#34;,
+       &#34;DB&#34;,
+       &#34;GE1&#34;,
+       &#34;GE2&#34;,
+       &#34;CPF&#34;,
+       &#34;CPC&#34;,
+       &#34;CPG&#34;,
+       &#34;RLC&#34;,
+       &#34;TCP&#34;,
+       &#34;SQC (inst)&#34;,
+       &#34;SQC (data)&#34;,
+       &#34;SQG/PC/SC&#34;,
+       &#34;Reserved&#34;,
+       &#34;SDMA0&#34;,
+       &#34;SDMA1&#34;,
+       &#34;GCR&#34;,
+       &#34;Reserved&#34;,
+       &#34;Reserved&#34;,
+       &#34;WGS&#34;,
+       &#34;DSM&#34;,
+       &#34;PA&#34;
</span> };

 static uint32_t gfxhub_v12_0_get_invalidate_req(unsigned int vmid,
<span
class="del">--
</span>2.34.1

</pre></div></content></entry><entry><author><name>Danijel Slivka</name><email>danijel.slivka@amd.com</email></author><title>[PATCH] drm/amdgpu: clear IH_RB_W/RPTR during enabling interrupts in sriov case</title><updated>2024-06-20T13:46:49Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620135521.230223-1-danijel.slivka@amd.com/"/><id>urn:uuid:2403df9e-7e0a-045e-e401-7d7a42d3d96d</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Clearing the IH_RB_W/RPTR during interrupts disable is not clearing
the RB_OVERFLOW bit.
Adding workaround to clear the wptr when enabling interrupts in case
RB_OVERFLOW bit is set.

Signed-off-by: Danijel Slivka &lt;danijel.slivka@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/ih_v6_0.c | 6 ++++++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620135521.230223-1-danijel.slivka@amd.com/#related">changed</a>, 6 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/ih_v6_0.c b/drivers/gpu/drm/amd/amdgpu/ih_v6_0.c
index 3cb64c8f7175..d6212a98ca99 100644
--- a/drivers/gpu/drm/amd/amdgpu/ih_v6_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/ih_v6_0.c
</span><span
class="hunk">@@ -147,6 +147,12 @@ static int ih_v6_0_toggle_ring_interrupts(struct amdgpu_device *adev,
</span> 	}
 
 	if (enable) {
<span
class="add">+		if (amdgpu_sriov_vf(adev) &#38;&#38;
+		    REG_GET_FIELD(RREG32(ih_regs-&gt;ih_rb_wptr), IH_RB_WPTR, RB_OVERFLOW)) {
+			/* clear rptr, wptr*/
+			WREG32(ih_regs-&gt;ih_rb_rptr, 0);
+			WREG32(ih_regs-&gt;ih_rb_wptr, 0);
+		}
</span> 		ih-&gt;enabled = true;
 	} else {
 		/* set rptr, wptr to 0 */
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Jane Jian</name><email>Jane.Jian@amd.com</email></author><title>[PATCH] drm/amdgpu: normalize registers as local xcc to read/write under sriov in TLB flush</title><updated>2024-06-20T13:41:40Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620134132.1736532-1-Jane.Jian@amd.com/"/><id>urn:uuid:284d81aa-7afa-2f39-62d4-b7daf4898cda</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHY]
sriov has the higher bit violation when flushing tlb

[HOW]
normalize the registers to keep lower 16-bit(dword aligned) to aviod higher bit violation
RLCG will mask xcd out and always assume it&#39;s accessing its own xcd

[TODO]
later will add the normalization in sriovw/rreg after fixing bugs

v2
rename the normalized macro, add ip block type for further use
move asics func declaration after ip block type since new func
refers ip block type

Signed-off-by: Jane Jian &lt;Jane.Jian@amd.com&gt;
---
 amdgpu.h        | 112 +++++++++++----------
 aqua_vanjaram.c |  16 +++
 gmc_v9_0.c      |   8 +-
 soc15.c         |   1 +
 soc15.h         |   1 +
 soc15_common.h  |   5 +-
 6 files <a href="http://lore.kernel.org/amd-gfx/20240620134132.1736532-1-Jane.Jian@amd.com/#related">changed</a>, 85 insertions(+), 58 deletions(-)

<span
class="head">diff --git a/amdgpu.h b/amdgpu.h
index 083f353cff6e..070fd9e601fe 100644
--- a/amdgpu.h
+++ b/amdgpu.h
</span><span
class="hunk">@@ -583,61 +583,6 @@ struct amdgpu_video_codecs {
</span> 	const struct amdgpu_video_codec_info *codec_array;
 };
 
<span
class="del">-/*
- * ASIC specific functions.
- */
-struct amdgpu_asic_funcs {
-	bool (*read_disabled_bios)(struct amdgpu_device *adev);
-	bool (*read_bios_from_rom)(struct amdgpu_device *adev,
-				   u8 *bios, u32 length_bytes);
-	int (*read_register)(struct amdgpu_device *adev, u32 se_num,
-			     u32 sh_num, u32 reg_offset, u32 *value);
-	void (*set_vga_state)(struct amdgpu_device *adev, bool state);
-	int (*reset)(struct amdgpu_device *adev);
-	enum amd_reset_method (*reset_method)(struct amdgpu_device *adev);
-	/* get the reference clock */
-	u32 (*get_xclk)(struct amdgpu_device *adev);
-	/* MM block clocks */
-	int (*set_uvd_clocks)(struct amdgpu_device *adev, u32 vclk, u32 dclk);
-	int (*set_vce_clocks)(struct amdgpu_device *adev, u32 evclk, u32 ecclk);
-	/* static power management */
-	int (*get_pcie_lanes)(struct amdgpu_device *adev);
-	void (*set_pcie_lanes)(struct amdgpu_device *adev, int lanes);
-	/* get config memsize register */
-	u32 (*get_config_memsize)(struct amdgpu_device *adev);
-	/* flush hdp write queue */
-	void (*flush_hdp)(struct amdgpu_device *adev, struct amdgpu_ring *ring);
-	/* invalidate hdp read cache */
-	void (*invalidate_hdp)(struct amdgpu_device *adev,
-			       struct amdgpu_ring *ring);
-	/* check if the asic needs a full reset of if soft reset will work */
-	bool (*need_full_reset)(struct amdgpu_device *adev);
-	/* initialize doorbell layout for specific asic*/
-	void (*init_doorbell_index)(struct amdgpu_device *adev);
-	/* PCIe bandwidth usage */
-	void (*get_pcie_usage)(struct amdgpu_device *adev, uint64_t *count0,
-			       uint64_t *count1);
-	/* do we need to reset the asic at init time (e.g., kexec) */
-	bool (*need_reset_on_init)(struct amdgpu_device *adev);
-	/* PCIe replay counter */
-	uint64_t (*get_pcie_replay_count)(struct amdgpu_device *adev);
-	/* device supports BACO */
-	int (*supports_baco)(struct amdgpu_device *adev);
-	/* pre asic_init quirks */
-	void (*pre_asic_init)(struct amdgpu_device *adev);
-	/* enter/exit umd stable pstate */
-	int (*update_umd_stable_pstate)(struct amdgpu_device *adev, bool enter);
-	/* query video codecs */
-	int (*query_video_codecs)(struct amdgpu_device *adev, bool encode,
-				  const struct amdgpu_video_codecs **codecs);
-	/* encode &#34;&gt; 32bits&#34; smn addressing */
-	u64 (*encode_ext_smn_addressing)(int ext_id);
-
-	ssize_t (*get_reg_state)(struct amdgpu_device *adev,
-				 enum amdgpu_reg_state reg_state, void *buf,
-				 size_t max_size);
-};
-
</span> /*
  * IOCTL.
  */
<span
class="hunk">@@ -728,6 +673,63 @@ enum amd_hw_ip_block_type {
</span> 	MAX_HWIP
 };
 
<span
class="add">+/*
+ * ASIC specific functions.
+ */
+struct amdgpu_asic_funcs {
+	bool (*read_disabled_bios)(struct amdgpu_device *adev);
+	bool (*read_bios_from_rom)(struct amdgpu_device *adev,
+				   u8 *bios, u32 length_bytes);
+	int (*read_register)(struct amdgpu_device *adev, u32 se_num,
+			     u32 sh_num, u32 reg_offset, u32 *value);
+	void (*set_vga_state)(struct amdgpu_device *adev, bool state);
+	int (*reset)(struct amdgpu_device *adev);
+	enum amd_reset_method (*reset_method)(struct amdgpu_device *adev);
+	/* get the reference clock */
+	u32 (*get_xclk)(struct amdgpu_device *adev);
+	/* MM block clocks */
+	int (*set_uvd_clocks)(struct amdgpu_device *adev, u32 vclk, u32 dclk);
+	int (*set_vce_clocks)(struct amdgpu_device *adev, u32 evclk, u32 ecclk);
+	/* static power management */
+	int (*get_pcie_lanes)(struct amdgpu_device *adev);
+	void (*set_pcie_lanes)(struct amdgpu_device *adev, int lanes);
+	/* get config memsize register */
+	u32 (*get_config_memsize)(struct amdgpu_device *adev);
+	/* flush hdp write queue */
+	void (*flush_hdp)(struct amdgpu_device *adev, struct amdgpu_ring *ring);
+	/* invalidate hdp read cache */
+	void (*invalidate_hdp)(struct amdgpu_device *adev,
+			       struct amdgpu_ring *ring);
+	/* check if the asic needs a full reset of if soft reset will work */
+	bool (*need_full_reset)(struct amdgpu_device *adev);
+	/* initialize doorbell layout for specific asic*/
+	void (*init_doorbell_index)(struct amdgpu_device *adev);
+	/* PCIe bandwidth usage */
+	void (*get_pcie_usage)(struct amdgpu_device *adev, uint64_t *count0,
+			       uint64_t *count1);
+	/* do we need to reset the asic at init time (e.g., kexec) */
+	bool (*need_reset_on_init)(struct amdgpu_device *adev);
+	/* PCIe replay counter */
+	uint64_t (*get_pcie_replay_count)(struct amdgpu_device *adev);
+	/* device supports BACO */
+	int (*supports_baco)(struct amdgpu_device *adev);
+	/* pre asic_init quirks */
+	void (*pre_asic_init)(struct amdgpu_device *adev);
+	/* enter/exit umd stable pstate */
+	int (*update_umd_stable_pstate)(struct amdgpu_device *adev, bool enter);
+	/* query video codecs */
+	int (*query_video_codecs)(struct amdgpu_device *adev, bool encode,
+				  const struct amdgpu_video_codecs **codecs);
+	/* encode &#34;&gt; 32bits&#34; smn addressing */
+	u64 (*encode_ext_smn_addressing)(int ext_id);
+
+	ssize_t (*get_reg_state)(struct amdgpu_device *adev,
+				 enum amdgpu_reg_state reg_state, void *buf,
+				 size_t max_size);
+	/* normalize offset to keep in lower 16-bit */
+	u32 (*normalize_reg_offset)(enum amd_hw_ip_block_type hwip, u32 offset);
+};
+
</span> #define HWIP_MAX_INSTANCE	44
 
 #define HW_ID_MAX		300
<span
class="head">diff --git a/aqua_vanjaram.c b/aqua_vanjaram.c
index 2c9a0aa41e2d..98b00c0e522f 100644
--- a/aqua_vanjaram.c
+++ b/aqua_vanjaram.c
</span><span
class="hunk">@@ -1085,3 +1085,19 @@ ssize_t aqua_vanjaram_get_reg_state(struct amdgpu_device *adev,
</span> 
 	return size;
 }
<span
class="add">+
+u32 aqua_vanjaram_normalize_reg_offset(enum amd_hw_ip_block_type hwip, u32 offset)
+{
+	u32 normalized_offset;
+
+	switch (hwip) {
+	case GC_HWIP:
+		normalized_offset = offset &#38; 0xffff;
+		break;
+	default:
+		normalized_offset = offset;
+		break;
+	}
+
+	return normalized_offset;
+}
</span><span
class="head">diff --git a/gmc_v9_0.c b/gmc_v9_0.c
index 88b4644f8e96..66fd229c196a 100644
--- a/gmc_v9_0.c
+++ b/gmc_v9_0.c
</span><span
class="hunk">@@ -853,8 +853,12 @@ static void gmc_v9_0_flush_gpu_tlb(struct amdgpu_device *adev, uint32_t vmid,
</span> 	 */
 	if (adev-&gt;gfx.kiq[inst].ring.sched.ready &#38;&#38;
 	    (amdgpu_sriov_runtime(adev) || !amdgpu_sriov_vf(adev))) {
<span
class="del">-		uint32_t req = hub-&gt;vm_inv_eng0_req + hub-&gt;eng_distance * eng;
-		uint32_t ack = hub-&gt;vm_inv_eng0_ack + hub-&gt;eng_distance * eng;
</span><span
class="add">+
+		/* Select lower 16 bits to write in local xcc */
+		if (AMDGPU_IS_GFXHUB(vmhub)) {
+			req = NORMALIZE_XCC_REG_OFFSET(GC, req);
+			ack = NORMALIZE_XCC_REG_OFFSET(GC, ack);
+		}
</span> 
 		amdgpu_gmc_fw_reg_write_reg_wait(adev, req, ack, inv_req,
 						 1 &lt;&lt; vmid, inst);
<span
class="head">diff --git a/soc15.c b/soc15.c
index 8d16dacdc172..e6e61fc77080 100644
--- a/soc15.c
+++ b/soc15.c
</span><span
class="hunk">@@ -927,6 +927,7 @@ static const struct amdgpu_asic_funcs aqua_vanjaram_asic_funcs =
</span> 	.query_video_codecs = &#38;soc15_query_video_codecs,
 	.encode_ext_smn_addressing = &#38;aqua_vanjaram_encode_ext_smn_addressing,
 	.get_reg_state = &#38;aqua_vanjaram_get_reg_state,
<span
class="add">+	.normalize_reg_offset = &#38;aqua_vanjaram_normalize_reg_offset,
</span> };
 
 static int soc15_common_early_init(void *handle)
<span
class="head">diff --git a/soc15.h b/soc15.h
index 282584a48be0..f1e974604e3e 100644
--- a/soc15.h
+++ b/soc15.h
</span><span
class="hunk">@@ -124,4 +124,5 @@ ssize_t aqua_vanjaram_get_reg_state(struct amdgpu_device *adev,
</span> void vega10_doorbell_index_init(struct amdgpu_device *adev);
 void vega20_doorbell_index_init(struct amdgpu_device *adev);
 void aqua_vanjaram_doorbell_index_init(struct amdgpu_device *adev);
<span
class="add">+u32 aqua_vanjaram_normalize_reg_offset(u32 hwip, u32 offset);
</span> #endif
<span
class="head">diff --git a/soc15_common.h b/soc15_common.h
index 242b24f73c17..ddf0aad51821 100644
--- a/soc15_common.h
+++ b/soc15_common.h
</span><span
class="hunk">@@ -210,4 +210,7 @@
</span> #define WREG64_MCA(ext, mca_base, idx, val) \
 	WREG64_PCIE_EXT(adev-&gt;asic_funcs-&gt;encode_ext_smn_addressing(ext) + mca_base + (idx * 8), val)
 
<span
class="del">-#endif
</span><span
class="add">+#define NORMALIZE_XCC_REG_OFFSET(ip, offset) \
+	((amdgpu_sriov_vf(adev) &#38;&#38; adev-&gt;asic_funcs-&gt;normalize_reg_offset) ? \
+	adev-&gt;asic_funcs-&gt;normalize_reg_offset(ip##_HWIP, offset) : offset)
+#endif
</span>\ No newline at end of file
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Dan Carpenter</name><email>dan.carpenter@linaro.org</email></author><title>[PATCH] drm/amd/display: Clean up indenting in dm_dp_mst_is_port_support_mode()</title><updated>2024-06-21T07:13:23Z</updated><link
href="http://lore.kernel.org/amd-gfx/a57a9d8f-40bb-4cfa-9dad-4f93a1f33303@moroto.mountain/"/><id>urn:uuid:4b337e57-10ad-8f76-2b25-4f959c24c9f3</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This code works, but it&#39;s not aligned correctly.  Add a couple missing
tabs.

Signed-off-by: Dan Carpenter &lt;dan.carpenter@linaro.org&gt;
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c | 4 ++--
 1 file <a href="http://lore.kernel.org/amd-gfx/a57a9d8f-40bb-4cfa-9dad-4f93a1f33303@moroto.mountain/#related">changed</a>, 2 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 48118447c8d9..5d4f831b1e55 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
</span><span
class="hunk">@@ -1691,7 +1691,7 @@ enum dc_status dm_dp_mst_is_port_support_mode(
</span> 		if (aconnector-&gt;mst_output_port-&gt;passthrough_aux) {
 			if (bw_range.min_kbps &gt; end_to_end_bw_in_kbps) {
 				DRM_DEBUG_DRIVER(&#34;DSC passthrough. Max dsc compression can&#39;t fit into end-to-end bw\n&#34;);
<span
class="del">-			return DC_FAIL_BANDWIDTH_VALIDATE;
</span><span
class="add">+				return DC_FAIL_BANDWIDTH_VALIDATE;
</span> 			}
 		} else {
 			/*dsc bitstream decoded at the dp last link*/
<span
class="hunk">@@ -1756,7 +1756,7 @@ enum dc_status dm_dp_mst_is_port_support_mode(
</span> 		if (branch_max_throughput_mps != 0 &#38;&#38;
 			((stream-&gt;timing.pix_clk_100hz / 10) &gt;  branch_max_throughput_mps * 1000)) {
 			DRM_DEBUG_DRIVER(&#34;DSC is required but max throughput mps fails&#34;);
<span
class="del">-		return DC_FAIL_BANDWIDTH_VALIDATE;
</span><span
class="add">+			return DC_FAIL_BANDWIDTH_VALIDATE;
</span> 		}
 	} else {
 		DRM_DEBUG_DRIVER(&#34;DSC is required but can&#39;t find common dsc config.&#34;);
-- 
2.43.0

</pre></div></content></entry><entry><author><name>Dan Carpenter</name><email>dan.carpenter@linaro.org</email></author><title>[PATCH] drm/amdgpu/kfd: Add unlock() on error path to add_queue_mes()</title><updated>2024-06-21T07:13:22Z</updated><link
href="http://lore.kernel.org/amd-gfx/10510733-a59a-4419-afb5-e75fdd802794@moroto.mountain/"/><id>urn:uuid:df252a79-c6c9-51e8-896d-0f795df30bd0</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">We recently added locking to add_queue_mes() but this error path was
overlooked.  Add an unlock to the error path.

Fixes: 1802b042a343 (&#34;drm/amdgpu/kfd: remove is_hws_hang and is_resetting&#34;)
Signed-off-by: Dan Carpenter &lt;dan.carpenter@linaro.org&gt;
---
 drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager.c | 1 +
 1 file <a href="http://lore.kernel.org/amd-gfx/10510733-a59a-4419-afb5-e75fdd802794@moroto.mountain/#related">changed</a>, 1 insertion(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager.c b/drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager.c
index d2fceb6f9802..4f48507418d2 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager.c
</span><span
class="hunk">@@ -230,6 +230,7 @@ static int add_queue_mes(struct device_queue_manager *dqm, struct queue *q,
</span> 	if (queue_type &lt; 0) {
 		dev_err(adev-&gt;dev, &#34;Queue type not supported with MES, queue:%d\n&#34;,
 			q-&gt;properties.type);
<span
class="add">+		up_read(&#38;adev-&gt;reset_domain-&gt;sem);
</span> 		return -EINVAL;
 	}
 	queue_input.queue_type = (uint32_t)queue_type;
-- 
2.43.0

</pre></div></content></entry><entry><author><name>Jiapeng Chong</name><email>jiapeng.chong@linux.alibaba.com</email></author><title>[PATCH] drm/amd/display: Remove redundant code and semicolons</title><updated>2024-06-21T07:13:21Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620081052.56439-1-jiapeng.chong@linux.alibaba.com/"/><id>urn:uuid:0ee64551-f84a-96ae-36a0-ba055c2bdc4e</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">No functional modification involved.

./drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_shared.c:3171:2-3: Unneeded semicolon.
./drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_shared.c:3185:2-3: Unneeded semicolon.
./drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_shared.c:3200:2-3: Unneeded semicolon.

Reported-by: Abaci Robot &lt;abaci@linux.alibaba.com&gt;
Closes: <a
href="https://bugzilla.openanolis.cn/show_bug.cgi?id=9365">https://bugzilla.openanolis.cn/show_bug.cgi?id=9365</a>
Signed-off-by: Jiapeng Chong &lt;jiapeng.chong@linux.alibaba.com&gt;
---
 .../dml21/src/dml2_core/dml2_core_shared.c    | 46 +++++++++----------
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620081052.56439-1-jiapeng.chong@linux.alibaba.com/#related">changed</a>, 23 insertions(+), 23 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_shared.c b/drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_shared.c
index cfa4c4475821..1a9895b1833f 100644
--- a/drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_shared.c
+++ b/drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_shared.c
</span><span
class="hunk">@@ -3142,62 +3142,62 @@ static unsigned int dml_get_tile_block_size_bytes(enum dml2_swizzle_mode sw_mode
</span> {
 	switch (sw_mode) {
 	case (dml2_sw_linear):
<span
class="del">-		return 256; break;
</span><span
class="add">+		return 256;
</span> 	case (dml2_sw_256b_2d):
<span
class="del">-		return 256; break;
</span><span
class="add">+		return 256;
</span> 	case (dml2_sw_4kb_2d):
<span
class="del">-		return 4096; break;
</span><span
class="add">+		return 4096;
</span> 	case (dml2_sw_64kb_2d):
<span
class="del">-		return 65536; break;
</span><span
class="add">+		return 65536;
</span> 	case (dml2_sw_256kb_2d):
<span
class="del">-		return 262144; break;
</span><span
class="add">+		return 262144;
</span> 	case (dml2_gfx11_sw_linear):
<span
class="del">-		return 256; break;
</span><span
class="add">+		return 256;
</span> 	case (dml2_gfx11_sw_64kb_d):
<span
class="del">-		return 65536; break;
</span><span
class="add">+		return 65536;
</span> 	case (dml2_gfx11_sw_64kb_d_t):
<span
class="del">-		return 65536; break;
</span><span
class="add">+		return 65536;
</span> 	case (dml2_gfx11_sw_64kb_d_x):
<span
class="del">-		return 65536; break;
</span><span
class="add">+		return 65536;
</span> 	case (dml2_gfx11_sw_64kb_r_x):
<span
class="del">-		return 65536; break;
</span><span
class="add">+		return 65536;
</span> 	case (dml2_gfx11_sw_256kb_d_x):
<span
class="del">-		return 262144; break;
</span><span
class="add">+		return 262144;
</span> 	case (dml2_gfx11_sw_256kb_r_x):
<span
class="del">-		return 262144; break;
</span><span
class="add">+		return 262144;
</span> 	default:
 		DML2_ASSERT(0);
 		return 256;
<span
class="del">-	};
</span><span
class="add">+	}
</span> }
 
 const char *dml2_core_internal_bw_type_str(enum dml2_core_internal_bw_type bw_type)
 {
 	switch (bw_type) {
 	case (dml2_core_internal_bw_sdp):
<span
class="del">-		return(&#34;dml2_core_internal_bw_sdp&#34;); break;
</span><span
class="add">+		return(&#34;dml2_core_internal_bw_sdp&#34;);
</span> 	case (dml2_core_internal_bw_dram):
<span
class="del">-		return(&#34;dml2_core_internal_bw_dram&#34;); break;
</span><span
class="add">+		return(&#34;dml2_core_internal_bw_dram&#34;);
</span> 	case (dml2_core_internal_bw_max):
<span
class="del">-		return(&#34;dml2_core_internal_bw_max&#34;); break;
</span><span
class="add">+		return(&#34;dml2_core_internal_bw_max&#34;);
</span> 	default:
<span
class="del">-		return(&#34;dml2_core_internal_bw_unknown&#34;); break;
-	};
</span><span
class="add">+		return(&#34;dml2_core_internal_bw_unknown&#34;);
+	}
</span> }
 
 const char *dml2_core_internal_soc_state_type_str(enum dml2_core_internal_soc_state_type dml2_core_internal_soc_state_type)
 {
 	switch (dml2_core_internal_soc_state_type) {
 	case (dml2_core_internal_soc_state_sys_idle):
<span
class="del">-		return(&#34;dml2_core_internal_soc_state_sys_idle&#34;); break;
</span><span
class="add">+		return(&#34;dml2_core_internal_soc_state_sys_idle&#34;);
</span> 	case (dml2_core_internal_soc_state_sys_active):
<span
class="del">-		return(&#34;dml2_core_internal_soc_state_sys_active&#34;); break;
</span><span
class="add">+		return(&#34;dml2_core_internal_soc_state_sys_active&#34;);
</span> 	case (dml2_core_internal_soc_state_svp_prefetch):
<span
class="del">-		return(&#34;dml2_core_internal_soc_state_svp_prefetch&#34;); break;
</span><span
class="add">+		return(&#34;dml2_core_internal_soc_state_svp_prefetch&#34;);
</span> 	case dml2_core_internal_soc_state_max:
 	default:
<span
class="del">-		return(&#34;dml2_core_internal_soc_state_unknown&#34;); break;
-	};
</span><span
class="add">+		return(&#34;dml2_core_internal_soc_state_unknown&#34;);
+	}
</span> }
 
 static bool dml_is_vertical_rotation(enum dml2_rotation_angle Scan)
-- 
2.20.1.7.g153144c

</pre></div></content></entry><entry><author><name>Bob Zhou</name><email>bob.zhou@amd.com</email></author><title>[PATCH] drm/amdgpu: add missing error handling in function amdgpu_gmc_flush_gpu_tlb_pasid</title><updated>2024-06-20T07:40:21Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620074006.11922-1-bob.zhou@amd.com/"/><id>urn:uuid:c9c9e65d-6cdb-49ee-5f9a-c2da05fa98e2</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Fix the unchecked return value warning by warning reported by
Coverity, so add error handling.

Signed-off-by: Bob Zhou &lt;bob.zhou@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.c | 6 +++++-
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620074006.11922-1-bob.zhou@amd.com/#related">changed</a>, 5 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.c
index 322b8ff67cde..3a7622611916 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.c
</span><span
class="hunk">@@ -718,7 +718,11 @@ int amdgpu_gmc_flush_gpu_tlb_pasid(struct amdgpu_device *adev, uint16_t pasid,
</span> 			ndw += kiq-&gt;pmf-&gt;invalidate_tlbs_size;
 
 		spin_lock(&#38;adev-&gt;gfx.kiq[inst].ring_lock);
<span
class="del">-		amdgpu_ring_alloc(ring, ndw);
</span><span
class="add">+		r = amdgpu_ring_alloc(ring, ndw);
+		if (r) {
+			spin_unlock(&#38;adev-&gt;gfx.kiq[inst].ring_lock);
+			goto error_unlock_reset;
+		}
</span> 		if (adev-&gt;gmc.flush_tlb_needs_extra_type_2)
 			kiq-&gt;pmf-&gt;kiq_invalidate_tlbs(ring, pasid, 2, all_hub);
 
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Bob Zhou</name><email>bob.zhou@amd.com</email></author><title>[PATCH] drm/amdgpu: Fix the null pointer dereference for amdgpu_ras_reset_error_status</title><updated>2024-06-20T07:04:47Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620070432.8455-1-bob.zhou@amd.com/"/><id>urn:uuid:3d699c02-43c5-88d5-1764-b73ba3656a33</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Check return value and conduct null pointer handling to avoid null pointer dereference.

Signed-off-by: Bob Zhou &lt;bob.zhou@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c | 3 +++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620070432.8455-1-bob.zhou@amd.com/#related">changed</a>, 3 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
index 68e9935028db..0ea836b376a6 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
</span><span
class="hunk">@@ -1442,6 +1442,9 @@ int amdgpu_ras_reset_error_status(struct amdgpu_device *adev,
</span> 	if (amdgpu_ras_reset_error_count(adev, block) == -EOPNOTSUPP)
 		return 0;
 
<span
class="add">+	if (!block_obj || !block_obj-&gt;hw_ops)
+		return -EINVAL;
+
</span> 	if ((block == AMDGPU_RAS_BLOCK__GFX) ||
 	    (block == AMDGPU_RAS_BLOCK__MMHUB)) {
 		if (block_obj-&gt;hw_ops-&gt;reset_ras_error_status)
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Min, Frank</name><email>Frank.Min@amd.com</email></author><title>[PATCH] drm/amdgpu: access ltr through pci cfg space</title><updated>2024-06-20T06:52:14Z</updated><link
href="http://lore.kernel.org/amd-gfx/SA1PR12MB5659299BF8D06931F83065E1E9C82@SA1PR12MB5659.namprd12.prod.outlook.com/"/><id>urn:uuid:33793445-17a0-307e-2d5f-ca1bba0a0e68</id><thr:in-reply-to
ref="urn:uuid:0b08aa8c-58a9-7c80-4acd-50b3e84a1bdc"
href="http://lore.kernel.org/amd-gfx/20240620054406.2662-1-Frank.Min@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[AMD Official Use Only - AMD Internal Distribution Only]

From: Frank Min &lt;Frank.Min@amd.com&gt;

Access ltr through pci cfg space instead of mmio while programing aspm on gfx12

Signed-off-by: Frank Min &lt;Frank.Min@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/nbif_v6_3_1.c | 14 ++++++++++----
 1 file <a href="http://lore.kernel.org/amd-gfx/SA1PR12MB5659299BF8D06931F83065E1E9C82@SA1PR12MB5659.namprd12.prod.outlook.com/#related">changed</a>, 10 insertions(+), 4 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/nbif_v6_3_1.c b/drivers/gpu/drm/amd/amdgpu/nbif_v6_3_1.c
index 5a20bb229788..39919e0892c1 100644
--- a/drivers/gpu/drm/amd/amdgpu/nbif_v6_3_1.c
+++ b/drivers/gpu/drm/amd/amdgpu/nbif_v6_3_1.c
</span><span
class="hunk">@@ -345,6 +345,7 @@ static void nbif_v6_3_1_program_aspm(struct amdgpu_device *adev)  {  #ifdef CONFIG_PCIEASPM
</span>        uint32_t def, data;
<span
class="add">+       u16 devctl2, ltr;
</span>
        def = data = RREG32_SOC15(PCIE, 0, regPCIE_LC_CNTL);
        data &#38;= ~PCIE_LC_CNTL__LC_L1_INACTIVITY_MASK;
<span
class="hunk">@@ -374,12 +375,17 @@ static void nbif_v6_3_1_program_aspm(struct amdgpu_device *adev)
</span>        if (def != data)
                WREG32_SOC15(NBIO, 0, regRCC_STRAP0_RCC_BIF_STRAP5, data);

<span
class="del">-       def = data = RREG32_SOC15(NBIO, 0, regBIF_CFG_DEV0_EPF0_DEVICE_CNTL2);
-       data &#38;= ~BIF_CFG_DEV0_EPF0_DEVICE_CNTL2__LTR_EN_MASK;
</span><span
class="add">+       pcie_capability_read_word(adev-&gt;pdev, PCI_EXP_DEVCTL2, &#38;devctl2);
+       data = def = devctl2;
+       data &#38;= ~PCI_EXP_DEVCTL2_LTR_EN;
</span>        if (def != data)
<span
class="del">-               WREG32_SOC15(NBIO, 0, regBIF_CFG_DEV0_EPF0_DEVICE_CNTL2, data);
</span><span
class="add">+               pcie_capability_set_word(adev-&gt;pdev, PCI_EXP_DEVCTL2, (u16)data);
+
+       ltr = pci_find_ext_capability(adev-&gt;pdev, PCI_EXT_CAP_ID_LTR);
</span>
<span
class="del">-       WREG32_SOC15(NBIO, 0, regBIF_CFG_DEV0_EPF0_PCIE_LTR_CAP, 0x10011001);
</span><span
class="add">+       if (ltr) {
+               pci_write_config_dword(adev-&gt;pdev, ltr + PCI_LTR_MAX_SNOOP_LAT, 0x10011001);
+       }
</span>
 #if 0
        /* regPSWUSP0_PCIE_LC_CNTL2 should be replace by PCIE_LC_CNTL2 or someone else ? */
<span
class="del">--
</span>2.34.1

</pre></div></content></entry><entry><author><name>Vignesh Chander</name><email>Vignesh.Chander@amd.com</email></author><title>[PATCH] drm/amdgpu: process RAS fatal error MB notification</title><updated>2024-06-20T06:26:55Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620062626.619810-1-Vignesh.Chander@amd.com/"/><id>urn:uuid:be800152-6d8a-e091-bee7-7f36b7334b18</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">For RAS error scenario, VF guest driver will check mailbox
and set fed flag to avoid unnecessary HW accesses.
additionally, poll for reset completion message first
to avoid accidentally spamming multiple reset requests to host.

v2: add another mailbox check for handling case where kfd detects
timeout first

v3: set host_flr bit and use wait_for_reset

Signed-off-by: Vignesh Chander &lt;Vignesh.Chander@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_device.c |  5 +++++
 drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c   | 25 +++++++++++++++++++---
 drivers/gpu/drm/amd/amdgpu/amdgpu_virt.h   |  4 +++-
 drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c      | 14 +++++++++++-
 drivers/gpu/drm/amd/amdgpu/mxgpu_ai.h      |  4 +++-
 drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c      | 14 +++++++++++-
 drivers/gpu/drm/amd/amdgpu/mxgpu_nv.h      |  5 +++--
 7 files <a href="http://lore.kernel.org/amd-gfx/20240620062626.619810-1-Vignesh.Chander@amd.com/#related">changed</a>, 62 insertions(+), 9 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
index 7df5544ac9839e..1b204af9831d24 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
</span><span
class="hunk">@@ -5834,6 +5834,11 @@ int amdgpu_device_gpu_recover(struct amdgpu_device *adev,
</span> 	/* Actual ASIC resets if needed.*/
 	/* Host driver will handle XGMI hive reset for SRIOV */
 	if (amdgpu_sriov_vf(adev)) {
<span
class="add">+		if (amdgpu_ras_get_fed_status(adev) || amdgpu_virt_rcvd_ras_interrupt(adev)) {
+			dev_dbg(adev-&gt;dev, &#34;Detected RAS error, wait for FLR completion\n&#34;);
+			set_bit(AMDGPU_HOST_FLR, &#38;reset_context-&gt;flags);
+		}
+
</span> 		r = amdgpu_device_reset_sriov(adev, reset_context);
 		if (AMDGPU_RETRY_SRIOV_RESET(r) &#38;&#38; (retry_limit--) &gt; 0) {
 			amdgpu_virt_release_full_gpu(adev, true);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c
index 63f2286858c484..ccb3d041c2b249 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c
</span><span
class="hunk">@@ -229,6 +229,22 @@ void amdgpu_virt_free_mm_table(struct amdgpu_device *adev)
</span> 	adev-&gt;virt.mm_table.gpu_addr = 0;
 }
 
<span
class="add">+/**
+ * amdgpu_virt_rcvd_ras_interrupt() - receive ras interrupt
+ * @adev:	amdgpu device.
+ * Check whether host sent RAS error message
+ * Return: true if found, otherwise false
+ */
+bool amdgpu_virt_rcvd_ras_interrupt(struct amdgpu_device *adev)
+{
+	struct amdgpu_virt *virt = &#38;adev-&gt;virt;
+
+	if (!virt-&gt;ops || !virt-&gt;ops-&gt;rcvd_ras_intr)
+		return false;
+
+	return virt-&gt;ops-&gt;rcvd_ras_intr(adev);
+}
+
</span> 
 unsigned int amd_sriov_msg_checksum(void *obj,
 				unsigned long obj_size,
<span
class="hunk">@@ -612,11 +628,14 @@ static void amdgpu_virt_update_vf2pf_work_item(struct work_struct *work)
</span> 	ret = amdgpu_virt_read_pf2vf_data(adev);
 	if (ret) {
 		adev-&gt;virt.vf2pf_update_retry_cnt++;
<span
class="del">-		if ((adev-&gt;virt.vf2pf_update_retry_cnt &gt;= AMDGPU_VF2PF_UPDATE_MAX_RETRY_LIMIT) &#38;&#38;
-		    amdgpu_sriov_runtime(adev)) {
</span><span
class="add">+
+		if ((amdgpu_virt_rcvd_ras_interrupt(adev) ||
+			adev-&gt;virt.vf2pf_update_retry_cnt &gt;= AMDGPU_VF2PF_UPDATE_MAX_RETRY_LIMIT) &#38;&#38;
+			amdgpu_sriov_runtime(adev)) {
+
</span> 			amdgpu_ras_set_fed(adev, true);
 			if (amdgpu_reset_domain_schedule(adev-&gt;reset_domain,
<span
class="del">-							  &#38;adev-&gt;kfd.reset_work))
</span><span
class="add">+							&#38;adev-&gt;kfd.reset_work))
</span> 				return;
 			else
 				dev_err(adev-&gt;dev, &#34;Failed to queue work! at %s&#34;, __func__);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.h
index f04cd1586c7220..b42a8854dca0cb 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.h
</span><span
class="hunk">@@ -52,7 +52,7 @@
</span> /* tonga/fiji use this offset */
 #define mmBIF_IOV_FUNC_IDENTIFIER 0x1503
 
<span
class="del">-#define AMDGPU_VF2PF_UPDATE_MAX_RETRY_LIMIT 5
</span><span
class="add">+#define AMDGPU_VF2PF_UPDATE_MAX_RETRY_LIMIT 2
</span> 
 enum amdgpu_sriov_vf_mode {
 	SRIOV_VF_MODE_BARE_METAL = 0,
<span
class="hunk">@@ -94,6 +94,7 @@ struct amdgpu_virt_ops {
</span> 			  u32 data1, u32 data2, u32 data3);
 	void (*ras_poison_handler)(struct amdgpu_device *adev,
 					enum amdgpu_ras_block block);
<span
class="add">+	bool (*rcvd_ras_intr)(struct amdgpu_device *adev);
</span> };
 
 /*
<span
class="hunk">@@ -352,6 +353,7 @@ void amdgpu_virt_ready_to_reset(struct amdgpu_device *adev);
</span> int amdgpu_virt_wait_reset(struct amdgpu_device *adev);
 int amdgpu_virt_alloc_mm_table(struct amdgpu_device *adev);
 void amdgpu_virt_free_mm_table(struct amdgpu_device *adev);
<span
class="add">+bool amdgpu_virt_rcvd_ras_interrupt(struct amdgpu_device *adev);
</span> void amdgpu_virt_release_ras_err_handler_data(struct amdgpu_device *adev);
 void amdgpu_virt_init_data_exchange(struct amdgpu_device *adev);
 void amdgpu_virt_exchange_data(struct amdgpu_device *adev);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c b/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c
index 65656afc6ed1c2..2eba51b58ea88d 100644
--- a/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c
+++ b/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c
</span><span
class="hunk">@@ -257,9 +257,13 @@ static void xgpu_ai_ready_to_reset(struct amdgpu_device *adev)
</span> static int xgpu_ai_wait_reset(struct amdgpu_device *adev)
 {
 	int timeout = AI_MAILBOX_POLL_FLR_TIMEDOUT;
<span
class="add">+
+	if (adev-&gt;gmc.xgmi.num_physical_nodes &gt; 1)
+		timeout *= adev-&gt;gmc.xgmi.num_physical_nodes;
+
</span> 	do {
 		if (xgpu_ai_mailbox_peek_msg(adev) == IDH_FLR_NOTIFICATION_CMPL) {
<span
class="del">-			dev_dbg(adev-&gt;dev, &#34;Got AI IDH_FLR_NOTIFICATION_CMPL after %d ms\n&#34;, AI_MAILBOX_POLL_FLR_TIMEDOUT - timeout);
</span><span
class="add">+			dev_dbg(adev-&gt;dev, &#34;Got AI IDH_FLR_NOTIFICATION_CMPL with %d ms remaining\n&#34;, timeout);
</span> 			return 0;
 		}
 		msleep(10);
<span
class="hunk">@@ -408,6 +412,13 @@ static void xgpu_ai_ras_poison_handler(struct amdgpu_device *adev,
</span> 	xgpu_ai_send_access_requests(adev, IDH_RAS_POISON);
 }
 
<span
class="add">+static bool xgpu_ai_rcvd_ras_intr(struct amdgpu_device *adev)
+{
+	enum idh_event msg = xgpu_ai_mailbox_peek_msg(adev);
+
+	return (msg == IDH_RAS_ERROR_DETECTED || msg == 0xFFFFFFFF);
+}
+
</span> const struct amdgpu_virt_ops xgpu_ai_virt_ops = {
 	.req_full_gpu	= xgpu_ai_request_full_gpu_access,
 	.rel_full_gpu	= xgpu_ai_release_full_gpu_access,
<span
class="hunk">@@ -417,4 +428,5 @@ const struct amdgpu_virt_ops xgpu_ai_virt_ops = {
</span> 	.trans_msg = xgpu_ai_mailbox_trans_msg,
 	.req_init_data  = xgpu_ai_request_init_data,
 	.ras_poison_handler = xgpu_ai_ras_poison_handler,
<span
class="add">+	.rcvd_ras_intr = xgpu_ai_rcvd_ras_intr,
</span> };
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.h b/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.h
index c520b2fabfb9a8..ed57cbc150afba 100644
--- a/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.h
+++ b/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.h
</span><span
class="hunk">@@ -51,7 +51,9 @@ enum idh_event {
</span> 	IDH_FAIL,
 	IDH_QUERY_ALIVE,
 	IDH_REQ_GPU_INIT_DATA_READY,
<span
class="del">-
</span><span
class="add">+	IDH_RAS_POISON_READY,
+	IDH_PF_SOFT_FLR_NOTIFICATION,
+	IDH_RAS_ERROR_DETECTED,
</span> 	IDH_TEXT_MESSAGE = 255,
 };
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c b/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c
index 17e1e8cc243752..5854e8d2bbd4b1 100644
--- a/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c
+++ b/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c
</span><span
class="hunk">@@ -294,9 +294,13 @@ static void xgpu_nv_ready_to_reset(struct amdgpu_device *adev)
</span> static int xgpu_nv_wait_reset(struct amdgpu_device *adev)
 {
 	int timeout = NV_MAILBOX_POLL_FLR_TIMEDOUT;
<span
class="add">+
+	if (adev-&gt;gmc.xgmi.num_physical_nodes &gt; 1)
+		timeout *= adev-&gt;gmc.xgmi.num_physical_nodes;
+
</span> 	do {
 		if (xgpu_nv_mailbox_peek_msg(adev) == IDH_FLR_NOTIFICATION_CMPL) {
<span
class="del">-			dev_dbg(adev-&gt;dev, &#34;Got NV IDH_FLR_NOTIFICATION_CMPL after %d ms\n&#34;, NV_MAILBOX_POLL_FLR_TIMEDOUT - timeout);
</span><span
class="add">+			dev_dbg(adev-&gt;dev, &#34;Got NV IDH_FLR_NOTIFICATION_CMPL with %d ms remaining\n&#34;, timeout);
</span> 			return 0;
 		}
 		msleep(10);
<span
class="hunk">@@ -449,6 +453,13 @@ static void xgpu_nv_ras_poison_handler(struct amdgpu_device *adev,
</span> 	}
 }
 
<span
class="add">+static bool xgpu_nv_rcvd_ras_intr(struct amdgpu_device *adev)
+{
+	enum idh_event msg = xgpu_nv_mailbox_peek_msg(adev);
+
+	return (msg == IDH_RAS_ERROR_DETECTED || msg == 0xFFFFFFFF);
+}
+
</span> const struct amdgpu_virt_ops xgpu_nv_virt_ops = {
 	.req_full_gpu	= xgpu_nv_request_full_gpu_access,
 	.rel_full_gpu	= xgpu_nv_release_full_gpu_access,
<span
class="hunk">@@ -458,4 +469,5 @@ const struct amdgpu_virt_ops xgpu_nv_virt_ops = {
</span> 	.wait_reset = xgpu_nv_wait_reset,
 	.trans_msg = xgpu_nv_mailbox_trans_msg,
 	.ras_poison_handler = xgpu_nv_ras_poison_handler,
<span
class="add">+	.rcvd_ras_intr = xgpu_nv_rcvd_ras_intr,
</span> };
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.h b/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.h
index 1e8fd90cab4347..caf616a2c8a6c5 100644
--- a/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.h
+++ b/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.h
</span><span
class="hunk">@@ -26,7 +26,7 @@
</span> 
 #define NV_MAILBOX_POLL_ACK_TIMEDOUT	500
 #define NV_MAILBOX_POLL_MSG_TIMEDOUT	6000
<span
class="del">-#define NV_MAILBOX_POLL_FLR_TIMEDOUT	5000
</span><span
class="add">+#define NV_MAILBOX_POLL_FLR_TIMEDOUT	10000
</span> #define NV_MAILBOX_POLL_MSG_REP_MAX	11
 
 enum idh_request {
<span
class="hunk">@@ -52,7 +52,8 @@ enum idh_event {
</span> 	IDH_QUERY_ALIVE,
 	IDH_REQ_GPU_INIT_DATA_READY,
 	IDH_RAS_POISON_READY,
<span
class="del">-
</span><span
class="add">+	IDH_PF_SOFT_FLR_NOTIFICATION,
+	IDH_RAS_ERROR_DETECTED,
</span> 	IDH_TEXT_MESSAGE = 255,
 };
 
-- 
2.25.1

</pre></div></content></entry><entry><author><name>YiPeng Chai</name><email>YiPeng.Chai@amd.com</email></author><title>[PATCH V2 4/4] drm/amdgpu: add gpu reset check and exception handling</title><updated>2024-06-20T05:41:32Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620054020.434523-4-YiPeng.Chai@amd.com/"/><id>urn:uuid:5dab5b8b-1be9-6afd-da1f-0f4107500747</id><thr:in-reply-to
ref="urn:uuid:ff94a36d-537c-03bd-0d4e-97f020b684d6"
href="http://lore.kernel.org/amd-gfx/20240620054020.434523-1-YiPeng.Chai@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Add gpu reset check and exception handling for
page retirement.

v2:
  Clear poison consumption messages cached in fifo after
non mode-1 reset.

Signed-off-by: YiPeng Chai &lt;YiPeng.Chai@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c | 52 +++++++++++++++++++++++++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240620054020.434523-4-YiPeng.Chai@amd.com/#related">changed</a>, 52 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
index a4030dc12a1c..ce7c7723e626 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
</span><span
class="hunk">@@ -1384,10 +1384,15 @@ int amdgpu_ras_query_error_status(struct amdgpu_device *adev, struct ras_query_i
</span> 	memset(&#38;qctx, 0, sizeof(qctx));
 	qctx.event_id = amdgpu_ras_acquire_event_id(adev, amdgpu_ras_intr_triggered() ?
 						   RAS_EVENT_TYPE_ISR : RAS_EVENT_TYPE_INVALID);
<span
class="add">+
+	if (!down_read_trylock(&#38;adev-&gt;reset_domain-&gt;sem))
+		return -EIO;
+
</span> 	ret = amdgpu_ras_query_error_status_helper(adev, info,
 						   &#38;err_data,
 						   &#38;qctx,
 						   error_query_mode);
<span
class="add">+	up_read(&#38;adev-&gt;reset_domain-&gt;sem);
</span> 	if (ret)
 		goto out_fini_err_data;
 
<span
class="hunk">@@ -2916,6 +2921,14 @@ static int amdgpu_ras_poison_creation_handler(struct amdgpu_device *adev,
</span> 	return 0;
 }
 
<span
class="add">+static void amdgpu_ras_clear_poison_fifo(struct amdgpu_device *adev)
+{
+	struct amdgpu_ras *con = amdgpu_ras_get_context(adev);
+	struct ras_poison_msg msg;
+
+	while (kfifo_get(&#38;con-&gt;poison_fifo, &#38;msg));
+}
+
</span> static int amdgpu_ras_poison_consumption_handler(struct amdgpu_device *adev,
 			uint32_t msg_count, uint32_t *gpu_reset)
 {
<span
class="hunk">@@ -2946,12 +2959,20 @@ static int amdgpu_ras_poison_consumption_handler(struct amdgpu_device *adev,
</span> 		else
 			reset = reset_flags;
 
<span
class="add">+		/* If gpu reset is ongoing, not need to reset gpu again */
+		if (!down_read_trylock(&#38;adev-&gt;reset_domain-&gt;sem))
+			return -EIO;
+		up_read(&#38;adev-&gt;reset_domain-&gt;sem);
+
</span> 		flush_delayed_work(&#38;con-&gt;page_retirement_dwork);
 
 		con-&gt;gpu_reset_flags |= reset;
 		amdgpu_ras_reset_gpu(adev);
 
 		*gpu_reset = reset;
<span
class="add">+
+		/* Wait for gpu recovery to complete */
+		flush_work(&#38;con-&gt;recovery_work);
</span> 	}
 
 	return 0;
<span
class="hunk">@@ -3000,6 +3021,37 @@ static int amdgpu_ras_page_retirement_thread(void *param)
</span> 			}
 		}
 
<span
class="add">+		if ((ret == -EIO) || (gpu_reset == AMDGPU_RAS_GPU_RESET_MODE1_RESET)) {
+			/* gpu mode-1 reset is ongoing or just completed ras mode-1 reset */
+			/* Clear poison creation request */
+			atomic_set(&#38;con-&gt;poison_creation_count, 0);
+
+			/* Clear poison fifo */
+			amdgpu_ras_clear_poison_fifo(adev);
+
+			/* Clear all poison requests*/
+			atomic_set(&#38;con-&gt;page_retirement_req_cnt, 0);
+
+			if (ret == -EIO) {
+				/* Wait for mode-1 reset to complete */
+				down_read(&#38;adev-&gt;reset_domain-&gt;sem);
+				up_read(&#38;adev-&gt;reset_domain-&gt;sem);
+			}
+
+			/* Wake up work to save bad pages to eeprom */
+			schedule_delayed_work(&#38;con-&gt;page_retirement_dwork, 0);
+		} else if (gpu_reset) {
+			/* gpu just completed mode-2 reset or other reset */
+			/* Clear poison consumption messages cached in fifo */
+			msg_count = kfifo_len(&#38;con-&gt;poison_fifo);
+			if (msg_count) {
+				amdgpu_ras_clear_poison_fifo(adev);
+				atomic_sub(msg_count, &#38;con-&gt;page_retirement_req_cnt);
+			}
+
+			/* Wake up work to save bad pages to eeprom */
+			schedule_delayed_work(&#38;con-&gt;page_retirement_dwork, 0);
+		}
</span> #else
         dev_info(adev-&gt;dev, &#34;Start processing page retirement. request:%d\n&#34;,
                     atomic_read(&#38;con-&gt;page_retirement_req_cnt));
-- 
2.34.1

</pre></div></content></entry><entry><author><name>YiPeng Chai</name><email>YiPeng.Chai@amd.com</email></author><title>[PATCH V2 2/4] drm/amdgpu: refine poison creation interrupt handler</title><updated>2024-06-20T05:41:31Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620054020.434523-2-YiPeng.Chai@amd.com/"/><id>urn:uuid:8a73780e-4839-ca49-e8c4-22d6f95ba987</id><thr:in-reply-to
ref="urn:uuid:ff94a36d-537c-03bd-0d4e-97f020b684d6"
href="http://lore.kernel.org/amd-gfx/20240620054020.434523-1-YiPeng.Chai@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">In order to apply to the case where a large number
of ras poison interrupts:
1. Change to use variable to record poison creation
   requests to avoid fifo full.
2. Prioritize handling poison creation requests
   instead of following the order of requests
   received by the driver.

Signed-off-by: YiPeng Chai &lt;YiPeng.Chai@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c | 37 ++++++++++++-------------
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h |  1 +
 2 files <a href="http://lore.kernel.org/amd-gfx/20240620054020.434523-2-YiPeng.Chai@amd.com/#related">changed</a>, 18 insertions(+), 20 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
index f674e34037b6..308348b4644f 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
</span><span
class="hunk">@@ -2106,10 +2106,8 @@ static void amdgpu_ras_interrupt_poison_creation_handler(struct ras_manager *obj
</span> 	if (amdgpu_ip_version(obj-&gt;adev, UMC_HWIP, 0) &gt;= IP_VERSION(12, 0, 0)) {
 		struct amdgpu_ras *con = amdgpu_ras_get_context(obj-&gt;adev);
 
<span
class="del">-		amdgpu_ras_put_poison_req(obj-&gt;adev,
-			AMDGPU_RAS_BLOCK__UMC, 0, NULL, NULL, false);
-
</span> 		atomic_inc(&#38;con-&gt;page_retirement_req_cnt);
<span
class="add">+		atomic_inc(&#38;con-&gt;poison_creation_count);
</span> 
 		wake_up(&#38;con-&gt;page_retirement_wq);
 	}
<span
class="hunk">@@ -2945,6 +2943,8 @@ static int amdgpu_ras_page_retirement_thread(void *param)
</span> {
 	struct amdgpu_device *adev = (struct amdgpu_device *)param;
 	struct amdgpu_ras *con = amdgpu_ras_get_context(adev);
<span
class="add">+	uint32_t poison_creation_count;
+	int ret;
</span> 	struct ras_poison_msg poison_msg;
 	enum amdgpu_ras_block ras_block;
 	bool poison_creation_is_handled = false;
<span
class="hunk">@@ -2958,7 +2958,18 @@ static int amdgpu_ras_page_retirement_thread(void *param)
</span> 		if (kthread_should_stop())
 			break;
 
<span
class="del">-		atomic_dec(&#38;con-&gt;page_retirement_req_cnt);
</span><span
class="add">+
+		do {
+			poison_creation_count = atomic_read(&#38;con-&gt;poison_creation_count);
+			ret = amdgpu_ras_poison_creation_handler(adev, poison_creation_count);
+			if (ret == -EIO)
+				break;
+
+			if (poison_creation_count) {
+				atomic_sub(poison_creation_count, &#38;con-&gt;poison_creation_count);
+				atomic_sub(poison_creation_count, &#38;con-&gt;page_retirement_req_cnt);
+			}
+		} while (atomic_read(&#38;con-&gt;poison_creation_count));
</span> 
 #ifdef HAVE_KFIFO_PUT_NON_POINTER
 		if (!amdgpu_ras_get_poison_req(adev, &#38;poison_msg))
<span
class="hunk">@@ -2969,24 +2980,8 @@ static int amdgpu_ras_page_retirement_thread(void *param)
</span> 		dev_dbg(adev-&gt;dev, &#34;Start processing ras block %s(%d)\n&#34;,
 				ras_block_str(ras_block), ras_block);
 
<span
class="del">-		if (ras_block == AMDGPU_RAS_BLOCK__UMC) {
-			amdgpu_ras_poison_creation_handler(adev,
-				MAX_UMC_POISON_POLLING_TIME_ASYNC);
-			poison_creation_is_handled = true;
-		} else {
-			/* poison_creation_is_handled:
-			 *   false: no poison creation interrupt, but it has poison
-			 *          consumption interrupt.
-			 *   true: It has poison creation interrupt at the beginning,
-			 *         but it has no poison creation interrupt later.
-			 */
-			amdgpu_ras_poison_creation_handler(adev,
-					poison_creation_is_handled ?
-					0 : MAX_UMC_POISON_POLLING_TIME_ASYNC);
</span> 
 			amdgpu_ras_poison_consumption_handler(adev, &#38;poison_msg);
<span
class="del">-			poison_creation_is_handled = false;
-		}
</span> #else
         dev_info(adev-&gt;dev, &#34;Start processing page retirement. request:%d\n&#34;,
                     atomic_read(&#38;con-&gt;page_retirement_req_cnt));
<span
class="hunk">@@ -3066,6 +3061,7 @@ int amdgpu_ras_recovery_init(struct amdgpu_device *adev)
</span> 	mutex_init(&#38;con-&gt;page_retirement_lock);
 	init_waitqueue_head(&#38;con-&gt;page_retirement_wq);
 	atomic_set(&#38;con-&gt;page_retirement_req_cnt, 0);
<span
class="add">+	atomic_set(&#38;con-&gt;poison_creation_count, 0);
</span> 	con-&gt;page_retirement_thread =
 		kthread_run(amdgpu_ras_page_retirement_thread, adev, &#34;umc_page_retirement&#34;);
 	if (IS_ERR(con-&gt;page_retirement_thread)) {
<span
class="hunk">@@ -3117,6 +3113,7 @@ static int amdgpu_ras_recovery_fini(struct amdgpu_device *adev)
</span> 		kthread_stop(con-&gt;page_retirement_thread);
 
 	atomic_set(&#38;con-&gt;page_retirement_req_cnt, 0);
<span
class="add">+	atomic_set(&#38;con-&gt;poison_creation_count, 0);
</span> 
 	mutex_destroy(&#38;con-&gt;page_rsv_lock);
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
index 748bbac666e6..0fa1148e6642 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
</span><span
class="hunk">@@ -532,6 +532,7 @@ struct amdgpu_ras {
</span> 	wait_queue_head_t page_retirement_wq;
 	struct mutex page_retirement_lock;
 	atomic_t page_retirement_req_cnt;
<span
class="add">+	atomic_t poison_creation_count;
</span> 	struct mutex page_rsv_lock;
 	DECLARE_KFIFO(poison_fifo, struct ras_poison_msg, 128);
 	struct ras_ecc_log_info  umc_ecc_log;
-- 
2.34.1

</pre></div></content></entry><entry><author><name>YiPeng Chai</name><email>YiPeng.Chai@amd.com</email></author><title>[PATCH V2 3/4] drm/amdgpu: refine poison consumption interrupt handler</title><updated>2024-06-20T05:41:30Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620054020.434523-3-YiPeng.Chai@amd.com/"/><id>urn:uuid:1833ddc0-54c8-2589-94c1-7c6392ac8bcf</id><thr:in-reply-to
ref="urn:uuid:ff94a36d-537c-03bd-0d4e-97f020b684d6"
href="http://lore.kernel.org/amd-gfx/20240620054020.434523-1-YiPeng.Chai@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">1. The poison fifo is only used for poison consumption
   requests.
2. Merge reset requests when poison fifo caches multiple
   poison consumption messages

Signed-off-by: YiPeng Chai &lt;YiPeng.Chai@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c | 56 ++++++++++++++++---------
 drivers/gpu/drm/amd/amdgpu/amdgpu_umc.c | 12 +++---
 2 files <a href="http://lore.kernel.org/amd-gfx/20240620054020.434523-3-YiPeng.Chai@amd.com/#related">changed</a>, 44 insertions(+), 24 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
index 308348b4644f..a4030dc12a1c 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
</span><span
class="hunk">@@ -2917,23 +2917,41 @@ static int amdgpu_ras_poison_creation_handler(struct amdgpu_device *adev,
</span> }
 
 static int amdgpu_ras_poison_consumption_handler(struct amdgpu_device *adev,
<span
class="del">-			struct ras_poison_msg *poison_msg)
</span><span
class="add">+			uint32_t msg_count, uint32_t *gpu_reset)
</span> {
 	struct amdgpu_ras *con = amdgpu_ras_get_context(adev);
<span
class="del">-	uint32_t reset = poison_msg-&gt;reset;
-	uint16_t pasid = poison_msg-&gt;pasid;
</span><span
class="add">+	uint32_t reset_flags = 0, reset = 0;
+	struct ras_poison_msg msg;
+	int ret, i;
</span> 
 	kgd2kfd_set_sram_ecc_flag(adev-&gt;kfd.dev);
 
<span
class="del">-	if (poison_msg-&gt;pasid_fn)
-		poison_msg-&gt;pasid_fn(adev, pasid, poison_msg-&gt;data);
</span><span
class="add">+	for (i = 0; i &lt; msg_count; i++) {
+		ret = amdgpu_ras_get_poison_req(adev, &#38;msg);
+		if (!ret)
+			continue;
+
+		if (msg.pasid_fn)
+			msg.pasid_fn(adev, msg.pasid, msg.data);
+
+		reset_flags |= msg.reset;
+	}
</span> 
 	/* for RMA, amdgpu_ras_poison_creation_handler will trigger gpu reset */
<span
class="del">-	if (reset &#38;&#38; !con-&gt;is_rma) {
</span><span
class="add">+	if (reset_flags &#38;&#38; !con-&gt;is_rma) {
+		if (reset_flags &#38; AMDGPU_RAS_GPU_RESET_MODE1_RESET)
+			reset = AMDGPU_RAS_GPU_RESET_MODE1_RESET;
+		else if (reset_flags &#38; AMDGPU_RAS_GPU_RESET_MODE2_RESET)
+			reset = AMDGPU_RAS_GPU_RESET_MODE2_RESET;
+		else
+			reset = reset_flags;
+
</span> 		flush_delayed_work(&#38;con-&gt;page_retirement_dwork);
 
 		con-&gt;gpu_reset_flags |= reset;
 		amdgpu_ras_reset_gpu(adev);
<span
class="add">+
+		*gpu_reset = reset;
</span> 	}
 
 	return 0;
<span
class="hunk">@@ -2943,11 +2961,9 @@ static int amdgpu_ras_page_retirement_thread(void *param)
</span> {
 	struct amdgpu_device *adev = (struct amdgpu_device *)param;
 	struct amdgpu_ras *con = amdgpu_ras_get_context(adev);
<span
class="del">-	uint32_t poison_creation_count;
</span><span
class="add">+	uint32_t poison_creation_count, msg_count;
+	uint32_t gpu_reset;
</span> 	int ret;
<span
class="del">-	struct ras_poison_msg poison_msg;
-	enum amdgpu_ras_block ras_block;
-	bool poison_creation_is_handled = false;
</span> 
 	while (!kthread_should_stop()) {
 
<span
class="hunk">@@ -2958,6 +2974,7 @@ static int amdgpu_ras_page_retirement_thread(void *param)
</span> 		if (kthread_should_stop())
 			break;
 
<span
class="add">+		gpu_reset = 0;
</span> 
 		do {
 			poison_creation_count = atomic_read(&#38;con-&gt;poison_creation_count);
<span
class="hunk">@@ -2972,16 +2989,17 @@ static int amdgpu_ras_page_retirement_thread(void *param)
</span> 		} while (atomic_read(&#38;con-&gt;poison_creation_count));
 
 #ifdef HAVE_KFIFO_PUT_NON_POINTER
<span
class="del">-		if (!amdgpu_ras_get_poison_req(adev, &#38;poison_msg))
-			continue;
-
-		ras_block = poison_msg.block;
-
-		dev_dbg(adev-&gt;dev, &#34;Start processing ras block %s(%d)\n&#34;,
-				ras_block_str(ras_block), ras_block);
-
</span><span
class="add">+		if (ret != -EIO) {
+			msg_count = kfifo_len(&#38;con-&gt;poison_fifo);
+			if (msg_count) {
+				ret = amdgpu_ras_poison_consumption_handler(adev,
+						msg_count, &#38;gpu_reset);
+				if ((ret != -EIO) &#38;&#38;
+				    (gpu_reset != AMDGPU_RAS_GPU_RESET_MODE1_RESET))
+					atomic_sub(msg_count, &#38;con-&gt;page_retirement_req_cnt);
+			}
+		}
</span> 
<span
class="del">-			amdgpu_ras_poison_consumption_handler(adev, &#38;poison_msg);
</span> #else
         dev_info(adev-&gt;dev, &#34;Start processing page retirement. request:%d\n&#34;,
                     atomic_read(&#38;con-&gt;page_retirement_req_cnt));
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_umc.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_umc.c
index 4a72ff8d8d80..38e7793137ee 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_umc.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_umc.c
</span><span
class="hunk">@@ -296,13 +296,15 @@ int amdgpu_umc_pasid_poison_handler(struct amdgpu_device *adev,
</span> 				struct amdgpu_ras *con = amdgpu_ras_get_context(adev);
 
 #ifdef HAVE_KFIFO_PUT_NON_POINTER
<span
class="del">-				amdgpu_ras_put_poison_req(adev,
</span><span
class="add">+				int ret;
+
+				ret = amdgpu_ras_put_poison_req(adev,
</span> 					block, pasid, pasid_fn, data, reset);
<span
class="add">+				if (!ret) {
+					atomic_inc(&#38;con-&gt;page_retirement_req_cnt);
+					wake_up(&#38;con-&gt;page_retirement_wq);
+				}
</span> #endif
<span
class="del">-
-				atomic_inc(&#38;con-&gt;page_retirement_req_cnt);
-
-				wake_up(&#38;con-&gt;page_retirement_wq);
</span> 		}
 	} else {
 		if (adev-&gt;virt.ops &#38;&#38; adev-&gt;virt.ops-&gt;ras_poison_handler)
-- 
2.34.1

</pre></div></content></entry><entry><author><name>YiPeng Chai</name><email>YiPeng.Chai@amd.com</email></author><title>[PATCH V2 1/4] drm/amdgpu: add variable to record the deferred error number read by driver</title><updated>2024-06-20T05:41:25Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620054020.434523-1-YiPeng.Chai@amd.com/"/><id>urn:uuid:ff94a36d-537c-03bd-0d4e-97f020b684d6</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Add variable to record the deferred error
number read by driver.

Signed-off-by: YiPeng Chai &lt;YiPeng.Chai@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c | 62 ++++++++++++++++++-------
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h |  3 +-
 drivers/gpu/drm/amd/amdgpu/umc_v12_0.c  |  4 +-
 3 files <a href="http://lore.kernel.org/amd-gfx/20240620054020.434523-1-YiPeng.Chai@amd.com/#related">changed</a>, 48 insertions(+), 21 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
index 86cb97d2155b..f674e34037b6 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
</span><span
class="hunk">@@ -120,7 +120,7 @@ const char *get_ras_block_str(struct ras_common_if *ras_block)
</span> /* typical ECC bad page rate is 1 bad page per 100MB VRAM */
 #define RAS_BAD_PAGE_COVER              (100 * 1024 * 1024ULL)
 
<span
class="del">-#define MAX_UMC_POISON_POLLING_TIME_ASYNC  100  //ms
</span><span
class="add">+#define MAX_UMC_POISON_POLLING_TIME_ASYNC  300  //ms
</span> 
 #define AMDGPU_RAS_RETIRE_PAGE_INTERVAL 100  //ms
 
<span
class="hunk">@@ -2804,7 +2804,8 @@ static void amdgpu_ras_ecc_log_init(struct ras_ecc_log_info *ecc_log)
</span> 	memset(&#38;ecc_log-&gt;ecc_key, 0xad, sizeof(ecc_log-&gt;ecc_key));
 
 	INIT_RADIX_TREE(&#38;ecc_log-&gt;de_page_tree, GFP_KERNEL);
<span
class="del">-	ecc_log-&gt;de_updated = false;
</span><span
class="add">+	ecc_log-&gt;de_queried_count = 0;
+	ecc_log-&gt;prev_de_queried_count = 0;
</span> }
 
 static void amdgpu_ras_ecc_log_fini(struct ras_ecc_log_info *ecc_log)
<span
class="hunk">@@ -2823,7 +2824,8 @@ static void amdgpu_ras_ecc_log_fini(struct ras_ecc_log_info *ecc_log)
</span> 	mutex_unlock(&#38;ecc_log-&gt;lock);
 
 	mutex_destroy(&#38;ecc_log-&gt;lock);
<span
class="del">-	ecc_log-&gt;de_updated = false;
</span><span
class="add">+	ecc_log-&gt;de_queried_count = 0;
+	ecc_log-&gt;prev_de_queried_count = 0;
</span> }
 #endif
 
<span
class="hunk">@@ -2856,40 +2858,64 @@ static void amdgpu_ras_do_page_retirement(struct work_struct *work)
</span> 	mutex_unlock(&#38;con-&gt;umc_ecc_log.lock);
 }
 
<span
class="del">-static void amdgpu_ras_poison_creation_handler(struct amdgpu_device *adev,
-				uint32_t timeout_ms)
</span><span
class="add">+static int amdgpu_ras_poison_creation_handler(struct amdgpu_device *adev,
+				uint32_t poison_creation_count)
</span> {
 	int ret = 0;
 	struct ras_ecc_log_info *ecc_log;
 	struct ras_query_if info;
<span
class="del">-	uint32_t timeout = timeout_ms;
</span><span
class="add">+	uint32_t timeout = 0;
</span> 	struct amdgpu_ras *ras = amdgpu_ras_get_context(adev);
<span
class="add">+	uint64_t de_queried_count;
+	uint32_t new_detect_count, total_detect_count;
+	uint32_t need_query_count = poison_creation_count;
+	bool query_data_timeout = false;
</span> 
 	memset(&#38;info, 0, sizeof(info));
 	info.head.block = AMDGPU_RAS_BLOCK__UMC;
 
 	ecc_log = &#38;ras-&gt;umc_ecc_log;
<span
class="del">-	ecc_log-&gt;de_updated = false;
</span><span
class="add">+	total_detect_count = 0;
</span> 	do {
 		ret = amdgpu_ras_query_error_status(adev, &#38;info);
<span
class="del">-		if (ret) {
-			dev_err(adev-&gt;dev, &#34;Failed to query ras error! ret:%d\n&#34;, ret);
-			return;
</span><span
class="add">+		if (ret)
+			return ret;
+
+		de_queried_count = ecc_log-&gt;de_queried_count;
+		if (de_queried_count &gt; ecc_log-&gt;prev_de_queried_count) {
+			new_detect_count = de_queried_count - ecc_log-&gt;prev_de_queried_count;
+			ecc_log-&gt;prev_de_queried_count = de_queried_count;
+			timeout = 0;
+		} else {
+			new_detect_count = 0;
</span> 		}
 
<span
class="del">-		if (timeout &#38;&#38; !ecc_log-&gt;de_updated) {
-			msleep(1);
-			timeout--;
</span><span
class="add">+		if (new_detect_count) {
+			total_detect_count += new_detect_count;
+		} else {
+			if (!timeout &#38;&#38; need_query_count)
+				timeout = MAX_UMC_POISON_POLLING_TIME_ASYNC;
+
+			if (timeout) {
+				if (!--timeout) {
+					query_data_timeout = true;
+					break;
+				}
+				msleep(1);
+			}
</span> 		}
<span
class="del">-	} while (timeout &#38;&#38; !ecc_log-&gt;de_updated);
</span><span
class="add">+	} while (total_detect_count &lt; need_query_count);
</span> 
<span
class="del">-	if (timeout_ms &#38;&#38; !timeout) {
-		dev_warn(adev-&gt;dev, &#34;Can&#39;t find deferred error\n&#34;);
-		return;
</span><span
class="add">+	if (query_data_timeout) {
+		dev_warn(adev-&gt;dev, &#34;Can&#39;t find deferred error! count: %u\n&#34;,
+			(need_query_count - total_detect_count));
+		return -ENOENT;
</span> 	}
 
<span
class="del">-	if (!ret)
</span><span
class="add">+	if (total_detect_count)
</span> 		schedule_delayed_work(&#38;ras-&gt;page_retirement_dwork, 0);
<span
class="add">+
+	return 0;
</span> }
 
 static int amdgpu_ras_poison_consumption_handler(struct amdgpu_device *adev,
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
index 83437fef9df5..748bbac666e6 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
</span><span
class="hunk">@@ -469,7 +469,8 @@ struct ras_ecc_log_info {
</span> 	struct mutex lock;
 	siphash_key_t ecc_key;
 	struct radix_tree_root de_page_tree;
<span
class="del">-	bool	de_updated;
</span><span
class="add">+	uint64_t	de_queried_count;
+	uint64_t	prev_de_queried_count;
</span> };
 
 struct amdgpu_ras {
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/umc_v12_0.c b/drivers/gpu/drm/amd/amdgpu/umc_v12_0.c
index 6d6350f220b0..0faa21d8a7b4 100644
--- a/drivers/gpu/drm/amd/amdgpu/umc_v12_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/umc_v12_0.c
</span><span
class="hunk">@@ -557,7 +557,7 @@ static int umc_v12_0_update_ecc_status(struct amdgpu_device *adev,
</span> 	ret = amdgpu_umc_logs_ecc_err(adev, &#38;con-&gt;umc_ecc_log.de_page_tree, ecc_err);
 	if (ret) {
 		if (ret == -EEXIST)
<span
class="del">-			con-&gt;umc_ecc_log.de_updated = true;
</span><span
class="add">+			con-&gt;umc_ecc_log.de_queried_count++;
</span> 		else
 			dev_err(adev-&gt;dev, &#34;Fail to log ecc error! ret:%d\n&#34;, ret);
 
<span
class="hunk">@@ -566,7 +566,7 @@ static int umc_v12_0_update_ecc_status(struct amdgpu_device *adev,
</span> 		return ret;
 	}
 
<span
class="del">-	con-&gt;umc_ecc_log.de_updated = true;
</span><span
class="add">+	con-&gt;umc_ecc_log.de_queried_count++;
</span> 
 	return 0;
 }
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Kenneth Feng</name><email>kenneth.feng@amd.com</email></author><title
type="html">[PATCH 2/2] Revert &#34;drm/amd/amdgpu: add module parameter for jpeg&#34;</title><updated>2024-06-20T01:24:50Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620012434.1742537-2-kenneth.feng@amd.com/"/><id>urn:uuid:284e84c9-f555-27e6-09c8-d544da5c0cb7</id><thr:in-reply-to
ref="urn:uuid:b3df72ea-2bd9-0ba8-2c5e-f37e956e279d"
href="http://lore.kernel.org/amd-gfx/20240620012434.1742537-1-kenneth.feng@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This reverts commit 63400bcf5cb23b6a9b674eb3f2d733d826860065.
Revert this due to a final solution in amdgu vcn:
commit eef47ed5f703377781ce89eae4b9140325049873
Author: Sonny Jiang &lt;sonjiang@amd.com&gt;
Date:   Tue Jun 18 11:11:11 2024 -0400

drm/amdgpu/jpeg5: reprogram doorbell setting after power up for each playback

Doorbell needs to be configured after power up during each playback

Signed-off-by: Kenneth Feng &lt;kenneth.feng@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu.h           | 2 --
 drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c | 2 --
 drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c       | 4 ----
 3 files <a href="http://lore.kernel.org/amd-gfx/20240620012434.1742537-2-kenneth.feng@amd.com/#related">changed</a>, 8 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
index 6129f9f7a577..137a88b8de45 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
</span><span
class="hunk">@@ -224,7 +224,6 @@ extern int amdgpu_mes;
</span> extern int amdgpu_mes_log_enable;
 extern int amdgpu_mes_kiq;
 extern int amdgpu_uni_mes;
<span
class="del">-extern int amdgpu_jpeg_test;
</span> extern int amdgpu_noretry;
 extern int amdgpu_force_asic_type;
 extern int amdgpu_smartshift_bias;
<span
class="hunk">@@ -1022,7 +1021,6 @@ struct amdgpu_device {
</span> 
 	/* jpeg */
 	struct amdgpu_jpeg		jpeg;
<span
class="del">-	bool enable_jpeg_test;
</span> 
 	/* vpe */
 	struct amdgpu_vpe		vpe;
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
index 4edcbd272fa4..df753ebfd109 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
</span><span
class="hunk">@@ -2302,8 +2302,6 @@ static int amdgpu_discovery_set_mm_ip_blocks(struct amdgpu_device *adev)
</span> 		case IP_VERSION(5, 0, 0):
 			amdgpu_device_ip_block_add(adev, &#38;vcn_v5_0_0_ip_block);
 			amdgpu_device_ip_block_add(adev, &#38;jpeg_v5_0_0_ip_block);
<span
class="del">-			if (amdgpu_jpeg_test)
-				adev-&gt;enable_jpeg_test = true;
</span> 			break;
 		default:
 			dev_err(adev-&gt;dev,
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
index 60d5758939ae..802debd8d9f0 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
</span><span
class="hunk">@@ -205,7 +205,6 @@ int amdgpu_force_asic_type = -1;
</span> int amdgpu_tmz = -1; /* auto */
 uint amdgpu_freesync_vid_mode;
 int amdgpu_reset_method = -1; /* auto */
<span
class="del">-int amdgpu_jpeg_test;
</span> int amdgpu_num_kcq = -1;
 int amdgpu_smartshift_bias;
 int amdgpu_use_xgmi_p2p = 1;
<span
class="hunk">@@ -941,9 +940,6 @@ module_param_named(freesync_video, amdgpu_freesync_vid_mode, uint, 0444);
</span> MODULE_PARM_DESC(reset_method, &#34;GPU reset method (-1 = auto (default), 0 = legacy, 1 = mode0, 2 = mode1, 3 = mode2, 4 = baco/bamaco)&#34;);
 module_param_named(reset_method, amdgpu_reset_method, int, 0644);
 
<span
class="del">-MODULE_PARM_DESC(jpeg_test, &#34;jpeg test(0 = disable (default), 1 = enable)&#34;);
-module_param_named(jpeg_test, amdgpu_jpeg_test, int, 0444);
-
</span> /**
  * DOC: bad_page_threshold (int) Bad page threshold is specifies the
  * threshold value of faulty pages detected by RAS ECC, which may
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Kenneth Feng</name><email>kenneth.feng@amd.com</email></author><title
type="html">[PATCH 1/2] Revert &#34;drm/amd/pm: workaround to pass jpeg unit test&#34;</title><updated>2024-06-20T01:24:45Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620012434.1742537-1-kenneth.feng@amd.com/"/><id>urn:uuid:b3df72ea-2bd9-0ba8-2c5e-f37e956e279d</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This reverts commit a03b8169582453c01cbf76d8a92a8194d3421b13.
Revert this due to a final solution in amdgpu vcn:
commit eef47ed5f703377781ce89eae4b9140325049873
Author: Sonny Jiang &lt;sonjiang@amd.com&gt;
Date:   Tue Jun 18 11:11:11 2024 -0400

    drm/amdgpu/jpeg5: reprogram doorbell setting after power up for each playback

    Doorbell needs to be configured after power up during each playback

Signed-off-by: Kenneth Feng &lt;kenneth.feng@amd.com&gt;
---
 drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c     |  3 +-
 .../drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c  | 30 +------------------
 2 files <a href="http://lore.kernel.org/amd-gfx/20240620012434.1742537-1-kenneth.feng@amd.com/#related">changed</a>, 2 insertions(+), 31 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c b/drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c
index 8e694b576d1c..00384b381289 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c
</span><span
class="hunk">@@ -237,7 +237,6 @@ static int smu_dpm_set_vcn_enable(struct smu_context *smu,
</span> {
 	struct smu_power_context *smu_power = &#38;smu-&gt;smu_power;
 	struct smu_power_gate *power_gate = &#38;smu_power-&gt;power_gate;
<span
class="del">-	struct amdgpu_device *adev = smu-&gt;adev;
</span> 	int ret = 0;
 
 	/*
<span
class="hunk">@@ -253,7 +252,7 @@ static int smu_dpm_set_vcn_enable(struct smu_context *smu,
</span> 		return 0;
 
 	ret = smu-&gt;ppt_funcs-&gt;dpm_set_vcn_enable(smu, enable);
<span
class="del">-	if (!ret &#38;&#38; !adev-&gt;enable_jpeg_test)
</span><span
class="add">+	if (!ret)
</span> 		atomic_set(&#38;power_gate-&gt;vcn_gated, !enable);
 
 	return ret;
<span
class="head">diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c
index 7179cdacf156..98ea58d792ca 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c
</span><span
class="hunk">@@ -1869,34 +1869,6 @@ static ssize_t smu_v14_0_2_get_ecc_info(struct smu_context *smu,
</span> 	return ret;
 }
 
<span
class="del">-static int smu_v14_0_2_set_vcn_enable(struct smu_context *smu,
-			     bool enable)
-{
-	struct amdgpu_device *adev = smu-&gt;adev;
-	struct smu_power_gate *power_gate = &#38;smu-&gt;smu_power.power_gate;
-	int i, ret = 0;
-
-	if (!adev-&gt;enable_jpeg_test)
-		return smu_v14_0_set_vcn_enable(smu, enable);
-
-	if (!atomic_read(&#38;power_gate-&gt;vcn_gated) || !enable)
-		return 0;
-
-	for (i = 0; i &lt; adev-&gt;vcn.num_vcn_inst; i++) {
-		if (adev-&gt;vcn.harvest_config &#38; (1 &lt;&lt; i))
-			continue;
-
-		ret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_PowerUpVcn,
-						      i &lt;&lt; 16U, NULL);
-		if (ret)
-			return ret;
-	}
-
-	atomic_set(&#38;power_gate-&gt;vcn_gated, 0);
-
-	return ret;
-}
-
</span> static const struct pptable_funcs smu_v14_0_2_ppt_funcs = {
 	.get_allowed_feature_mask = smu_v14_0_2_get_allowed_feature_mask,
 	.set_default_dpm_table = smu_v14_0_2_set_default_dpm_table,
<span
class="hunk">@@ -1919,7 +1891,7 @@ static const struct pptable_funcs smu_v14_0_2_ppt_funcs = {
</span> 	.system_features_control = smu_v14_0_system_features_control,
 	.set_allowed_mask = smu_v14_0_set_allowed_mask,
 	.get_enabled_mask = smu_cmn_get_enabled_mask,
<span
class="del">-	.dpm_set_vcn_enable = smu_v14_0_2_set_vcn_enable,
</span><span
class="add">+	.dpm_set_vcn_enable = smu_v14_0_set_vcn_enable,
</span> 	.dpm_set_jpeg_enable = smu_v14_0_set_jpeg_enable,
 	.get_dpm_ultimate_freq = smu_v14_0_2_get_dpm_ultimate_freq,
 	.get_vbios_bootup_values = smu_v14_0_get_vbios_bootup_values,
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Yunxiang Li</name><email>Yunxiang.Li@amd.com</email></author><title>[PATCH] drm/amdgpu: track bo memory stats at runtime</title><updated>2024-06-20T00:30:35Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240620003014.21453-1-Yunxiang.Li@amd.com/"/><id>urn:uuid:23e8f056-ef06-9ffd-45e8-e0cded6c9717</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Before, every time fdinfo is queried we try to lock all the BOs in the
VM and calculate memory usage from scratch. This works okay if the
fdinfo is rarely read and the VMs don&#39;t have a ton of BOs. If either of
these conditions is not true, we get a massive performance hit.

In this new revision, we track the BOs as they change state. This way
when the fdinfo is queried we only need to take the status lock and copy
out the usage stats with minimal impact to the runtime performance.

To simplify the initial implementation, this revision drops tracking how
much memory is visible, since on modern systems all of vram can be
visible anyways. Also we do not track &#34;unsharing&#34; a BO, the shared stat
is only decreased when the BO is destroyed.

Signed-off-by: Yunxiang Li &lt;Yunxiang.Li@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_dma_buf.c | 26 ++++++++++-
 drivers/gpu/drm/amd/amdgpu/amdgpu_fdinfo.c  |  6 ---
 drivers/gpu/drm/amd/amdgpu/amdgpu_object.c  | 52 ++++++++++++++-------
 drivers/gpu/drm/amd/amdgpu/amdgpu_object.h  | 31 ++----------
 drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c     | 15 ++++--
 drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c      | 47 +++----------------
 drivers/gpu/drm/amd/amdgpu/amdgpu_vm.h      | 25 +++++++++-
 drivers/gpu/drm/amd/amdgpu/amdgpu_vm_pt.c   |  1 +
 include/uapi/drm/amdgpu_drm.h               |  5 ++
 9 files <a href="http://lore.kernel.org/amd-gfx/20240620003014.21453-1-Yunxiang.Li@amd.com/#related">changed</a>, 111 insertions(+), 97 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dma_buf.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_dma_buf.c
index 8e81a83d37d8..cc78704a5f4e 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dma_buf.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dma_buf.c
</span><span
class="hunk">@@ -35,6 +35,8 @@
</span> #include &#34;amdgpu_display.h&#34;
 #include &#34;amdgpu_gem.h&#34;
 #include &#34;amdgpu_dma_buf.h&#34;
<span
class="add">+#include &#34;amdgpu_object.h&#34;
+#include &#34;amdgpu_vm.h&#34;
</span> #include &#34;amdgpu_xgmi.h&#34;
 #include &lt;drm/amdgpu_drm.h&gt;
 #include &lt;drm/ttm/ttm_tt.h&gt;
<span
class="hunk">@@ -259,14 +261,36 @@ struct dma_buf *amdgpu_gem_prime_export(struct drm_gem_object *gobj,
</span> {
 	struct amdgpu_bo *bo = gem_to_amdgpu_bo(gobj);
 	struct dma_buf *buf;
<span
class="add">+	struct amdgpu_vm_bo_base *base;
+	struct amdgpu_mem_stats stats = { 0 };
+	bool update_stats;
</span> 
 	if (amdgpu_ttm_tt_get_usermm(bo-&gt;tbo.ttm) ||
 	    bo-&gt;flags &#38; AMDGPU_GEM_CREATE_VM_ALWAYS_VALID)
 		return ERR_PTR(-EPERM);
 
<span
class="add">+	dma_resv_lock(bo-&gt;tbo.base.resv, NULL);
+	update_stats = !(bo-&gt;flags &#38; AMDGPU_GEM_WAS_EXPORTED);
+	if (update_stats)
+		amdgpu_bo_add_memory(bo, &#38;stats);
+	else
+		dma_resv_unlock(bo-&gt;tbo.base.resv);
+
</span> 	buf = drm_gem_prime_export(gobj, flags);
<span
class="del">-	if (!IS_ERR(buf))
</span><span
class="add">+	if (!IS_ERR(buf)) {
</span> 		buf-&gt;ops = &#38;amdgpu_dmabuf_ops;
<span
class="add">+		if (update_stats) {
+			for (base = bo-&gt;vm_bo; base; base = base-&gt;next) {
+				spin_lock(&#38;base-&gt;vm-&gt;status_lock);
+				base-&gt;vm-&gt;stats.vram_shared += stats.vram;
+				base-&gt;vm-&gt;stats.gtt_shared += stats.gtt;
+				base-&gt;vm-&gt;stats.cpu_shared += stats.cpu;
+				spin_unlock(&#38;base-&gt;vm-&gt;status_lock);
+			}
+			bo-&gt;flags |= AMDGPU_GEM_WAS_EXPORTED;
+			dma_resv_unlock(bo-&gt;tbo.base.resv);
+		}
+	}
</span> 
 	return buf;
 }
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_fdinfo.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_fdinfo.c
index c7df7fa3459f..9a40ff5c6dd3 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_fdinfo.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_fdinfo.c
</span><span
class="hunk">@@ -85,16 +85,10 @@ void amdgpu_show_fdinfo(struct drm_printer *p, struct drm_file *file)
</span> 	drm_printf(p, &#34;drm-memory-vram:\t%llu KiB\n&#34;, stats.vram/1024UL);
 	drm_printf(p, &#34;drm-memory-gtt: \t%llu KiB\n&#34;, stats.gtt/1024UL);
 	drm_printf(p, &#34;drm-memory-cpu: \t%llu KiB\n&#34;, stats.cpu/1024UL);
<span
class="del">-	drm_printf(p, &#34;amd-memory-visible-vram:\t%llu KiB\n&#34;,
-		   stats.visible_vram/1024UL);
</span> 	drm_printf(p, &#34;amd-evicted-vram:\t%llu KiB\n&#34;,
 		   stats.evicted_vram/1024UL);
<span
class="del">-	drm_printf(p, &#34;amd-evicted-visible-vram:\t%llu KiB\n&#34;,
-		   stats.evicted_visible_vram/1024UL);
</span> 	drm_printf(p, &#34;amd-requested-vram:\t%llu KiB\n&#34;,
 		   stats.requested_vram/1024UL);
<span
class="del">-	drm_printf(p, &#34;amd-requested-visible-vram:\t%llu KiB\n&#34;,
-		   stats.requested_visible_vram/1024UL);
</span> 	drm_printf(p, &#34;amd-requested-gtt:\t%llu KiB\n&#34;,
 		   stats.requested_gtt/1024UL);
 	drm_printf(p, &#34;drm-shared-vram:\t%llu KiB\n&#34;, stats.vram_shared/1024UL);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
index 1eadcad1856d..4d6fda142f65 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
</span><span
class="hunk">@@ -29,6 +29,7 @@
</span>  *    Thomas Hellstrom &lt;thomas-at-tungstengraphics-dot-com&gt;
  *    Dave Airlie
  */
<span
class="add">+#include &#34;amdgpu_vm.h&#34;
</span> #include &lt;linux/list.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/dma-buf.h&gt;
<span
class="hunk">@@ -1260,12 +1261,20 @@ void amdgpu_bo_move_notify(struct ttm_buffer_object *bo,
</span> {
 	struct amdgpu_device *adev = amdgpu_ttm_adev(bo-&gt;bdev);
 	struct ttm_resource *old_mem = bo-&gt;resource;
<span
class="del">-	struct amdgpu_bo *abo;
</span><span
class="add">+	struct amdgpu_bo *abo, *tmp;
+	struct amdgpu_vm_bo_base *base;
</span> 
 	if (!amdgpu_bo_is_amdgpu_bo(bo))
 		return;
 
<span
class="del">-	abo = ttm_to_amdgpu_bo(bo);
</span><span
class="add">+	tmp = abo = ttm_to_amdgpu_bo(bo);
+	if (tmp-&gt;parent &#38;&#38; (amdgpu_bo_shadowed(tmp-&gt;parent) == tmp))
+		tmp = tmp-&gt;parent;
+	for (base = tmp-&gt;vm_bo; base; base = base-&gt;next) {
+		spin_lock(&#38;base-&gt;vm-&gt;status_lock);
+		amdgpu_bo_sub_memory(tmp, &#38;base-&gt;vm-&gt;stats);
+		spin_unlock(&#38;base-&gt;vm-&gt;status_lock);
+	}
</span> 	amdgpu_vm_bo_invalidate(adev, abo, evict);
 
 	amdgpu_bo_kunmap(abo);
<span
class="hunk">@@ -1279,27 +1288,22 @@ void amdgpu_bo_move_notify(struct ttm_buffer_object *bo,
</span> 			     old_mem ? old_mem-&gt;mem_type : -1);
 }
 
<span
class="del">-void amdgpu_bo_get_memory(struct amdgpu_bo *bo,
</span><span
class="add">+void amdgpu_bo_add_memory(struct amdgpu_bo *bo,
</span> 			  struct amdgpu_mem_stats *stats)
 {
<span
class="del">-	struct amdgpu_device *adev = amdgpu_ttm_adev(bo-&gt;tbo.bdev);
</span> 	struct ttm_resource *res = bo-&gt;tbo.resource;
 	uint64_t size = amdgpu_bo_size(bo);
<span
class="del">-	struct drm_gem_object *obj;
</span> 	bool shared;
 
 	/* Abort if the BO doesn&#39;t currently have a backing store */
 	if (!res)
 		return;
 
<span
class="del">-	obj = &#38;bo-&gt;tbo.base;
-	shared = drm_gem_object_is_shared_for_memory_stats(obj);
</span><span
class="add">+	shared = !!(bo-&gt;flags &#38; AMDGPU_GEM_WAS_EXPORTED);
</span> 
 	switch (res-&gt;mem_type) {
 	case TTM_PL_VRAM:
 		stats-&gt;vram += size;
<span
class="del">-		if (amdgpu_res_cpu_visible(adev, res))
-			stats-&gt;visible_vram += size;
</span> 		if (shared)
 			stats-&gt;vram_shared += size;
 		break;
<span
class="hunk">@@ -1318,19 +1322,35 @@ void amdgpu_bo_get_memory(struct amdgpu_bo *bo,
</span> 
 	if (bo-&gt;preferred_domains &#38; AMDGPU_GEM_DOMAIN_VRAM) {
 		stats-&gt;requested_vram += size;
<span
class="del">-		if (bo-&gt;flags &#38; AMDGPU_GEM_CREATE_CPU_ACCESS_REQUIRED)
-			stats-&gt;requested_visible_vram += size;
-
-		if (res-&gt;mem_type != TTM_PL_VRAM) {
</span><span
class="add">+		if (res-&gt;mem_type != TTM_PL_VRAM)
</span> 			stats-&gt;evicted_vram += size;
<span
class="del">-			if (bo-&gt;flags &#38; AMDGPU_GEM_CREATE_CPU_ACCESS_REQUIRED)
-				stats-&gt;evicted_visible_vram += size;
-		}
</span> 	} else if (bo-&gt;preferred_domains &#38; AMDGPU_GEM_DOMAIN_GTT) {
 		stats-&gt;requested_gtt += size;
 	}
 }
 
<span
class="add">+void amdgpu_bo_sub_memory(struct amdgpu_bo *bo,
+			  struct amdgpu_mem_stats *stats)
+{
+	struct amdgpu_device *adev = amdgpu_ttm_adev(bo-&gt;tbo.bdev);
+	struct amdgpu_mem_stats bo_stats = { 0 };
+	uint64_t *stats_arr = (uint64_t *)stats;
+	uint64_t *bo_stats_arr = (uint64_t *)&#38;bo_stats;
+
+	amdgpu_bo_add_memory(bo, &#38;bo_stats);
+
+	// stats is a struct with all uint64_t members so we cast and loop over it like an array
+	for (int i = 0; i &lt; (sizeof(*stats) / sizeof(*stats_arr)); ++i) {
+		if (stats_arr[i] &gt;= bo_stats_arr[i]) {
+			stats_arr[i] -= bo_stats_arr[i];
+		} else if (bo_stats_arr[i]) {
+			stats_arr[i] = 0;
+			dev_err(adev-&gt;dev,
+				&#34;amdgpu memory stats doesn&#39;t match, some bo was missed?\n&#34;);
+		}
+	}
+}
+
</span> /**
  * amdgpu_bo_release_notify - notification about a BO being released
  * @bo: pointer to a buffer object
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h
index bc42ccbde659..23c1c9385f7f 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h
</span><span
class="hunk">@@ -135,33 +135,6 @@ struct amdgpu_bo_vm {
</span> 	struct amdgpu_vm_bo_base        entries[];
 };
 
<span
class="del">-struct amdgpu_mem_stats {
-	/* current VRAM usage, includes visible VRAM */
-	uint64_t vram;
-	/* current shared VRAM usage, includes visible VRAM */
-	uint64_t vram_shared;
-	/* current visible VRAM usage */
-	uint64_t visible_vram;
-	/* current GTT usage */
-	uint64_t gtt;
-	/* current shared GTT usage */
-	uint64_t gtt_shared;
-	/* current system memory usage */
-	uint64_t cpu;
-	/* current shared system memory usage */
-	uint64_t cpu_shared;
-	/* sum of evicted buffers, includes visible VRAM */
-	uint64_t evicted_vram;
-	/* sum of evicted buffers due to CPU access */
-	uint64_t evicted_visible_vram;
-	/* how much userspace asked for, includes vis.VRAM */
-	uint64_t requested_vram;
-	/* how much userspace asked for */
-	uint64_t requested_visible_vram;
-	/* how much userspace asked for */
-	uint64_t requested_gtt;
-};
-
</span> static inline struct amdgpu_bo *ttm_to_amdgpu_bo(struct ttm_buffer_object *tbo)
 {
 	return container_of(tbo, struct amdgpu_bo, tbo);
<span
class="hunk">@@ -341,7 +314,9 @@ int amdgpu_bo_sync_wait_resv(struct amdgpu_device *adev, struct dma_resv *resv,
</span> int amdgpu_bo_sync_wait(struct amdgpu_bo *bo, void *owner, bool intr);
 u64 amdgpu_bo_gpu_offset(struct amdgpu_bo *bo);
 u64 amdgpu_bo_gpu_offset_no_check(struct amdgpu_bo *bo);
<span
class="del">-void amdgpu_bo_get_memory(struct amdgpu_bo *bo,
</span><span
class="add">+void amdgpu_bo_add_memory(struct amdgpu_bo *bo,
+			  struct amdgpu_mem_stats *stats);
+void amdgpu_bo_sub_memory(struct amdgpu_bo *bo,
</span> 			  struct amdgpu_mem_stats *stats);
 void amdgpu_bo_add_to_shadow_list(struct amdgpu_bo_vm *vmbo);
 int amdgpu_bo_restore_shadow(struct amdgpu_bo *shadow,
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c
index 9a92dd3c9fb8..af1b480ea4d4 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c
</span><span
class="hunk">@@ -478,6 +478,7 @@ static int amdgpu_bo_move(struct ttm_buffer_object *bo, bool evict,
</span> 	struct amdgpu_device *adev;
 	struct amdgpu_bo *abo;
 	struct ttm_resource *old_mem = bo-&gt;resource;
<span
class="add">+	struct amdgpu_vm_bo_base *base;
</span> 	int r;
 
 	if (new_mem-&gt;mem_type == TTM_PL_TT ||
<span
class="hunk">@@ -494,14 +495,14 @@ static int amdgpu_bo_move(struct ttm_buffer_object *bo, bool evict,
</span> 			 bo-&gt;ttm == NULL)) {
 		amdgpu_bo_move_notify(bo, evict, new_mem);
 		ttm_bo_move_null(bo, new_mem);
<span
class="del">-		return 0;
</span><span
class="add">+		goto out;
</span> 	}
 	if (old_mem-&gt;mem_type == TTM_PL_SYSTEM &#38;&#38;
 	    (new_mem-&gt;mem_type == TTM_PL_TT ||
 	     new_mem-&gt;mem_type == AMDGPU_PL_PREEMPT)) {
 		amdgpu_bo_move_notify(bo, evict, new_mem);
 		ttm_bo_move_null(bo, new_mem);
<span
class="del">-		return 0;
</span><span
class="add">+		goto out;
</span> 	}
 	if ((old_mem-&gt;mem_type == TTM_PL_TT ||
 	     old_mem-&gt;mem_type == AMDGPU_PL_PREEMPT) &#38;&#38;
<span
class="hunk">@@ -514,7 +515,7 @@ static int amdgpu_bo_move(struct ttm_buffer_object *bo, bool evict,
</span> 		amdgpu_bo_move_notify(bo, evict, new_mem);
 		ttm_resource_free(bo, &#38;bo-&gt;resource);
 		ttm_bo_assign_mem(bo, new_mem);
<span
class="del">-		return 0;
</span><span
class="add">+		goto out;
</span> 	}
 
 	if (old_mem-&gt;mem_type == AMDGPU_PL_GDS ||
<span
class="hunk">@@ -528,7 +529,7 @@ static int amdgpu_bo_move(struct ttm_buffer_object *bo, bool evict,
</span> 		/* Nothing to save here */
 		amdgpu_bo_move_notify(bo, evict, new_mem);
 		ttm_bo_move_null(bo, new_mem);
<span
class="del">-		return 0;
</span><span
class="add">+		goto out;
</span> 	}
 
 	if (bo-&gt;type == ttm_bo_type_device &#38;&#38;
<span
class="hunk">@@ -575,6 +576,12 @@ static int amdgpu_bo_move(struct ttm_buffer_object *bo, bool evict,
</span> 	if (evict)
 		atomic64_inc(&#38;adev-&gt;num_evictions);
 	atomic64_add(bo-&gt;base.size, &#38;adev-&gt;num_bytes_moved);
<span
class="add">+out:
+	for (base = abo-&gt;vm_bo; base; base = base-&gt;next) {
+		spin_lock(&#38;base-&gt;vm-&gt;status_lock);
+		amdgpu_bo_add_memory(abo, &#38;base-&gt;vm-&gt;stats);
+		spin_unlock(&#38;base-&gt;vm-&gt;status_lock);
+	}
</span> 	return 0;
 }
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
index 3abfa66d72a2..b373bafa7b4e 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
</span><span
class="hunk">@@ -332,6 +332,9 @@ void amdgpu_vm_bo_base_init(struct amdgpu_vm_bo_base *base,
</span> 		return;
 	base-&gt;next = bo-&gt;vm_bo;
 	bo-&gt;vm_bo = base;
<span
class="add">+	spin_lock(&#38;vm-&gt;status_lock);
+	amdgpu_bo_add_memory(bo, &#38;vm-&gt;stats);
+	spin_unlock(&#38;vm-&gt;status_lock);
</span> 
 	if (!amdgpu_vm_is_bo_always_valid(vm, bo))
 		return;
<span
class="hunk">@@ -1088,51 +1091,11 @@ int amdgpu_vm_update_range(struct amdgpu_device *adev, struct amdgpu_vm *vm,
</span> 	return r;
 }
 
<span
class="del">-static void amdgpu_vm_bo_get_memory(struct amdgpu_bo_va *bo_va,
-				    struct amdgpu_mem_stats *stats)
-{
-	struct amdgpu_vm *vm = bo_va-&gt;base.vm;
-	struct amdgpu_bo *bo = bo_va-&gt;base.bo;
-
-	if (!bo)
-		return;
-
-	/*
-	 * For now ignore BOs which are currently locked and potentially
-	 * changing their location.
-	 */
-	if (!amdgpu_vm_is_bo_always_valid(vm, bo) &#38;&#38;
-	    !dma_resv_trylock(bo-&gt;tbo.base.resv))
-		return;
-
-	amdgpu_bo_get_memory(bo, stats);
-	if (!amdgpu_vm_is_bo_always_valid(vm, bo))
-		dma_resv_unlock(bo-&gt;tbo.base.resv);
-}
-
</span> void amdgpu_vm_get_memory(struct amdgpu_vm *vm,
 			  struct amdgpu_mem_stats *stats)
 {
<span
class="del">-	struct amdgpu_bo_va *bo_va, *tmp;
-
</span> 	spin_lock(&#38;vm-&gt;status_lock);
<span
class="del">-	list_for_each_entry_safe(bo_va, tmp, &#38;vm-&gt;idle, base.vm_status)
-		amdgpu_vm_bo_get_memory(bo_va, stats);
-
-	list_for_each_entry_safe(bo_va, tmp, &#38;vm-&gt;evicted, base.vm_status)
-		amdgpu_vm_bo_get_memory(bo_va, stats);
-
-	list_for_each_entry_safe(bo_va, tmp, &#38;vm-&gt;relocated, base.vm_status)
-		amdgpu_vm_bo_get_memory(bo_va, stats);
-
-	list_for_each_entry_safe(bo_va, tmp, &#38;vm-&gt;moved, base.vm_status)
-		amdgpu_vm_bo_get_memory(bo_va, stats);
-
-	list_for_each_entry_safe(bo_va, tmp, &#38;vm-&gt;invalidated, base.vm_status)
-		amdgpu_vm_bo_get_memory(bo_va, stats);
-
-	list_for_each_entry_safe(bo_va, tmp, &#38;vm-&gt;done, base.vm_status)
-		amdgpu_vm_bo_get_memory(bo_va, stats);
</span><span
class="add">+	*stats = vm-&gt;stats;
</span> 	spin_unlock(&#38;vm-&gt;status_lock);
 }
 
<span
class="hunk">@@ -2049,6 +2012,8 @@ void amdgpu_vm_bo_del(struct amdgpu_device *adev,
</span> 	}
 
 	spin_lock(&#38;vm-&gt;status_lock);
<span
class="add">+	if (bo)
+		amdgpu_bo_sub_memory(bo, &#38;vm-&gt;stats);
</span> 	list_del(&#38;bo_va-&gt;base.vm_status);
 	spin_unlock(&#38;vm-&gt;status_lock);
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.h
index 046949c4b695..3f9650ac612e 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.h
</span><span
class="hunk">@@ -42,7 +42,28 @@ struct amdgpu_bo_va;
</span> struct amdgpu_job;
 struct amdgpu_bo_list_entry;
 struct amdgpu_bo_vm;
<span
class="del">-struct amdgpu_mem_stats;
</span><span
class="add">+
+struct amdgpu_mem_stats {
+	/* current VRAM usage */
+	uint64_t vram;
+	/* current shared VRAM usage */
+	uint64_t vram_shared;
+	/* current GTT usage */
+	uint64_t gtt;
+	/* current shared GTT usage */
+	uint64_t gtt_shared;
+	/* current system memory usage */
+	uint64_t cpu;
+	/* current shared system memory usage */
+	uint64_t cpu_shared;
+	/* sum of evicted buffers */
+	uint64_t evicted_vram;
+	/* how much userspace asked for */
+	uint64_t requested_vram;
+	/* how much userspace asked for */
+	uint64_t requested_gtt;
+};
+
</span> 
 /*
  * GPUVM handling
<span
class="hunk">@@ -336,6 +357,8 @@ struct amdgpu_vm {
</span> 	/* Lock to protect vm_bo add/del/move on all lists of vm */
 	spinlock_t		status_lock;
 
<span
class="add">+	struct amdgpu_mem_stats stats;
+
</span> 	/* Per-VM and PT BOs who needs a validation */
 	struct list_head	evicted;
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm_pt.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm_pt.c
index e39d6e7643bf..ed98bc78c8e2 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm_pt.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm_pt.c
</span><span
class="hunk">@@ -595,6 +595,7 @@ static void amdgpu_vm_pt_free(struct amdgpu_vm_bo_base *entry)
</span> 	ttm_bo_set_bulk_move(&#38;entry-&gt;bo-&gt;tbo, NULL);
 
 	spin_lock(&#38;entry-&gt;vm-&gt;status_lock);
<span
class="add">+	amdgpu_bo_sub_memory(entry-&gt;bo, &#38;entry-&gt;vm-&gt;stats);
</span> 	list_del(&#38;entry-&gt;vm_status);
 	spin_unlock(&#38;entry-&gt;vm-&gt;status_lock);
 	amdgpu_bo_unref(&#38;entry-&gt;bo);
<span
class="head">diff --git a/include/uapi/drm/amdgpu_drm.h b/include/uapi/drm/amdgpu_drm.h
index 3e488b0119eb..7ddf020817e1 100644
--- a/include/uapi/drm/amdgpu_drm.h
+++ b/include/uapi/drm/amdgpu_drm.h
</span><span
class="hunk">@@ -174,6 +174,11 @@ extern &#34;C&#34; {
</span> /* Set PTE.D and recompress during GTT-&gt;VRAM moves according to TILING flags. */
 #define AMDGPU_GEM_CREATE_GFX12_DCC		(1 &lt;&lt; 16)
 
<span
class="add">+/* Flag that BO was exported at one point and counts torwards the &#34;shared&#34;
+ * memory stats. Once set it does not get cleared until the BO is destroyed.
+ */
+#define AMDGPU_GEM_WAS_EXPORTED 		(1 &lt;&lt; 17)
+
</span> struct drm_amdgpu_gem_create_in  {
 	/** the requested memory size */
 	__u64 bo_size;
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Jane Jian</name><email>Jane.Jian@amd.com</email></author><title>[PATCH] drm/amdgpu: part I - normalize registers as local xcc to read/write under sriov in TLB</title><updated>2024-06-19T16:31:56Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240619163147.1706778-1-Jane.Jian@amd.com/"/><id>urn:uuid:1fc7a5ee-3ec1-bf8a-e2d6-5a69940aaf4e</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHY]
sriov has the higher bit violation when flushing tlb

[HOW]
normalize the registers to keep lower 16-bit(dword aligned) to aviod higher bit violation
RLCG will mask xcd out and always assume it&#39;s accessing its own xcd

[TODO]
later will add the normalization in sriovw/rreg after fixing bugs

v2
rename the normalized macro, add ip block type for further use

Signed-off-by: Jane Jian &lt;Jane.Jian@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu.h        |  2 ++
 drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c | 16 ++++++++++++++++
 drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c      | 10 ++++++++--
 drivers/gpu/drm/amd/amdgpu/soc15.c         |  1 +
 drivers/gpu/drm/amd/amdgpu/soc15.h         |  1 +
 drivers/gpu/drm/amd/amdgpu/soc15_common.h  |  5 ++++-
 6 files <a href="http://lore.kernel.org/amd-gfx/20240619163147.1706778-1-Jane.Jian@amd.com/#related">changed</a>, 32 insertions(+), 3 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
index 083f353cff6e..eb2e7312bf1b 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
</span><span
class="hunk">@@ -636,6 +636,8 @@ struct amdgpu_asic_funcs {
</span> 	ssize_t (*get_reg_state)(struct amdgpu_device *adev,
 				 enum amdgpu_reg_state reg_state, void *buf,
 				 size_t max_size);
<span
class="add">+	/* normalize offset to keep in lower 16-bit */
+	u32 (*normalize_reg_offset)(u32 hwip, u32 offset);
</span> };
 
 /*
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c b/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c
index 2c9a0aa41e2d..9b4bea2ca7df 100644
--- a/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c
+++ b/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c
</span><span
class="hunk">@@ -1085,3 +1085,19 @@ ssize_t aqua_vanjaram_get_reg_state(struct amdgpu_device *adev,
</span> 
 	return size;
 }
<span
class="add">+
+u32 aqua_vanjaram_normalize_reg_offset(u32 hwip, u32 offset)
+{
+	u32 normalized_offset;
+
+	switch (hwip) {
+	case GC_HWIP:
+		normalized_offset = offset &#38; 0xffff;
+		break;
+	default:
+		normalized_offset = offset;
+		break;
+	}
+
+	return normalized_offset;
+}
</span><span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
index 88b4644f8e96..1d24e19f304d 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
</span><span
class="hunk">@@ -853,8 +853,14 @@ static void gmc_v9_0_flush_gpu_tlb(struct amdgpu_device *adev, uint32_t vmid,
</span> 	 */
 	if (adev-&gt;gfx.kiq[inst].ring.sched.ready &#38;&#38;
 	    (amdgpu_sriov_runtime(adev) || !amdgpu_sriov_vf(adev))) {
<span
class="del">-		uint32_t req = hub-&gt;vm_inv_eng0_req + hub-&gt;eng_distance * eng;
-		uint32_t ack = hub-&gt;vm_inv_eng0_ack + hub-&gt;eng_distance * eng;
</span><span
class="add">+
+		/* Select lower 16 bits to write in local xcc
+		 * for MMHUB it uses xcc0, NO cross AID reg offset
+		 */
+		if (AMDGPU_IS_GFXHUB(vmhub)) {
+			req = NORMALIZE_XCC_REG_OFFSET(GC, req);
+			ack = NORMALIZE_XCC_REG_OFFSET(GC, ack);
+		}
</span> 
 		amdgpu_gmc_fw_reg_write_reg_wait(adev, req, ack, inv_req,
 						 1 &lt;&lt; vmid, inst);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/soc15.c b/drivers/gpu/drm/amd/amdgpu/soc15.c
index 8d16dacdc172..e6e61fc77080 100644
--- a/drivers/gpu/drm/amd/amdgpu/soc15.c
+++ b/drivers/gpu/drm/amd/amdgpu/soc15.c
</span><span
class="hunk">@@ -927,6 +927,7 @@ static const struct amdgpu_asic_funcs aqua_vanjaram_asic_funcs =
</span> 	.query_video_codecs = &#38;soc15_query_video_codecs,
 	.encode_ext_smn_addressing = &#38;aqua_vanjaram_encode_ext_smn_addressing,
 	.get_reg_state = &#38;aqua_vanjaram_get_reg_state,
<span
class="add">+	.normalize_reg_offset = &#38;aqua_vanjaram_normalize_reg_offset,
</span> };
 
 static int soc15_common_early_init(void *handle)
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/soc15.h b/drivers/gpu/drm/amd/amdgpu/soc15.h
index 282584a48be0..f1e974604e3e 100644
--- a/drivers/gpu/drm/amd/amdgpu/soc15.h
+++ b/drivers/gpu/drm/amd/amdgpu/soc15.h
</span><span
class="hunk">@@ -124,4 +124,5 @@ ssize_t aqua_vanjaram_get_reg_state(struct amdgpu_device *adev,
</span> void vega10_doorbell_index_init(struct amdgpu_device *adev);
 void vega20_doorbell_index_init(struct amdgpu_device *adev);
 void aqua_vanjaram_doorbell_index_init(struct amdgpu_device *adev);
<span
class="add">+u32 aqua_vanjaram_normalize_reg_offset(u32 hwip, u32 offset);
</span> #endif
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/soc15_common.h b/drivers/gpu/drm/amd/amdgpu/soc15_common.h
index 242b24f73c17..ddf0aad51821 100644
--- a/drivers/gpu/drm/amd/amdgpu/soc15_common.h
+++ b/drivers/gpu/drm/amd/amdgpu/soc15_common.h
</span><span
class="hunk">@@ -210,4 +210,7 @@
</span> #define WREG64_MCA(ext, mca_base, idx, val) \
 	WREG64_PCIE_EXT(adev-&gt;asic_funcs-&gt;encode_ext_smn_addressing(ext) + mca_base + (idx * 8), val)
 
<span
class="del">-#endif
</span><span
class="add">+#define NORMALIZE_XCC_REG_OFFSET(ip, offset) \
+	((amdgpu_sriov_vf(adev) &#38;&#38; adev-&gt;asic_funcs-&gt;normalize_reg_offset) ? \
+	adev-&gt;asic_funcs-&gt;normalize_reg_offset(ip##_HWIP, offset) : offset)
+#endif
</span>\ No newline at end of file
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Jane Jian</name><email>Jane.Jian@amd.com</email></author><title>[PATCH] drm/amdgpu: part I - normalize registers as local xcc to read/write under sriov in TLB</title><updated>2024-06-19T09:55:36Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240619095526.1387723-1-Jane.Jian@amd.com/"/><id>urn:uuid:69a23669-afa9-a36b-1c00-84e2408e3d7c</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHY]
sriov has the higher bit violation when flushing tlb

[HOW]
normalize the registers to keep lower 16-bit(dword aligned) to aviod higher bit violation
RLCG will mask xcd out and always assume it&#39;s accessing its own xcd

[TODO]
later will add the normalization in sriovw/rreg after fixing bugs

Signed-off-by: Jane Jian &lt;Jane.Jian@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu.h        |  2 ++
 drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c |  9 +++++++++
 drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c      | 10 ++++++++--
 drivers/gpu/drm/amd/amdgpu/soc15.c         |  1 +
 drivers/gpu/drm/amd/amdgpu/soc15.h         |  1 +
 drivers/gpu/drm/amd/amdgpu/soc15_common.h  |  3 +++
 6 files <a href="http://lore.kernel.org/amd-gfx/20240619095526.1387723-1-Jane.Jian@amd.com/#related">changed</a>, 24 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
index 083f353cff6e..da8d3669cc23 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
</span><span
class="hunk">@@ -632,6 +632,8 @@ struct amdgpu_asic_funcs {
</span> 				  const struct amdgpu_video_codecs **codecs);
 	/* encode &#34;&gt; 32bits&#34; smn addressing */
 	u64 (*encode_ext_smn_addressing)(int ext_id);
<span
class="add">+	/* normalize offset to keep in lower 16-bit */
+	u32 (*normalize_xcc_reg_offset)(u32 offset);
</span> 
 	ssize_t (*get_reg_state)(struct amdgpu_device *adev,
 				 enum amdgpu_reg_state reg_state, void *buf,
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c b/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c
index 2c9a0aa41e2d..3306df74457b 100644
--- a/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c
+++ b/drivers/gpu/drm/amd/amdgpu/aqua_vanjaram.c
</span><span
class="hunk">@@ -1085,3 +1085,12 @@ ssize_t aqua_vanjaram_get_reg_state(struct amdgpu_device *adev,
</span> 
 	return size;
 }
<span
class="add">+
+u32 aqua_vanjaram_normalize_xcc_reg_offset(u32 offset)
+{
+	u32 normalized_offset;
+
+	normalized_offset = offset &#38; 0xffff;
+
+	return normalized_offset;
+}
</span><span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
index 88b4644f8e96..fba2e4ad58db 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
</span><span
class="hunk">@@ -853,8 +853,14 @@ static void gmc_v9_0_flush_gpu_tlb(struct amdgpu_device *adev, uint32_t vmid,
</span> 	 */
 	if (adev-&gt;gfx.kiq[inst].ring.sched.ready &#38;&#38;
 	    (amdgpu_sriov_runtime(adev) || !amdgpu_sriov_vf(adev))) {
<span
class="del">-		uint32_t req = hub-&gt;vm_inv_eng0_req + hub-&gt;eng_distance * eng;
-		uint32_t ack = hub-&gt;vm_inv_eng0_ack + hub-&gt;eng_distance * eng;
</span><span
class="add">+
+		/* Select lower 16 bits to write in local xcc
+		 * for MMHUB it uses xcc0, NO cross AID reg offset
+		 */
+		if (AMDGPU_IS_GFXHUB(vmhub)) {
+			req = NORMALIZE_XCC_REG_OFFSET(req);
+			ack = NORMALIZE_XCC_REG_OFFSET(ack);
+		}
</span> 
 		amdgpu_gmc_fw_reg_write_reg_wait(adev, req, ack, inv_req,
 						 1 &lt;&lt; vmid, inst);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/soc15.c b/drivers/gpu/drm/amd/amdgpu/soc15.c
index 8d16dacdc172..31037f068902 100644
--- a/drivers/gpu/drm/amd/amdgpu/soc15.c
+++ b/drivers/gpu/drm/amd/amdgpu/soc15.c
</span><span
class="hunk">@@ -927,6 +927,7 @@ static const struct amdgpu_asic_funcs aqua_vanjaram_asic_funcs =
</span> 	.query_video_codecs = &#38;soc15_query_video_codecs,
 	.encode_ext_smn_addressing = &#38;aqua_vanjaram_encode_ext_smn_addressing,
 	.get_reg_state = &#38;aqua_vanjaram_get_reg_state,
<span
class="add">+	.normalize_xcc_reg_offset = &#38;aqua_vanjaram_normalize_xcc_reg_offset,
</span> };
 
 static int soc15_common_early_init(void *handle)
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/soc15.h b/drivers/gpu/drm/amd/amdgpu/soc15.h
index 282584a48be0..0d405a474283 100644
--- a/drivers/gpu/drm/amd/amdgpu/soc15.h
+++ b/drivers/gpu/drm/amd/amdgpu/soc15.h
</span><span
class="hunk">@@ -124,4 +124,5 @@ ssize_t aqua_vanjaram_get_reg_state(struct amdgpu_device *adev,
</span> void vega10_doorbell_index_init(struct amdgpu_device *adev);
 void vega20_doorbell_index_init(struct amdgpu_device *adev);
 void aqua_vanjaram_doorbell_index_init(struct amdgpu_device *adev);
<span
class="add">+u32 aqua_vanjaram_normalize_xcc_reg_offset(u32 offset);
</span> #endif
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/soc15_common.h b/drivers/gpu/drm/amd/amdgpu/soc15_common.h
index 242b24f73c17..43887836377d 100644
--- a/drivers/gpu/drm/amd/amdgpu/soc15_common.h
+++ b/drivers/gpu/drm/amd/amdgpu/soc15_common.h
</span><span
class="hunk">@@ -210,4 +210,7 @@
</span> #define WREG64_MCA(ext, mca_base, idx, val) \
 	WREG64_PCIE_EXT(adev-&gt;asic_funcs-&gt;encode_ext_smn_addressing(ext) + mca_base + (idx * 8), val)
 
<span
class="add">+#define NORMALIZE_XCC_REG_OFFSET(offset) \
+	(amdgpu_sriov_vf(adev) ? \
+	adev-&gt;asic_funcs-&gt;normalize_xcc_reg_offset(offset) : offset)
</span> #endif
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Julia Zhang</name><email>julia.zhang@amd.com</email></author><title>[PATCH v2] drm/amdgpu: avoid using null object of framebuffer</title><updated>2024-06-19T04:30:35Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240619042924.1489294-1-julia.zhang@amd.com/"/><id>urn:uuid:36b27403-8ddb-06b2-3844-236006299534</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Instead of using state-&gt;fb-&gt;obj[0] directly, get object from framebuffer
by calling drm_gem_fb_get_obj() and return error code when object is
null to avoid using null object of framebuffer.

v2: Call drm_gem_fb_get_obj after check old_state-&gt;fb for NULL.

Signed-off-by: Julia Zhang &lt;Julia.Zhang@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_vkms.c | 18 ++++++++++++++++--
 1 file <a href="http://lore.kernel.org/amd-gfx/20240619042924.1489294-1-julia.zhang@amd.com/#related">changed</a>, 16 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vkms.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vkms.c
index d60c4a2eeb0c..212f6522859d 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vkms.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vkms.c
</span><span
class="hunk">@@ -2,6 +2,7 @@
</span> 
 #include &lt;drm/drm_atomic_helper.h&gt;
 #include &lt;drm/drm_simple_kms_helper.h&gt;
<span
class="add">+#include &lt;drm/drm_gem_framebuffer_helper.h&gt;
</span> #include &lt;drm/drm_vblank.h&gt;
 
 #include &#34;amdgpu.h&#34;
<span
class="hunk">@@ -311,7 +312,13 @@ static int amdgpu_vkms_prepare_fb(struct drm_plane *plane,
</span> 		return 0;
 	}
 	afb = to_amdgpu_framebuffer(new_state-&gt;fb);
<span
class="del">-	obj = new_state-&gt;fb-&gt;obj[0];
</span><span
class="add">+
+	obj = drm_gem_fb_get_obj(new_state-&gt;fb, 0);
+	if (!obj) {
+		DRM_ERROR(&#34;Failed to get obj from framebuffer\n&#34;);
+		return -EINVAL;
+	}
+
</span> 	rbo = gem_to_amdgpu_bo(obj);
 	adev = amdgpu_ttm_adev(rbo-&gt;tbo.bdev);
 
<span
class="hunk">@@ -365,12 +372,19 @@ static void amdgpu_vkms_cleanup_fb(struct drm_plane *plane,
</span> 				   struct drm_plane_state *old_state)
 {
 	struct amdgpu_bo *rbo;
<span
class="add">+	struct drm_gem_object *obj;
</span> 	int r;
 
 	if (!old_state-&gt;fb)
 		return;
 
<span
class="del">-	rbo = gem_to_amdgpu_bo(old_state-&gt;fb-&gt;obj[0]);
</span><span
class="add">+	obj = drm_gem_fb_get_obj(old_state-&gt;fb, 0);
+	if (!obj) {
+		DRM_ERROR(&#34;Failed to get obj from framebuffer\n&#34;);
+		return;
+	}
+
+	rbo = gem_to_amdgpu_bo(obj);
</span> 	r = amdgpu_bo_reserve(rbo, false);
 	if (unlikely(r)) {
 		DRM_ERROR(&#34;failed to reserve rbo before unpin\n&#34;);
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Vignesh Chander</name><email>Vignesh.Chander@amd.com</email></author><title>[PATCH] drm/amdgpu: process RAS fatal error MB notification</title><updated>2024-06-18T21:15:11Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618211446.598261-1-Vignesh.Chander@amd.com/"/><id>urn:uuid:3e015ed8-b32e-3528-b3f3-c4daaede9e92</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">For RAS error scenario, VF guest driver will check mailbox
and set fed flag to avoid unnecessary HW accesses.
additionally, poll for reset completion message first
to avoid accidentally spamming multiple reset requests to host.

v2: add another mailbox check for handling case where kfd detects
timeout first

Signed-off-by: Vignesh Chander &lt;Vignesh.Chander@amd.com&gt;
Change-Id: Ib501c653265883999c62a12a209ce5eb81c80846
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c | 25 +++++++++++++++++++++---
 drivers/gpu/drm/amd/amdgpu/amdgpu_virt.h |  4 +++-
 drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c    | 22 +++++++++++++++++++--
 drivers/gpu/drm/amd/amdgpu/mxgpu_ai.h    |  4 +++-
 drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c    | 22 +++++++++++++++++++--
 drivers/gpu/drm/amd/amdgpu/mxgpu_nv.h    |  3 ++-
 6 files <a href="http://lore.kernel.org/amd-gfx/20240618211446.598261-1-Vignesh.Chander@amd.com/#related">changed</a>, 70 insertions(+), 10 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c
index 63f2286858c484..ccb3d041c2b249 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c
</span><span
class="hunk">@@ -229,6 +229,22 @@ void amdgpu_virt_free_mm_table(struct amdgpu_device *adev)
</span> 	adev-&gt;virt.mm_table.gpu_addr = 0;
 }
 
<span
class="add">+/**
+ * amdgpu_virt_rcvd_ras_interrupt() - receive ras interrupt
+ * @adev:	amdgpu device.
+ * Check whether host sent RAS error message
+ * Return: true if found, otherwise false
+ */
+bool amdgpu_virt_rcvd_ras_interrupt(struct amdgpu_device *adev)
+{
+	struct amdgpu_virt *virt = &#38;adev-&gt;virt;
+
+	if (!virt-&gt;ops || !virt-&gt;ops-&gt;rcvd_ras_intr)
+		return false;
+
+	return virt-&gt;ops-&gt;rcvd_ras_intr(adev);
+}
+
</span> 
 unsigned int amd_sriov_msg_checksum(void *obj,
 				unsigned long obj_size,
<span
class="hunk">@@ -612,11 +628,14 @@ static void amdgpu_virt_update_vf2pf_work_item(struct work_struct *work)
</span> 	ret = amdgpu_virt_read_pf2vf_data(adev);
 	if (ret) {
 		adev-&gt;virt.vf2pf_update_retry_cnt++;
<span
class="del">-		if ((adev-&gt;virt.vf2pf_update_retry_cnt &gt;= AMDGPU_VF2PF_UPDATE_MAX_RETRY_LIMIT) &#38;&#38;
-		    amdgpu_sriov_runtime(adev)) {
</span><span
class="add">+
+		if ((amdgpu_virt_rcvd_ras_interrupt(adev) ||
+			adev-&gt;virt.vf2pf_update_retry_cnt &gt;= AMDGPU_VF2PF_UPDATE_MAX_RETRY_LIMIT) &#38;&#38;
+			amdgpu_sriov_runtime(adev)) {
+
</span> 			amdgpu_ras_set_fed(adev, true);
 			if (amdgpu_reset_domain_schedule(adev-&gt;reset_domain,
<span
class="del">-							  &#38;adev-&gt;kfd.reset_work))
</span><span
class="add">+							&#38;adev-&gt;kfd.reset_work))
</span> 				return;
 			else
 				dev_err(adev-&gt;dev, &#34;Failed to queue work! at %s&#34;, __func__);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.h
index f04cd1586c7220..b42a8854dca0cb 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.h
</span><span
class="hunk">@@ -52,7 +52,7 @@
</span> /* tonga/fiji use this offset */
 #define mmBIF_IOV_FUNC_IDENTIFIER 0x1503
 
<span
class="del">-#define AMDGPU_VF2PF_UPDATE_MAX_RETRY_LIMIT 5
</span><span
class="add">+#define AMDGPU_VF2PF_UPDATE_MAX_RETRY_LIMIT 2
</span> 
 enum amdgpu_sriov_vf_mode {
 	SRIOV_VF_MODE_BARE_METAL = 0,
<span
class="hunk">@@ -94,6 +94,7 @@ struct amdgpu_virt_ops {
</span> 			  u32 data1, u32 data2, u32 data3);
 	void (*ras_poison_handler)(struct amdgpu_device *adev,
 					enum amdgpu_ras_block block);
<span
class="add">+	bool (*rcvd_ras_intr)(struct amdgpu_device *adev);
</span> };
 
 /*
<span
class="hunk">@@ -352,6 +353,7 @@ void amdgpu_virt_ready_to_reset(struct amdgpu_device *adev);
</span> int amdgpu_virt_wait_reset(struct amdgpu_device *adev);
 int amdgpu_virt_alloc_mm_table(struct amdgpu_device *adev);
 void amdgpu_virt_free_mm_table(struct amdgpu_device *adev);
<span
class="add">+bool amdgpu_virt_rcvd_ras_interrupt(struct amdgpu_device *adev);
</span> void amdgpu_virt_release_ras_err_handler_data(struct amdgpu_device *adev);
 void amdgpu_virt_init_data_exchange(struct amdgpu_device *adev);
 void amdgpu_virt_exchange_data(struct amdgpu_device *adev);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c b/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c
index 65656afc6ed1c2..1bb8393ad6d358 100644
--- a/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c
+++ b/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c
</span><span
class="hunk">@@ -196,11 +196,22 @@ static int xgpu_ai_request_reset(struct amdgpu_device *adev)
</span> {
 	int ret, i = 0;
 
<span
class="del">-	while (i &lt; AI_MAILBOX_POLL_MSG_REP_MAX) {
</span><span
class="add">+	if (amdgpu_ras_get_fed_status(adev) || xgpu_ai_rcvd_ras_intr(adev)) {
+		dev_dbg(adev-&gt;dev, &#34;ras flag is set, poll for IDH_FLR_NOTIFICATION_CMPL\n&#34;);
+
+		for (i = 0; i &lt; AI_MAILBOX_POLL_MSG_REP_MAX; i++) {
+			ret = xgpu_ai_poll_msg(adev, IDH_FLR_NOTIFICATION_CMPL);
+			if (!ret)
+				break;
+
+			dev_dbg(adev-&gt;dev, &#34;retries left = %d\n&#34;, AI_MAILBOX_POLL_MSG_REP_MAX - i);
+		}
+	}
+
+	for (i = 0; i &lt; AI_MAILBOX_POLL_MSG_REP_MAX; i++) {
</span> 		ret = xgpu_ai_send_access_requests(adev, IDH_REQ_GPU_RESET_ACCESS);
 		if (!ret)
 			break;
<span
class="del">-		i++;
</span> 	}
 
 	return ret;
<span
class="hunk">@@ -408,6 +419,12 @@ static void xgpu_ai_ras_poison_handler(struct amdgpu_device *adev,
</span> 	xgpu_ai_send_access_requests(adev, IDH_RAS_POISON);
 }
 
<span
class="add">+static bool xgpu_ai_rcvd_ras_intr(struct amdgpu_device *adev)
+{
+	enum idh_event msg = xgpu_ai_mailbox_peek_msg(adev);
+	return (msg == IDH_RAS_ERROR_DETECTED || msg == 0xFFFFFFFF);
+}
+
</span> const struct amdgpu_virt_ops xgpu_ai_virt_ops = {
 	.req_full_gpu	= xgpu_ai_request_full_gpu_access,
 	.rel_full_gpu	= xgpu_ai_release_full_gpu_access,
<span
class="hunk">@@ -417,4 +434,5 @@ const struct amdgpu_virt_ops xgpu_ai_virt_ops = {
</span> 	.trans_msg = xgpu_ai_mailbox_trans_msg,
 	.req_init_data  = xgpu_ai_request_init_data,
 	.ras_poison_handler = xgpu_ai_ras_poison_handler,
<span
class="add">+	.rcvd_ras_intr = xgpu_ai_rcvd_ras_intr,
</span> };
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.h b/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.h
index c520b2fabfb9a8..ed57cbc150afba 100644
--- a/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.h
+++ b/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.h
</span><span
class="hunk">@@ -51,7 +51,9 @@ enum idh_event {
</span> 	IDH_FAIL,
 	IDH_QUERY_ALIVE,
 	IDH_REQ_GPU_INIT_DATA_READY,
<span
class="del">-
</span><span
class="add">+	IDH_RAS_POISON_READY,
+	IDH_PF_SOFT_FLR_NOTIFICATION,
+	IDH_RAS_ERROR_DETECTED,
</span> 	IDH_TEXT_MESSAGE = 255,
 };
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c b/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c
index 17e1e8cc243752..f2e5b38a64314c 100644
--- a/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c
+++ b/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c
</span><span
class="hunk">@@ -225,11 +225,22 @@ static int xgpu_nv_request_reset(struct amdgpu_device *adev)
</span> {
 	int ret, i = 0;
 
<span
class="del">-	while (i &lt; NV_MAILBOX_POLL_MSG_REP_MAX) {
</span><span
class="add">+	if (amdgpu_ras_get_fed_status(adev) || xgpu_nv_rcvd_ras_intr(adev) {
+		dev_dbg(adev-&gt;dev, &#34;ras flag is set, poll for IDH_FLR_NOTIFICATION_CMPL\n&#34;);
+
+		for (i = 0; i &lt; NV_MAILBOX_POLL_MSG_REP_MAX; i++) {
+			ret = xgpu_nv_poll_msg(adev, IDH_FLR_NOTIFICATION_CMPL);
+			if (!ret)
+				break;
+
+			dev_dbg(adev-&gt;dev, &#34;retries left = %d\n&#34;, NV_MAILBOX_POLL_MSG_REP_MAX - i);
+		}
+	}
+
+	for (i = 0; i &lt; NV_MAILBOX_POLL_MSG_REP_MAX; i++) {
</span> 		ret = xgpu_nv_send_access_requests(adev, IDH_REQ_GPU_RESET_ACCESS);
 		if (!ret)
 			break;
<span
class="del">-		i++;
</span> 	}
 
 	return ret;
<span
class="hunk">@@ -449,6 +460,12 @@ static void xgpu_nv_ras_poison_handler(struct amdgpu_device *adev,
</span> 	}
 }
 
<span
class="add">+static bool xgpu_nv_rcvd_ras_intr(struct amdgpu_device *adev)
+{
+	enum idh_event msg = xgpu_nv_mailbox_peek_msg(adev);
+	return (msg == IDH_RAS_ERROR_DETECTED || msg == 0xFFFFFFFF);
+}
+
</span> const struct amdgpu_virt_ops xgpu_nv_virt_ops = {
 	.req_full_gpu	= xgpu_nv_request_full_gpu_access,
 	.rel_full_gpu	= xgpu_nv_release_full_gpu_access,
<span
class="hunk">@@ -458,4 +475,5 @@ const struct amdgpu_virt_ops xgpu_nv_virt_ops = {
</span> 	.wait_reset = xgpu_nv_wait_reset,
 	.trans_msg = xgpu_nv_mailbox_trans_msg,
 	.ras_poison_handler = xgpu_nv_ras_poison_handler,
<span
class="add">+	.rcvd_ras_intr = xgpu_nv_rcvd_ras_intr,
</span> };
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.h b/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.h
index 1e8fd90cab4347..719a4c88615752 100644
--- a/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.h
+++ b/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.h
</span><span
class="hunk">@@ -52,7 +52,8 @@ enum idh_event {
</span> 	IDH_QUERY_ALIVE,
 	IDH_REQ_GPU_INIT_DATA_READY,
 	IDH_RAS_POISON_READY,
<span
class="del">-
</span><span
class="add">+	IDH_PF_SOFT_FLR_NOTIFICATION,
+	IDH_RAS_ERROR_DETECTED,
</span> 	IDH_TEXT_MESSAGE = 255,
 };
 
-- 
2.25.1

</pre></div></content></entry><entry><author><name>Mario Limonciello</name><email>mario.limonciello@amd.com</email></author><title
type="html">[PATCH] drm/amd: Don&#39;t initialize ISP hardware without FW</title><updated>2024-06-18T16:44:11Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618164305.24221-1-mario.limonciello@amd.com/"/><id>urn:uuid:9bba0b39-63af-f432-ef40-3fe415ca8a61</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Although designs may contain an ISP IP block, the camera might be a USB
camera. Because of this the ISP firmware is considered optional from
amdgpu.  However if the firmware doesn&#39;t get loaded the hardware should
not be initialized.

Adjust the return code for early init to ensure the IP block doesn&#39;t go
through the other init and fini sequences. Also decrease the message
about firmware load failure to debug so it&#39;s not as alarming to users.

Signed-off-by: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_isp.c | 4 ++--
 1 file <a href="http://lore.kernel.org/amd-gfx/20240618164305.24221-1-mario.limonciello@amd.com/#related">changed</a>, 2 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_isp.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_isp.c
index 215bae809153..4766e99dd98f 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_isp.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_isp.c
</span><span
class="hunk">@@ -142,8 +142,8 @@ static int isp_early_init(void *handle)
</span> 	isp-&gt;parent = adev-&gt;dev;
 
 	if (isp_load_fw_by_psp(adev)) {
<span
class="del">-		DRM_WARN(&#34;%s: isp fw load failed\n&#34;, __func__);
-		return 0;
</span><span
class="add">+		DRM_DEBUG_DRIVER(&#34;%s: isp fw load failed\n&#34;, __func__);
+		return -ENOENT;
</span> 	}
 
 	return 0;
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Sonny Jiang</name><email>sonny.jiang@amd.com</email></author><title>[PATCH] drm/amdgpu/jpeg5: reprogram doorbell setting after power up for each playback</title><updated>2024-06-18T16:40:23Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618163953.699473-1-sonny.jiang@amd.com/"/><id>urn:uuid:c028d7a7-aeac-6c76-2889-bc027e08bbfc</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Sonny Jiang &lt;sonjiang@amd.com&gt;

Doorbell needs to be configured after power up during each playback

Signed-off-by: Sonny Jiang &lt;sonjiang@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/jpeg_v5_0_0.c | 8 ++++----
 1 file <a href="http://lore.kernel.org/amd-gfx/20240618163953.699473-1-sonny.jiang@amd.com/#related">changed</a>, 4 insertions(+), 4 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/jpeg_v5_0_0.c b/drivers/gpu/drm/amd/amdgpu/jpeg_v5_0_0.c
index 68ef29bc70e2..e766b9463759 100644
--- a/drivers/gpu/drm/amd/amdgpu/jpeg_v5_0_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/jpeg_v5_0_0.c
</span><span
class="hunk">@@ -137,10 +137,6 @@ static int jpeg_v5_0_0_hw_init(void *handle)
</span> 	adev-&gt;nbio.funcs-&gt;vcn_doorbell_range(adev, ring-&gt;use_doorbell,
 			(adev-&gt;doorbell_index.vcn.vcn_ring0_1 &lt;&lt; 1), 0);
 
<span
class="del">-	WREG32_SOC15(VCN, 0, regVCN_JPEG_DB_CTRL,
-			ring-&gt;doorbell_index &lt;&lt; VCN_JPEG_DB_CTRL__OFFSET__SHIFT |
-			VCN_JPEG_DB_CTRL__EN_MASK);
-
</span> 	r = amdgpu_ring_test_helper(ring);
 	if (r)
 		return r;
<span
class="hunk">@@ -314,6 +310,10 @@ static int jpeg_v5_0_0_start(struct amdgpu_device *adev)
</span> 		JPEG_SYS_INT_EN__DJRBC0_MASK,
 		~JPEG_SYS_INT_EN__DJRBC0_MASK);
 
<span
class="add">+	WREG32_SOC15(VCN, 0, regVCN_JPEG_DB_CTRL,
+		ring-&gt;doorbell_index &lt;&lt; VCN_JPEG_DB_CTRL__OFFSET__SHIFT |
+		VCN_JPEG_DB_CTRL__EN_MASK);
+
</span> 	WREG32_SOC15(JPEG, 0, regUVD_LMI_JRBC_RB_VMID, 0);
 	WREG32_SOC15(JPEG, 0, regUVD_JRBC_RB_CNTL, (0x00000001L | 0x00000002L));
 	WREG32_SOC15(JPEG, 0, regUVD_LMI_JRBC_RB_64BIT_BAR_LOW,
-- 
2.45.1

</pre></div></content></entry><entry><author><name>Pierre-Eric Pelloux-Prayer</name><email>pierre-eric.pelloux-prayer@amd.com</email></author><title>[PATCH 5/6] drm/amdgpu: cache mclk/sclk min/max values</title><updated>2024-06-18T15:31:00Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618153003.146168-6-pierre-eric.pelloux-prayer@amd.com/"/><id>urn:uuid:48918648-6931-5520-ca34-b8f21f691700</id><thr:in-reply-to
ref="urn:uuid:531c3d1e-9d8f-567e-6124-b18d14ef3e42"
href="http://lore.kernel.org/amd-gfx/20240618153003.146168-1-pierre-eric.pelloux-prayer@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This way these values can be returned directly when using
AMDGPU_INFO_DEV_INFO, without waking up the GPU.

Signed-off-by: Pierre-Eric Pelloux-Prayer &lt;pierre-eric.pelloux-prayer@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu.h           | 12 ++++++++++--
 drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c  |  8 ++++----
 .../gpu/drm/amd/amdgpu/amdgpu_atomfirmware.c  |  8 ++++----
 drivers/gpu/drm/amd/amdgpu/amdgpu_device.c    |  7 +++++++
 drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c       | 19 +++++--------------
 drivers/gpu/drm/amd/pm/legacy-dpm/kv_dpm.c    |  8 ++++----
 drivers/gpu/drm/amd/pm/legacy-dpm/si_dpm.c    | 12 ++++++------
 7 files <a href="http://lore.kernel.org/amd-gfx/20240618153003.146168-6-pierre-eric.pelloux-prayer@amd.com/#related">changed</a>, 40 insertions(+), 34 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
index 083f353cff6e..75db8eba73d9 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
</span><span
class="hunk">@@ -418,8 +418,16 @@ struct amdgpu_clock {
</span> 	struct amdgpu_pll spll;
 	struct amdgpu_pll mpll;
 	/* 10 Khz units */
<span
class="del">-	uint32_t default_mclk;
-	uint32_t default_sclk;
</span><span
class="add">+	struct {
+		uint32_t min;
+		uint32_t max;
+		uint32_t def;
+	} mclk;
+	struct {
+		uint32_t min;
+		uint32_t max;
+		uint32_t def;
+	} sclk;
</span> 	uint32_t default_dispclk;
 	uint32_t current_dispclk;
 	uint32_t dp_extclk;
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c
index 7dc102f0bc1d..f2c2b05233f0 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c
</span><span
class="hunk">@@ -658,9 +658,9 @@ int amdgpu_atombios_get_clock_info(struct amdgpu_device *adev)
</span> 		mpll-&gt;pll_in_max =
 		    le16_to_cpu(firmware_info-&gt;info.usMaxMemoryClockPLL_Input);
 
<span
class="del">-		adev-&gt;clock.default_sclk =
</span><span
class="add">+		adev-&gt;clock.sclk.def = adev-&gt;clock.sclk.min = adev-&gt;clock.sclk.max =
</span> 		    le32_to_cpu(firmware_info-&gt;info.ulDefaultEngineClock);
<span
class="del">-		adev-&gt;clock.default_mclk =
</span><span
class="add">+		adev-&gt;clock.mclk.def = adev-&gt;clock.mclk.min = adev-&gt;clock.mclk.max =
</span> 		    le32_to_cpu(firmware_info-&gt;info.ulDefaultMemoryClock);
 
 		mpll-&gt;min_post_div = 1;
<span
class="hunk">@@ -699,8 +699,8 @@ int amdgpu_atombios_get_clock_info(struct amdgpu_device *adev)
</span> 		ret = 0;
 	}
 
<span
class="del">-	adev-&gt;pm.current_sclk = adev-&gt;clock.default_sclk;
-	adev-&gt;pm.current_mclk = adev-&gt;clock.default_mclk;
</span><span
class="add">+	adev-&gt;pm.current_sclk = adev-&gt;clock.sclk.def;
+	adev-&gt;pm.current_mclk = adev-&gt;clock.mclk.def;
</span> 
 	return ret;
 }
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_atomfirmware.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_atomfirmware.c
index f932bec6e534..6eb125b1bd08 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_atomfirmware.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_atomfirmware.c
</span><span
class="hunk">@@ -719,13 +719,13 @@ int amdgpu_atomfirmware_get_clock_info(struct amdgpu_device *adev)
</span> 			(union firmware_info *)(mode_info-&gt;atom_context-&gt;bios +
 						data_offset);
 
<span
class="del">-		adev-&gt;clock.default_sclk =
</span><span
class="add">+		adev-&gt;clock.sclk.def = adev-&gt;clock.sclk.min = adev-&gt;clock.sclk.max =
</span> 			le32_to_cpu(firmware_info-&gt;v31.bootup_sclk_in10khz);
<span
class="del">-		adev-&gt;clock.default_mclk =
</span><span
class="add">+		adev-&gt;clock.mclk.def = adev-&gt;clock.mclk.min = adev-&gt;clock.mclk.max =
</span> 			le32_to_cpu(firmware_info-&gt;v31.bootup_mclk_in10khz);
 
<span
class="del">-		adev-&gt;pm.current_sclk = adev-&gt;clock.default_sclk;
-		adev-&gt;pm.current_mclk = adev-&gt;clock.default_mclk;
</span><span
class="add">+		adev-&gt;pm.current_sclk = adev-&gt;clock.sclk.def;
+		adev-&gt;pm.current_mclk = adev-&gt;clock.mclk.def;
</span> 
 		ret = 0;
 	}
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
index 3fb02f5b91c9..03417e7e8961 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
</span><span
class="hunk">@@ -4422,6 +4422,13 @@ int amdgpu_device_init(struct amdgpu_device *adev,
</span> 
 	amdgpu_device_check_iommu_direct_map(adev);
 
<span
class="add">+	if (adev-&gt;pm.dpm_enabled) {
+		adev-&gt;clock.sclk.min = amdgpu_dpm_get_sclk(adev, true);
+		adev-&gt;clock.sclk.max = amdgpu_dpm_get_sclk(adev, false);
+		adev-&gt;clock.mclk.min = amdgpu_dpm_get_mclk(adev, true);
+		adev-&gt;clock.mclk.max = amdgpu_dpm_get_mclk(adev, false);
+	}
+
</span> 	return 0;
 
 release_ras_con:
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c
index dbb05d51682b..781851cf8dc9 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c
</span><span
class="hunk">@@ -827,19 +827,10 @@ static int amdgpu_info(struct drm_device *dev, void *data, struct drm_file *filp
</span> 		dev_info-&gt;num_shader_arrays_per_engine = adev-&gt;gfx.config.max_sh_per_se;
 		/* return all clocks in KHz */
 		dev_info-&gt;gpu_counter_freq = amdgpu_asic_get_xclk(adev) * 10;
<span
class="del">-		if (adev-&gt;pm.dpm_enabled) {
-			dev_info-&gt;max_engine_clock = amdgpu_dpm_get_sclk(adev, false) * 10;
-			dev_info-&gt;max_memory_clock = amdgpu_dpm_get_mclk(adev, false) * 10;
-			dev_info-&gt;min_engine_clock = amdgpu_dpm_get_sclk(adev, true) * 10;
-			dev_info-&gt;min_memory_clock = amdgpu_dpm_get_mclk(adev, true) * 10;
-		} else {
-			dev_info-&gt;max_engine_clock =
-				dev_info-&gt;min_engine_clock =
-					adev-&gt;clock.default_sclk * 10;
-			dev_info-&gt;max_memory_clock =
-				dev_info-&gt;min_memory_clock =
-					adev-&gt;clock.default_mclk * 10;
-		}
</span><span
class="add">+		dev_info-&gt;min_engine_clock = adev-&gt;clock.sclk.min * 10;
+		dev_info-&gt;max_engine_clock = adev-&gt;clock.sclk.max * 10;
+		dev_info-&gt;min_memory_clock = adev-&gt;clock.mclk.min * 10;
+		dev_info-&gt;max_memory_clock = adev-&gt;clock.mclk.max * 10;
</span> 		dev_info-&gt;enabled_rb_pipes_mask = adev-&gt;gfx.config.backend_enable_mask;
 		dev_info-&gt;num_rb_pipes = adev-&gt;gfx.config.max_backends_per_se *
 			adev-&gt;gfx.config.max_shader_engines;
<span
class="hunk">@@ -1315,12 +1306,12 @@ int amdgpu_info_ioctl(struct drm_device *dev, void *data, struct drm_file *filp)
</span> 	case AMDGPU_INFO_MAX_IBS:
 	case AMDGPU_INFO_GPUVM_FAULT:
 	case AMDGPU_INFO_GB_ADDR_CONFIG:
<span
class="add">+	case AMDGPU_INFO_DEV_INFO:
</span> 		need_runtime_pm = false;
 		break;
 
 	case AMDGPU_INFO_TIMESTAMP:
 	case AMDGPU_INFO_READ_MMR_REG:
<span
class="del">-	case AMDGPU_INFO_DEV_INFO:
</span> 	case AMDGPU_INFO_SENSOR:
 		need_runtime_pm = true;
 		break;
<span
class="head">diff --git a/drivers/gpu/drm/amd/pm/legacy-dpm/kv_dpm.c b/drivers/gpu/drm/amd/pm/legacy-dpm/kv_dpm.c
index 6bb42d04b247..75c262acb704 100644
--- a/drivers/gpu/drm/amd/pm/legacy-dpm/kv_dpm.c
+++ b/drivers/gpu/drm/amd/pm/legacy-dpm/kv_dpm.c
</span><span
class="hunk">@@ -2996,10 +2996,10 @@ static int kv_dpm_sw_init(void *handle)
</span> 	adev-&gt;pm.dpm.state = POWER_STATE_TYPE_BALANCED;
 	adev-&gt;pm.dpm.user_state = POWER_STATE_TYPE_BALANCED;
 	adev-&gt;pm.dpm.forced_level = AMD_DPM_FORCED_LEVEL_AUTO;
<span
class="del">-	adev-&gt;pm.default_sclk = adev-&gt;clock.default_sclk;
-	adev-&gt;pm.default_mclk = adev-&gt;clock.default_mclk;
-	adev-&gt;pm.current_sclk = adev-&gt;clock.default_sclk;
-	adev-&gt;pm.current_mclk = adev-&gt;clock.default_mclk;
</span><span
class="add">+	adev-&gt;pm.default_sclk = adev-&gt;clock.sclk.def;
+	adev-&gt;pm.default_mclk = adev-&gt;clock.mclk.def;
+	adev-&gt;pm.current_sclk = adev-&gt;clock.sclk.def;
+	adev-&gt;pm.current_mclk = adev-&gt;clock.mclk.def;
</span> 	adev-&gt;pm.int_thermal_type = THERMAL_TYPE_NONE;
 
 	if (amdgpu_dpm == 0)
<span
class="head">diff --git a/drivers/gpu/drm/amd/pm/legacy-dpm/si_dpm.c b/drivers/gpu/drm/amd/pm/legacy-dpm/si_dpm.c
index a1baa13ab2c2..e72eb59af6a5 100644
--- a/drivers/gpu/drm/amd/pm/legacy-dpm/si_dpm.c
+++ b/drivers/gpu/drm/amd/pm/legacy-dpm/si_dpm.c
</span><span
class="hunk">@@ -7232,8 +7232,8 @@ static void si_parse_pplib_clock_info(struct amdgpu_device *adev,
</span> 	if (rps-&gt;class &#38; ATOM_PPLIB_CLASSIFICATION_BOOT) {
 		u16 vddc, vddci, mvdd;
 		amdgpu_atombios_get_default_voltages(adev, &#38;vddc, &#38;vddci, &#38;mvdd);
<span
class="del">-		pl-&gt;mclk = adev-&gt;clock.default_mclk;
-		pl-&gt;sclk = adev-&gt;clock.default_sclk;
</span><span
class="add">+		pl-&gt;mclk = adev-&gt;clock.mclk.def;
+		pl-&gt;sclk = adev-&gt;clock.sclk.def;
</span> 		pl-&gt;vddc = vddc;
 		pl-&gt;vddci = vddci;
 		si_pi-&gt;mvdd_bootup_value = mvdd;
<span
class="hunk">@@ -7733,10 +7733,10 @@ static int si_dpm_sw_init(void *handle)
</span> 	adev-&gt;pm.dpm.state = POWER_STATE_TYPE_BALANCED;
 	adev-&gt;pm.dpm.user_state = POWER_STATE_TYPE_BALANCED;
 	adev-&gt;pm.dpm.forced_level = AMD_DPM_FORCED_LEVEL_AUTO;
<span
class="del">-	adev-&gt;pm.default_sclk = adev-&gt;clock.default_sclk;
-	adev-&gt;pm.default_mclk = adev-&gt;clock.default_mclk;
-	adev-&gt;pm.current_sclk = adev-&gt;clock.default_sclk;
-	adev-&gt;pm.current_mclk = adev-&gt;clock.default_mclk;
</span><span
class="add">+	adev-&gt;pm.default_sclk = adev-&gt;clock.sclk.def;
+	adev-&gt;pm.default_mclk = adev-&gt;clock.mclk.def;
+	adev-&gt;pm.current_sclk = adev-&gt;clock.sclk.def;
+	adev-&gt;pm.current_mclk = adev-&gt;clock.mclk.def;
</span> 	adev-&gt;pm.int_thermal_type = THERMAL_TYPE_NONE;
 
 	if (amdgpu_dpm == 0)
-- 
2.40.1

</pre></div></content></entry><entry><author><name>Pierre-Eric Pelloux-Prayer</name><email>pierre-eric.pelloux-prayer@amd.com</email></author><title>[PATCH 6/6] drm/amdgpu: resume the device from amdgpu_gem_fault</title><updated>2024-06-18T15:30:56Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618153003.146168-7-pierre-eric.pelloux-prayer@amd.com/"/><id>urn:uuid:168fbede-182a-156e-c4db-d3b00e36a2f7</id><thr:in-reply-to
ref="urn:uuid:531c3d1e-9d8f-567e-6124-b18d14ef3e42"
href="http://lore.kernel.org/amd-gfx/20240618153003.146168-1-pierre-eric.pelloux-prayer@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The fault handler may push some work to the GPU through amdgpu_bo_move
so use the pm_runtime functions before that.

Since we&#39;re in an interrupt context, we can&#39;t use the sync version,
so pm_runtime_get is called.

Signed-off-by: Pierre-Eric Pelloux-Prayer &lt;pierre-eric.pelloux-prayer@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c | 13 +++++++++++--
 1 file <a href="http://lore.kernel.org/amd-gfx/20240618153003.146168-7-pierre-eric.pelloux-prayer@amd.com/#related">changed</a>, 11 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
index 1f22b4208729..ec120e33536d 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
</span><span
class="hunk">@@ -30,6 +30,7 @@
</span> #include &lt;linux/pagemap.h&gt;
 #include &lt;linux/pci.h&gt;
 #include &lt;linux/dma-buf.h&gt;
<span
class="add">+#include &lt;linux/pm_runtime.h&gt;
</span> 
 #include &lt;drm/amdgpu_drm.h&gt;
 #include &lt;drm/drm_drv.h&gt;
<span
class="hunk">@@ -52,9 +53,13 @@ static vm_fault_t amdgpu_gem_fault(struct vm_fault *vmf)
</span> 	vm_fault_t ret;
 	int idx;
 
<span
class="add">+	ret = pm_runtime_get(ddev-&gt;dev);
+	if (ret &lt; 0)
+		return ret;
+
</span> 	ret = ttm_bo_vm_reserve(bo, vmf);
 	if (ret)
<span
class="del">-		return ret;
</span><span
class="add">+		goto put_pm;
</span> 
 	if (drm_dev_enter(ddev, &#38;idx)) {
 		ret = amdgpu_bo_fault_reserve_notify(bo);
<span
class="hunk">@@ -71,10 +76,14 @@ static vm_fault_t amdgpu_gem_fault(struct vm_fault *vmf)
</span> 		ret = ttm_bo_vm_dummy_page(vmf, vmf-&gt;vma-&gt;vm_page_prot);
 	}
 	if (ret == VM_FAULT_RETRY &#38;&#38; !(vmf-&gt;flags &#38; FAULT_FLAG_RETRY_NOWAIT))
<span
class="del">-		return ret;
</span><span
class="add">+		goto put_pm;
</span> 
 unlock:
 	dma_resv_unlock(bo-&gt;base.resv);
<span
class="add">+put_pm:
+	pm_runtime_mark_last_busy(ddev-&gt;dev);
+	pm_runtime_put_autosuspend(ddev-&gt;dev);
+
</span> 	return ret;
 }
 
-- 
2.40.1

</pre></div></content></entry><entry><author><name>Pierre-Eric Pelloux-Prayer</name><email>pierre-eric.pelloux-prayer@amd.com</email></author><title>[PATCH 3/6] drm/amdgpu: refactor amdgpu_info_ioctl to allow finer pm</title><updated>2024-06-18T15:30:54Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618153003.146168-4-pierre-eric.pelloux-prayer@amd.com/"/><id>urn:uuid:c59022fb-5920-a62f-15e1-2501d6e14cf5</id><thr:in-reply-to
ref="urn:uuid:531c3d1e-9d8f-567e-6124-b18d14ef3e42"
href="http://lore.kernel.org/amd-gfx/20240618153003.146168-1-pierre-eric.pelloux-prayer@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">AMDGPU_INFO_xxx has lots of different queries, and only a small
number of them actually reaches out to the GPU.

This commit extract the amdgpu_info_ioctl implementation to a
helper function, and then wrap it with the runtime pm logic
each query type needs.

Signed-off-by: Pierre-Eric Pelloux-Prayer &lt;pierre-eric.pelloux-prayer@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c |  2 +
 drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c | 94 ++++++++++++++++++++-----
 2 files <a href="http://lore.kernel.org/amd-gfx/20240618153003.146168-4-pierre-eric.pelloux-prayer@amd.com/#related">changed</a>, 80 insertions(+), 16 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
index d21d5af7f187..f51f121d804e 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
</span><span
class="hunk">@@ -2871,6 +2871,8 @@ long amdgpu_drm_ioctl(struct file *filp,
</span> 
 	if (is_driver_ioctl) {
 		switch (nr - DRM_COMMAND_BASE) {
<span
class="add">+		/* amdgpu_info_ioctl will resume the device if it needs to. */
+		case DRM_AMDGPU_INFO:
</span> 		/* These 4 only operate on kernel data structure. */
 		case DRM_AMDGPU_VM:
 		case DRM_AMDGPU_SCHED:
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c
index 260cd0ad286d..b32ff6e1baaf 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c
</span><span
class="hunk">@@ -543,22 +543,7 @@ static int amdgpu_hw_ip_info(struct amdgpu_device *adev,
</span> 	return 0;
 }
 
<span
class="del">-/*
- * Userspace get information ioctl
- */
-/**
- * amdgpu_info_ioctl - answer a device specific request.
- *
- * @dev: drm device pointer
- * @data: request object
- * @filp: drm filp
- *
- * This function is used to pass device specific parameters to the userspace
- * drivers.  Examples include: pci device id, pipeline parms, tiling params,
- * etc. (all asics).
- * Returns 0 on success, -EINVAL on failure.
- */
-int amdgpu_info_ioctl(struct drm_device *dev, void *data, struct drm_file *filp)
</span><span
class="add">+static int amdgpu_info(struct drm_device *dev, void *data, struct drm_file *filp)
</span> {
 	struct amdgpu_device *adev = drm_to_adev(dev);
 	struct drm_amdgpu_info *info = data;
<span
class="hunk">@@ -1278,6 +1263,83 @@ int amdgpu_info_ioctl(struct drm_device *dev, void *data, struct drm_file *filp)
</span> 	return 0;
 }
 
<span
class="add">+/*
+ * Userspace get information ioctl
+ */
+/**
+ * amdgpu_info_ioctl - answer a device specific request.
+ *
+ * @dev: drm device pointer
+ * @data: request object
+ * @filp: drm filp
+ *
+ * This function is used to pass device specific parameters to the userspace
+ * drivers.  Examples include: pci device id, pipeline parms, tiling params,
+ * etc. (all asics).
+ * Returns 0 on success, -EINVAL on failure.
+ */
+int amdgpu_info_ioctl(struct drm_device *dev, void *data, struct drm_file *filp)
+{
+	struct drm_amdgpu_info *info = data;
+	bool need_runtime_pm;
+	int ret;
+
+	if (!info-&gt;return_size || !info-&gt;return_pointer)
+		return -EINVAL;
+
+	switch (info-&gt;query) {
+	case AMDGPU_INFO_ACCEL_WORKING:
+	case AMDGPU_INFO_CRTC_FROM_ID:
+	case AMDGPU_INFO_HW_IP_INFO:
+	case AMDGPU_INFO_HW_IP_COUNT:
+	case AMDGPU_INFO_FW_VERSION:
+	case AMDGPU_INFO_NUM_BYTES_MOVED:
+	case AMDGPU_INFO_NUM_EVICTIONS:
+	case AMDGPU_INFO_NUM_VRAM_CPU_PAGE_FAULTS:
+	case AMDGPU_INFO_VRAM_USAGE:
+	case AMDGPU_INFO_VIS_VRAM_USAGE:
+	case AMDGPU_INFO_GTT_USAGE:
+	case AMDGPU_INFO_GDS_CONFIG:
+	case AMDGPU_INFO_VRAM_GTT:
+	case AMDGPU_INFO_MEMORY:
+	case AMDGPU_INFO_VCE_CLOCK_TABLE:
+	case AMDGPU_INFO_VBIOS:
+	case AMDGPU_INFO_NUM_HANDLES:
+	case AMDGPU_INFO_VRAM_LOST_COUNTER:
+	case AMDGPU_INFO_RAS_ENABLED_FEATURES:
+	case AMDGPU_INFO_VIDEO_CAPS:
+	case AMDGPU_INFO_MAX_IBS:
+	case AMDGPU_INFO_GPUVM_FAULT:
+		need_runtime_pm = false;
+		break;
+
+	case AMDGPU_INFO_TIMESTAMP:
+	case AMDGPU_INFO_READ_MMR_REG:
+	case AMDGPU_INFO_DEV_INFO:
+	case AMDGPU_INFO_SENSOR:
+		need_runtime_pm = true;
+		break;
+	default:
+		DRM_DEBUG_KMS(&#34;Invalid request %d\n&#34;, info-&gt;query);
+		return -EINVAL;
+	}
+
+	if (need_runtime_pm) {
+		ret = pm_runtime_get_sync(dev-&gt;dev);
+		if (ret &lt; 0)
+			goto put_pm;
+	}
+
+	ret = amdgpu_info(dev, data, filp);
+
+put_pm:
+	if (need_runtime_pm) {
+		pm_runtime_mark_last_busy(dev-&gt;dev);
+		pm_runtime_put_autosuspend(dev-&gt;dev);
+	}
+
+	return ret;
+}
</span> 
 /*
  * Outdated mess for old drm with Xorg being in charge (void function now).
-- 
2.40.1

</pre></div></content></entry><entry><author><name>Pierre-Eric Pelloux-Prayer</name><email>pierre-eric.pelloux-prayer@amd.com</email></author><title>[PATCH 4/6] drm/amdgpu: add AMDGPU_INFO_GB_ADDR_CONFIG query</title><updated>2024-06-18T15:30:53Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618153003.146168-5-pierre-eric.pelloux-prayer@amd.com/"/><id>urn:uuid:21c7e33a-67cd-c36e-5ba8-9e8333a600b0</id><thr:in-reply-to
ref="urn:uuid:531c3d1e-9d8f-567e-6124-b18d14ef3e42"
href="http://lore.kernel.org/amd-gfx/20240618153003.146168-1-pierre-eric.pelloux-prayer@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">libdrm_amdgpu uses AMDGPU_INFO_READ_MMR_REG to fill the dev-&gt;info.gb_addr_cfg
value.
Since this value is already known by the kernel, this commit implements a new
query to return it.

The libdrm MR to use this query is:
   <a
href="https://gitlab.freedesktop.org/mesa/drm/-/merge_requests/368">https://gitlab.freedesktop.org/mesa/drm/-/merge_requests/368</a>

Signed-off-by: Pierre-Eric Pelloux-Prayer &lt;pierre-eric.pelloux-prayer@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c | 3 ++-
 drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c | 5 +++++
 include/uapi/drm/amdgpu_drm.h           | 2 ++
 3 files <a href="http://lore.kernel.org/amd-gfx/20240618153003.146168-5-pierre-eric.pelloux-prayer@amd.com/#related">changed</a>, 9 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
index f51f121d804e..403add7f05af 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
</span><span
class="hunk">@@ -117,9 +117,10 @@
</span>  * - 3.56.0 - Update IB start address and size alignment for decode and encode
  * - 3.57.0 - Compute tunneling on GFX10+
  * - 3.58.0 - Add AMDGPU_IDS_FLAGS_MODE_PF, AMDGPU_IDS_FLAGS_MODE_VF &#38; AMDGPU_IDS_FLAGS_MODE_PT
<span
class="add">+ * - 3.59.0 - Add AMDGPU_INFO_GB_ADDR_CONFIG support
</span>  */
 #define KMS_DRIVER_MAJOR	3
<span
class="del">-#define KMS_DRIVER_MINOR	58
</span><span
class="add">+#define KMS_DRIVER_MINOR	59
</span> #define KMS_DRIVER_PATCHLEVEL	0
 
 /*
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c
index b32ff6e1baaf..dbb05d51682b 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c
</span><span
class="hunk">@@ -1256,6 +1256,10 @@ static int amdgpu_info(struct drm_device *dev, void *data, struct drm_file *filp
</span> 		return copy_to_user(out, &#38;gpuvm_fault,
 				    min((size_t)size, sizeof(gpuvm_fault))) ? -EFAULT : 0;
 	}
<span
class="add">+	case AMDGPU_INFO_GB_ADDR_CONFIG: {
+		ui32 = adev-&gt;gfx.config.gb_addr_config;
+		return copy_to_user(out, &#38;ui32, min(size, 4u)) ? -EFAULT : 0;
+	}
</span> 	default:
 		DRM_DEBUG_KMS(&#34;Invalid request %d\n&#34;, info-&gt;query);
 		return -EINVAL;
<span
class="hunk">@@ -1310,6 +1314,7 @@ int amdgpu_info_ioctl(struct drm_device *dev, void *data, struct drm_file *filp)
</span> 	case AMDGPU_INFO_VIDEO_CAPS:
 	case AMDGPU_INFO_MAX_IBS:
 	case AMDGPU_INFO_GPUVM_FAULT:
<span
class="add">+	case AMDGPU_INFO_GB_ADDR_CONFIG:
</span> 		need_runtime_pm = false;
 		break;
 
<span
class="head">diff --git a/include/uapi/drm/amdgpu_drm.h b/include/uapi/drm/amdgpu_drm.h
index 3e488b0119eb..680492cd73d8 100644
--- a/include/uapi/drm/amdgpu_drm.h
+++ b/include/uapi/drm/amdgpu_drm.h
</span><span
class="hunk">@@ -933,6 +933,8 @@ struct drm_amdgpu_cs_chunk_cp_gfx_shadow {
</span> #define AMDGPU_INFO_MAX_IBS			0x22
 /* query last page fault info */
 #define AMDGPU_INFO_GPUVM_FAULT			0x23
<span
class="add">+/* Query GB_ADDR_CONFIG */
+#define AMDGPU_INFO_GB_ADDR_CONFIG		0x24
</span> 
 #define AMDGPU_INFO_MMR_SE_INDEX_SHIFT	0
 #define AMDGPU_INFO_MMR_SE_INDEX_MASK	0xff
-- 
2.40.1

</pre></div></content></entry><entry><author><name>Pierre-Eric Pelloux-Prayer</name><email>pierre-eric.pelloux-prayer@amd.com</email></author><title>[PATCH 2/6] drm/amdgpu: skip runtime pm for selected ioctls</title><updated>2024-06-18T15:30:47Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618153003.146168-3-pierre-eric.pelloux-prayer@amd.com/"/><id>urn:uuid:67e5636d-1916-bb9d-05b1-208f8e32f1e8</id><thr:in-reply-to
ref="urn:uuid:531c3d1e-9d8f-567e-6124-b18d14ef3e42"
href="http://lore.kernel.org/amd-gfx/20240618153003.146168-1-pierre-eric.pelloux-prayer@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">These ioctls don&#39;t need to GPU, so don&#39;t resume it.

Signed-off-by: Pierre-Eric Pelloux-Prayer &lt;pierre-eric.pelloux-prayer@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c | 45 +++++++++++++++++++++++--
 1 file <a href="http://lore.kernel.org/amd-gfx/20240618153003.146168-3-pierre-eric.pelloux-prayer@amd.com/#related">changed</a>, 42 insertions(+), 3 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
index a9831b243bfc..d21d5af7f187 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
</span><span
class="hunk">@@ -2855,7 +2855,9 @@ long amdgpu_drm_ioctl(struct file *filp,
</span> {
 	struct drm_file *file_priv = filp-&gt;private_data;
 	struct drm_device *dev;
<span
class="add">+	bool is_driver_ioctl;
</span> 	bool needs_device;
<span
class="add">+	unsigned int nr;
</span> 	long ret;
 
 	dev = file_priv-&gt;minor-&gt;dev;
<span
class="hunk">@@ -2863,9 +2865,46 @@ long amdgpu_drm_ioctl(struct file *filp,
</span> 	/* Some ioctl can opt-out of powermanagement handling
 	 * if they don&#39;t require the device to be resumed.
 	 */
<span
class="del">-	switch (cmd) {
-	default:
-		needs_device = true;
</span><span
class="add">+	nr = DRM_IOCTL_NR(cmd);
+
+	is_driver_ioctl = nr &gt;= DRM_COMMAND_BASE &#38;&#38; nr &lt; DRM_COMMAND_END;
+
+	if (is_driver_ioctl) {
+		switch (nr - DRM_COMMAND_BASE) {
+		/* These 4 only operate on kernel data structure. */
+		case DRM_AMDGPU_VM:
+		case DRM_AMDGPU_SCHED:
+		case DRM_AMDGPU_BO_LIST:
+		case DRM_AMDGPU_FENCE_TO_HANDLE:
+		/* All the waits don&#39;t need to resume up the device. If there are
+		 * jobs in progress, the device can&#39;t be in suspended state. And if
+		 * there&#39;s nothing no in-flight jobs, then the waits are no-op.
+		 */
+		case DRM_AMDGPU_GEM_WAIT_IDLE:
+		case DRM_AMDGPU_WAIT_CS:
+		case DRM_AMDGPU_WAIT_FENCES:
+			needs_device = false;
+			break;
+		default:
+			needs_device = true;
+		}
+	} else {
+		/* Most drm core ioctls don&#39;t need the device, but to avoid missing one
+		 * that requires it, implement the &#34;can skip pm&#34; logic as an allow list.
+		 */
+		switch (nr) {
+		case DRM_IOCTL_NR(DRM_IOCTL_VERSION):
+		case DRM_IOCTL_NR(DRM_IOCTL_AUTH_MAGIC):
+		case DRM_IOCTL_NR(DRM_IOCTL_GET_CAP):
+		case DRM_IOCTL_NR(DRM_IOCTL_SYNCOBJ_CREATE):
+		/* Same logic as DRM_AMDGPU_WAIT_* */
+		case DRM_IOCTL_NR(DRM_IOCTL_SYNCOBJ_WAIT):
+		case DRM_IOCTL_NR(DRM_IOCTL_SYNCOBJ_DESTROY):
+			needs_device = false;
+			break;
+		default:
+			needs_device = true;
+		}
</span> 	}
 
 	if (needs_device) {
-- 
2.40.1

</pre></div></content></entry><entry><author><name>Pierre-Eric Pelloux-Prayer</name><email>pierre-eric.pelloux-prayer@amd.com</email></author><title>[PATCH 1/6] drm/amdgpu: allow ioctls to opt-out of runtime pm</title><updated>2024-06-18T15:30:44Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618153003.146168-2-pierre-eric.pelloux-prayer@amd.com/"/><id>urn:uuid:dcea0fb8-30da-41a2-3f48-cdf7c344d532</id><thr:in-reply-to
ref="urn:uuid:531c3d1e-9d8f-567e-6124-b18d14ef3e42"
href="http://lore.kernel.org/amd-gfx/20240618153003.146168-1-pierre-eric.pelloux-prayer@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Waking up a device can take multiple seconds, so if it&#39;s not
going to be used we might as well not resume it.

The safest default behavior for all ioctls is to resume the GPU,
so this change allows specific ioctls to opt-out of generic
runtime pm.

Signed-off-by: Pierre-Eric Pelloux-Prayer &lt;pierre-eric.pelloux-prayer@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c | 25 ++++++++++++++++++++-----
 1 file <a href="http://lore.kernel.org/amd-gfx/20240618153003.146168-2-pierre-eric.pelloux-prayer@amd.com/#related">changed</a>, 20 insertions(+), 5 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
index 60d5758939ae..a9831b243bfc 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
</span><span
class="hunk">@@ -2855,18 +2855,33 @@ long amdgpu_drm_ioctl(struct file *filp,
</span> {
 	struct drm_file *file_priv = filp-&gt;private_data;
 	struct drm_device *dev;
<span
class="add">+	bool needs_device;
</span> 	long ret;
 
 	dev = file_priv-&gt;minor-&gt;dev;
<span
class="del">-	ret = pm_runtime_get_sync(dev-&gt;dev);
-	if (ret &lt; 0)
-		goto out;
</span><span
class="add">+
+	/* Some ioctl can opt-out of powermanagement handling
+	 * if they don&#39;t require the device to be resumed.
+	 */
+	switch (cmd) {
+	default:
+		needs_device = true;
+	}
+
+	if (needs_device) {
+		ret = pm_runtime_get_sync(dev-&gt;dev);
+		if (ret &lt; 0)
+			goto out;
+	}
</span> 
 	ret = drm_ioctl(filp, cmd, arg);
 
<span
class="del">-	pm_runtime_mark_last_busy(dev-&gt;dev);
</span> out:
<span
class="del">-	pm_runtime_put_autosuspend(dev-&gt;dev);
</span><span
class="add">+	if (needs_device) {
+		pm_runtime_mark_last_busy(dev-&gt;dev);
+		pm_runtime_put_autosuspend(dev-&gt;dev);
+	}
+
</span> 	return ret;
 }
 
-- 
2.40.1

</pre></div></content></entry><entry><author><name>Pierre-Eric Pelloux-Prayer</name><email>pierre-eric.pelloux-prayer@amd.com</email></author><title>[PATCH 0/6] Reduce the number of GPU resumes</title><updated>2024-06-18T15:30:30Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618153003.146168-1-pierre-eric.pelloux-prayer@amd.com/"/><id>urn:uuid:531c3d1e-9d8f-567e-6124-b18d14ef3e42</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The goal I&#39;m aiming for is to be able to open a dri node and use
amdgpu_device_initialize without waking up the GPU. One visible outcome
is that it would become possible to call vkEnumeratePhysicalDevices
without having to resume all the GPUs in the system.

This series implements some of the changes required to achieve this
goal with a focus on not waking up the GPU for ioctls that don&#39;t need
the GPU to be active.
The output of AMD_DEBUG=info doesn&#39;t change with these patches applied.

The other changes required are found in following patchset:
<a
href="https://lists.freedesktop.org/archives/amd-gfx/2024-June/109796.html">https://lists.freedesktop.org/archives/amd-gfx/2024-June/109796.html</a>

Pierre-Eric Pelloux-Prayer (6):
  drm/amdgpu: allow ioctls to opt-out of runtime pm
  drm/amdgpu: skip runtime pm for selected ioctls
  drm/amdgpu: refactor amdgpu_info_ioctl to allow finer pm
  drm/amdgpu: add AMDGPU_INFO_GB_ADDR_CONFIG query
  drm/amdgpu: cache mclk/sclk min/max values
  drm/amdgpu: resume the device from amdgpu_gem_fault

 drivers/gpu/drm/amd/amdgpu/amdgpu.h           |  12 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c  |   8 +-
 .../gpu/drm/amd/amdgpu/amdgpu_atomfirmware.c  |   8 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_device.c    |   7 ++
 drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c       |  69 ++++++++++-
 drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c       |  13 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c       | 116 +++++++++++++-----
 drivers/gpu/drm/amd/pm/legacy-dpm/kv_dpm.c    |   8 +-
 drivers/gpu/drm/amd/pm/legacy-dpm/si_dpm.c    |  12 +-
 include/uapi/drm/amdgpu_drm.h                 |   2 +
 10 files changed, 198 insertions(+), 57 deletions(-)

-- 
2.40.1

</pre></div></content></entry><entry><author><name>Danijel Slivka</name><email>danijel.slivka@amd.com</email></author><title>[PATCH] drm/amd/pm: check whether smu is idle in sriov case</title><updated>2024-06-18T14:51:14Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618145944.95640-1-danijel.slivka@amd.com/"/><id>urn:uuid:7c165f32-c161-7fa2-50a3-7828cf8f3780</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Why:
If the reg mmMP1_SMN_C2PMSG_90 is being written to before or during
amdgpu driver load or driver unload in sriov case, subsequent amdgpu
driver load will fail at smu hw_init.
The default of mmMP1_SMN_C2PMSG_90 register at a clean environment is 0x1,
and if value differs from 0x1, amdgpu driver load will fail.

How to fix:
This patch is to check whether smu is idle by sending a test
message to smu. If smu is idle, it will respond.
This will avoid errors in case mmMP1_SMN_C2PMSG_90 is not 0x1 eventhough
smu is idle.

Signed-off-by: Danijel Slivka &lt;danijel.slivka@amd.com&gt;
Signed-off-by: Jingwen Chen &lt;Jingwen.Chen2@amd.com&gt;
Signed-off-by: pengzhou &lt;PengJu.Zhou@amd.com&gt;
---
 .../gpu/drm/amd/pm/swsmu/smu13/smu_v13_0.c    | 17 ++++++--
 drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c        | 42 +++++++++++++++++++
 drivers/gpu/drm/amd/pm/swsmu/smu_cmn.h        |  3 ++
 3 files <a href="http://lore.kernel.org/amd-gfx/20240618145944.95640-1-danijel.slivka@amd.com/#related">changed</a>, 58 insertions(+), 4 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0.c b/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0.c
index e17466cc1952..dafd91b352ec 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0.c
</span><span
class="hunk">@@ -231,6 +231,7 @@ int smu_v13_0_check_fw_status(struct smu_context *smu)
</span> {
 	struct amdgpu_device *adev = smu-&gt;adev;
 	uint32_t mp1_fw_flags;
<span
class="add">+	int ret = 0;
</span> 
 	switch (amdgpu_ip_version(adev, MP1_HWIP, 0)) {
 	case IP_VERSION(13, 0, 4):
<span
class="hunk">@@ -244,11 +245,19 @@ int smu_v13_0_check_fw_status(struct smu_context *smu)
</span> 		break;
 	}
 
<span
class="del">-	if ((mp1_fw_flags &#38; MP1_FIRMWARE_FLAGS__INTERRUPTS_ENABLED_MASK) &gt;&gt;
-	    MP1_FIRMWARE_FLAGS__INTERRUPTS_ENABLED__SHIFT)
-		return 0;
</span><span
class="add">+	if (!((mp1_fw_flags &#38; MP1_FIRMWARE_FLAGS__INTERRUPTS_ENABLED_MASK) &gt;&gt;
+	    MP1_FIRMWARE_FLAGS__INTERRUPTS_ENABLED__SHIFT))
+		return -EIO;
+
+	if (amdgpu_sriov_vf(adev)) {
+		ret = smu_cmn_wait_smu_idle(smu);
+		if (ret) {
+			dev_err(adev-&gt;dev, &#34;SMU is not idle\n&#34;);
+			return ret;
+		}
+	}
</span> 
<span
class="del">-	return -EIO;
</span><span
class="add">+	return 0;
</span> }
 
 int smu_v13_0_check_fw_version(struct smu_context *smu)
<span
class="head">diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c b/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c
index 5592fd825aa3..de431c31ca7f 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c
</span><span
class="hunk">@@ -359,6 +359,48 @@ int smu_cmn_wait_for_response(struct smu_context *smu)
</span> 	return res;
 }
 
<span
class="add">+/**
+ * smu_cmn_wait_smu_idle -- wait for smu to become idle
+ * @smu: pointer to an SMU context
+ *
+ * Send SMU_MSG_TestMessage to check whether SMU is idle.
+ * If SMU is idle, it will respond.
+ * The returned parameter will be the param you pass + 1.
+ *
+ * Return 0 on success, -errno on error, indicating the execution
+ * status and result of the message being waited for. See
+ * __smu_cmn_reg2errno() for details of the -errno.
+ */
+int smu_cmn_wait_smu_idle(struct smu_context *smu)
+{
+	u32 reg;
+	u32 param = 0xff00011;
+	uint32_t read_arg;
+	int res, index;
+
+	index = smu_cmn_to_asic_specific_index(smu,
+					       CMN2ASIC_MAPPING_MSG,
+					       SMU_MSG_TestMessage);
+
+	if (index &lt; 0)
+		return index == -EACCES ? 0 : index;
+
+	__smu_cmn_send_msg(smu, index, param);
+	reg = __smu_cmn_poll_stat(smu);
+	res = __smu_cmn_reg2errno(smu, reg);
+
+	if (unlikely(smu-&gt;adev-&gt;pm.smu_debug_mask &#38; SMU_DEBUG_HALT_ON_ERROR) &#38;&#38;
+	    res &#38;&#38; (res != -ETIME)) {
+		amdgpu_device_halt(smu-&gt;adev);
+		WARN_ON(1);
+	}
+
+	smu_cmn_read_arg(smu, &#38;read_arg);
+	if (read_arg == param + 1)
+		return 0;
+	return res;
+}
+
</span> /**
  * smu_cmn_send_smc_msg_with_param -- send a message with parameter
  * @smu: pointer to an SMU context
<span
class="head">diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.h b/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.h
index 1de685defe85..486acfc956a5 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.h
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.h
</span><span
class="hunk">@@ -51,6 +51,9 @@ static inline int pcie_gen_to_speed(uint32_t gen)
</span> int smu_cmn_send_msg_without_waiting(struct smu_context *smu,
 				     uint16_t msg_index,
 				     uint32_t param);
<span
class="add">+
+int smu_cmn_wait_smu_idle(struct smu_context *smu);
+
</span> int smu_cmn_send_smc_msg_with_param(struct smu_context *smu,
 				    enum smu_message_type msg,
 				    uint32_t param,
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Min, Frank</name><email>Frank.Min@amd.com</email></author><title>[PATCH] drm/amdgpu: update MTYPE mapping for gfx12</title><updated>2024-06-18T13:07:06Z</updated><link
href="http://lore.kernel.org/amd-gfx/SA1PR12MB565900CF1142A9A43F8B0921E9CE2@SA1PR12MB5659.namprd12.prod.outlook.com/"/><id>urn:uuid:a3e29e1f-6500-f761-9304-e6824d4a981a</id><thr:in-reply-to
ref="urn:uuid:72c38927-4663-cd39-ceb2-851fb1d61b76"
href="http://lore.kernel.org/amd-gfx/20240618130033.3721-1-Frank.Min@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[AMD Official Use Only - AMD Internal Distribution Only]

From: Frank Min &lt;Frank.Min@amd.com&gt;

gfx12 only support MTYPE UC and NC, so update it accordingly.

Signed-off-by: Frank Min &lt;Frank.Min@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/gmc_v12_0.c | 4 ----
 1 file <a href="http://lore.kernel.org/amd-gfx/SA1PR12MB565900CF1142A9A43F8B0921E9CE2@SA1PR12MB5659.namprd12.prod.outlook.com/#related">changed</a>, 4 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v12_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v12_0.c
index 26122c8cfcc3..61db331adcc2 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v12_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v12_0.c
</span><span
class="hunk">@@ -464,10 +464,6 @@ static uint64_t gmc_v12_0_map_mtype(struct amdgpu_device *adev, uint32_t flags)
</span>                return AMDGPU_PTE_MTYPE_GFX12(0ULL, MTYPE_NC);
        case AMDGPU_VM_MTYPE_NC:
                return AMDGPU_PTE_MTYPE_GFX12(0ULL, MTYPE_NC);
<span
class="del">-       case AMDGPU_VM_MTYPE_WC:
-               return AMDGPU_PTE_MTYPE_GFX12(0ULL, MTYPE_WC);
-       case AMDGPU_VM_MTYPE_CC:
-               return AMDGPU_PTE_MTYPE_GFX12(0ULL, MTYPE_CC);
</span>        case AMDGPU_VM_MTYPE_UC:
                return AMDGPU_PTE_MTYPE_GFX12(0ULL, MTYPE_UC);
        default:
<span
class="del">--
</span>2.34.1

</pre></div></content></entry><entry><author><name>Sasha Levin</name><email>sashal@kernel.org</email></author><title>[PATCH AUTOSEL 6.9 38/44] drm/amdgpu/pptable: Fix UBSAN array-index-out-of-bounds</title><updated>2024-06-18T12:37:45Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618123611.3301370-38-sashal@kernel.org/"/><id>urn:uuid:c30a8ed7-0bd0-32ad-7624-718a80840ba0</id><thr:in-reply-to
ref="urn:uuid:9e4388ce-7a3f-83b5-4b4c-3f9b723b6261"
href="http://lore.kernel.org/amd-gfx/20240618123611.3301370-1-sashal@kernel.org/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Tasos Sahanidis &lt;tasos@tasossah.com&gt;

[ Upstream commit c6c4dd54012551cce5cde408b35468f2c62b0cce ]

Flexible arrays used [1] instead of []. Replace the former with the latter
to resolve multiple UBSAN warnings observed on boot with a BONAIRE card.

In addition, use the __counted_by attribute where possible to hint the
length of the arrays to the compiler and any sanitizers.

Signed-off-by: Tasos Sahanidis &lt;tasos@tasossah.com&gt;
Signed-off-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Signed-off-by: Sasha Levin &lt;sashal@kernel.org&gt;
---
 drivers/gpu/drm/amd/include/pptable.h | 91 ++++++++++++++-------------
 1 file <a href="http://lore.kernel.org/amd-gfx/20240618123611.3301370-38-sashal@kernel.org/#related">changed</a>, 49 insertions(+), 42 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/include/pptable.h b/drivers/gpu/drm/amd/include/pptable.h
index 2e8e6c9875f6c..f83ace2d7ec30 100644
--- a/drivers/gpu/drm/amd/include/pptable.h
+++ b/drivers/gpu/drm/amd/include/pptable.h
</span><span
class="hunk">@@ -477,31 +477,30 @@ typedef struct _ATOM_PPLIB_STATE_V2
</span> } ATOM_PPLIB_STATE_V2;
 
 typedef struct _StateArray{
<span
class="del">-    //how many states we have 
-    UCHAR ucNumEntries;
-    
-    ATOM_PPLIB_STATE_V2 states[1];
</span><span
class="add">+	//how many states we have
+	UCHAR ucNumEntries;
+
+	ATOM_PPLIB_STATE_V2 states[] /* __counted_by(ucNumEntries) */;
</span> }StateArray;
 
 
 typedef struct _ClockInfoArray{
<span
class="del">-    //how many clock levels we have
-    UCHAR ucNumEntries;
-    
-    //sizeof(ATOM_PPLIB_CLOCK_INFO)
-    UCHAR ucEntrySize;
-    
-    UCHAR clockInfo[];
</span><span
class="add">+	//how many clock levels we have
+	UCHAR ucNumEntries;
+
+	//sizeof(ATOM_PPLIB_CLOCK_INFO)
+	UCHAR ucEntrySize;
+
+	UCHAR clockInfo[];
</span> }ClockInfoArray;
 
 typedef struct _NonClockInfoArray{
<span
class="add">+	//how many non-clock levels we have. normally should be same as number of states
+	UCHAR ucNumEntries;
+	//sizeof(ATOM_PPLIB_NONCLOCK_INFO)
+	UCHAR ucEntrySize;
</span> 
<span
class="del">-    //how many non-clock levels we have. normally should be same as number of states
-    UCHAR ucNumEntries;
-    //sizeof(ATOM_PPLIB_NONCLOCK_INFO)
-    UCHAR ucEntrySize;
-    
-    ATOM_PPLIB_NONCLOCK_INFO nonClockInfo[];
</span><span
class="add">+	ATOM_PPLIB_NONCLOCK_INFO nonClockInfo[] __counted_by(ucNumEntries);
</span> }NonClockInfoArray;
 
 typedef struct _ATOM_PPLIB_Clock_Voltage_Dependency_Record
<span
class="hunk">@@ -513,8 +512,10 @@ typedef struct _ATOM_PPLIB_Clock_Voltage_Dependency_Record
</span> 
 typedef struct _ATOM_PPLIB_Clock_Voltage_Dependency_Table
 {
<span
class="del">-    UCHAR ucNumEntries;                                                // Number of entries.
-    ATOM_PPLIB_Clock_Voltage_Dependency_Record entries[1];             // Dynamically allocate entries.
</span><span
class="add">+	// Number of entries.
+	UCHAR ucNumEntries;
+	// Dynamically allocate entries.
+	ATOM_PPLIB_Clock_Voltage_Dependency_Record entries[] __counted_by(ucNumEntries);
</span> }ATOM_PPLIB_Clock_Voltage_Dependency_Table;
 
 typedef struct _ATOM_PPLIB_Clock_Voltage_Limit_Record
<span
class="hunk">@@ -529,8 +530,10 @@ typedef struct _ATOM_PPLIB_Clock_Voltage_Limit_Record
</span> 
 typedef struct _ATOM_PPLIB_Clock_Voltage_Limit_Table
 {
<span
class="del">-    UCHAR ucNumEntries;                                                // Number of entries.
-    ATOM_PPLIB_Clock_Voltage_Limit_Record entries[1];                  // Dynamically allocate entries.
</span><span
class="add">+	// Number of entries.
+	UCHAR ucNumEntries;
+	// Dynamically allocate entries.
+	ATOM_PPLIB_Clock_Voltage_Limit_Record entries[] __counted_by(ucNumEntries);
</span> }ATOM_PPLIB_Clock_Voltage_Limit_Table;
 
 union _ATOM_PPLIB_CAC_Leakage_Record
<span
class="hunk">@@ -553,8 +556,10 @@ typedef union _ATOM_PPLIB_CAC_Leakage_Record ATOM_PPLIB_CAC_Leakage_Record;
</span> 
 typedef struct _ATOM_PPLIB_CAC_Leakage_Table
 {
<span
class="del">-    UCHAR ucNumEntries;                                                 // Number of entries.
-    ATOM_PPLIB_CAC_Leakage_Record entries[1];                           // Dynamically allocate entries.
</span><span
class="add">+	// Number of entries.
+	UCHAR ucNumEntries;
+	// Dynamically allocate entries.
+	ATOM_PPLIB_CAC_Leakage_Record entries[] __counted_by(ucNumEntries);
</span> }ATOM_PPLIB_CAC_Leakage_Table;
 
 typedef struct _ATOM_PPLIB_PhaseSheddingLimits_Record
<span
class="hunk">@@ -568,8 +573,10 @@ typedef struct _ATOM_PPLIB_PhaseSheddingLimits_Record
</span> 
 typedef struct _ATOM_PPLIB_PhaseSheddingLimits_Table
 {
<span
class="del">-    UCHAR ucNumEntries;                                                 // Number of entries.
-    ATOM_PPLIB_PhaseSheddingLimits_Record entries[1];                   // Dynamically allocate entries.
</span><span
class="add">+	// Number of entries.
+	UCHAR ucNumEntries;
+	// Dynamically allocate entries.
+	ATOM_PPLIB_PhaseSheddingLimits_Record entries[] __counted_by(ucNumEntries);
</span> }ATOM_PPLIB_PhaseSheddingLimits_Table;
 
 typedef struct _VCEClockInfo{
<span
class="hunk">@@ -580,8 +587,8 @@ typedef struct _VCEClockInfo{
</span> }VCEClockInfo;
 
 typedef struct _VCEClockInfoArray{
<span
class="del">-    UCHAR ucNumEntries;
-    VCEClockInfo entries[1];
</span><span
class="add">+	UCHAR ucNumEntries;
+	VCEClockInfo entries[] __counted_by(ucNumEntries);
</span> }VCEClockInfoArray;
 
 typedef struct _ATOM_PPLIB_VCE_Clock_Voltage_Limit_Record
<span
class="hunk">@@ -592,8 +599,8 @@ typedef struct _ATOM_PPLIB_VCE_Clock_Voltage_Limit_Record
</span> 
 typedef struct _ATOM_PPLIB_VCE_Clock_Voltage_Limit_Table
 {
<span
class="del">-    UCHAR numEntries;
-    ATOM_PPLIB_VCE_Clock_Voltage_Limit_Record entries[1];
</span><span
class="add">+	UCHAR numEntries;
+	ATOM_PPLIB_VCE_Clock_Voltage_Limit_Record entries[] __counted_by(numEntries);
</span> }ATOM_PPLIB_VCE_Clock_Voltage_Limit_Table;
 
 typedef struct _ATOM_PPLIB_VCE_State_Record
<span
class="hunk">@@ -604,8 +611,8 @@ typedef struct _ATOM_PPLIB_VCE_State_Record
</span> 
 typedef struct _ATOM_PPLIB_VCE_State_Table
 {
<span
class="del">-    UCHAR numEntries;
-    ATOM_PPLIB_VCE_State_Record entries[1];
</span><span
class="add">+	UCHAR numEntries;
+	ATOM_PPLIB_VCE_State_Record entries[] __counted_by(numEntries);
</span> }ATOM_PPLIB_VCE_State_Table;
 
 
<span
class="hunk">@@ -626,8 +633,8 @@ typedef struct _UVDClockInfo{
</span> }UVDClockInfo;
 
 typedef struct _UVDClockInfoArray{
<span
class="del">-    UCHAR ucNumEntries;
-    UVDClockInfo entries[1];
</span><span
class="add">+	UCHAR ucNumEntries;
+	UVDClockInfo entries[] __counted_by(ucNumEntries);
</span> }UVDClockInfoArray;
 
 typedef struct _ATOM_PPLIB_UVD_Clock_Voltage_Limit_Record
<span
class="hunk">@@ -638,8 +645,8 @@ typedef struct _ATOM_PPLIB_UVD_Clock_Voltage_Limit_Record
</span> 
 typedef struct _ATOM_PPLIB_UVD_Clock_Voltage_Limit_Table
 {
<span
class="del">-    UCHAR numEntries;
-    ATOM_PPLIB_UVD_Clock_Voltage_Limit_Record entries[1];
</span><span
class="add">+	UCHAR numEntries;
+	ATOM_PPLIB_UVD_Clock_Voltage_Limit_Record entries[] __counted_by(numEntries);
</span> }ATOM_PPLIB_UVD_Clock_Voltage_Limit_Table;
 
 typedef struct _ATOM_PPLIB_UVD_Table
<span
class="hunk">@@ -657,8 +664,8 @@ typedef struct _ATOM_PPLIB_SAMClk_Voltage_Limit_Record
</span> }ATOM_PPLIB_SAMClk_Voltage_Limit_Record;
 
 typedef struct _ATOM_PPLIB_SAMClk_Voltage_Limit_Table{
<span
class="del">-    UCHAR numEntries;
-    ATOM_PPLIB_SAMClk_Voltage_Limit_Record entries[];
</span><span
class="add">+	UCHAR numEntries;
+	ATOM_PPLIB_SAMClk_Voltage_Limit_Record entries[] __counted_by(numEntries);
</span> }ATOM_PPLIB_SAMClk_Voltage_Limit_Table;
 
 typedef struct _ATOM_PPLIB_SAMU_Table
<span
class="hunk">@@ -675,8 +682,8 @@ typedef struct _ATOM_PPLIB_ACPClk_Voltage_Limit_Record
</span> }ATOM_PPLIB_ACPClk_Voltage_Limit_Record;
 
 typedef struct _ATOM_PPLIB_ACPClk_Voltage_Limit_Table{
<span
class="del">-    UCHAR numEntries;
-    ATOM_PPLIB_ACPClk_Voltage_Limit_Record entries[1];
</span><span
class="add">+	UCHAR numEntries;
+	ATOM_PPLIB_ACPClk_Voltage_Limit_Record entries[] __counted_by(numEntries);
</span> }ATOM_PPLIB_ACPClk_Voltage_Limit_Table;
 
 typedef struct _ATOM_PPLIB_ACP_Table
<span
class="hunk">@@ -743,9 +750,9 @@ typedef struct ATOM_PPLIB_VQ_Budgeting_Record{
</span> } ATOM_PPLIB_VQ_Budgeting_Record;
 
 typedef struct ATOM_PPLIB_VQ_Budgeting_Table {
<span
class="del">-    UCHAR revid;
-    UCHAR numEntries;
-    ATOM_PPLIB_VQ_Budgeting_Record         entries[1];
</span><span
class="add">+	UCHAR revid;
+	UCHAR numEntries;
+	ATOM_PPLIB_VQ_Budgeting_Record entries[] __counted_by(numEntries);
</span> } ATOM_PPLIB_VQ_Budgeting_Table;
 
 #pragma pack()
-- 
2.43.0

</pre></div></content></entry><entry><author><name>Lijo Lazar</name><email>lijo.lazar@amd.com</email></author><title>[PATCH] drm/amdgpu: Fix pci state save during mode-1 reset</title><updated>2024-06-18T08:44:46Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618084423.1144125-1-lijo.lazar@amd.com/"/><id>urn:uuid:44628afa-2b4a-48ee-4f09-ee28ed22df62</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Cache the PCI state before bus master is disabled. The saved state is
later used for other cases like restoring config space after mode-2
reset.

Signed-off-by: Lijo Lazar &lt;lijo.lazar@amd.com&gt;
Fixes: 5c03e5843e6b (&#34;drm/amdgpu:add smu mode1/2 support for aldebaran&#34;)
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_device.c | 7 +++++--
 1 file <a href="http://lore.kernel.org/amd-gfx/20240618084423.1144125-1-lijo.lazar@amd.com/#related">changed</a>, 5 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
index 3fb02f5b91c9..6c2ab14ca102 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
</span><span
class="hunk">@@ -5224,11 +5224,14 @@ int amdgpu_device_mode1_reset(struct amdgpu_device *adev)
</span> 
 	dev_info(adev-&gt;dev, &#34;GPU mode1 reset\n&#34;);
 
<span
class="add">+	/* Cache the state before bus master disable. The saved config space
+	 * values are used in other cases like restore after mode-2 reset.
+	 */
+	amdgpu_device_cache_pci_state(adev-&gt;pdev);
+
</span> 	/* disable BM */
 	pci_clear_master(adev-&gt;pdev);
 
<span
class="del">-	amdgpu_device_cache_pci_state(adev-&gt;pdev);
-
</span> 	if (amdgpu_dpm_is_mode1_reset_supported(adev)) {
 		dev_info(adev-&gt;dev, &#34;GPU smu mode1 reset\n&#34;);
 		ret = amdgpu_dpm_mode1_reset(adev);
-- 
2.25.1

</pre></div></content></entry><entry><author><name>Yang Wang</name><email>kevinyang.wang@amd.com</email></author><title
type="html">[PATCH 1/2] Revert &#34;drm/amdgpu: change bank cache lock type to spinlock&#34;</title><updated>2024-06-18T07:48:57Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618074835.1439008-1-kevinyang.wang@amd.com/"/><id>urn:uuid:fdd92a77-dd38-7159-1522-cb4035bcb011</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This reverts commit 379e6cd11499f35d67bbf8f0114b0a054b9f73d7

revert this patch to modify lock type back to &#39;mutex&#39; to avoid kernel
calltrace issue.

[  602.668806] Workqueue: amdgpu-reset-dev amdgpu_ras_do_recovery [amdgpu]
[  602.668939] Call Trace:
[  602.668940]  &lt;TASK&gt;
[  602.668941]  dump_stack_lvl+0x4c/0x70
[  602.668945]  dump_stack+0x14/0x20
[  602.668946]  __schedule_bug+0x5a/0x70
[  602.668950]  __schedule+0x940/0xb30
[  602.668952]  ? srso_alias_return_thunk+0x5/0xfbef5
[  602.668955]  ? hrtimer_reprogram+0x77/0xb0
[  602.668957]  ? srso_alias_return_thunk+0x5/0xfbef5
[  602.668959]  ? hrtimer_start_range_ns+0x126/0x370
[  602.668961]  schedule+0x39/0xe0
[  602.668962]  schedule_hrtimeout_range_clock+0xb1/0x140
[  602.668964]  ? __pfx_hrtimer_wakeup+0x10/0x10
[  602.668966]  schedule_hrtimeout_range+0x17/0x20
[  602.668967]  usleep_range_state+0x69/0x90
[  602.668970]  psp_cmd_submit_buf+0x132/0x570 [amdgpu]
[  602.669066]  psp_ras_invoke+0x75/0x1a0 [amdgpu]
[  602.669156]  psp_ras_query_address+0x9c/0x120 [amdgpu]
[  602.669245]  umc_v12_0_update_ecc_status+0x16d/0x520 [amdgpu]
[  602.669337]  ? srso_alias_return_thunk+0x5/0xfbef5
[  602.669339]  ? stack_depot_save+0x12/0x20
[  602.669342]  ? srso_alias_return_thunk+0x5/0xfbef5
[  602.669343]  ? set_track_prepare+0x52/0x70
[  602.669346]  ? kmemleak_alloc+0x4f/0x90
[  602.669348]  ? __kmalloc_node+0x34b/0x450
[  602.669352]  amdgpu_umc_update_ecc_status+0x23/0x40 [amdgpu]
[  602.669438]  mca_umc_mca_get_err_count+0x85/0xc0 [amdgpu]
[  602.669554]  mca_smu_parse_mca_error_count+0x120/0x1d0 [amdgpu]
[  602.669655]  amdgpu_mca_dispatch_mca_set.part.0+0x141/0x250 [amdgpu]
[  602.669743]  ? kmemleak_free+0x36/0x60
[  602.669745]  ? kvfree+0x32/0x40
[  602.669747]  ? srso_alias_return_thunk+0x5/0xfbef5
[  602.669749]  ? kfree+0x15d/0x2a0
[  602.669752]  amdgpu_mca_smu_log_ras_error+0x1f6/0x210 [amdgpu]
[  602.669839]  amdgpu_ras_query_error_status_helper+0x2ad/0x390 [amdgpu]
[  602.669924]  ? srso_alias_return_thunk+0x5/0xfbef5
[  602.669925]  ? __call_rcu_common.constprop.0+0xa6/0x2b0
[  602.669929]  amdgpu_ras_query_error_status+0xf3/0x620 [amdgpu]
[  602.670014]  ? srso_alias_return_thunk+0x5/0xfbef5
[  602.670017]  amdgpu_ras_log_on_err_counter+0xe1/0x170 [amdgpu]
[  602.670103]  amdgpu_ras_do_recovery+0xd2/0x2c0 [amdgpu]
[  602.670187]  ? srso_alias_return_thunk+0x5/0xfbef5
[  602.670189]  ? __schedule+0x37d/0xb30
[  602.670191]  process_one_work+0x176/0x350
[  602.670194]  worker_thread+0x2f7/0x420
[  602.670197]  ?

Signed-off-by: Yang Wang &lt;kevinyang.wang@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_mca.c | 11 ++++++-----
 drivers/gpu/drm/amd/amdgpu/amdgpu_mca.h |  2 +-
 2 files <a href="http://lore.kernel.org/amd-gfx/20240618074835.1439008-1-kevinyang.wang@amd.com/#related">changed</a>, 7 insertions(+), 6 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_mca.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_mca.c
index c7e602d69f2c..9d3a3c778504 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_mca.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_mca.c
</span><span
class="hunk">@@ -232,7 +232,7 @@ int amdgpu_mca_init(struct amdgpu_device *adev)
</span> 
 	for (i = 0; i &lt; ARRAY_SIZE(mca-&gt;mca_caches); i++) {
 		mca_cache = &#38;mca-&gt;mca_caches[i];
<span
class="del">-		spin_lock_init(&#38;mca_cache-&gt;lock);
</span><span
class="add">+		mutex_init(&#38;mca_cache-&gt;lock);
</span> 		amdgpu_mca_bank_set_init(&#38;mca_cache-&gt;mca_set);
 	}
 
<span
class="hunk">@@ -250,6 +250,7 @@ void amdgpu_mca_fini(struct amdgpu_device *adev)
</span> 	for (i = 0; i &lt; ARRAY_SIZE(mca-&gt;mca_caches); i++) {
 		mca_cache = &#38;mca-&gt;mca_caches[i];
 		amdgpu_mca_bank_set_release(&#38;mca_cache-&gt;mca_set);
<span
class="add">+		mutex_destroy(&#38;mca_cache-&gt;lock);
</span> 	}
 }
 
<span
class="hunk">@@ -454,9 +455,9 @@ static int amdgpu_mca_add_mca_set_to_cache(struct amdgpu_device *adev, enum amdg
</span> 	struct mca_bank_cache *mca_cache = &#38;adev-&gt;mca.mca_caches[type];
 	int ret;
 
<span
class="del">-	spin_lock(&#38;mca_cache-&gt;lock);
</span><span
class="add">+	mutex_lock(&#38;mca_cache-&gt;lock);
</span> 	ret = amdgpu_mca_bank_set_merge(&#38;mca_cache-&gt;mca_set, new);
<span
class="del">-	spin_unlock(&#38;mca_cache-&gt;lock);
</span><span
class="add">+	mutex_unlock(&#38;mca_cache-&gt;lock);
</span> 
 	return ret;
 }
<span
class="hunk">@@ -486,10 +487,10 @@ int amdgpu_mca_smu_log_ras_error(struct amdgpu_device *adev, enum amdgpu_ras_blo
</span> 	}
 
 	/* dispatch mca set again if mca cache has valid data */
<span
class="del">-	spin_lock(&#38;mca_cache-&gt;lock);
</span><span
class="add">+	mutex_lock(&#38;mca_cache-&gt;lock);
</span> 	if (mca_cache-&gt;mca_set.nr_entries)
 		ret = amdgpu_mca_dispatch_mca_set(adev, blk, type, &#38;mca_cache-&gt;mca_set, err_data);
<span
class="del">-	spin_unlock(&#38;mca_cache-&gt;lock);
</span><span
class="add">+	mutex_unlock(&#38;mca_cache-&gt;lock);
</span> 
 out_mca_release:
 	amdgpu_mca_bank_set_release(&#38;mca_set);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_mca.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_mca.h
index c3c184c88dad..e80323ff90c1 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_mca.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_mca.h
</span><span
class="hunk">@@ -84,7 +84,7 @@ struct mca_bank_set {
</span> 
 struct mca_bank_cache {
 	struct mca_bank_set mca_set;
<span
class="del">-	spinlock_t lock;
</span><span
class="add">+	struct mutex lock;
</span> };
 
 struct amdgpu_mca {
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Yang Wang</name><email>kevinyang.wang@amd.com</email></author><title
type="html">[PATCH 2/2] Revert &#34;drm/amdgpu: change aca bank error lock type to spinlock&#34;</title><updated>2024-06-18T07:48:55Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618074835.1439008-2-kevinyang.wang@amd.com/"/><id>urn:uuid:4675c561-90a0-85aa-2c6e-32d4dd8155e2</id><thr:in-reply-to
ref="urn:uuid:fdd92a77-dd38-7159-1522-cb4035bcb011"
href="http://lore.kernel.org/amd-gfx/20240618074835.1439008-1-kevinyang.wang@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This reverts commit 354436e7905d166011f2aa26dccd9fa04b20940e.

Revert this patch to modify lock type back to &#39;mutex&#39; to avoid kernel
calltrace issue.

[  602.668806] Workqueue: amdgpu-reset-dev amdgpu_ras_do_recovery [amdgpu]
[  602.668939] Call Trace:
[  602.668940]  &lt;TASK&gt;
[  602.668941]  dump_stack_lvl+0x4c/0x70
[  602.668945]  dump_stack+0x14/0x20
[  602.668946]  __schedule_bug+0x5a/0x70
[  602.668950]  __schedule+0x940/0xb30
[  602.668952]  ? srso_alias_return_thunk+0x5/0xfbef5
[  602.668955]  ? hrtimer_reprogram+0x77/0xb0
[  602.668957]  ? srso_alias_return_thunk+0x5/0xfbef5
[  602.668959]  ? hrtimer_start_range_ns+0x126/0x370
[  602.668961]  schedule+0x39/0xe0
[  602.668962]  schedule_hrtimeout_range_clock+0xb1/0x140
[  602.668964]  ? __pfx_hrtimer_wakeup+0x10/0x10
[  602.668966]  schedule_hrtimeout_range+0x17/0x20
[  602.668967]  usleep_range_state+0x69/0x90
[  602.668970]  psp_cmd_submit_buf+0x132/0x570 [amdgpu]
[  602.669066]  psp_ras_invoke+0x75/0x1a0 [amdgpu]
[  602.669156]  psp_ras_query_address+0x9c/0x120 [amdgpu]
[  602.669245]  umc_v12_0_update_ecc_status+0x16d/0x520 [amdgpu]
[  602.669337]  ? srso_alias_return_thunk+0x5/0xfbef5
[  602.669339]  ? stack_depot_save+0x12/0x20
[  602.669342]  ? srso_alias_return_thunk+0x5/0xfbef5
[  602.669343]  ? set_track_prepare+0x52/0x70
[  602.669346]  ? kmemleak_alloc+0x4f/0x90
[  602.669348]  ? __kmalloc_node+0x34b/0x450
[  602.669352]  amdgpu_umc_update_ecc_status+0x23/0x40 [amdgpu]
[  602.669438]  mca_umc_mca_get_err_count+0x85/0xc0 [amdgpu]
[  602.669554]  mca_smu_parse_mca_error_count+0x120/0x1d0 [amdgpu]
[  602.669655]  amdgpu_mca_dispatch_mca_set.part.0+0x141/0x250 [amdgpu]
[  602.669743]  ? kmemleak_free+0x36/0x60
[  602.669745]  ? kvfree+0x32/0x40
[  602.669747]  ? srso_alias_return_thunk+0x5/0xfbef5
[  602.669749]  ? kfree+0x15d/0x2a0
[  602.669752]  amdgpu_mca_smu_log_ras_error+0x1f6/0x210 [amdgpu]
[  602.669839]  amdgpu_ras_query_error_status_helper+0x2ad/0x390 [amdgpu]
[  602.669924]  ? srso_alias_return_thunk+0x5/0xfbef5
[  602.669925]  ? __call_rcu_common.constprop.0+0xa6/0x2b0
[  602.669929]  amdgpu_ras_query_error_status+0xf3/0x620 [amdgpu]
[  602.670014]  ? srso_alias_return_thunk+0x5/0xfbef5
[  602.670017]  amdgpu_ras_log_on_err_counter+0xe1/0x170 [amdgpu]
[  602.670103]  amdgpu_ras_do_recovery+0xd2/0x2c0 [amdgpu]
[  602.670187]  ? srso_alias_return_thunk+0x5/0

Signed-off-by: Yang Wang &lt;kevinyang.wang@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_aca.c | 19 ++++++++++---------
 drivers/gpu/drm/amd/amdgpu/amdgpu_aca.h |  3 +--
 2 files <a href="http://lore.kernel.org/amd-gfx/20240618074835.1439008-2-kevinyang.wang@amd.com/#related">changed</a>, 11 insertions(+), 11 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_aca.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_aca.c
index 04515c1c7241..7945173321a2 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_aca.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_aca.c
</span><span
class="hunk">@@ -222,9 +222,9 @@ static struct aca_bank_error *new_bank_error(struct aca_error *aerr, struct aca_
</span> 	INIT_LIST_HEAD(&#38;bank_error-&gt;node);
 	memcpy(&#38;bank_error-&gt;info, info, sizeof(*info));
 
<span
class="del">-	spin_lock(&#38;aerr-&gt;lock);
</span><span
class="add">+	mutex_lock(&#38;aerr-&gt;lock);
</span> 	list_add_tail(&#38;bank_error-&gt;node, &#38;aerr-&gt;list);
<span
class="del">-	spin_unlock(&#38;aerr-&gt;lock);
</span><span
class="add">+	mutex_unlock(&#38;aerr-&gt;lock);
</span> 
 	return bank_error;
 }
<span
class="hunk">@@ -235,7 +235,7 @@ static struct aca_bank_error *find_bank_error(struct aca_error *aerr, struct aca
</span> 	struct aca_bank_info *tmp_info;
 	bool found = false;
 
<span
class="del">-	spin_lock(&#38;aerr-&gt;lock);
</span><span
class="add">+	mutex_lock(&#38;aerr-&gt;lock);
</span> 	list_for_each_entry(bank_error, &#38;aerr-&gt;list, node) {
 		tmp_info = &#38;bank_error-&gt;info;
 		if (tmp_info-&gt;socket_id == info-&gt;socket_id &#38;&#38;
<span
class="hunk">@@ -246,7 +246,7 @@ static struct aca_bank_error *find_bank_error(struct aca_error *aerr, struct aca
</span> 	}
 
 out_unlock:
<span
class="del">-	spin_unlock(&#38;aerr-&gt;lock);
</span><span
class="add">+	mutex_unlock(&#38;aerr-&gt;lock);
</span> 
 	return found ? bank_error : NULL;
 }
<span
class="hunk">@@ -474,7 +474,7 @@ static int aca_log_aca_error(struct aca_handle *handle, enum aca_error_type type
</span> 	struct aca_error *aerr = &#38;error_cache-&gt;errors[type];
 	struct aca_bank_error *bank_error, *tmp;
 
<span
class="del">-	spin_lock(&#38;aerr-&gt;lock);
</span><span
class="add">+	mutex_lock(&#38;aerr-&gt;lock);
</span> 
 	if (list_empty(&#38;aerr-&gt;list))
 		goto out_unlock;
<span
class="hunk">@@ -485,7 +485,7 @@ static int aca_log_aca_error(struct aca_handle *handle, enum aca_error_type type
</span> 	}
 
 out_unlock:
<span
class="del">-	spin_unlock(&#38;aerr-&gt;lock);
</span><span
class="add">+	mutex_unlock(&#38;aerr-&gt;lock);
</span> 
 	return 0;
 }
<span
class="hunk">@@ -542,7 +542,7 @@ int amdgpu_aca_get_error_data(struct amdgpu_device *adev, struct aca_handle *han
</span> 
 static void aca_error_init(struct aca_error *aerr, enum aca_error_type type)
 {
<span
class="del">-	spin_lock_init(&#38;aerr-&gt;lock);
</span><span
class="add">+	mutex_init(&#38;aerr-&gt;lock);
</span> 	INIT_LIST_HEAD(&#38;aerr-&gt;list);
 	aerr-&gt;type = type;
 	aerr-&gt;nr_errors = 0;
<span
class="hunk">@@ -561,10 +561,11 @@ static void aca_error_fini(struct aca_error *aerr)
</span> {
 	struct aca_bank_error *bank_error, *tmp;
 
<span
class="del">-	spin_lock(&#38;aerr-&gt;lock);
</span><span
class="add">+	mutex_lock(&#38;aerr-&gt;lock);
</span> 	list_for_each_entry_safe(bank_error, tmp, &#38;aerr-&gt;list, node)
 		aca_bank_error_remove(aerr, bank_error);
<span
class="del">-	spin_unlock(&#38;aerr-&gt;lock);
</span><span
class="add">+
+	mutex_destroy(&#38;aerr-&gt;lock);
</span> }
 
 static void aca_fini_error_cache(struct aca_handle *handle)
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_aca.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_aca.h
index ba724c2a997d..5ef6b745f222 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_aca.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_aca.h
</span><span
class="hunk">@@ -25,7 +25,6 @@
</span> #define __AMDGPU_ACA_H__
 
 #include &lt;linux/list.h&gt;
<span
class="del">-#include &lt;linux/spinlock.h&gt;
</span> 
 struct ras_err_data;
 struct ras_query_context;
<span
class="hunk">@@ -134,7 +133,7 @@ struct aca_bank_error {
</span> 
 struct aca_error {
 	struct list_head list;
<span
class="del">-	spinlock_t lock;
</span><span
class="add">+	struct mutex lock;
</span> 	enum aca_error_type type;
 	int nr_errors;
 };
-- 
2.34.1

</pre></div></content></entry><entry><author><name>YiPeng Chai</name><email>YiPeng.Chai@amd.com</email></author><title>[PATCH 4/5] drm/amdgpu: add completion to wait for ras reset to complete</title><updated>2024-06-18T06:34:47Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618063359.304293-4-YiPeng.Chai@amd.com/"/><id>urn:uuid:0a4d2290-6146-b2dc-de0d-cee5cc8ff015</id><thr:in-reply-to
ref="urn:uuid:3815ac3e-3827-4a73-5397-ac5f4a5a1270"
href="http://lore.kernel.org/amd-gfx/20240618063359.304293-1-YiPeng.Chai@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Add completion to wait for ras reset to complete.

Signed-off-by: YiPeng Chai &lt;YiPeng.Chai@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c | 11 +++++++++++
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h |  1 +
 2 files <a href="http://lore.kernel.org/amd-gfx/20240618063359.304293-4-YiPeng.Chai@amd.com/#related">changed</a>, 12 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
index 898889600771..7f8e6ca07957 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
</span><span
class="hunk">@@ -124,6 +124,8 @@ const char *get_ras_block_str(struct ras_common_if *ras_block)
</span> 
 #define AMDGPU_RAS_RETIRE_PAGE_INTERVAL 100  //ms
 
<span
class="add">+#define MAX_RAS_RECOVERY_COMPLETION_TIME  120000 //ms
+
</span> enum amdgpu_ras_retire_page_reservation {
 	AMDGPU_RAS_RETIRE_PAGE_RESERVED,
 	AMDGPU_RAS_RETIRE_PAGE_PENDING,
<span
class="hunk">@@ -2518,6 +2520,8 @@ static void amdgpu_ras_do_recovery(struct work_struct *work)
</span> 		atomic_set(&#38;hive-&gt;ras_recovery, 0);
 		amdgpu_put_xgmi_hive(hive);
 	}
<span
class="add">+
+	complete_all(&#38;ras-&gt;ras_recovery_completion);
</span> }
 
 /* alloc/realloc bps array */
<span
class="hunk">@@ -2911,10 +2915,16 @@ static int amdgpu_ras_poison_consumption_handler(struct amdgpu_device *adev,
</span> 
 		flush_delayed_work(&#38;con-&gt;page_retirement_dwork);
 
<span
class="add">+		reinit_completion(&#38;con-&gt;ras_recovery_completion);
+
</span> 		con-&gt;gpu_reset_flags |= reset;
 		amdgpu_ras_reset_gpu(adev);
 
 		*gpu_reset = reset;
<span
class="add">+		if (!wait_for_completion_timeout(&#38;con-&gt;ras_recovery_completion,
+				msecs_to_jiffies(MAX_RAS_RECOVERY_COMPLETION_TIME)))
+			dev_err(adev-&gt;dev, &#34;Waiting for GPU to complete ras reset timeout! reset:0x%x\n&#34;,
+				reset);
</span> 	}
 
 	return 0;
<span
class="hunk">@@ -3041,6 +3051,7 @@ int amdgpu_ras_recovery_init(struct amdgpu_device *adev)
</span> 		}
 	}
 
<span
class="add">+	init_completion(&#38;con-&gt;ras_recovery_completion);
</span> 	mutex_init(&#38;con-&gt;page_rsv_lock);
 	INIT_KFIFO(con-&gt;poison_fifo);
 	mutex_init(&#38;con-&gt;page_retirement_lock);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
index 91daf48be03a..b47f03edac87 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
</span><span
class="hunk">@@ -537,6 +537,7 @@ struct amdgpu_ras {
</span> 	DECLARE_KFIFO(poison_fifo, struct ras_poison_msg, 128);
 	struct ras_ecc_log_info  umc_ecc_log;
 	struct delayed_work page_retirement_dwork;
<span
class="add">+	struct completion ras_recovery_completion;
</span> 
 	/* Fatal error detected flag */
 	atomic_t fed;
-- 
2.34.1

</pre></div></content></entry><entry><author><name>YiPeng Chai</name><email>YiPeng.Chai@amd.com</email></author><title>[PATCH 5/5] drm/amdgpu: add gpu reset check and exception handling</title><updated>2024-06-18T06:34:45Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618063359.304293-5-YiPeng.Chai@amd.com/"/><id>urn:uuid:feae9e14-83c4-6abe-b877-94c4d83aca92</id><thr:in-reply-to
ref="urn:uuid:3815ac3e-3827-4a73-5397-ac5f4a5a1270"
href="http://lore.kernel.org/amd-gfx/20240618063359.304293-1-YiPeng.Chai@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Add gpu reset check and exception handling for
page retirement.

Signed-off-by: YiPeng Chai &lt;YiPeng.Chai@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c | 43 +++++++++++++++++++++++++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240618063359.304293-5-YiPeng.Chai@amd.com/#related">changed</a>, 43 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
index 7f8e6ca07957..635dc86dbfd8 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
</span><span
class="hunk">@@ -1386,10 +1386,15 @@ int amdgpu_ras_query_error_status(struct amdgpu_device *adev, struct ras_query_i
</span> 	memset(&#38;qctx, 0, sizeof(qctx));
 	qctx.event_id = amdgpu_ras_acquire_event_id(adev, amdgpu_ras_intr_triggered() ?
 						   RAS_EVENT_TYPE_ISR : RAS_EVENT_TYPE_INVALID);
<span
class="add">+
+	if (!down_read_trylock(&#38;adev-&gt;reset_domain-&gt;sem))
+		return -EIO;
+
</span> 	ret = amdgpu_ras_query_error_status_helper(adev, info,
 						   &#38;err_data,
 						   &#38;qctx,
 						   error_query_mode);
<span
class="add">+	up_read(&#38;adev-&gt;reset_domain-&gt;sem);
</span> 	if (ret)
 		goto out_fini_err_data;
 
<span
class="hunk">@@ -2884,6 +2889,14 @@ static int amdgpu_ras_poison_creation_handler(struct amdgpu_device *adev,
</span> 	return 0;
 }
 
<span
class="add">+static void amdgpu_ras_clear_poison_fifo(struct amdgpu_device *adev)
+{
+	struct amdgpu_ras *con = amdgpu_ras_get_context(adev);
+	struct ras_poison_msg msg;
+
+	while (kfifo_get(&#38;con-&gt;poison_fifo, &#38;msg));
+}
+
</span> static int amdgpu_ras_poison_consumption_handler(struct amdgpu_device *adev,
 			uint32_t msg_count, uint32_t *gpu_reset)
 {
<span
class="hunk">@@ -2913,6 +2926,11 @@ static int amdgpu_ras_poison_consumption_handler(struct amdgpu_device *adev,
</span> 		else
 			reset = reset_flags;
 
<span
class="add">+		/* Check if gpu is in reset state */
+		if (!down_read_trylock(&#38;adev-&gt;reset_domain-&gt;sem))
+			return -EIO;
+		up_read(&#38;adev-&gt;reset_domain-&gt;sem);
+
</span> 		flush_delayed_work(&#38;con-&gt;page_retirement_dwork);
 
 		reinit_completion(&#38;con-&gt;ras_recovery_completion);
<span
class="hunk">@@ -2977,6 +2995,31 @@ static int amdgpu_ras_page_retirement_thread(void *param)
</span> 			}
 		}
 
<span
class="add">+		if ((ret == -EIO) || (gpu_reset == AMDGPU_RAS_GPU_RESET_MODE1_RESET)) {
+			/* gpu is in mode-1 reset state */
+			/* Clear poison creation request */
+			while (atomic_read(&#38;con-&gt;poison_creation_count))
+				atomic_dec(&#38;con-&gt;poison_creation_count);
+
+			/* Clear poison consumption fifo */
+			amdgpu_ras_clear_poison_fifo(adev);
+
+			while (atomic_read(&#38;con-&gt;page_retirement_req_cnt))
+				atomic_dec(&#38;con-&gt;page_retirement_req_cnt);
+
+			if (ret == -EIO) {
+				/* Wait for mode-1 reset to complete */
+				down_read(&#38;adev-&gt;reset_domain-&gt;sem);
+				up_read(&#38;adev-&gt;reset_domain-&gt;sem);
+			}
+
+			/* Wake up work queue to save bad pages to eeprom */
+			schedule_delayed_work(&#38;con-&gt;page_retirement_dwork, 0);
+		} else if (gpu_reset) {
+			/* gpu is in mode-2 reset or other reset state */
+			/* Wake up work queue to save bad pages to eeprom */
+			schedule_delayed_work(&#38;con-&gt;page_retirement_dwork, 0);
+		}
</span> #else
         dev_info(adev-&gt;dev, &#34;Start processing page retirement. request:%d\n&#34;,
                     atomic_read(&#38;con-&gt;page_retirement_req_cnt));
-- 
2.34.1

</pre></div></content></entry><entry><author><name>YiPeng Chai</name><email>YiPeng.Chai@amd.com</email></author><title>[PATCH 3/5] drm/amdgpu: refine poison consumption interrupt handler</title><updated>2024-06-18T06:34:43Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618063359.304293-3-YiPeng.Chai@amd.com/"/><id>urn:uuid:02a7a5a6-3ea2-0edc-9282-2f594b8864ec</id><thr:in-reply-to
ref="urn:uuid:3815ac3e-3827-4a73-5397-ac5f4a5a1270"
href="http://lore.kernel.org/amd-gfx/20240618063359.304293-1-YiPeng.Chai@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">1. The poison fifo is only used for poison consumption
   requests.
2. Merge reset requests when poison fifo caches multiple
   poison consumption messages

Signed-off-by: YiPeng Chai &lt;YiPeng.Chai@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c | 58 +++++++++++++++++--------
 drivers/gpu/drm/amd/amdgpu/amdgpu_umc.c | 12 ++---
 2 files <a href="http://lore.kernel.org/amd-gfx/20240618063359.304293-3-YiPeng.Chai@amd.com/#related">changed</a>, 46 insertions(+), 24 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
index 13cd6a9234f2..898889600771 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
</span><span
class="hunk">@@ -2881,22 +2881,40 @@ static int amdgpu_ras_poison_creation_handler(struct amdgpu_device *adev,
</span> }
 
 static int amdgpu_ras_poison_consumption_handler(struct amdgpu_device *adev,
<span
class="del">-			struct ras_poison_msg *poison_msg)
</span><span
class="add">+			uint32_t msg_count, uint32_t *gpu_reset)
</span> {
 	struct amdgpu_ras *con = amdgpu_ras_get_context(adev);
<span
class="del">-	uint32_t reset = poison_msg-&gt;reset;
-	uint16_t pasid = poison_msg-&gt;pasid;
</span><span
class="add">+	uint32_t reset_flags = 0, reset = 0;
+	struct ras_poison_msg msg;
+	int ret, i;
</span> 
 	kgd2kfd_set_sram_ecc_flag(adev-&gt;kfd.dev);
 
<span
class="del">-	if (poison_msg-&gt;pasid_fn)
-		poison_msg-&gt;pasid_fn(adev, pasid, poison_msg-&gt;data);
</span><span
class="add">+	for (i = 0; i &lt; msg_count; i++) {
+		ret = amdgpu_ras_get_poison_req(adev, &#38;msg);
+		if (!ret)
+			continue;
+
+		if (msg.pasid_fn)
+			msg.pasid_fn(adev, msg.pasid, msg.data);
+
+		reset_flags |= msg.reset;
+	}
+
+	if (reset_flags) {
+		if (reset_flags &#38; AMDGPU_RAS_GPU_RESET_MODE1_RESET)
+			reset = AMDGPU_RAS_GPU_RESET_MODE1_RESET;
+		else if (reset_flags &#38; AMDGPU_RAS_GPU_RESET_MODE2_RESET)
+			reset = AMDGPU_RAS_GPU_RESET_MODE2_RESET;
+		else
+			reset = reset_flags;
</span> 
<span
class="del">-	if (reset) {
</span> 		flush_delayed_work(&#38;con-&gt;page_retirement_dwork);
 
 		con-&gt;gpu_reset_flags |= reset;
 		amdgpu_ras_reset_gpu(adev);
<span
class="add">+
+		*gpu_reset = reset;
</span> 	}
 
 	return 0;
<span
class="hunk">@@ -2906,11 +2924,9 @@ static int amdgpu_ras_page_retirement_thread(void *param)
</span> {
 	struct amdgpu_device *adev = (struct amdgpu_device *)param;
 	struct amdgpu_ras *con = amdgpu_ras_get_context(adev);
<span
class="del">-	uint32_t poison_creation_count;
</span><span
class="add">+	uint32_t poison_creation_count, msg_count;
+	uint32_t gpu_reset;
</span> 	int ret;
<span
class="del">-	struct ras_poison_msg poison_msg;
-	enum amdgpu_ras_block ras_block;
-	bool poison_creation_is_handled = false;
</span> 
 	while (!kthread_should_stop()) {
 
<span
class="hunk">@@ -2921,6 +2937,7 @@ static int amdgpu_ras_page_retirement_thread(void *param)
</span> 		if (kthread_should_stop())
 			break;
 
<span
class="add">+		gpu_reset = 0;
</span> 
 		do {
 			poison_creation_count = atomic_read(&#38;con-&gt;poison_creation_count);
<span
class="hunk">@@ -2937,16 +2954,19 @@ static int amdgpu_ras_page_retirement_thread(void *param)
</span> 		} while (atomic_read(&#38;con-&gt;poison_creation_count));
 
 #ifdef HAVE_KFIFO_PUT_NON_POINTER
<span
class="del">-		if (!amdgpu_ras_get_poison_req(adev, &#38;poison_msg))
-			continue;
-
-		ras_block = poison_msg.block;
-
-		dev_dbg(adev-&gt;dev, &#34;Start processing ras block %s(%d)\n&#34;,
-				ras_block_str(ras_block), ras_block);
-
</span><span
class="add">+		if (ret != -EIO) {
+			msg_count = kfifo_len(&#38;con-&gt;poison_fifo);
+			if (msg_count) {
+				ret = amdgpu_ras_poison_consumption_handler(adev,
+						msg_count, &#38;gpu_reset);
+				if ((ret != -EIO) &#38;&#38;
+				    (gpu_reset != AMDGPU_RAS_GPU_RESET_MODE1_RESET)) {
+					while (msg_count--)
+						atomic_dec(&#38;con-&gt;page_retirement_req_cnt);
+				}
+			}
+		}
</span> 
<span
class="del">-			amdgpu_ras_poison_consumption_handler(adev, &#38;poison_msg);
</span> #else
         dev_info(adev-&gt;dev, &#34;Start processing page retirement. request:%d\n&#34;,
                     atomic_read(&#38;con-&gt;page_retirement_req_cnt));
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_umc.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_umc.c
index 1dbe69eabb9a..47a46bf49a06 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_umc.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_umc.c
</span><span
class="hunk">@@ -296,13 +296,15 @@ int amdgpu_umc_pasid_poison_handler(struct amdgpu_device *adev,
</span> 				struct amdgpu_ras *con = amdgpu_ras_get_context(adev);
 
 #ifdef HAVE_KFIFO_PUT_NON_POINTER
<span
class="del">-				amdgpu_ras_put_poison_req(adev,
</span><span
class="add">+				int ret;
+
+				ret = amdgpu_ras_put_poison_req(adev,
</span> 					block, pasid, pasid_fn, data, reset);
<span
class="add">+				if (!ret) {
+					atomic_inc(&#38;con-&gt;page_retirement_req_cnt);
+					wake_up(&#38;con-&gt;page_retirement_wq);
+				}
</span> #endif
<span
class="del">-
-				atomic_inc(&#38;con-&gt;page_retirement_req_cnt);
-
-				wake_up(&#38;con-&gt;page_retirement_wq);
</span> 		}
 	} else {
 		if (adev-&gt;virt.ops &#38;&#38; adev-&gt;virt.ops-&gt;ras_poison_handler)
-- 
2.34.1

</pre></div></content></entry><entry><author><name>YiPeng Chai</name><email>YiPeng.Chai@amd.com</email></author><title>[PATCH 2/5] drm/amdgpu: refine poison creation interrupt handler</title><updated>2024-06-18T06:34:39Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618063359.304293-2-YiPeng.Chai@amd.com/"/><id>urn:uuid:8b9f894b-f505-7bce-bda7-6e51b7583ef3</id><thr:in-reply-to
ref="urn:uuid:3815ac3e-3827-4a73-5397-ac5f4a5a1270"
href="http://lore.kernel.org/amd-gfx/20240618063359.304293-1-YiPeng.Chai@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">In order to apply to the case where a large number
of ras poison interrupts:
1. Change to use variable to record poison creation
   requests to avoid fifo full.
2. Prioritize handling poison creation requests
   instead of following the order of requests
   received by the driver.

Signed-off-by: YiPeng Chai &lt;YiPeng.Chai@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c | 41 ++++++++++++-------------
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h |  1 +
 2 files <a href="http://lore.kernel.org/amd-gfx/20240618063359.304293-2-YiPeng.Chai@amd.com/#related">changed</a>, 21 insertions(+), 21 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
index ec8e848122f9..13cd6a9234f2 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
</span><span
class="hunk">@@ -2093,10 +2093,8 @@ static void amdgpu_ras_interrupt_poison_creation_handler(struct ras_manager *obj
</span> 	if (amdgpu_ip_version(obj-&gt;adev, UMC_HWIP, 0) &gt;= IP_VERSION(12, 0, 0)) {
 		struct amdgpu_ras *con = amdgpu_ras_get_context(obj-&gt;adev);
 
<span
class="del">-		amdgpu_ras_put_poison_req(obj-&gt;adev,
-			AMDGPU_RAS_BLOCK__UMC, 0, NULL, NULL, false);
-
</span> 		atomic_inc(&#38;con-&gt;page_retirement_req_cnt);
<span
class="add">+		atomic_inc(&#38;con-&gt;poison_creation_count);
</span> 
 		wake_up(&#38;con-&gt;page_retirement_wq);
 	}
<span
class="hunk">@@ -2873,7 +2871,7 @@ static int amdgpu_ras_poison_creation_handler(struct amdgpu_device *adev,
</span> 	if (query_data_timeout) {
 		dev_warn(adev-&gt;dev, &#34;Can&#39;t find deferred error! count: %u\n&#34;,
 			(need_query_count - total_detect_count));
<span
class="del">-		return 0;
</span><span
class="add">+		return -ENOENT;
</span> 	}
 
 	if (total_detect_count)
<span
class="hunk">@@ -2908,6 +2906,8 @@ static int amdgpu_ras_page_retirement_thread(void *param)
</span> {
 	struct amdgpu_device *adev = (struct amdgpu_device *)param;
 	struct amdgpu_ras *con = amdgpu_ras_get_context(adev);
<span
class="add">+	uint32_t poison_creation_count;
+	int ret;
</span> 	struct ras_poison_msg poison_msg;
 	enum amdgpu_ras_block ras_block;
 	bool poison_creation_is_handled = false;
<span
class="hunk">@@ -2921,7 +2921,20 @@ static int amdgpu_ras_page_retirement_thread(void *param)
</span> 		if (kthread_should_stop())
 			break;
 
<span
class="del">-		atomic_dec(&#38;con-&gt;page_retirement_req_cnt);
</span><span
class="add">+
+		do {
+			poison_creation_count = atomic_read(&#38;con-&gt;poison_creation_count);
+			ret = amdgpu_ras_poison_creation_handler(adev, poison_creation_count);
+			if (ret == -EIO)
+				break;
+
+			if (poison_creation_count) {
+				while (poison_creation_count--) {
+					atomic_dec(&#38;con-&gt;poison_creation_count);
+					atomic_dec(&#38;con-&gt;page_retirement_req_cnt);
+				}
+			}
+		} while (atomic_read(&#38;con-&gt;poison_creation_count));
</span> 
 #ifdef HAVE_KFIFO_PUT_NON_POINTER
 		if (!amdgpu_ras_get_poison_req(adev, &#38;poison_msg))
<span
class="hunk">@@ -2932,24 +2945,8 @@ static int amdgpu_ras_page_retirement_thread(void *param)
</span> 		dev_dbg(adev-&gt;dev, &#34;Start processing ras block %s(%d)\n&#34;,
 				ras_block_str(ras_block), ras_block);
 
<span
class="del">-		if (ras_block == AMDGPU_RAS_BLOCK__UMC) {
-			amdgpu_ras_poison_creation_handler(adev,
-				MAX_UMC_POISON_POLLING_TIME_ASYNC);
-			poison_creation_is_handled = true;
-		} else {
-			/* poison_creation_is_handled:
-			 *   false: no poison creation interrupt, but it has poison
-			 *          consumption interrupt.
-			 *   true: It has poison creation interrupt at the beginning,
-			 *         but it has no poison creation interrupt later.
-			 */
-			amdgpu_ras_poison_creation_handler(adev,
-					poison_creation_is_handled ?
-					0 : MAX_UMC_POISON_POLLING_TIME_ASYNC);
</span> 
 			amdgpu_ras_poison_consumption_handler(adev, &#38;poison_msg);
<span
class="del">-			poison_creation_is_handled = false;
-		}
</span> #else
         dev_info(adev-&gt;dev, &#34;Start processing page retirement. request:%d\n&#34;,
                     atomic_read(&#38;con-&gt;page_retirement_req_cnt));
<span
class="hunk">@@ -3029,6 +3026,7 @@ int amdgpu_ras_recovery_init(struct amdgpu_device *adev)
</span> 	mutex_init(&#38;con-&gt;page_retirement_lock);
 	init_waitqueue_head(&#38;con-&gt;page_retirement_wq);
 	atomic_set(&#38;con-&gt;page_retirement_req_cnt, 0);
<span
class="add">+	atomic_set(&#38;con-&gt;poison_creation_count, 0);
</span> 	con-&gt;page_retirement_thread =
 		kthread_run(amdgpu_ras_page_retirement_thread, adev, &#34;umc_page_retirement&#34;);
 	if (IS_ERR(con-&gt;page_retirement_thread)) {
<span
class="hunk">@@ -3080,6 +3078,7 @@ static int amdgpu_ras_recovery_fini(struct amdgpu_device *adev)
</span> 		kthread_stop(con-&gt;page_retirement_thread);
 
 	atomic_set(&#38;con-&gt;page_retirement_req_cnt, 0);
<span
class="add">+	atomic_set(&#38;con-&gt;poison_creation_count, 0);
</span> 
 	mutex_destroy(&#38;con-&gt;page_rsv_lock);
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
index c50f5f2b1f4f..91daf48be03a 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
</span><span
class="hunk">@@ -532,6 +532,7 @@ struct amdgpu_ras {
</span> 	wait_queue_head_t page_retirement_wq;
 	struct mutex page_retirement_lock;
 	atomic_t page_retirement_req_cnt;
<span
class="add">+	atomic_t poison_creation_count;
</span> 	struct mutex page_rsv_lock;
 	DECLARE_KFIFO(poison_fifo, struct ras_poison_msg, 128);
 	struct ras_ecc_log_info  umc_ecc_log;
-- 
2.34.1

</pre></div></content></entry><entry><author><name>YiPeng Chai</name><email>YiPeng.Chai@amd.com</email></author><title>[PATCH 1/5] drm/amdgpu: add variable to record the deferred error number read by driver</title><updated>2024-06-18T06:34:36Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618063359.304293-1-YiPeng.Chai@amd.com/"/><id>urn:uuid:3815ac3e-3827-4a73-5397-ac5f4a5a1270</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Add variable to record the deferred error
number read by driver.

Signed-off-by: YiPeng Chai &lt;YiPeng.Chai@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c | 62 ++++++++++++++++++-------
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h |  3 +-
 drivers/gpu/drm/amd/amdgpu/umc_v12_0.c  |  4 +-
 3 files <a href="http://lore.kernel.org/amd-gfx/20240618063359.304293-1-YiPeng.Chai@amd.com/#related">changed</a>, 48 insertions(+), 21 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
index d0dcd3d37e6d..ec8e848122f9 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
</span><span
class="hunk">@@ -120,7 +120,7 @@ const char *get_ras_block_str(struct ras_common_if *ras_block)
</span> /* typical ECC bad page rate is 1 bad page per 100MB VRAM */
 #define RAS_BAD_PAGE_COVER              (100 * 1024 * 1024ULL)
 
<span
class="del">-#define MAX_UMC_POISON_POLLING_TIME_ASYNC  100  //ms
</span><span
class="add">+#define MAX_UMC_POISON_POLLING_TIME_ASYNC  300  //ms
</span> 
 #define AMDGPU_RAS_RETIRE_PAGE_INTERVAL 100  //ms
 
<span
class="hunk">@@ -2773,7 +2773,8 @@ static void amdgpu_ras_ecc_log_init(struct ras_ecc_log_info *ecc_log)
</span> 	memset(&#38;ecc_log-&gt;ecc_key, 0xad, sizeof(ecc_log-&gt;ecc_key));
 
 	INIT_RADIX_TREE(&#38;ecc_log-&gt;de_page_tree, GFP_KERNEL);
<span
class="del">-	ecc_log-&gt;de_updated = false;
</span><span
class="add">+	ecc_log-&gt;de_queried_count = 0;
+	ecc_log-&gt;prev_de_queried_count = 0;
</span> }
 
 static void amdgpu_ras_ecc_log_fini(struct ras_ecc_log_info *ecc_log)
<span
class="hunk">@@ -2792,7 +2793,8 @@ static void amdgpu_ras_ecc_log_fini(struct ras_ecc_log_info *ecc_log)
</span> 	mutex_unlock(&#38;ecc_log-&gt;lock);
 
 	mutex_destroy(&#38;ecc_log-&gt;lock);
<span
class="del">-	ecc_log-&gt;de_updated = false;
</span><span
class="add">+	ecc_log-&gt;de_queried_count = 0;
+	ecc_log-&gt;prev_de_queried_count = 0;
</span> }
 #endif
 
<span
class="hunk">@@ -2820,40 +2822,64 @@ static void amdgpu_ras_do_page_retirement(struct work_struct *work)
</span> 	mutex_unlock(&#38;con-&gt;umc_ecc_log.lock);
 }
 
<span
class="del">-static void amdgpu_ras_poison_creation_handler(struct amdgpu_device *adev,
-				uint32_t timeout_ms)
</span><span
class="add">+static int amdgpu_ras_poison_creation_handler(struct amdgpu_device *adev,
+				uint32_t poison_creation_count)
</span> {
 	int ret = 0;
 	struct ras_ecc_log_info *ecc_log;
 	struct ras_query_if info;
<span
class="del">-	uint32_t timeout = timeout_ms;
</span><span
class="add">+	uint32_t timeout = 0;
</span> 	struct amdgpu_ras *ras = amdgpu_ras_get_context(adev);
<span
class="add">+	uint64_t de_queried_count;
+	uint32_t new_detect_count, total_detect_count;
+	uint32_t need_query_count = poison_creation_count;
+	bool query_data_timeout = false;
</span> 
 	memset(&#38;info, 0, sizeof(info));
 	info.head.block = AMDGPU_RAS_BLOCK__UMC;
 
 	ecc_log = &#38;ras-&gt;umc_ecc_log;
<span
class="del">-	ecc_log-&gt;de_updated = false;
</span><span
class="add">+	total_detect_count = 0;
</span> 	do {
 		ret = amdgpu_ras_query_error_status(adev, &#38;info);
<span
class="del">-		if (ret) {
-			dev_err(adev-&gt;dev, &#34;Failed to query ras error! ret:%d\n&#34;, ret);
-			return;
</span><span
class="add">+		if (ret)
+			return ret;
+
+		de_queried_count = ecc_log-&gt;de_queried_count;
+		if (de_queried_count &gt; ecc_log-&gt;prev_de_queried_count) {
+			new_detect_count = de_queried_count - ecc_log-&gt;prev_de_queried_count;
+			ecc_log-&gt;prev_de_queried_count = de_queried_count;
+			timeout = 0;
+		} else {
+			new_detect_count = 0;
</span> 		}
 
<span
class="del">-		if (timeout &#38;&#38; !ecc_log-&gt;de_updated) {
-			msleep(1);
-			timeout--;
</span><span
class="add">+		if (new_detect_count) {
+			total_detect_count += new_detect_count;
+		} else {
+			if (!timeout &#38;&#38; need_query_count)
+				timeout = MAX_UMC_POISON_POLLING_TIME_ASYNC;
+
+			if (timeout) {
+				if (!--timeout) {
+					query_data_timeout = true;
+					break;
+				}
+				msleep(1);
+			}
</span> 		}
<span
class="del">-	} while (timeout &#38;&#38; !ecc_log-&gt;de_updated);
</span><span
class="add">+	} while (total_detect_count &lt; need_query_count);
</span> 
<span
class="del">-	if (timeout_ms &#38;&#38; !timeout) {
-		dev_warn(adev-&gt;dev, &#34;Can&#39;t find deferred error\n&#34;);
-		return;
</span><span
class="add">+	if (query_data_timeout) {
+		dev_warn(adev-&gt;dev, &#34;Can&#39;t find deferred error! count: %u\n&#34;,
+			(need_query_count - total_detect_count));
+		return 0;
</span> 	}
 
<span
class="del">-	if (!ret)
</span><span
class="add">+	if (total_detect_count)
</span> 		schedule_delayed_work(&#38;ras-&gt;page_retirement_dwork, 0);
<span
class="add">+
+	return 0;
</span> }
 
 static int amdgpu_ras_poison_consumption_handler(struct amdgpu_device *adev,
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
index e70c45712ddb..c50f5f2b1f4f 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
</span><span
class="hunk">@@ -469,7 +469,8 @@ struct ras_ecc_log_info {
</span> 	struct mutex lock;
 	siphash_key_t ecc_key;
 	struct radix_tree_root de_page_tree;
<span
class="del">-	bool	de_updated;
</span><span
class="add">+	uint64_t	de_queried_count;
+	uint64_t	prev_de_queried_count;
</span> };
 
 struct amdgpu_ras {
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/umc_v12_0.c b/drivers/gpu/drm/amd/amdgpu/umc_v12_0.c
index 6d6350f220b0..0faa21d8a7b4 100644
--- a/drivers/gpu/drm/amd/amdgpu/umc_v12_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/umc_v12_0.c
</span><span
class="hunk">@@ -557,7 +557,7 @@ static int umc_v12_0_update_ecc_status(struct amdgpu_device *adev,
</span> 	ret = amdgpu_umc_logs_ecc_err(adev, &#38;con-&gt;umc_ecc_log.de_page_tree, ecc_err);
 	if (ret) {
 		if (ret == -EEXIST)
<span
class="del">-			con-&gt;umc_ecc_log.de_updated = true;
</span><span
class="add">+			con-&gt;umc_ecc_log.de_queried_count++;
</span> 		else
 			dev_err(adev-&gt;dev, &#34;Fail to log ecc error! ret:%d\n&#34;, ret);
 
<span
class="hunk">@@ -566,7 +566,7 @@ static int umc_v12_0_update_ecc_status(struct amdgpu_device *adev,
</span> 		return ret;
 	}
 
<span
class="del">-	con-&gt;umc_ecc_log.de_updated = true;
</span><span
class="add">+	con-&gt;umc_ecc_log.de_queried_count++;
</span> 
 	return 0;
 }
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v7 9/9] drm/amdgpu: Make it possible to async flip overlay planes</title><updated>2024-06-18T03:01:52Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618030024.500532-10-andrealmeid@igalia.com/"/><id>urn:uuid:b0dae4e6-69ec-915c-b950-8fe04535f238</id><thr:in-reply-to
ref="urn:uuid:f08b8c6a-8a39-8a8c-40ca-9964220814dc"
href="http://lore.kernel.org/amd-gfx/20240618030024.500532-1-andrealmeid@igalia.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">amdgpu can handle async flips on overlay planes, so mark it as true
during the plane initialization.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c | 1 +
 1 file <a href="http://lore.kernel.org/amd-gfx/20240618030024.500532-10-andrealmeid@igalia.com/#related">changed</a>, 1 insertion(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
index 0c126c5609d3..7d508d816f0d 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
</span><span
class="hunk">@@ -1709,6 +1709,7 @@ int amdgpu_dm_plane_init(struct amdgpu_display_manager *dm,
</span> 	} else if (plane-&gt;type == DRM_PLANE_TYPE_OVERLAY) {
 		unsigned int zpos = 1 + drm_plane_index(plane);
 		drm_plane_create_zpos_property(plane, zpos, 1, 254);
<span
class="add">+		plane-&gt;async_flip = true;
</span> 	} else if (plane-&gt;type == DRM_PLANE_TYPE_CURSOR) {
 		drm_plane_create_zpos_immutable_property(plane, 255);
 	}
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v7 8/9] drm: Enable per-plane async flip check</title><updated>2024-06-18T03:01:45Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618030024.500532-9-andrealmeid@igalia.com/"/><id>urn:uuid:506dcd8f-b983-fe43-5553-eaee0586c451</id><thr:in-reply-to
ref="urn:uuid:f08b8c6a-8a39-8a8c-40ca-9964220814dc"
href="http://lore.kernel.org/amd-gfx/20240618030024.500532-1-andrealmeid@igalia.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Replace the generic &#34;is this plane primary&#34; for a plane::async_flip
check, so DRM follows the plane restrictions set by the driver.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---
 drivers/gpu/drm/drm_atomic_uapi.c | 4 ++--
 1 file <a href="http://lore.kernel.org/amd-gfx/20240618030024.500532-9-andrealmeid@igalia.com/#related">changed</a>, 2 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/drm_atomic_uapi.c b/drivers/gpu/drm/drm_atomic_uapi.c
index 2e1d9391febe..ed1af3455477 100644
--- a/drivers/gpu/drm/drm_atomic_uapi.c
+++ b/drivers/gpu/drm/drm_atomic_uapi.c
</span><span
class="hunk">@@ -1079,9 +1079,9 @@ int drm_atomic_set_property(struct drm_atomic_state *state,
</span> 			break;
 		}
 
<span
class="del">-		if (async_flip &#38;&#38; plane_state-&gt;plane-&gt;type != DRM_PLANE_TYPE_PRIMARY) {
</span><span
class="add">+		if (async_flip &#38;&#38; !plane-&gt;async_flip) {
</span> 			drm_dbg_atomic(prop-&gt;dev,
<span
class="del">-				       &#34;[OBJECT:%d] Only primary planes can be changed during async flip\n&#34;,
</span><span
class="add">+				       &#34;[PLANE:%d] does not support async flips\n&#34;,
</span> 				       obj-&gt;id);
 			ret = -EINVAL;
 			break;
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v7 7/9] drm/vc4: Enable async flips on the primary plane</title><updated>2024-06-18T03:01:36Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618030024.500532-8-andrealmeid@igalia.com/"/><id>urn:uuid:c703a4ef-608c-8dd8-b5c5-868935aee168</id><thr:in-reply-to
ref="urn:uuid:f08b8c6a-8a39-8a8c-40ca-9964220814dc"
href="http://lore.kernel.org/amd-gfx/20240618030024.500532-1-andrealmeid@igalia.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This driver can perfom async flips on primary planes, so enable it.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---
 drivers/gpu/drm/vc4/vc4_plane.c | 4 +++-
 1 file <a href="http://lore.kernel.org/amd-gfx/20240618030024.500532-8-andrealmeid@igalia.com/#related">changed</a>, 3 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/vc4/vc4_plane.c b/drivers/gpu/drm/vc4/vc4_plane.c
index 07caf2a47c6c..e3d41da14e6f 100644
--- a/drivers/gpu/drm/vc4/vc4_plane.c
+++ b/drivers/gpu/drm/vc4/vc4_plane.c
</span><span
class="hunk">@@ -1672,8 +1672,10 @@ struct drm_plane *vc4_plane_init(struct drm_device *dev,
</span> 					  DRM_COLOR_YCBCR_BT709,
 					  DRM_COLOR_YCBCR_LIMITED_RANGE);
 
<span
class="del">-	if (type == DRM_PLANE_TYPE_PRIMARY)
</span><span
class="add">+	if (type == DRM_PLANE_TYPE_PRIMARY) {
</span> 		drm_plane_create_zpos_immutable_property(plane, 0);
<span
class="add">+		plane-&gt;async_flip = true;
+	}
</span> 
 	return plane;
 }
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v7 6/9] drm/nouveau: Enable async flips on the primary plane</title><updated>2024-06-18T03:01:28Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618030024.500532-7-andrealmeid@igalia.com/"/><id>urn:uuid:05c55a7c-e323-03e6-5817-c102c614b2cd</id><thr:in-reply-to
ref="urn:uuid:f08b8c6a-8a39-8a8c-40ca-9964220814dc"
href="http://lore.kernel.org/amd-gfx/20240618030024.500532-1-andrealmeid@igalia.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This driver can perfom async flips on primary planes, so enable it.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---
 drivers/gpu/drm/nouveau/dispnv04/crtc.c | 4 ++++
 drivers/gpu/drm/nouveau/dispnv50/wndw.c | 4 ++++
 2 files <a href="http://lore.kernel.org/amd-gfx/20240618030024.500532-7-andrealmeid@igalia.com/#related">changed</a>, 8 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/nouveau/dispnv04/crtc.c b/drivers/gpu/drm/nouveau/dispnv04/crtc.c
index 4310ad71870b..fd06d46d49ec 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/crtc.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/crtc.c
</span><span
class="hunk">@@ -1285,6 +1285,7 @@ int
</span> nv04_crtc_create(struct drm_device *dev, int crtc_num)
 {
 	struct nouveau_display *disp = nouveau_display(dev);
<span
class="add">+	struct nouveau_drm *drm = nouveau_drm(dev);
</span> 	struct nouveau_crtc *nv_crtc;
 	struct drm_plane *primary;
 	int ret;
<span
class="hunk">@@ -1338,6 +1339,9 @@ nv04_crtc_create(struct drm_device *dev, int crtc_num)
</span> 	if (ret)
 		return ret;
 
<span
class="add">+	if (drm-&gt;client.device.info.chipset &gt;= 0x11)
+		primary-&gt;async_flip = true;
+
</span> 	return nvif_head_vblank_event_ctor(&#38;nv_crtc-&gt;head, &#34;kmsVbl&#34;, nv04_crtc_vblank_handler,
 					   false, &#38;nv_crtc-&gt;vblank);
 }
<span
class="head">diff --git a/drivers/gpu/drm/nouveau/dispnv50/wndw.c b/drivers/gpu/drm/nouveau/dispnv50/wndw.c
index 7a2cceaee6e9..55db0fdf61e7 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/wndw.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/wndw.c
</span><span
class="hunk">@@ -763,6 +763,10 @@ nv50_wndw_new_(const struct nv50_wndw_func *func, struct drm_device *dev,
</span> 			return ret;
 	}
 
<span
class="add">+	if (type == DRM_PLANE_TYPE_PRIMARY &#38;&#38;
+	    drm-&gt;client.device.info.chipset &gt;= 0x11)
+		wndw-&gt;plane.async_flip = true;
+
</span> 	return 0;
 }
 
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v7 5/9] drm/i915: Enable async flips on the primary plane</title><updated>2024-06-18T03:01:20Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618030024.500532-6-andrealmeid@igalia.com/"/><id>urn:uuid:0d2042a2-a2be-1b4a-a0aa-7f04123f9f5d</id><thr:in-reply-to
ref="urn:uuid:f08b8c6a-8a39-8a8c-40ca-9964220814dc"
href="http://lore.kernel.org/amd-gfx/20240618030024.500532-1-andrealmeid@igalia.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This driver can perfom async flips on primary planes, so enable it.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---
 drivers/gpu/drm/i915/display/i9xx_plane.c          | 3 +++
 drivers/gpu/drm/i915/display/skl_universal_plane.c | 1 +
 2 files <a href="http://lore.kernel.org/amd-gfx/20240618030024.500532-6-andrealmeid@igalia.com/#related">changed</a>, 4 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/i915/display/i9xx_plane.c b/drivers/gpu/drm/i915/display/i9xx_plane.c
index 0279c8aabdd1..0142beef20dc 100644
--- a/drivers/gpu/drm/i915/display/i9xx_plane.c
+++ b/drivers/gpu/drm/i915/display/i9xx_plane.c
</span><span
class="hunk">@@ -931,6 +931,9 @@ intel_primary_plane_create(struct drm_i915_private *dev_priv, enum pipe pipe)
</span> 
 	intel_plane_helper_add(plane);
 
<span
class="add">+	if (plane-&gt;async_flip)
+		plane-&gt;base.async_flip = true;
+
</span> 	return plane;
 
 fail:
<span
class="head">diff --git a/drivers/gpu/drm/i915/display/skl_universal_plane.c b/drivers/gpu/drm/i915/display/skl_universal_plane.c
index 860574d04f88..8d0a9f69709a 100644
--- a/drivers/gpu/drm/i915/display/skl_universal_plane.c
+++ b/drivers/gpu/drm/i915/display/skl_universal_plane.c
</span><span
class="hunk">@@ -2371,6 +2371,7 @@ skl_universal_plane_create(struct drm_i915_private *dev_priv,
</span> 		plane-&gt;async_flip = skl_plane_async_flip;
 		plane-&gt;enable_flip_done = skl_plane_enable_flip_done;
 		plane-&gt;disable_flip_done = skl_plane_disable_flip_done;
<span
class="add">+		plane-&gt;base.async_flip = true;
</span> 	}
 
 	if (DISPLAY_VER(dev_priv) &gt;= 11)
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v7 4/9] drm: atmel-hlcdc: Enable async flips on the primary plane</title><updated>2024-06-18T03:01:11Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618030024.500532-5-andrealmeid@igalia.com/"/><id>urn:uuid:ff2ba109-86cd-97b6-0baa-9316ea86a0a6</id><thr:in-reply-to
ref="urn:uuid:f08b8c6a-8a39-8a8c-40ca-9964220814dc"
href="http://lore.kernel.org/amd-gfx/20240618030024.500532-1-andrealmeid@igalia.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This driver can perfom async flips on primary planes, so enable it.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---
 drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_plane.c | 3 +++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240618030024.500532-5-andrealmeid@igalia.com/#related">changed</a>, 3 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_plane.c b/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_plane.c
index 4a7ba0918eca..22b8a5c888ef 100644
--- a/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_plane.c
+++ b/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_plane.c
</span><span
class="hunk">@@ -1227,6 +1227,9 @@ static int atmel_hlcdc_plane_create(struct drm_device *dev,
</span> 	if (ret)
 		return ret;
 
<span
class="add">+	if (type == DRM_PLANE_TYPE_PRIMARY)
+		plane-&gt;base.async_flip = true;
+
</span> 	drm_plane_helper_add(&#38;plane-&gt;base,
 			     &#38;atmel_hlcdc_layer_plane_helper_funcs);
 
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v7 3/9] drm/amdgpu: Enable async flips on the primary plane</title><updated>2024-06-18T03:01:09Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618030024.500532-4-andrealmeid@igalia.com/"/><id>urn:uuid:8ab2ff06-4596-a055-b54a-f84ee1a41d6f</id><thr:in-reply-to
ref="urn:uuid:f08b8c6a-8a39-8a8c-40ca-9964220814dc"
href="http://lore.kernel.org/amd-gfx/20240618030024.500532-1-andrealmeid@igalia.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This driver can perfom async flips on primary planes, so enable it.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c | 1 +
 1 file <a href="http://lore.kernel.org/amd-gfx/20240618030024.500532-4-andrealmeid@igalia.com/#related">changed</a>, 1 insertion(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
index 8a4c40b4c27e..0c126c5609d3 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
</span><span
class="hunk">@@ -1705,6 +1705,7 @@ int amdgpu_dm_plane_init(struct amdgpu_display_manager *dm,
</span> 
 	if (plane-&gt;type == DRM_PLANE_TYPE_PRIMARY) {
 		drm_plane_create_zpos_immutable_property(plane, 0);
<span
class="add">+		plane-&gt;async_flip = true;
</span> 	} else if (plane-&gt;type == DRM_PLANE_TYPE_OVERLAY) {
 		unsigned int zpos = 1 + drm_plane_index(plane);
 		drm_plane_create_zpos_property(plane, zpos, 1, 254);
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v7 2/9] drm: Support per-plane async flip configuration</title><updated>2024-06-18T03:01:07Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618030024.500532-3-andrealmeid@igalia.com/"/><id>urn:uuid:84502f8a-c2cc-0eb7-967c-36f22d7f92b1</id><thr:in-reply-to
ref="urn:uuid:f08b8c6a-8a39-8a8c-40ca-9964220814dc"
href="http://lore.kernel.org/amd-gfx/20240618030024.500532-1-andrealmeid@igalia.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Drivers have different capabilities on what plane types they can or
cannot perform async flips. Create a plane::async_flip field so each
driver can choose which planes they allow doing async flips.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---
 include/drm/drm_plane.h | 5 +++++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240618030024.500532-3-andrealmeid@igalia.com/#related">changed</a>, 5 insertions(+)

<span
class="head">diff --git a/include/drm/drm_plane.h b/include/drm/drm_plane.h
index 9507542121fa..0bebc72af5c3 100644
--- a/include/drm/drm_plane.h
+++ b/include/drm/drm_plane.h
</span><span
class="hunk">@@ -786,6 +786,11 @@ struct drm_plane {
</span> 	 * @kmsg_panic: Used to register a panic notifier for this plane
 	 */
 	struct kmsg_dumper kmsg_panic;
<span
class="add">+
+	/**
+	 * @async_flip: indicates if a plane can do async flips
+	 */
+	bool async_flip;
</span> };
 
 #define obj_to_plane(x) container_of(x, struct drm_plane, base)
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v7 1/9] drm/atomic: Allow userspace to use explicit sync with atomic async flips</title><updated>2024-06-18T03:00:58Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618030024.500532-2-andrealmeid@igalia.com/"/><id>urn:uuid:b0354a44-80f0-671a-74b4-126c9fef490d</id><thr:in-reply-to
ref="urn:uuid:f08b8c6a-8a39-8a8c-40ca-9964220814dc"
href="http://lore.kernel.org/amd-gfx/20240618030024.500532-1-andrealmeid@igalia.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Allow userspace to use explicit synchronization with atomic async flips.
That means that the flip will wait for some hardware fence, and then
will flip as soon as possible (async) in regard of the vblank.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---
 drivers/gpu/drm/drm_atomic_uapi.c | 4 +++-
 1 file <a href="http://lore.kernel.org/amd-gfx/20240618030024.500532-2-andrealmeid@igalia.com/#related">changed</a>, 3 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/drm_atomic_uapi.c b/drivers/gpu/drm/drm_atomic_uapi.c
index 22bbb2d83e30..2e1d9391febe 100644
--- a/drivers/gpu/drm/drm_atomic_uapi.c
+++ b/drivers/gpu/drm/drm_atomic_uapi.c
</span><span
class="hunk">@@ -1070,7 +1070,9 @@ int drm_atomic_set_property(struct drm_atomic_state *state,
</span> 			break;
 		}
 
<span
class="del">-		if (async_flip &#38;&#38; prop != config-&gt;prop_fb_id) {
</span><span
class="add">+		if (async_flip &#38;&#38;
+		    prop != config-&gt;prop_fb_id &#38;&#38;
+		    prop != config-&gt;prop_in_fence_fd) {
</span> 			ret = drm_atomic_plane_get_property(plane, plane_state,
 							    prop, &#38;old_val);
 			ret = drm_atomic_check_prop_changes(ret, old_val, prop_value, prop);
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v7 0/9] drm: Support per-plane async flip configuration</title><updated>2024-06-18T03:00:53Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240618030024.500532-1-andrealmeid@igalia.com/"/><id>urn:uuid:f08b8c6a-8a39-8a8c-40ca-9964220814dc</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">AMD hardware can do async flips with overlay planes, but currently there&#39;s no
easy way to enable that in DRM. To solve that, this patchset creates a new
drm_plane field, bool async_flip, that allows drivers to choose which plane can
or cannot do async flips. This is latter used on drm_atomic_set_property when
users want to do async flips.

Patch 1 allows async commits with IN_FENCE_ID in any driver.

Patches 2 to 7 have no functional change. As per current code, every driver that
allows async page flips using the atomic API, allows doing it only in the
primary plane. Those patches then enable it for every driver.

Every driver that I found out capable of doing async flips were changed here.
The drivers that weren&#39;t touch don&#39;t have any mention to
mode_config::async_page_flip, so they are not currently advertising to userspace
that they can do async flips.

Patch 8 changes the current DRM uAPI check from allowing only primary planes to
allowing any plane that the driver allows flipping asynchronously.

Patch 9 finally enables async flip on overlay planes for amdgpu.

Changes from v6:
- Added async_flip check for i915/skl planes (Rodrigo)
- Commit the plane-&gt;async_flip check just after all driver had set their
async_flip capabilities (Dmitry)
<a
href="https://lore.kernel.org/dri-devel/20240614153535.351689-1-andrealmeid@igalia.com/">https://lore.kernel.org/dri-devel/20240614153535.351689-1-andrealmeid@igalia.com/</a>

Changes from v5:
- Instead of enabling plane-&gt;async_flip in the common code, move it to driver
code.
- Enable primary plane async flip on every driver
<a
href="https://lore.kernel.org/dri-devel/20240612193713.167448-1-andrealmeid@igalia.com/">https://lore.kernel.org/dri-devel/20240612193713.167448-1-andrealmeid@igalia.com/</a>

Andr&#233; Almeida (9):
  drm/atomic: Allow userspace to use explicit sync with atomic async
    flips
  drm: Support per-plane async flip configuration
  drm/amdgpu: Enable async flips on the primary plane
  drm: atmel-hlcdc: Enable async flips on the primary plane
  drm/i915: Enable async flips on the primary plane
  drm/nouveau: Enable async flips on the primary plane
  drm/vc4: Enable async flips on the primary plane
  drm: Enable per-plane async flip check
  drm/amdgpu: Make it possible to async flip overlay planes

 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c | 2 ++
 drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_plane.c         | 3 +++
 drivers/gpu/drm/drm_atomic_uapi.c                       | 8 +++++---
 drivers/gpu/drm/i915/display/i9xx_plane.c               | 3 +++
 drivers/gpu/drm/i915/display/skl_universal_plane.c      | 1 +
 drivers/gpu/drm/nouveau/dispnv04/crtc.c                 | 4 ++++
 drivers/gpu/drm/nouveau/dispnv50/wndw.c                 | 4 ++++
 drivers/gpu/drm/vc4/vc4_plane.c                         | 4 +++-
 include/drm/drm_plane.h                                 | 5 +++++
 9 files changed, 30 insertions(+), 4 deletions(-)

-- 
2.45.2

</pre></div></content></entry><entry><author><name>Aurabindo Pillai</name><email>aurabindo.pillai@amd.com</email></author><title>[PATCH 1/2] drm/amd: Add reg definitions for DCN401 DCC</title><updated>2024-06-17T22:14:42Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240617221426.3136257-1-aurabindo.pillai@amd.com/"/><id>urn:uuid:01e5cbd9-b303-3750-82c5-f794468de64d</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Add the necessary register definitions to enable DCC on DCN4x

Signed-off-by: Aurabindo Pillai &lt;aurabindo.pillai@amd.com&gt;
---
 .../include/asic_reg/dcn/dcn_4_1_0_sh_mask.h  | 110 ++++++++++++++++++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240617221426.3136257-1-aurabindo.pillai@amd.com/#related">changed</a>, 110 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/include/asic_reg/dcn/dcn_4_1_0_sh_mask.h b/drivers/gpu/drm/amd/include/asic_reg/dcn/dcn_4_1_0_sh_mask.h
index 0c68f5d818bb..f42a276499cd 100644
--- a/drivers/gpu/drm/amd/include/asic_reg/dcn/dcn_4_1_0_sh_mask.h
+++ b/drivers/gpu/drm/amd/include/asic_reg/dcn/dcn_4_1_0_sh_mask.h
</span><span
class="hunk">@@ -6430,6 +6430,28 @@
</span> //DCHUBBUB_SDPIF_MEM_PWR_STATUS
 #define DCHUBBUB_SDPIF_MEM_PWR_STATUS__DCHUBBUB_SDPIF_MEM_PWR_STATE__SHIFT                                    0x0
 #define DCHUBBUB_SDPIF_MEM_PWR_STATUS__DCHUBBUB_SDPIF_MEM_PWR_STATE_MASK                                      0x00000003L
<span
class="add">+//DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_FLIP_AWAY_MISSING_PIPE0__SHIFT                 0x0
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_FLIP_AWAY_MISSING_PIPE1__SHIFT                 0x1
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_FLIP_AWAY_MISSING_PIPE2__SHIFT                 0x2
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_FLIP_AWAY_MISSING_PIPE3__SHIFT                 0x3
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_ERR_CLEAR_PIPE0__SHIFT            0xc
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_ERR_CLEAR_PIPE1__SHIFT            0xd
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_ERR_CLEAR_PIPE2__SHIFT            0xe
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_ERR_CLEAR_PIPE3__SHIFT            0xf
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_ERR_ENABLE__SHIFT                 0x1c
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_VREADY_MODE__SHIFT                0x1f
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_FLIP_AWAY_MISSING_PIPE0_MASK                   0x00000001L
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_FLIP_AWAY_MISSING_PIPE1_MASK                   0x00000002L
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_FLIP_AWAY_MISSING_PIPE2_MASK                   0x00000004L
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_FLIP_AWAY_MISSING_PIPE3_MASK                   0x00000008L
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_ERR_CLEAR_PIPE0_MASK              0x00001000L
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_ERR_CLEAR_PIPE1_MASK              0x00002000L
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_ERR_CLEAR_PIPE2_MASK              0x00004000L
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_ERR_CLEAR_PIPE3_MASK              0x00008000L
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_ERR_ENABLE_MASK                   0x10000000L
+#define DCHUBBUB_SDPIF_MCACHE_INVALIDATION_CTL__DCHUBBUB_SDPIF_MCACHEID_INV_VREADY_MODE_MASK                  0x80000000L
+
</span> 
 
 // addressBlock: dcn_dcec_dchubbubl_hubbub_ret_path_dispdec
<span
class="hunk">@@ -7084,6 +7106,11 @@
</span> #define HUBP0_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_Y_START__SHIFT                                          0x10
 #define HUBP0_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_X_START_MASK                                            0x0000FFFFL
 #define HUBP0_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_Y_START_MASK                                            0xFFFF0000L
<span
class="add">+//HUBP0_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE
+#define HUBP0_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE__SHIFT                0x0
+#define HUBP0_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_C__SHIFT              0x10
+#define HUBP0_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_MASK                  0x0000FFFFL
+#define HUBP0_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_C_MASK                0xFFFF0000L
</span> //HUBP0_DCSURF_PRI_VIEWPORT_DIMENSION
 #define HUBP0_DCSURF_PRI_VIEWPORT_DIMENSION__PRI_VIEWPORT_WIDTH__SHIFT                                        0x0
 #define HUBP0_DCSURF_PRI_VIEWPORT_DIMENSION__PRI_VIEWPORT_HEIGHT__SHIFT                                       0x10
<span
class="hunk">@@ -7244,6 +7271,23 @@
</span> #define HUBP0_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_NEXT_S1__SHIFT                                               0xc
 #define HUBP0_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_CURR_S1_MASK                                                 0x00000FFFL
 #define HUBP0_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_NEXT_S1_MASK                                                 0x00FFF000L
<span
class="add">+//HUBP0_DCHUBP_MCACHEID_CONFIG
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P0__SHIFT                                          0x0
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P0__SHIFT                                          0x4
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P1__SHIFT                                          0x8
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P1__SHIFT                                          0xc
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P0__SHIFT                                         0x10
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P0__SHIFT                                         0x14
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P1__SHIFT                                         0x18
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P1__SHIFT                                         0x1c
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P0_MASK                                            0x0000000FL
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P0_MASK                                            0x000000F0L
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P1_MASK                                            0x00000F00L
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P1_MASK                                            0x0000F000L
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P0_MASK                                           0x000F0000L
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P0_MASK                                           0x00F00000L
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P1_MASK                                           0x0F000000L
+#define HUBP0_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P1_MASK                                           0xF0000000L
</span> //HUBP0_HUBP_MEASURE_WIN_CTRL_DCFCLK
 #define HUBP0_HUBP_MEASURE_WIN_CTRL_DCFCLK__HUBP_MEASURE_WIN_EN_DCFCLK__SHIFT                                 0x0
 #define HUBP0_HUBP_MEASURE_WIN_CTRL_DCFCLK__HUBP_MEASURE_WIN_PERIOD_M1_DCFCLK__SHIFT                          0x4
<span
class="hunk">@@ -8013,6 +8057,11 @@
</span> #define HUBP1_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_Y_START__SHIFT                                          0x10
 #define HUBP1_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_X_START_MASK                                            0x0000FFFFL
 #define HUBP1_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_Y_START_MASK                                            0xFFFF0000L
<span
class="add">+//HUBP1_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE
+#define HUBP1_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE__SHIFT                0x0
+#define HUBP1_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_C__SHIFT              0x10
+#define HUBP1_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_MASK                  0x0000FFFFL
+#define HUBP1_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_C_MASK                0xFFFF0000L
</span> //HUBP1_DCSURF_PRI_VIEWPORT_DIMENSION
 #define HUBP1_DCSURF_PRI_VIEWPORT_DIMENSION__PRI_VIEWPORT_WIDTH__SHIFT                                        0x0
 #define HUBP1_DCSURF_PRI_VIEWPORT_DIMENSION__PRI_VIEWPORT_HEIGHT__SHIFT                                       0x10
<span
class="hunk">@@ -8173,6 +8222,23 @@
</span> #define HUBP1_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_NEXT_S1__SHIFT                                               0xc
 #define HUBP1_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_CURR_S1_MASK                                                 0x00000FFFL
 #define HUBP1_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_NEXT_S1_MASK                                                 0x00FFF000L
<span
class="add">+//HUBP1_DCHUBP_MCACHEID_CONFIG
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P0__SHIFT                                          0x0
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P0__SHIFT                                          0x4
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P1__SHIFT                                          0x8
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P1__SHIFT                                          0xc
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P0__SHIFT                                         0x10
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P0__SHIFT                                         0x14
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P1__SHIFT                                         0x18
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P1__SHIFT                                         0x1c
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P0_MASK                                            0x0000000FL
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P0_MASK                                            0x000000F0L
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P1_MASK                                            0x00000F00L
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P1_MASK                                            0x0000F000L
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P0_MASK                                           0x000F0000L
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P0_MASK                                           0x00F00000L
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P1_MASK                                           0x0F000000L
+#define HUBP1_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P1_MASK                                           0xF0000000L
</span> //HUBP1_HUBP_MEASURE_WIN_CTRL_DCFCLK
 #define HUBP1_HUBP_MEASURE_WIN_CTRL_DCFCLK__HUBP_MEASURE_WIN_EN_DCFCLK__SHIFT                                 0x0
 #define HUBP1_HUBP_MEASURE_WIN_CTRL_DCFCLK__HUBP_MEASURE_WIN_PERIOD_M1_DCFCLK__SHIFT                          0x4
<span
class="hunk">@@ -8942,6 +9008,11 @@
</span> #define HUBP2_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_Y_START__SHIFT                                          0x10
 #define HUBP2_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_X_START_MASK                                            0x0000FFFFL
 #define HUBP2_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_Y_START_MASK                                            0xFFFF0000L
<span
class="add">+//HUBP2_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE
+#define HUBP2_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE__SHIFT                0x0
+#define HUBP2_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_C__SHIFT              0x10
+#define HUBP2_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_MASK                  0x0000FFFFL
+#define HUBP2_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_C_MASK                0xFFFF0000L
</span> //HUBP2_DCSURF_PRI_VIEWPORT_DIMENSION
 #define HUBP2_DCSURF_PRI_VIEWPORT_DIMENSION__PRI_VIEWPORT_WIDTH__SHIFT                                        0x0
 #define HUBP2_DCSURF_PRI_VIEWPORT_DIMENSION__PRI_VIEWPORT_HEIGHT__SHIFT                                       0x10
<span
class="hunk">@@ -9102,6 +9173,23 @@
</span> #define HUBP2_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_NEXT_S1__SHIFT                                               0xc
 #define HUBP2_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_CURR_S1_MASK                                                 0x00000FFFL
 #define HUBP2_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_NEXT_S1_MASK                                                 0x00FFF000L
<span
class="add">+//HUBP2_DCHUBP_MCACHEID_CONFIG
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P0__SHIFT                                          0x0
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P0__SHIFT                                          0x4
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P1__SHIFT                                          0x8
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P1__SHIFT                                          0xc
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P0__SHIFT                                         0x10
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P0__SHIFT                                         0x14
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P1__SHIFT                                         0x18
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P1__SHIFT                                         0x1c
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P0_MASK                                            0x0000000FL
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P0_MASK                                            0x000000F0L
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P1_MASK                                            0x00000F00L
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P1_MASK                                            0x0000F000L
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P0_MASK                                           0x000F0000L
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P0_MASK                                           0x00F00000L
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P1_MASK                                           0x0F000000L
+#define HUBP2_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P1_MASK                                           0xF0000000L
</span> //HUBP2_HUBP_MEASURE_WIN_CTRL_DCFCLK
 #define HUBP2_HUBP_MEASURE_WIN_CTRL_DCFCLK__HUBP_MEASURE_WIN_EN_DCFCLK__SHIFT                                 0x0
 #define HUBP2_HUBP_MEASURE_WIN_CTRL_DCFCLK__HUBP_MEASURE_WIN_PERIOD_M1_DCFCLK__SHIFT                          0x4
<span
class="hunk">@@ -9871,6 +9959,11 @@
</span> #define HUBP3_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_Y_START__SHIFT                                          0x10
 #define HUBP3_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_X_START_MASK                                            0x0000FFFFL
 #define HUBP3_DCSURF_PRI_VIEWPORT_START__PRI_VIEWPORT_Y_START_MASK                                            0xFFFF0000L
<span
class="add">+//HUBP3_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE
+#define HUBP3_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE__SHIFT                0x0
+#define HUBP3_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_C__SHIFT              0x10
+#define HUBP3_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_MASK                  0x0000FFFFL
+#define HUBP3_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE__VIEWPORT_MCACHE_SPLIT_COORDINATE_C_MASK                0xFFFF0000L
</span> //HUBP3_DCSURF_PRI_VIEWPORT_DIMENSION
 #define HUBP3_DCSURF_PRI_VIEWPORT_DIMENSION__PRI_VIEWPORT_WIDTH__SHIFT                                        0x0
 #define HUBP3_DCSURF_PRI_VIEWPORT_DIMENSION__PRI_VIEWPORT_HEIGHT__SHIFT                                       0x10
<span
class="hunk">@@ -10031,6 +10124,23 @@
</span> #define HUBP3_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_NEXT_S1__SHIFT                                               0xc
 #define HUBP3_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_CURR_S1_MASK                                                 0x00000FFFL
 #define HUBP3_DCHUBP_MALL_SUB_VP2__SUB_VP_HEIGHT_NEXT_S1_MASK                                                 0x00FFF000L
<span
class="add">+//HUBP3_DCHUBP_MCACHEID_CONFIG
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P0__SHIFT                                          0x0
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P0__SHIFT                                          0x4
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P1__SHIFT                                          0x8
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P1__SHIFT                                          0xc
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P0__SHIFT                                         0x10
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P0__SHIFT                                         0x14
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P1__SHIFT                                         0x18
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P1__SHIFT                                         0x1c
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P0_MASK                                            0x0000000FL
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P0_MASK                                            0x000000F0L
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_1H_P1_MASK                                            0x00000F00L
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_REG_READ_2H_P1_MASK                                            0x0000F000L
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P0_MASK                                           0x000F0000L
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P0_MASK                                           0x00F00000L
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_1H_P1_MASK                                           0x0F000000L
+#define HUBP3_DCHUBP_MCACHEID_CONFIG__MCACHEID_MALL_PREF_2H_P1_MASK                                           0xF0000000L
</span> //HUBP3_HUBP_MEASURE_WIN_CTRL_DCFCLK
 #define HUBP3_HUBP_MEASURE_WIN_CTRL_DCFCLK__HUBP_MEASURE_WIN_EN_DCFCLK__SHIFT                                 0x0
 #define HUBP3_HUBP_MEASURE_WIN_CTRL_DCFCLK__HUBP_MEASURE_WIN_PERIOD_M1_DCFCLK__SHIFT                          0x4
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Aurabindo Pillai</name><email>aurabindo.pillai@amd.com</email></author><title>[PATCH 2/2] drm/amd/display: Enable DCC on DCN401</title><updated>2024-06-17T22:14:39Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240617221426.3136257-2-aurabindo.pillai@amd.com/"/><id>urn:uuid:bf38652c-8d58-7413-0e12-16aaaaef867e</id><thr:in-reply-to
ref="urn:uuid:01e5cbd9-b303-3750-82c5-f794468de64d"
href="http://lore.kernel.org/amd-gfx/20240617221426.3136257-1-aurabindo.pillai@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Add registers and entry points to enable DCC on DCN4x

Signed-off-by: Aurabindo Pillai &lt;aurabindo.pillai@amd.com&gt;
---
 drivers/gpu/drm/amd/display/dc/core/dc.c      |  10 +
 .../drm/amd/display/dc/core/dc_hw_sequencer.c |  11 +
 drivers/gpu/drm/amd/display/dc/dc.h           |   4 +
 .../drm/amd/display/dc/dml2/dml2_wrapper.c    |   6 +
 .../drm/amd/display/dc/dml2/dml2_wrapper.h    |   2 +-
 .../display/dc/hubbub/dcn30/dcn30_hubbub.c    |   3 +
 .../display/dc/hubbub/dcn31/dcn31_hubbub.c    |   3 +
 .../display/dc/hubbub/dcn401/dcn401_hubbub.c  | 280 ++++++++++++++++++
 .../display/dc/hubbub/dcn401/dcn401_hubbub.h  |   5 +
 .../amd/display/dc/hubp/dcn20/dcn20_hubp.h    |  14 +
 .../amd/display/dc/hubp/dcn401/dcn401_hubp.c  |  21 ++
 .../amd/display/dc/hubp/dcn401/dcn401_hubp.h  |  14 +-
 .../amd/display/dc/hwss/dcn20/dcn20_hwseq.c   |   4 +
 .../amd/display/dc/hwss/dcn401/dcn401_hwseq.c |  25 ++
 .../amd/display/dc/hwss/dcn401/dcn401_hwseq.h |   2 +
 .../amd/display/dc/hwss/dcn401/dcn401_init.c  |   1 +
 .../drm/amd/display/dc/hwss/hw_sequencer.h    |   9 +
 .../gpu/drm/amd/display/dc/inc/core_types.h   |   3 +
 .../gpu/drm/amd/display/dc/inc/hw/dchubbub.h  |   4 +
 drivers/gpu/drm/amd/display/dc/inc/hw/hubp.h  |   1 +
 .../dc/resource/dcn401/dcn401_resource.c      |   9 +
 .../dc/resource/dcn401/dcn401_resource.h      |   2 +
 22 files <a href="http://lore.kernel.org/amd-gfx/20240617221426.3136257-2-aurabindo.pillai@amd.com/#related">changed</a>, 431 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a4ba6f99cd34..8c691bee49a3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
</span><span
class="hunk">@@ -1264,6 +1264,9 @@ static void disable_dangling_plane(struct dc *dc, struct dc_state *context)
</span> 				apply_ctx_interdependent_lock(dc, dc-&gt;current_state, old_stream, false);
 				dc-&gt;hwss.post_unlock_program_front_end(dc, dangling_context);
 			}
<span
class="add">+
+			if (dc-&gt;res_pool-&gt;funcs-&gt;prepare_mcache_programming)
+				dc-&gt;res_pool-&gt;funcs-&gt;prepare_mcache_programming(dc, dangling_context);
</span> 			if (dc-&gt;hwss.program_front_end_for_ctx) {
 				dc-&gt;hwss.interdependent_update_lock(dc, dc-&gt;current_state, true);
 				dc-&gt;hwss.program_front_end_for_ctx(dc, dangling_context);
<span
class="hunk">@@ -2037,6 +2040,8 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
</span> 	}
 
 	/* Program all planes within new context*/
<span
class="add">+	if (dc-&gt;res_pool-&gt;funcs-&gt;prepare_mcache_programming)
+		dc-&gt;res_pool-&gt;funcs-&gt;prepare_mcache_programming(dc, context);
</span> 	if (dc-&gt;hwss.program_front_end_for_ctx) {
 		dc-&gt;hwss.interdependent_update_lock(dc, context, true);
 		dc-&gt;hwss.program_front_end_for_ctx(dc, context);
<span
class="hunk">@@ -3884,6 +3889,7 @@ static void commit_planes_for_stream(struct dc *dc,
</span> 				odm_pipe-&gt;ttu_regs.min_ttu_vblank = MAX_TTU;
 	}
 
<span
class="add">+
</span> 	if ((update_type != UPDATE_TYPE_FAST) &#38;&#38; stream-&gt;update_flags.bits.dsc_changed)
 		if (top_pipe_to_program &#38;&#38;
 			top_pipe_to_program-&gt;stream_res.tg-&gt;funcs-&gt;lock_doublebuffer_enable) {
<span
class="hunk">@@ -3903,6 +3909,10 @@ static void commit_planes_for_stream(struct dc *dc,
</span> 						top_pipe_to_program-&gt;stream_res.tg);
 		}
 
<span
class="add">+	if (dc-&gt;hwss.wait_for_dcc_meta_propagation) {
+		dc-&gt;hwss.wait_for_dcc_meta_propagation(dc, top_pipe_to_program);
+	}
+
</span> 	if (should_lock_all_pipes &#38;&#38; dc-&gt;hwss.interdependent_update_lock) {
 		if (dc-&gt;hwss.subvp_pipe_control_lock)
 			dc-&gt;hwss.subvp_pipe_control_lock(dc, context, true, should_lock_all_pipes, NULL, subvp_prev_use);
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/core/dc_hw_sequencer.c
index 5037474bf95c..87e36d51c56d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_hw_sequencer.c
</span><span
class="hunk">@@ -595,6 +595,12 @@ void hwss_build_fast_sequence(struct dc *dc,
</span> 	if (!plane || !stream)
 		return;
 
<span
class="add">+	if (dc-&gt;hwss.wait_for_dcc_meta_propagation) {
+		block_sequence[*num_steps].params.wait_for_dcc_meta_propagation_params.dc = dc;
+		block_sequence[*num_steps].params.wait_for_dcc_meta_propagation_params.top_pipe_to_program = pipe_ctx;
+		block_sequence[*num_steps].func = HUBP_WAIT_FOR_DCC_META_PROP;
+		(*num_steps)++;
+	}
</span> 	if (dc-&gt;hwss.subvp_pipe_control_lock_fast) {
 		block_sequence[*num_steps].params.subvp_pipe_control_lock_fast_params.dc = dc;
 		block_sequence[*num_steps].params.subvp_pipe_control_lock_fast_params.lock = true;
<span
class="hunk">@@ -835,6 +841,11 @@ void hwss_execute_sequence(struct dc *dc,
</span> 		case DMUB_SUBVP_SAVE_SURF_ADDR:
 			hwss_subvp_save_surf_addr(params);
 			break;
<span
class="add">+		case HUBP_WAIT_FOR_DCC_META_PROP:
+			dc-&gt;hwss.wait_for_dcc_meta_propagation(
+					params-&gt;wait_for_dcc_meta_propagation_params.dc,
+					params-&gt;wait_for_dcc_meta_propagation_params.top_pipe_to_program);
+			break;
</span> 		case DMUB_FAMS2_GLOBAL_CONTROL_LOCK_FAST:
 			dc-&gt;hwss.fams2_global_control_lock_fast(params);
 			break;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dc.h b/drivers/gpu/drm/amd/display/dc/dc.h
index d0d1af451b64..9a59f6ef8106 100644
--- a/drivers/gpu/drm/amd/display/dc/dc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc.h
</span><span
class="hunk">@@ -333,6 +333,9 @@ struct dc_dcc_setting {
</span> 		uint32_t dcc_128_128_uncontrained : 1;  //available in ASICs before DCN 3.0
 		uint32_t dcc_256_128_128 : 1;		//available starting with DCN 3.0
 		uint32_t dcc_256_256_unconstrained : 1;  //available in ASICs before DCN 3.0 (the best compression case)
<span
class="add">+		uint32_t dcc_256_256 : 1;  //available in ASICs starting with DCN 4.0x (the best compression case)
+		uint32_t dcc_256_128 : 1;  //available in ASICs starting with DCN 4.0x
+		uint32_t dcc_256_64 : 1;   //available in ASICs starting with DCN 4.0x (the worst compression case)
</span> 	} dcc_controls;
 };
 
<span
class="hunk">@@ -1036,6 +1039,7 @@ struct dc_debug_options {
</span> 	unsigned int static_screen_wait_frames;
 	uint32_t pwm_freq;
 	bool force_chroma_subsampling_1tap;
<span
class="add">+	unsigned int dcc_meta_propagation_delay_us;
</span> 	bool disable_422_left_edge_pixel;
 	bool dml21_force_pstate_method;
 	uint32_t dml21_force_pstate_method_value;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c
index f6310408dbba..c09013794dea 100644
--- a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c
+++ b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c
</span><span
class="hunk">@@ -806,6 +806,12 @@ void dml2_extract_dram_and_fclk_change_support(struct dml2_context *dml2,
</span> 	*dram_clk_change_support = (unsigned int) dml2-&gt;v20.dml_core_ctx.ms.support.DRAMClockChangeSupport[0];
 }
 
<span
class="add">+void dml2_prepare_mcache_programming(struct dc *in_dc, struct dc_state *context, struct dml2_context *dml2)
+{
+	if (dml2-&gt;architecture == dml2_architecture_21)
+		dml21_prepare_mcache_programming(in_dc, context, dml2);
+}
+
</span> void dml2_copy(struct dml2_context *dst_dml2,
 	struct dml2_context *src_dml2)
 {
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.h b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.h
index 20b3970c0857..2ad20378d2ef 100644
--- a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.h
+++ b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.h
</span><span
class="hunk">@@ -301,5 +301,5 @@ bool dml2_validate(const struct dc *in_dc,
</span>  */
 void dml2_extract_dram_and_fclk_change_support(struct dml2_context *dml2,
 	unsigned int *fclk_change_support, unsigned int *dram_clk_change_support);
<span
class="del">-
</span><span
class="add">+void dml2_prepare_mcache_programming(struct dc *in_dc, struct dc_state *context, struct dml2_context *dml2);
</span> #endif //_DML2_WRAPPER_H_
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hubbub/dcn30/dcn30_hubbub.c b/drivers/gpu/drm/amd/display/dc/hubbub/dcn30/dcn30_hubbub.c
index 6a5af3da4b45..fe741100c0f8 100644
--- a/drivers/gpu/drm/amd/display/dc/hubbub/dcn30/dcn30_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/hubbub/dcn30/dcn30_hubbub.c
</span><span
class="hunk">@@ -339,6 +339,7 @@ bool hubbub3_get_dcc_compression_cap(struct hubbub *hubbub,
</span> 		return false;
 
 	switch (dcc_control) {
<span
class="add">+	case dcc_control__256_256:
</span> 	case dcc_control__256_256_xxx:
 		output-&gt;grph.rgb.max_uncompressed_blk_size = 256;
 		output-&gt;grph.rgb.max_compressed_blk_size = 256;
<span
class="hunk">@@ -346,6 +347,7 @@ bool hubbub3_get_dcc_compression_cap(struct hubbub *hubbub,
</span> 		output-&gt;grph.rgb.dcc_controls.dcc_256_256_unconstrained = 1;
 		output-&gt;grph.rgb.dcc_controls.dcc_256_128_128 = 1;
 		break;
<span
class="add">+	case dcc_control__256_128:
</span> 	case dcc_control__128_128_xxx:
 		output-&gt;grph.rgb.max_uncompressed_blk_size = 128;
 		output-&gt;grph.rgb.max_compressed_blk_size = 128;
<span
class="hunk">@@ -353,6 +355,7 @@ bool hubbub3_get_dcc_compression_cap(struct hubbub *hubbub,
</span> 		output-&gt;grph.rgb.dcc_controls.dcc_128_128_uncontrained = 1;
 		output-&gt;grph.rgb.dcc_controls.dcc_256_128_128 = 1;
 		break;
<span
class="add">+	case dcc_control__256_64:
</span> 	case dcc_control__256_64_64:
 		output-&gt;grph.rgb.max_uncompressed_blk_size = 256;
 		output-&gt;grph.rgb.max_compressed_blk_size = 64;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hubbub/dcn31/dcn31_hubbub.c b/drivers/gpu/drm/amd/display/dc/hubbub/dcn31/dcn31_hubbub.c
index b906db6e7355..7fb5523f9722 100644
--- a/drivers/gpu/drm/amd/display/dc/hubbub/dcn31/dcn31_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/hubbub/dcn31/dcn31_hubbub.c
</span><span
class="hunk">@@ -866,6 +866,7 @@ static bool hubbub31_get_dcc_compression_cap(struct hubbub *hubbub,
</span> 		return false;
 
 	switch (dcc_control) {
<span
class="add">+	case dcc_control__256_256:
</span> 	case dcc_control__256_256_xxx:
 		output-&gt;grph.rgb.max_uncompressed_blk_size = 256;
 		output-&gt;grph.rgb.max_compressed_blk_size = 256;
<span
class="hunk">@@ -881,12 +882,14 @@ static bool hubbub31_get_dcc_compression_cap(struct hubbub *hubbub,
</span> 		output-&gt;grph.rgb.dcc_controls.dcc_256_128_128 = 1;
 		break;
 	case dcc_control__256_64_64:
<span
class="add">+	case dcc_control__256_64:
</span> 		output-&gt;grph.rgb.max_uncompressed_blk_size = 256;
 		output-&gt;grph.rgb.max_compressed_blk_size = 64;
 		output-&gt;grph.rgb.independent_64b_blks = true;
 		output-&gt;grph.rgb.dcc_controls.dcc_256_64_64 = 1;
 		break;
 	case dcc_control__256_128_128:
<span
class="add">+	case dcc_control__256_128:
</span> 		output-&gt;grph.rgb.max_uncompressed_blk_size = 256;
 		output-&gt;grph.rgb.max_compressed_blk_size = 128;
 		output-&gt;grph.rgb.independent_64b_blks = false;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hubbub/dcn401/dcn401_hubbub.c b/drivers/gpu/drm/amd/display/dc/hubbub/dcn401/dcn401_hubbub.c
index 054607c944a3..b9201b60bd41 100644
--- a/drivers/gpu/drm/amd/display/dc/hubbub/dcn401/dcn401_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/hubbub/dcn401/dcn401_hubbub.c
</span><span
class="hunk">@@ -824,6 +824,285 @@ void hubbub401_det_request_size(
</span> 		}
 	}
 }
<span
class="add">+bool hubbub401_get_dcc_compression_cap(struct hubbub *hubbub,
+		const struct dc_dcc_surface_param *input,
+		struct dc_surface_dcc_cap *output)
+{
+	struct dc *dc = hubbub-&gt;ctx-&gt;dc;
+	/* DCN4_Programming_Guide_DCHUB.docx, Section 5.11.2.2 */
+	enum dcc_control dcc_control;
+	unsigned int plane0_bpe, plane1_bpe;
+	enum segment_order segment_order_horz, segment_order_vert;
+	enum segment_order p1_segment_order_horz, p1_segment_order_vert;
+	bool req128_horz_wc, req128_vert_wc;
+	unsigned int plane0_width = 0, plane0_height = 0, plane1_width = 0, plane1_height = 0;
+	bool p1_req128_horz_wc, p1_req128_vert_wc, is_dual_plane;
+
+	memset(output, 0, sizeof(*output));
+
+	if (dc-&gt;debug.disable_dcc == DCC_DISABLE)
+		return false;
+
+	switch (input-&gt;format) {
+	default:
+		is_dual_plane = false;
+
+		plane1_width = 0;
+		plane1_height = 0;
+
+		if (input-&gt;surface_size.width &gt; 6144 + 16)
+			plane0_width = 6160;
+		else
+			plane0_width = input-&gt;surface_size.width;
+
+		if (input-&gt;surface_size.height &gt; 6144 + 16)
+			plane0_height = 6160;
+		else
+			plane0_height = input-&gt;surface_size.height;
+
+		break;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCbCr:
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCrCb:
+		is_dual_plane = true;
+
+		if (input-&gt;surface_size.width &gt; 7680 + 16)
+			plane0_width = 7696;
+		else
+			plane0_width = input-&gt;surface_size.width;
+
+		if (input-&gt;surface_size.height &gt; 4320 + 16)
+			plane0_height = 4336;
+		else
+			plane0_height = input-&gt;surface_size.height;
+
+		if (input-&gt;plane1_size.width &gt; 7680 + 16)
+			plane1_width = 7696 / 2;
+		else
+			plane1_width = input-&gt;plane1_size.width;
+
+		if (input-&gt;plane1_size.height &gt; 4320 + 16)
+			plane1_height = 4336 / 2;
+		else
+			plane1_height = input-&gt;plane1_size.height;
+
+		break;
+
+	case SURFACE_PIXEL_FORMAT_GRPH_RGBE_ALPHA:
+		is_dual_plane = true;
+
+		if (input-&gt;surface_size.width &gt; 5120 + 16)
+			plane0_width = 5136;
+		else
+			plane0_width = input-&gt;surface_size.width;
+
+		if (input-&gt;surface_size.height &gt; 5120 + 16)
+			plane0_height = 5136;
+		else
+			plane0_height = input-&gt;surface_size.height;
+
+		if (input-&gt;plane1_size.width &gt; 5120 + 16)
+			plane1_width = 5136;
+		else
+			plane1_width = input-&gt;plane1_size.width;
+
+		if (input-&gt;plane1_size.height &gt; 5120 + 16)
+			plane1_height = 5136;
+		else
+			plane1_height = input-&gt;plane1_size.height;
+
+		break;
+	}
+
+	if (!hubbub-&gt;funcs-&gt;dcc_support_pixel_format_plane0_plane1(input-&gt;format,
+			&#38;plane0_bpe, &#38;plane1_bpe))
+		return false;
+
+	/* Find plane0 DCC Controls */
+	if (!is_dual_plane) {
+
+		if (!hubbub-&gt;funcs-&gt;dcc_support_swizzle_addr3(input-&gt;swizzle_mode_addr3,
+				input-&gt;plane0_pitch, plane0_bpe,
+				&#38;segment_order_horz, &#38;segment_order_vert))
+			return false;
+
+		hubbub401_det_request_size(TO_DCN20_HUBBUB(hubbub)-&gt;detile_buf_size, input-&gt;format,
+				plane0_height, plane0_width, plane0_bpe,
+				plane1_height, plane1_width, plane1_bpe,
+				&#38;req128_horz_wc, &#38;req128_vert_wc, &#38;p1_req128_horz_wc, &#38;p1_req128_vert_wc);
+
+		if (!req128_horz_wc &#38;&#38; !req128_vert_wc) {
+			dcc_control = dcc_control__256_256;
+		} else if (input-&gt;scan == SCAN_DIRECTION_HORIZONTAL) {
+			if (!req128_horz_wc)
+				dcc_control = dcc_control__256_256;
+			else if (segment_order_horz == segment_order__contiguous)
+				dcc_control = dcc_control__256_128;
+			else
+				dcc_control = dcc_control__256_64;
+		} else if (input-&gt;scan == SCAN_DIRECTION_VERTICAL) {
+			if (!req128_vert_wc)
+				dcc_control = dcc_control__256_256;
+			else if (segment_order_vert == segment_order__contiguous)
+				dcc_control = dcc_control__256_128;
+			else
+				dcc_control = dcc_control__256_64;
+		} else {
+			if ((req128_horz_wc &#38;&#38;
+				segment_order_horz == segment_order__non_contiguous) ||
+				(req128_vert_wc &#38;&#38;
+				segment_order_vert == segment_order__non_contiguous))
+				/* access_dir not known, must use most constraining */
+				dcc_control = dcc_control__256_64;
+			else
+				/* req128 is true for either horz and vert
+				 * but segment_order is contiguous
+				 */
+				dcc_control = dcc_control__256_128;
+		}
+
+		if (dc-&gt;debug.disable_dcc == DCC_HALF_REQ_DISALBE &#38;&#38;
+			dcc_control != dcc_control__256_256)
+			return false;
+
+		switch (dcc_control) {
+		case dcc_control__256_256:
+			output-&gt;grph.rgb.dcc_controls.dcc_256_256 = 1;
+			output-&gt;grph.rgb.dcc_controls.dcc_256_128 = 1;
+			output-&gt;grph.rgb.dcc_controls.dcc_256_64 = 1;
+			break;
+		case dcc_control__256_128:
+			output-&gt;grph.rgb.dcc_controls.dcc_256_128 = 1;
+			output-&gt;grph.rgb.dcc_controls.dcc_256_64 = 1;
+			break;
+		case dcc_control__256_64:
+			output-&gt;grph.rgb.dcc_controls.dcc_256_64 = 1;
+			break;
+		default:
+			/* Shouldnt get here */
+			ASSERT(0);
+			break;
+		}
+	} else {
+		/* For dual plane cases, need to examine both planes together */
+		if (!hubbub-&gt;funcs-&gt;dcc_support_swizzle_addr3(input-&gt;swizzle_mode_addr3,
+				input-&gt;plane0_pitch, plane0_bpe,
+				&#38;segment_order_horz, &#38;segment_order_vert))
+			return false;
+
+		if (!hubbub-&gt;funcs-&gt;dcc_support_swizzle_addr3(input-&gt;swizzle_mode_addr3,
+			input-&gt;plane1_pitch, plane1_bpe,
+			&#38;p1_segment_order_horz, &#38;p1_segment_order_vert))
+			return false;
+
+		hubbub401_det_request_size(TO_DCN20_HUBBUB(hubbub)-&gt;detile_buf_size, input-&gt;format,
+				plane0_height, plane0_width, plane0_bpe,
+				plane1_height, plane1_width, plane1_bpe,
+				&#38;req128_horz_wc, &#38;req128_vert_wc, &#38;p1_req128_horz_wc, &#38;p1_req128_vert_wc);
+
+		/* Determine Plane 0 DCC Controls */
+		if (!req128_horz_wc &#38;&#38; !req128_vert_wc) {
+			dcc_control = dcc_control__256_256;
+		} else if (input-&gt;scan == SCAN_DIRECTION_HORIZONTAL) {
+			if (!req128_horz_wc)
+				dcc_control = dcc_control__256_256;
+			else if (segment_order_horz == segment_order__contiguous)
+				dcc_control = dcc_control__256_128;
+			else
+				dcc_control = dcc_control__256_64;
+		} else if (input-&gt;scan == SCAN_DIRECTION_VERTICAL) {
+			if (!req128_vert_wc)
+				dcc_control = dcc_control__256_256;
+			else if (segment_order_vert == segment_order__contiguous)
+				dcc_control = dcc_control__256_128;
+			else
+				dcc_control = dcc_control__256_64;
+		} else {
+			if ((req128_horz_wc &#38;&#38;
+				segment_order_horz == segment_order__non_contiguous) ||
+				(req128_vert_wc &#38;&#38;
+				segment_order_vert == segment_order__non_contiguous))
+				/* access_dir not known, must use most constraining */
+				dcc_control = dcc_control__256_64;
+			else
+				/* req128 is true for either horz and vert
+				 * but segment_order is contiguous
+				 */
+				dcc_control = dcc_control__256_128;
+		}
+
+		switch (dcc_control) {
+		case dcc_control__256_256:
+			output-&gt;video.luma.dcc_controls.dcc_256_256 = 1;
+			output-&gt;video.luma.dcc_controls.dcc_256_128 = 1;
+			output-&gt;video.luma.dcc_controls.dcc_256_64 = 1;
+			break;
+		case dcc_control__256_128:
+			output-&gt;video.luma.dcc_controls.dcc_256_128 = 1;
+			output-&gt;video.luma.dcc_controls.dcc_256_64 = 1;
+			break;
+		case dcc_control__256_64:
+			output-&gt;video.luma.dcc_controls.dcc_256_64 = 1;
+			break;
+		default:
+			ASSERT(0);
+			break;
+		}
+
+		/* Determine Plane 1 DCC Controls */
+		if (!p1_req128_horz_wc &#38;&#38; !p1_req128_vert_wc) {
+			dcc_control = dcc_control__256_256;
+		} else if (input-&gt;scan == SCAN_DIRECTION_HORIZONTAL) {
+			if (!p1_req128_horz_wc)
+				dcc_control = dcc_control__256_256;
+			else if (p1_segment_order_horz == segment_order__contiguous)
+				dcc_control = dcc_control__256_128;
+			else
+				dcc_control = dcc_control__256_64;
+		} else if (input-&gt;scan == SCAN_DIRECTION_VERTICAL) {
+			if (!p1_req128_vert_wc)
+				dcc_control = dcc_control__256_256;
+			else if (p1_segment_order_vert == segment_order__contiguous)
+				dcc_control = dcc_control__256_128;
+			else
+				dcc_control = dcc_control__256_64;
+		} else {
+			if ((p1_req128_horz_wc &#38;&#38;
+				p1_segment_order_horz == segment_order__non_contiguous) ||
+				(p1_req128_vert_wc &#38;&#38;
+				p1_segment_order_vert == segment_order__non_contiguous))
+				/* access_dir not known, must use most constraining */
+				dcc_control = dcc_control__256_64;
+			else
+				/* req128 is true for either horz and vert
+				 * but segment_order is contiguous
+				 */
+				dcc_control = dcc_control__256_128;
+		}
+
+		switch (dcc_control) {
+		case dcc_control__256_256:
+			output-&gt;video.chroma.dcc_controls.dcc_256_256 = 1;
+			output-&gt;video.chroma.dcc_controls.dcc_256_128 = 1;
+			output-&gt;video.chroma.dcc_controls.dcc_256_64 = 1;
+			break;
+		case dcc_control__256_128:
+			output-&gt;video.chroma.dcc_controls.dcc_256_128 = 1;
+			output-&gt;video.chroma.dcc_controls.dcc_256_64 = 1;
+			break;
+		case dcc_control__256_64:
+			output-&gt;video.chroma.dcc_controls.dcc_256_64 = 1;
+			break;
+		default:
+			ASSERT(0);
+			break;
+		}
+	}
+
+	output-&gt;capable = true;
+	return true;
+}
</span> 
 static void dcn401_program_det_segments(struct hubbub *hubbub, int hubp_inst, unsigned det_buffer_size_seg)
 {
<span
class="hunk">@@ -891,6 +1170,7 @@ static const struct hubbub_funcs hubbub4_01_funcs = {
</span> 	.init_vm_ctx = hubbub2_init_vm_ctx,
 	.dcc_support_swizzle_addr3 = hubbub401_dcc_support_swizzle,
 	.dcc_support_pixel_format_plane0_plane1 = hubbub401_dcc_support_pixel_format,
<span
class="add">+	.get_dcc_compression_cap = hubbub401_get_dcc_compression_cap,
</span> 	.wm_read_state = hubbub401_wm_read_state,
 	.get_dchub_ref_freq = hubbub2_get_dchub_ref_freq,
 	.program_watermarks = hubbub401_program_watermarks,
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hubbub/dcn401/dcn401_hubbub.h b/drivers/gpu/drm/amd/display/dc/hubbub/dcn401/dcn401_hubbub.h
index d8a57f64a70c..f35f19ba3e18 100644
--- a/drivers/gpu/drm/amd/display/dc/hubbub/dcn401/dcn401_hubbub.h
+++ b/drivers/gpu/drm/amd/display/dc/hubbub/dcn401/dcn401_hubbub.h
</span><span
class="hunk">@@ -180,6 +180,11 @@ void hubbub401_det_request_size(
</span> 		bool *p0_req128_vert_wc,
 		bool *p1_req128_horz_wc,
 		bool *p1_req128_vert_wc);
<span
class="add">+bool hubbub401_get_dcc_compression_cap(
+		struct hubbub *hubbub,
+		const struct dc_dcc_surface_param *input,
+		struct dc_surface_dcc_cap *output);
+
</span> void hubbub401_construct(struct dcn20_hubbub *hubbub2,
 	struct dc_context *ctx,
 	const struct dcn_hubbub_registers *hubbub_regs,
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hubp/dcn20/dcn20_hubp.h b/drivers/gpu/drm/amd/display/dc/hubp/dcn20/dcn20_hubp.h
index ecc0a2f37938..18e194507e36 100644
--- a/drivers/gpu/drm/amd/display/dc/hubp/dcn20/dcn20_hubp.h
+++ b/drivers/gpu/drm/amd/display/dc/hubp/dcn20/dcn20_hubp.h
</span><span
class="hunk">@@ -175,6 +175,8 @@
</span> 	uint32_t HUBP_3DLUT_ADDRESS_LOW;\
 	uint32_t HUBP_3DLUT_CONTROL;\
 	uint32_t HUBP_3DLUT_DLG_PARAM;\
<span
class="add">+	uint32_t DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE;\
+	uint32_t DCHUBP_MCACHEID_CONFIG
</span> 
 #define DCN2_HUBP_REG_FIELD_VARIABLE_LIST(type) \
 	DCN_HUBP_REG_FIELD_BASE_LIST(type); \
<span
class="hunk">@@ -269,6 +271,18 @@
</span> 	type HUBP_3DLUT_ADDRESS_HIGH;\
 	type HUBP_3DLUT_ADDRESS_LOW;\
 	type REFCYC_PER_3DLUT_GROUP;\
<span
class="add">+	type VIEWPORT_MCACHE_SPLIT_COORDINATE;\
+	type VIEWPORT_MCACHE_SPLIT_COORDINATE_C;\
+	type MCACHEID_REG_READ_1H_P0;\
+	type MCACHEID_REG_READ_2H_P0;\
+	type MCACHEID_REG_READ_1H_P1;\
+	type MCACHEID_REG_READ_2H_P1;\
+	type MCACHEID_MALL_PREF_1H_P0;\
+	type MCACHEID_MALL_PREF_2H_P0;\
+	type MCACHEID_MALL_PREF_1H_P1;\
+	type MCACHEID_MALL_PREF_2H_P1
+
+
</span> 
 struct dcn_hubp2_registers {
 	DCN401_HUBP_REG_COMMON_VARIABLE_LIST;
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.c b/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.c
index 6692d57d5cce..40465fd0bcc0 100644
--- a/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.c
+++ b/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.c
</span><span
class="hunk">@@ -626,6 +626,26 @@ void hubp401_set_viewport(
</span> 		  SEC_VIEWPORT_Y_START_C, viewport_c-&gt;y);
 }
 
<span
class="add">+void hubp401_program_mcache_id_and_split_coordinate(
+	struct hubp *hubp,
+	struct dml2_hubp_pipe_mcache_regs *mcache_regs)
+{
+	struct dcn20_hubp *hubp2 = TO_DCN20_HUBP(hubp);
+
+	REG_SET_8(DCHUBP_MCACHEID_CONFIG, 0,
+		MCACHEID_REG_READ_1H_P0, mcache_regs-&gt;main.p0.mcache_id_first,
+		MCACHEID_REG_READ_2H_P0, mcache_regs-&gt;main.p0.mcache_id_second,
+		MCACHEID_REG_READ_1H_P1, mcache_regs-&gt;main.p1.mcache_id_first,
+		MCACHEID_REG_READ_2H_P1, mcache_regs-&gt;main.p1.mcache_id_second,
+		MCACHEID_MALL_PREF_1H_P0, mcache_regs-&gt;mall.p0.mcache_id_first,
+		MCACHEID_MALL_PREF_2H_P0, mcache_regs-&gt;mall.p0.mcache_id_second,
+		MCACHEID_MALL_PREF_1H_P1, mcache_regs-&gt;mall.p1.mcache_id_first,
+		MCACHEID_MALL_PREF_2H_P1, mcache_regs-&gt;mall.p1.mcache_id_second);
+
+	REG_SET_2(DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE, 0,
+		VIEWPORT_MCACHE_SPLIT_COORDINATE, mcache_regs-&gt;main.p0.split_location,
+		VIEWPORT_MCACHE_SPLIT_COORDINATE_C, mcache_regs-&gt;main.p1.split_location);
+}
</span> void hubp401_set_flip_int(struct hubp *hubp)
 {
 	struct dcn20_hubp *hubp2 = TO_DCN20_HUBP(hubp);
<span
class="hunk">@@ -993,6 +1013,7 @@ static struct hubp_funcs dcn401_hubp_funcs = {
</span> 	.phantom_hubp_post_enable = hubp32_phantom_hubp_post_enable,
 	.hubp_update_mall_sel = hubp401_update_mall_sel,
 	.hubp_prepare_subvp_buffering = hubp32_prepare_subvp_buffering,
<span
class="add">+	.hubp_program_mcache_id_and_split_coordinate = hubp401_program_mcache_id_and_split_coordinate,
</span> 	.hubp_update_3dlut_fl_bias_scale = hubp401_update_3dlut_fl_bias_scale,
 	.hubp_program_3dlut_fl_mode = hubp401_program_3dlut_fl_mode,
 	.hubp_program_3dlut_fl_format = hubp401_program_3dlut_fl_format,
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.h b/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.h
index e0cec898a2c0..e52fdb5b0cd0 100644
--- a/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.h
+++ b/drivers/gpu/drm/amd/display/dc/hubp/dcn401/dcn401_hubp.h
</span><span
class="hunk">@@ -243,6 +243,16 @@
</span> 	HUBP_SF(CURSOR0_0_HUBP_3DLUT_ADDRESS_HIGH, HUBP_3DLUT_ADDRESS_HIGH, mask_sh),\
 	HUBP_SF(CURSOR0_0_HUBP_3DLUT_ADDRESS_LOW, HUBP_3DLUT_ADDRESS_LOW, mask_sh),\
 	HUBP_SF(CURSOR0_0_HUBP_3DLUT_DLG_PARAM, REFCYC_PER_3DLUT_GROUP, mask_sh),\
<span
class="add">+	HUBP_SF(HUBP0_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE, VIEWPORT_MCACHE_SPLIT_COORDINATE, mask_sh),\
+	HUBP_SF(HUBP0_DCSURF_VIEWPORT_MCACHE_SPLIT_COORDINATE, VIEWPORT_MCACHE_SPLIT_COORDINATE_C, mask_sh),\
+	HUBP_SF(HUBP0_DCHUBP_MCACHEID_CONFIG, MCACHEID_REG_READ_1H_P0, mask_sh),\
+	HUBP_SF(HUBP0_DCHUBP_MCACHEID_CONFIG, MCACHEID_REG_READ_2H_P0, mask_sh),\
+	HUBP_SF(HUBP0_DCHUBP_MCACHEID_CONFIG, MCACHEID_REG_READ_1H_P1, mask_sh),\
+	HUBP_SF(HUBP0_DCHUBP_MCACHEID_CONFIG, MCACHEID_REG_READ_2H_P1, mask_sh),\
+	HUBP_SF(HUBP0_DCHUBP_MCACHEID_CONFIG, MCACHEID_MALL_PREF_1H_P0, mask_sh),\
+	HUBP_SF(HUBP0_DCHUBP_MCACHEID_CONFIG, MCACHEID_MALL_PREF_2H_P0, mask_sh),\
+	HUBP_SF(HUBP0_DCHUBP_MCACHEID_CONFIG, MCACHEID_MALL_PREF_1H_P1, mask_sh),\
+	HUBP_SF(HUBP0_DCHUBP_MCACHEID_CONFIG, MCACHEID_MALL_PREF_2H_P1, mask_sh)
</span> 
 void hubp401_update_mall_sel(struct hubp *hubp, uint32_t mall_sel, bool c_cursor);
 
<span
class="hunk">@@ -302,7 +312,9 @@ void hubp401_program_surface_config(
</span> void hubp401_set_viewport(struct hubp *hubp,
 		const struct rect *viewport,
 		const struct rect *viewport_c);
<span
class="del">-
</span><span
class="add">+void hubp401_program_mcache_id_and_split_coordinate(
+	struct hubp *hubp,
+	struct dml2_hubp_pipe_mcache_regs *mcache_regs);
</span> void hubp401_set_flip_int(struct hubp *hubp);
 
 bool hubp401_in_blank(struct hubp *hubp);
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn20/dcn20_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn20/dcn20_hwseq.c
index 82d1ded09561..0aaa5887ea64 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn20/dcn20_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn20/dcn20_hwseq.c
</span><span
class="hunk">@@ -1753,6 +1753,10 @@ static void dcn20_update_dchubp_dpp(
</span> 			&#38;pipe_ctx-&gt;plane_res.scl_data.viewport_c);
 		viewport_changed = true;
 	}
<span
class="add">+		if (hubp-&gt;funcs-&gt;hubp_program_mcache_id_and_split_coordinate)
+			hubp-&gt;funcs-&gt;hubp_program_mcache_id_and_split_coordinate(
+				hubp,
+				&#38;pipe_ctx-&gt;mcache_regs);
</span> 
 	/* Any updates are handled in dc interface, just need to apply existing for plane enable */
 	if ((pipe_ctx-&gt;update_flags.bits.enable || pipe_ctx-&gt;update_flags.bits.opp_changed ||
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
index 7a456618f313..43e73b436f29 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
</span><span
class="hunk">@@ -1408,6 +1408,31 @@ bool dcn401_apply_idle_power_optimizations(struct dc *dc, bool enable)
</span> 	return true;
 }
 
<span
class="add">+void dcn401_wait_for_dcc_meta_propagation(const struct dc *dc,
+		const struct pipe_ctx *top_pipe)
+{
+	bool is_wait_needed = false;
+	const struct pipe_ctx *pipe_ctx = top_pipe;
+
+	/* check if any surfaces are updating address while using flip immediate and dcc */
+	while (pipe_ctx != NULL) {
+		if (pipe_ctx-&gt;plane_state &#38;&#38;
+				pipe_ctx-&gt;plane_state-&gt;dcc.enable &#38;&#38;
+				pipe_ctx-&gt;plane_state-&gt;flip_immediate &#38;&#38;
+				pipe_ctx-&gt;plane_state-&gt;update_flags.bits.addr_update) {
+			is_wait_needed = true;
+			break;
+		}
+
+		/* check next pipe */
+		pipe_ctx = pipe_ctx-&gt;bottom_pipe;
+	}
+
+	if (is_wait_needed &#38;&#38; dc-&gt;debug.dcc_meta_propagation_delay_us &gt; 0) {
+		udelay(dc-&gt;debug.dcc_meta_propagation_delay_us);
+	}
+}
+
</span> void dcn401_prepare_bandwidth(struct dc *dc,
 	struct dc_state *context)
 {
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.h b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.h
index bada43d4b2eb..c1d4287d5a0d 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.h
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.h
</span><span
class="hunk">@@ -61,6 +61,8 @@ bool dcn401_apply_idle_power_optimizations(struct dc *dc, bool enable);
</span> 
 struct ips_ono_region_state dcn401_read_ono_state(struct dc *dc,
 						  uint8_t region);
<span
class="add">+void dcn401_wait_for_dcc_meta_propagation(const struct dc *dc,
+		const struct pipe_ctx *top_pipe_to_program);
</span> 
 void dcn401_prepare_bandwidth(struct dc *dc,
 		struct dc_state *context);
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_init.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_init.c
index 1cf0608e1980..90cf284fdd98 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_init.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_init.c
</span><span
class="hunk">@@ -94,6 +94,7 @@ static const struct hw_sequencer_funcs dcn401_funcs = {
</span> 	.update_dsc_pg = dcn32_update_dsc_pg,
 	.apply_update_flags_for_phantom = dcn32_apply_update_flags_for_phantom,
 	.blank_phantom = dcn32_blank_phantom,
<span
class="add">+	.wait_for_dcc_meta_propagation = dcn401_wait_for_dcc_meta_propagation,
</span> 	.is_pipe_topology_transition_seamless = dcn32_is_pipe_topology_transition_seamless,
 	.fams2_global_control_lock = dcn401_fams2_global_control_lock,
 	.fams2_update_config = dcn401_fams2_update_config,
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/hw_sequencer.h b/drivers/gpu/drm/amd/display/dc/hwss/hw_sequencer.h
index e9b85884edce..d05be65a2256 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/hw_sequencer.h
+++ b/drivers/gpu/drm/amd/display/dc/hwss/hw_sequencer.h
</span><span
class="hunk">@@ -141,6 +141,11 @@ struct subvp_save_surf_addr {
</span> 	uint8_t subvp_index;
 };
 
<span
class="add">+struct wait_for_dcc_meta_propagation_params {
+	const struct dc *dc;
+	const struct pipe_ctx *top_pipe_to_program;
+};
+
</span> struct fams2_global_control_lock_fast_params {
 	struct dc *dc;
 	bool is_required;
<span
class="hunk">@@ -165,6 +170,7 @@ union block_sequence_params {
</span> 	struct set_output_csc_params set_output_csc_params;
 	struct set_ocsc_default_params set_ocsc_default_params;
 	struct subvp_save_surf_addr subvp_save_surf_addr;
<span
class="add">+	struct wait_for_dcc_meta_propagation_params wait_for_dcc_meta_propagation_params;
</span> 	struct fams2_global_control_lock_fast_params fams2_global_control_lock_fast_params;
 };
 
<span
class="hunk">@@ -186,6 +192,7 @@ enum block_sequence_func {
</span> 	MPC_SET_OUTPUT_CSC,
 	MPC_SET_OCSC_DEFAULT,
 	DMUB_SUBVP_SAVE_SURF_ADDR,
<span
class="add">+	HUBP_WAIT_FOR_DCC_META_PROP,
</span> 	DMUB_FAMS2_GLOBAL_CONTROL_LOCK_FAST,
 
 };
<span
class="hunk">@@ -443,6 +450,8 @@ struct hw_sequencer_funcs {
</span> 	bool (*is_pipe_topology_transition_seamless)(struct dc *dc,
 			const struct dc_state *cur_ctx,
 			const struct dc_state *new_ctx);
<span
class="add">+	void (*wait_for_dcc_meta_propagation)(const struct dc *dc,
+		const struct pipe_ctx *top_pipe_to_program);
</span> 	void (*fams2_global_control_lock)(struct dc *dc,
 			struct dc_state *context,
 			bool lock);
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/inc/core_types.h b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
index f58c27ad8b3e..4c8e6436c7e1 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
</span><span
class="hunk">@@ -97,6 +97,9 @@ struct resource_funcs {
</span> 	unsigned int (*calculate_mall_ways_from_bytes)(
 				const struct dc *dc,
 				unsigned int total_size_in_mall_bytes);
<span
class="add">+	void (*prepare_mcache_programming)(
+					struct dc *dc,
+					struct dc_state *context);
</span> 	/**
 	 * @populate_dml_pipes - Populate pipe data struct
 	 *
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/dchubbub.h b/drivers/gpu/drm/amd/display/dc/inc/hw/dchubbub.h
index a73cb8f731b3..dd2b2864876c 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/dchubbub.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/dchubbub.h
</span><span
class="hunk">@@ -40,6 +40,10 @@ enum dcc_control {
</span> 	dcc_control__128_128_xxx,
 	dcc_control__256_64_64,
 	dcc_control__256_128_128,
<span
class="add">+	dcc_control__256_256,
+	dcc_control__256_128,
+	dcc_control__256_64,
+
</span> };
 
 enum segment_order {
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/hubp.h b/drivers/gpu/drm/amd/display/dc/inc/hw/hubp.h
index bcd7b22a1627..16580d624278 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/hubp.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/hubp.h
</span><span
class="hunk">@@ -257,6 +257,7 @@ struct hubp_funcs {
</span> 			unsigned int min_dst_y_next_start_optimized);
 
 	void (*hubp_wait_pipe_read_start)(struct hubp *hubp);
<span
class="add">+	void (*hubp_program_mcache_id_and_split_coordinate)(struct hubp *hubp, struct dml2_hubp_pipe_mcache_regs *mcache_regs);
</span> 	void (*hubp_update_3dlut_fl_bias_scale)(struct hubp *hubp, uint16_t bias, uint16_t scale);
 	void (*hubp_program_3dlut_fl_mode)(struct hubp *hubp,
 			enum hubp_3dlut_fl_mode mode);
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c b/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c
index 74fb21b88f12..4e27d2cee9fb 100644
--- a/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c
</span><span
class="hunk">@@ -1617,6 +1617,14 @@ bool dcn401_validate_bandwidth(struct dc *dc,
</span> 	return out;
 }
 
<span
class="add">+void dcn401_prepare_mcache_programming(struct dc *dc,
+		struct dc_state *context)
+{
+	if (dc-&gt;debug.using_dml21)
+		dml2_prepare_mcache_programming(dc, context,
+				context-&gt;power_source == DC_POWER_SOURCE_DC ? context-&gt;bw_ctx.dml2_dc_power_source : context-&gt;bw_ctx.dml2);
+}
+
</span> static void dcn401_build_pipe_pix_clk_params(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_stream_state *stream = pipe_ctx-&gt;stream;
<span
class="hunk">@@ -1699,6 +1707,7 @@ static struct resource_funcs dcn401_res_pool_funcs = {
</span> 	.patch_unknown_plane_state = dcn401_patch_unknown_plane_state,
 	.update_soc_for_wm_a = dcn30_update_soc_for_wm_a,
 	.add_phantom_pipes = dcn32_add_phantom_pipes,
<span
class="add">+	.prepare_mcache_programming = dcn401_prepare_mcache_programming,
</span> 	.build_pipe_pix_clk_params = dcn401_build_pipe_pix_clk_params,
 	.calculate_mall_ways_from_bytes = dcn32_calculate_mall_ways_from_bytes,
 };
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.h b/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.h
index c04c8b8f2114..26efeada4f41 100644
--- a/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.h
+++ b/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.h
</span><span
class="hunk">@@ -26,6 +26,8 @@ bool dcn401_validate_bandwidth(struct dc *dc,
</span> 		struct dc_state *context,
 		bool fast_validate);
 
<span
class="add">+void dcn401_prepare_mcache_programming(struct dc *dc, struct dc_state *context);
+
</span> /* Following are definitions for run time init of reg offsets */
 
 /* HUBP */
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Aurabindo Pillai</name><email>aurabindo.pillai@amd.com</email></author><title>[PATCH] drm/amdgpu: init TA fw for psp v14</title><updated>2024-06-17T19:14:41Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240617191428.3039656-1-aurabindo.pillai@amd.com/"/><id>urn:uuid:7577e633-3c55-5089-3637-68f86d8fad12</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Likun Gao &lt;Likun.Gao@amd.com&gt;

Add support to init TA firmware for psp v14.

Signed-off-by: Likun Gao &lt;Likun.Gao@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/psp_v14_0.c | 5 +++++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240617191428.3039656-1-aurabindo.pillai@amd.com/#related">changed</a>, 5 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/psp_v14_0.c b/drivers/gpu/drm/amd/amdgpu/psp_v14_0.c
index cc0248efa6b6..4d33c95a5116 100644
--- a/drivers/gpu/drm/amd/amdgpu/psp_v14_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/psp_v14_0.c
</span><span
class="hunk">@@ -32,7 +32,9 @@
</span> #include &#34;mp/mp_14_0_2_sh_mask.h&#34;
 
 MODULE_FIRMWARE(&#34;amdgpu/psp_14_0_2_sos.bin&#34;);
<span
class="add">+MODULE_FIRMWARE(&#34;amdgpu/psp_14_0_2_ta.bin&#34;);
</span> MODULE_FIRMWARE(&#34;amdgpu/psp_14_0_3_sos.bin&#34;);
<span
class="add">+MODULE_FIRMWARE(&#34;amdgpu/psp_14_0_3_ta.bin&#34;);
</span> 
 /* For large FW files the time to complete can be very long */
 #define USBC_PD_POLLING_LIMIT_S 240
<span
class="hunk">@@ -64,6 +66,9 @@ static int psp_v14_0_init_microcode(struct psp_context *psp)
</span> 	case IP_VERSION(14, 0, 2):
 	case IP_VERSION(14, 0, 3):
 		err = psp_init_sos_microcode(psp, ucode_prefix);
<span
class="add">+		if (err)
+			return err;
+		err = psp_init_ta_microcode(psp, ucode_prefix);
</span> 		if (err)
 			return err;
 		break;
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Vignesh Chander</name><email>Vignesh.Chander@amd.com</email></author><title>[PATCH 2/2] drm/amdgpu: process RAS fatal error MB notification</title><updated>2024-06-17T14:55:09Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240617145446.593279-2-Vignesh.Chander@amd.com/"/><id>urn:uuid:efea76af-8c92-f567-bdf8-8fe4e48859df</id><thr:in-reply-to
ref="urn:uuid:b757c5a2-ecb3-7277-8deb-88634b8eac35"
href="http://lore.kernel.org/amd-gfx/20240617145446.593279-1-Vignesh.Chander@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">For RAS error scenario, VF guest driver will check mailbox
and set fed flag to avoid unnecessary HW accesses.
additionally, poll for reset completion message first
to avoid accidentally spamming multiple reset requests to host.

Signed-off-by: Vignesh Chander &lt;Vignesh.Chander@amd.com&gt;
Change-Id: I364c417ce292bec6bf98671bc03ea882529361ac
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c | 25 +++++++++++++++++++++---
 drivers/gpu/drm/amd/amdgpu/amdgpu_virt.h |  4 +++-
 drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c    | 22 +++++++++++++++++++--
 drivers/gpu/drm/amd/amdgpu/mxgpu_ai.h    |  4 +++-
 drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c    | 22 +++++++++++++++++++--
 drivers/gpu/drm/amd/amdgpu/mxgpu_nv.h    |  3 ++-
 6 files <a href="http://lore.kernel.org/amd-gfx/20240617145446.593279-2-Vignesh.Chander@amd.com/#related">changed</a>, 70 insertions(+), 10 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c
index 63f2286858c484..ccb3d041c2b249 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c
</span><span
class="hunk">@@ -229,6 +229,22 @@ void amdgpu_virt_free_mm_table(struct amdgpu_device *adev)
</span> 	adev-&gt;virt.mm_table.gpu_addr = 0;
 }
 
<span
class="add">+/**
+ * amdgpu_virt_rcvd_ras_interrupt() - receive ras interrupt
+ * @adev:	amdgpu device.
+ * Check whether host sent RAS error message
+ * Return: true if found, otherwise false
+ */
+bool amdgpu_virt_rcvd_ras_interrupt(struct amdgpu_device *adev)
+{
+	struct amdgpu_virt *virt = &#38;adev-&gt;virt;
+
+	if (!virt-&gt;ops || !virt-&gt;ops-&gt;rcvd_ras_intr)
+		return false;
+
+	return virt-&gt;ops-&gt;rcvd_ras_intr(adev);
+}
+
</span> 
 unsigned int amd_sriov_msg_checksum(void *obj,
 				unsigned long obj_size,
<span
class="hunk">@@ -612,11 +628,14 @@ static void amdgpu_virt_update_vf2pf_work_item(struct work_struct *work)
</span> 	ret = amdgpu_virt_read_pf2vf_data(adev);
 	if (ret) {
 		adev-&gt;virt.vf2pf_update_retry_cnt++;
<span
class="del">-		if ((adev-&gt;virt.vf2pf_update_retry_cnt &gt;= AMDGPU_VF2PF_UPDATE_MAX_RETRY_LIMIT) &#38;&#38;
-		    amdgpu_sriov_runtime(adev)) {
</span><span
class="add">+
+		if ((amdgpu_virt_rcvd_ras_interrupt(adev) ||
+			adev-&gt;virt.vf2pf_update_retry_cnt &gt;= AMDGPU_VF2PF_UPDATE_MAX_RETRY_LIMIT) &#38;&#38;
+			amdgpu_sriov_runtime(adev)) {
+
</span> 			amdgpu_ras_set_fed(adev, true);
 			if (amdgpu_reset_domain_schedule(adev-&gt;reset_domain,
<span
class="del">-							  &#38;adev-&gt;kfd.reset_work))
</span><span
class="add">+							&#38;adev-&gt;kfd.reset_work))
</span> 				return;
 			else
 				dev_err(adev-&gt;dev, &#34;Failed to queue work! at %s&#34;, __func__);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.h
index f04cd1586c7220..b42a8854dca0cb 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.h
</span><span
class="hunk">@@ -52,7 +52,7 @@
</span> /* tonga/fiji use this offset */
 #define mmBIF_IOV_FUNC_IDENTIFIER 0x1503
 
<span
class="del">-#define AMDGPU_VF2PF_UPDATE_MAX_RETRY_LIMIT 5
</span><span
class="add">+#define AMDGPU_VF2PF_UPDATE_MAX_RETRY_LIMIT 2
</span> 
 enum amdgpu_sriov_vf_mode {
 	SRIOV_VF_MODE_BARE_METAL = 0,
<span
class="hunk">@@ -94,6 +94,7 @@ struct amdgpu_virt_ops {
</span> 			  u32 data1, u32 data2, u32 data3);
 	void (*ras_poison_handler)(struct amdgpu_device *adev,
 					enum amdgpu_ras_block block);
<span
class="add">+	bool (*rcvd_ras_intr)(struct amdgpu_device *adev);
</span> };
 
 /*
<span
class="hunk">@@ -352,6 +353,7 @@ void amdgpu_virt_ready_to_reset(struct amdgpu_device *adev);
</span> int amdgpu_virt_wait_reset(struct amdgpu_device *adev);
 int amdgpu_virt_alloc_mm_table(struct amdgpu_device *adev);
 void amdgpu_virt_free_mm_table(struct amdgpu_device *adev);
<span
class="add">+bool amdgpu_virt_rcvd_ras_interrupt(struct amdgpu_device *adev);
</span> void amdgpu_virt_release_ras_err_handler_data(struct amdgpu_device *adev);
 void amdgpu_virt_init_data_exchange(struct amdgpu_device *adev);
 void amdgpu_virt_exchange_data(struct amdgpu_device *adev);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c b/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c
index 65656afc6ed1c2..a2c0a43a02f351 100644
--- a/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c
+++ b/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c
</span><span
class="hunk">@@ -196,11 +196,22 @@ static int xgpu_ai_request_reset(struct amdgpu_device *adev)
</span> {
 	int ret, i = 0;
 
<span
class="del">-	while (i &lt; AI_MAILBOX_POLL_MSG_REP_MAX) {
</span><span
class="add">+	if (amdgpu_ras_get_fed_status(adev)) {
+		dev_dbg(adev-&gt;dev, &#34;ras flag is set, poll for IDH_FLR_NOTIFICATION_CMPL\n&#34;);
+
+		for (i = 0; i &lt; AI_MAILBOX_POLL_MSG_REP_MAX; i++) {
+			ret = xgpu_ai_poll_msg(adev, IDH_FLR_NOTIFICATION_CMPL);
+			if (!ret)
+				break;
+
+			dev_dbg(adev-&gt;dev, &#34;retries left = %d\n&#34;, AI_MAILBOX_POLL_MSG_REP_MAX - i);
+		}
+	}
+
+	for (i = 0; i &lt; AI_MAILBOX_POLL_MSG_REP_MAX; i++) {
</span> 		ret = xgpu_ai_send_access_requests(adev, IDH_REQ_GPU_RESET_ACCESS);
 		if (!ret)
 			break;
<span
class="del">-		i++;
</span> 	}
 
 	return ret;
<span
class="hunk">@@ -408,6 +419,12 @@ static void xgpu_ai_ras_poison_handler(struct amdgpu_device *adev,
</span> 	xgpu_ai_send_access_requests(adev, IDH_RAS_POISON);
 }
 
<span
class="add">+static bool xgpu_ai_rcvd_ras_intr(struct amdgpu_device *adev)
+{
+	enum idh_event msg = xgpu_ai_mailbox_peek_msg(adev);
+	return msg == IDH_RAS_ERROR_DETECTED;
+}
+
</span> const struct amdgpu_virt_ops xgpu_ai_virt_ops = {
 	.req_full_gpu	= xgpu_ai_request_full_gpu_access,
 	.rel_full_gpu	= xgpu_ai_release_full_gpu_access,
<span
class="hunk">@@ -417,4 +434,5 @@ const struct amdgpu_virt_ops xgpu_ai_virt_ops = {
</span> 	.trans_msg = xgpu_ai_mailbox_trans_msg,
 	.req_init_data  = xgpu_ai_request_init_data,
 	.ras_poison_handler = xgpu_ai_ras_poison_handler,
<span
class="add">+	.rcvd_ras_intr = xgpu_ai_rcvd_ras_intr,
</span> };
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.h b/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.h
index c520b2fabfb9a8..ed57cbc150afba 100644
--- a/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.h
+++ b/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.h
</span><span
class="hunk">@@ -51,7 +51,9 @@ enum idh_event {
</span> 	IDH_FAIL,
 	IDH_QUERY_ALIVE,
 	IDH_REQ_GPU_INIT_DATA_READY,
<span
class="del">-
</span><span
class="add">+	IDH_RAS_POISON_READY,
+	IDH_PF_SOFT_FLR_NOTIFICATION,
+	IDH_RAS_ERROR_DETECTED,
</span> 	IDH_TEXT_MESSAGE = 255,
 };
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c b/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c
index 17e1e8cc243752..67392356decd1f 100644
--- a/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c
+++ b/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c
</span><span
class="hunk">@@ -225,11 +225,22 @@ static int xgpu_nv_request_reset(struct amdgpu_device *adev)
</span> {
 	int ret, i = 0;
 
<span
class="del">-	while (i &lt; NV_MAILBOX_POLL_MSG_REP_MAX) {
</span><span
class="add">+	if (amdgpu_ras_get_fed_status(adev)) {
+		dev_dbg(adev-&gt;dev, &#34;ras flag is set, poll for IDH_FLR_NOTIFICATION_CMPL\n&#34;);
+
+		for (i = 0; i &lt; NV_MAILBOX_POLL_MSG_REP_MAX; i++) {
+			ret = xgpu_nv_poll_msg(adev, IDH_FLR_NOTIFICATION_CMPL);
+			if (!ret)
+				break;
+
+			dev_dbg(adev-&gt;dev, &#34;retries left = %d\n&#34;, NV_MAILBOX_POLL_MSG_REP_MAX - i);
+		}
+	}
+
+	for (i = 0; i &lt; NV_MAILBOX_POLL_MSG_REP_MAX; i++) {
</span> 		ret = xgpu_nv_send_access_requests(adev, IDH_REQ_GPU_RESET_ACCESS);
 		if (!ret)
 			break;
<span
class="del">-		i++;
</span> 	}
 
 	return ret;
<span
class="hunk">@@ -449,6 +460,12 @@ static void xgpu_nv_ras_poison_handler(struct amdgpu_device *adev,
</span> 	}
 }
 
<span
class="add">+static bool xgpu_nv_rcvd_ras_intr(struct amdgpu_device *adev)
+{
+	enum idh_event msg = xgpu_nv_mailbox_peek_msg(adev);
+	return msg == IDH_RAS_ERROR_DETECTED;
+}
+
</span> const struct amdgpu_virt_ops xgpu_nv_virt_ops = {
 	.req_full_gpu	= xgpu_nv_request_full_gpu_access,
 	.rel_full_gpu	= xgpu_nv_release_full_gpu_access,
<span
class="hunk">@@ -458,4 +475,5 @@ const struct amdgpu_virt_ops xgpu_nv_virt_ops = {
</span> 	.wait_reset = xgpu_nv_wait_reset,
 	.trans_msg = xgpu_nv_mailbox_trans_msg,
 	.ras_poison_handler = xgpu_nv_ras_poison_handler,
<span
class="add">+	.rcvd_ras_intr = xgpu_nv_rcvd_ras_intr,
</span> };
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.h b/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.h
index 1e8fd90cab4347..719a4c88615752 100644
--- a/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.h
+++ b/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.h
</span><span
class="hunk">@@ -52,7 +52,8 @@ enum idh_event {
</span> 	IDH_QUERY_ALIVE,
 	IDH_REQ_GPU_INIT_DATA_READY,
 	IDH_RAS_POISON_READY,
<span
class="del">-
</span><span
class="add">+	IDH_PF_SOFT_FLR_NOTIFICATION,
+	IDH_RAS_ERROR_DETECTED,
</span> 	IDH_TEXT_MESSAGE = 255,
 };
 
-- 
2.25.1

</pre></div></content></entry><entry><author><name>Vignesh Chander</name><email>Vignesh.Chander@amd.com</email></author><title>[PATCH 1/2] drm/amdgpu: Use dev_ prints for virtualization as it supports multi adapter</title><updated>2024-06-17T14:55:07Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240617145446.593279-1-Vignesh.Chander@amd.com/"/><id>urn:uuid:b757c5a2-ecb3-7277-8deb-88634b8eac35</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Signed-off-by: Vignesh Chander &lt;Vignesh.Chander@amd.com&gt;
Change-Id: Ifead637951c00e5b4e97c766d172323dcac4da08
---
 drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c | 19 +++++++++++--------
 drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c | 23 +++++++++++++++--------
 2 files <a href="http://lore.kernel.org/amd-gfx/20240617145446.593279-1-Vignesh.Chander@amd.com/#related">changed</a>, 26 insertions(+), 16 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c b/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c
index 6b71ee85ee6556..65656afc6ed1c2 100644
--- a/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c
+++ b/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c
</span><span
class="hunk">@@ -93,7 +93,7 @@ static int xgpu_ai_poll_ack(struct amdgpu_device *adev)
</span> 		timeout -= 5;
 	} while (timeout &gt; 1);
 
<span
class="del">-	pr_err(&#34;Doesn&#39;t get TRN_MSG_ACK from pf in %d msec\n&#34;, AI_MAILBOX_POLL_ACK_TIMEDOUT);
</span><span
class="add">+	dev_err(adev-&gt;dev, &#34;Doesn&#39;t get TRN_MSG_ACK from pf in %d msec\n&#34;, AI_MAILBOX_POLL_ACK_TIMEDOUT);
</span> 
 	return -ETIME;
 }
<span
class="hunk">@@ -111,7 +111,7 @@ static int xgpu_ai_poll_msg(struct amdgpu_device *adev, enum idh_event event)
</span> 		timeout -= 10;
 	} while (timeout &gt; 1);
 
<span
class="del">-	pr_err(&#34;Doesn&#39;t get msg:%d from pf, error=%d\n&#34;, event, r);
</span><span
class="add">+	dev_err(adev-&gt;dev, &#34;Doesn&#39;t get msg:%d from pf, error=%d\n&#34;, event, r);
</span> 
 	return -ETIME;
 }
<span
class="hunk">@@ -132,7 +132,7 @@ static void xgpu_ai_mailbox_trans_msg (struct amdgpu_device *adev,
</span> 		xgpu_ai_mailbox_set_valid(adev, false);
 		trn = xgpu_ai_peek_ack(adev);
 		if (trn) {
<span
class="del">-			pr_err(&#34;trn=%x ACK should not assert! wait again !\n&#34;, trn);
</span><span
class="add">+			dev_err_ratelimited(adev-&gt;dev, &#34;trn=%x ACK should not assert! wait again !\n&#34;, trn);
</span> 			msleep(1);
 		}
 	} while(trn);
<span
class="hunk">@@ -155,7 +155,7 @@ static void xgpu_ai_mailbox_trans_msg (struct amdgpu_device *adev,
</span> 	/* start to poll ack */
 	r = xgpu_ai_poll_ack(adev);
 	if (r)
<span
class="del">-		pr_err(&#34;Doesn&#39;t get ack from pf, continue\n&#34;);
</span><span
class="add">+		dev_err(adev-&gt;dev, &#34;Doesn&#39;t get ack from pf, continue\n&#34;);
</span> 
 	xgpu_ai_mailbox_set_valid(adev, false);
 }
<span
class="hunk">@@ -173,7 +173,7 @@ static int xgpu_ai_send_access_requests(struct amdgpu_device *adev,
</span> 		req == IDH_REQ_GPU_RESET_ACCESS) {
 		r = xgpu_ai_poll_msg(adev, IDH_READY_TO_ACCESS_GPU);
 		if (r) {
<span
class="del">-			pr_err(&#34;Doesn&#39;t get READY_TO_ACCESS_GPU from pf, give up\n&#34;);
</span><span
class="add">+			dev_err(adev-&gt;dev, &#34;Doesn&#39;t get READY_TO_ACCESS_GPU from pf, give up\n&#34;);
</span> 			return r;
 		}
 		/* Retrieve checksum from mailbox2 */
<span
class="hunk">@@ -231,7 +231,7 @@ static int xgpu_ai_mailbox_ack_irq(struct amdgpu_device *adev,
</span> 					struct amdgpu_irq_src *source,
 					struct amdgpu_iv_entry *entry)
 {
<span
class="del">-	DRM_DEBUG(&#34;get ack intr and do nothing.\n&#34;);
</span><span
class="add">+	dev_dbg(adev-&gt;dev, &#34;get ack intr and do nothing.\n&#34;);
</span> 	return 0;
 }
 
<span
class="hunk">@@ -258,12 +258,15 @@ static int xgpu_ai_wait_reset(struct amdgpu_device *adev)
</span> {
 	int timeout = AI_MAILBOX_POLL_FLR_TIMEDOUT;
 	do {
<span
class="del">-		if (xgpu_ai_mailbox_peek_msg(adev) == IDH_FLR_NOTIFICATION_CMPL)
</span><span
class="add">+		if (xgpu_ai_mailbox_peek_msg(adev) == IDH_FLR_NOTIFICATION_CMPL) {
+			dev_dbg(adev-&gt;dev, &#34;Got AI IDH_FLR_NOTIFICATION_CMPL after %d ms\n&#34;, AI_MAILBOX_POLL_FLR_TIMEDOUT - timeout);
</span> 			return 0;
<span
class="add">+		}
</span> 		msleep(10);
 		timeout -= 10;
 	} while (timeout &gt; 1);
<span
class="del">-	dev_warn(adev-&gt;dev, &#34;waiting IDH_FLR_NOTIFICATION_CMPL timeout\n&#34;);
</span><span
class="add">+
+	dev_dbg(adev-&gt;dev, &#34;waiting AI IDH_FLR_NOTIFICATION_CMPL timeout\n&#34;);
</span> 	return -ETIME;
 }
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c b/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c
index 22af30a15a5fd7..17e1e8cc243752 100644
--- a/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c
+++ b/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c
</span><span
class="hunk">@@ -91,7 +91,7 @@ static int xgpu_nv_poll_ack(struct amdgpu_device *adev)
</span> 		timeout -= 5;
 	} while (timeout &gt; 1);
 
<span
class="del">-	pr_err(&#34;Doesn&#39;t get TRN_MSG_ACK from pf in %d msec\n&#34;, NV_MAILBOX_POLL_ACK_TIMEDOUT);
</span><span
class="add">+	dev_err(adev-&gt;dev, &#34;Doesn&#39;t get TRN_MSG_ACK from pf in %d msec \n&#34;, NV_MAILBOX_POLL_ACK_TIMEDOUT);
</span> 
 	return -ETIME;
 }
<span
class="hunk">@@ -106,13 +106,16 @@ static int xgpu_nv_poll_msg(struct amdgpu_device *adev, enum idh_event event)
</span> 
 	do {
 		r = xgpu_nv_mailbox_rcv_msg(adev, event);
<span
class="del">-		if (!r)
</span><span
class="add">+		if (!r) {
+			dev_dbg(adev-&gt;dev, &#34;rcv_msg 0x%x after %llu ms\n&#34;, event, NV_MAILBOX_POLL_MSG_TIMEDOUT - timeout + now);
</span> 			return 0;
<span
class="add">+		}
</span> 
 		msleep(10);
 		now = (uint64_t)ktime_to_ms(ktime_get());
 	} while (timeout &gt; now);
 
<span
class="add">+	dev_dbg(adev-&gt;dev, &#34;nv_poll_msg timed out\n&#34;);
</span> 
 	return -ETIME;
 }
<span
class="hunk">@@ -133,11 +136,12 @@ static void xgpu_nv_mailbox_trans_msg (struct amdgpu_device *adev,
</span> 		xgpu_nv_mailbox_set_valid(adev, false);
 		trn = xgpu_nv_peek_ack(adev);
 		if (trn) {
<span
class="del">-			pr_err(&#34;trn=%x ACK should not assert! wait again !\n&#34;, trn);
</span><span
class="add">+			dev_err_ratelimited(adev-&gt;dev, &#34;trn=%x ACK should not assert! wait again !\n&#34;, trn);
</span> 			msleep(1);
 		}
 	} while (trn);
 
<span
class="add">+	dev_dbg(adev-&gt;dev, &#34;trans_msg req = 0x%x, data1 = 0x%x\n&#34;, req, data1);
</span> 	WREG32_NO_KIQ(mmMAILBOX_MSGBUF_TRN_DW0, req);
 	WREG32_NO_KIQ(mmMAILBOX_MSGBUF_TRN_DW1, data1);
 	WREG32_NO_KIQ(mmMAILBOX_MSGBUF_TRN_DW2, data2);
<span
class="hunk">@@ -147,7 +151,7 @@ static void xgpu_nv_mailbox_trans_msg (struct amdgpu_device *adev,
</span> 	/* start to poll ack */
 	r = xgpu_nv_poll_ack(adev);
 	if (r)
<span
class="del">-		pr_err(&#34;Doesn&#39;t get ack from pf, continue\n&#34;);
</span><span
class="add">+		dev_err(adev-&gt;dev, &#34;Doesn&#39;t get ack from pf, continue\n&#34;);
</span> 
 	xgpu_nv_mailbox_set_valid(adev, false);
 }
<span
class="hunk">@@ -185,7 +189,7 @@ static int xgpu_nv_send_access_requests_with_param(struct amdgpu_device *adev,
</span> 				goto send_request;
 
 			if (req != IDH_REQ_GPU_INIT_DATA) {
<span
class="del">-				pr_err(&#34;Doesn&#39;t get msg:%d from pf, error=%d\n&#34;, event, r);
</span><span
class="add">+				dev_err(adev-&gt;dev, &#34;Doesn&#39;t get msg:%d from pf, error=%d\n&#34;, event, r);
</span> 				return r;
 			} else /* host doesn&#39;t support REQ_GPU_INIT_DATA handshake */
 				adev-&gt;virt.req_init_data_ver = 0;
<span
class="hunk">@@ -261,7 +265,7 @@ static int xgpu_nv_mailbox_ack_irq(struct amdgpu_device *adev,
</span> 					struct amdgpu_irq_src *source,
 					struct amdgpu_iv_entry *entry)
 {
<span
class="del">-	DRM_DEBUG(&#34;get ack intr and do nothing.\n&#34;);
</span><span
class="add">+	dev_dbg(adev-&gt;dev, &#34;get ack intr and do nothing.\n&#34;);
</span> 	return 0;
 }
 
<span
class="hunk">@@ -291,12 +295,15 @@ static int xgpu_nv_wait_reset(struct amdgpu_device *adev)
</span> {
 	int timeout = NV_MAILBOX_POLL_FLR_TIMEDOUT;
 	do {
<span
class="del">-		if (xgpu_nv_mailbox_peek_msg(adev) == IDH_FLR_NOTIFICATION_CMPL)
</span><span
class="add">+		if (xgpu_nv_mailbox_peek_msg(adev) == IDH_FLR_NOTIFICATION_CMPL) {
+			dev_dbg(adev-&gt;dev, &#34;Got NV IDH_FLR_NOTIFICATION_CMPL after %d ms\n&#34;, NV_MAILBOX_POLL_FLR_TIMEDOUT - timeout);
</span> 			return 0;
<span
class="add">+		}
</span> 		msleep(10);
 		timeout -= 10;
 	} while (timeout &gt; 1);
<span
class="del">-	dev_warn(adev-&gt;dev, &#34;waiting IDH_FLR_NOTIFICATION_CMPL timeout\n&#34;);
</span><span
class="add">+
+	dev_dbg(adev-&gt;dev, &#34;waiting NV IDH_FLR_NOTIFICATION_CMPL timeout\n&#34;);
</span> 	return -ETIME;
 }
 
-- 
2.25.1

</pre></div></content></entry><entry><author><name>Sasha Levin</name><email>sashal@kernel.org</email></author><title>[PATCH AUTOSEL 6.9 38/44] drm/amdgpu/pptable: Fix UBSAN array-index-out-of-bounds</title><updated>2024-06-17T13:22:22Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240617132046.2587008-38-sashal@kernel.org/"/><id>urn:uuid:968cd3ed-f8ba-1fb6-c394-47aeb4132e5d</id><thr:in-reply-to
ref="urn:uuid:086ef42f-435b-1f14-e78d-d74ae9b48825"
href="http://lore.kernel.org/amd-gfx/20240617132046.2587008-1-sashal@kernel.org/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Tasos Sahanidis &lt;tasos@tasossah.com&gt;

[ Upstream commit c6c4dd54012551cce5cde408b35468f2c62b0cce ]

Flexible arrays used [1] instead of []. Replace the former with the latter
to resolve multiple UBSAN warnings observed on boot with a BONAIRE card.

In addition, use the __counted_by attribute where possible to hint the
length of the arrays to the compiler and any sanitizers.

Signed-off-by: Tasos Sahanidis &lt;tasos@tasossah.com&gt;
Signed-off-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Signed-off-by: Sasha Levin &lt;sashal@kernel.org&gt;
---
 drivers/gpu/drm/amd/include/pptable.h | 91 ++++++++++++++-------------
 1 file <a href="http://lore.kernel.org/amd-gfx/20240617132046.2587008-38-sashal@kernel.org/#related">changed</a>, 49 insertions(+), 42 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/include/pptable.h b/drivers/gpu/drm/amd/include/pptable.h
index 2e8e6c9875f6c..f83ace2d7ec30 100644
--- a/drivers/gpu/drm/amd/include/pptable.h
+++ b/drivers/gpu/drm/amd/include/pptable.h
</span><span
class="hunk">@@ -477,31 +477,30 @@ typedef struct _ATOM_PPLIB_STATE_V2
</span> } ATOM_PPLIB_STATE_V2;
 
 typedef struct _StateArray{
<span
class="del">-    //how many states we have 
-    UCHAR ucNumEntries;
-    
-    ATOM_PPLIB_STATE_V2 states[1];
</span><span
class="add">+	//how many states we have
+	UCHAR ucNumEntries;
+
+	ATOM_PPLIB_STATE_V2 states[] /* __counted_by(ucNumEntries) */;
</span> }StateArray;
 
 
 typedef struct _ClockInfoArray{
<span
class="del">-    //how many clock levels we have
-    UCHAR ucNumEntries;
-    
-    //sizeof(ATOM_PPLIB_CLOCK_INFO)
-    UCHAR ucEntrySize;
-    
-    UCHAR clockInfo[];
</span><span
class="add">+	//how many clock levels we have
+	UCHAR ucNumEntries;
+
+	//sizeof(ATOM_PPLIB_CLOCK_INFO)
+	UCHAR ucEntrySize;
+
+	UCHAR clockInfo[];
</span> }ClockInfoArray;
 
 typedef struct _NonClockInfoArray{
<span
class="add">+	//how many non-clock levels we have. normally should be same as number of states
+	UCHAR ucNumEntries;
+	//sizeof(ATOM_PPLIB_NONCLOCK_INFO)
+	UCHAR ucEntrySize;
</span> 
<span
class="del">-    //how many non-clock levels we have. normally should be same as number of states
-    UCHAR ucNumEntries;
-    //sizeof(ATOM_PPLIB_NONCLOCK_INFO)
-    UCHAR ucEntrySize;
-    
-    ATOM_PPLIB_NONCLOCK_INFO nonClockInfo[];
</span><span
class="add">+	ATOM_PPLIB_NONCLOCK_INFO nonClockInfo[] __counted_by(ucNumEntries);
</span> }NonClockInfoArray;
 
 typedef struct _ATOM_PPLIB_Clock_Voltage_Dependency_Record
<span
class="hunk">@@ -513,8 +512,10 @@ typedef struct _ATOM_PPLIB_Clock_Voltage_Dependency_Record
</span> 
 typedef struct _ATOM_PPLIB_Clock_Voltage_Dependency_Table
 {
<span
class="del">-    UCHAR ucNumEntries;                                                // Number of entries.
-    ATOM_PPLIB_Clock_Voltage_Dependency_Record entries[1];             // Dynamically allocate entries.
</span><span
class="add">+	// Number of entries.
+	UCHAR ucNumEntries;
+	// Dynamically allocate entries.
+	ATOM_PPLIB_Clock_Voltage_Dependency_Record entries[] __counted_by(ucNumEntries);
</span> }ATOM_PPLIB_Clock_Voltage_Dependency_Table;
 
 typedef struct _ATOM_PPLIB_Clock_Voltage_Limit_Record
<span
class="hunk">@@ -529,8 +530,10 @@ typedef struct _ATOM_PPLIB_Clock_Voltage_Limit_Record
</span> 
 typedef struct _ATOM_PPLIB_Clock_Voltage_Limit_Table
 {
<span
class="del">-    UCHAR ucNumEntries;                                                // Number of entries.
-    ATOM_PPLIB_Clock_Voltage_Limit_Record entries[1];                  // Dynamically allocate entries.
</span><span
class="add">+	// Number of entries.
+	UCHAR ucNumEntries;
+	// Dynamically allocate entries.
+	ATOM_PPLIB_Clock_Voltage_Limit_Record entries[] __counted_by(ucNumEntries);
</span> }ATOM_PPLIB_Clock_Voltage_Limit_Table;
 
 union _ATOM_PPLIB_CAC_Leakage_Record
<span
class="hunk">@@ -553,8 +556,10 @@ typedef union _ATOM_PPLIB_CAC_Leakage_Record ATOM_PPLIB_CAC_Leakage_Record;
</span> 
 typedef struct _ATOM_PPLIB_CAC_Leakage_Table
 {
<span
class="del">-    UCHAR ucNumEntries;                                                 // Number of entries.
-    ATOM_PPLIB_CAC_Leakage_Record entries[1];                           // Dynamically allocate entries.
</span><span
class="add">+	// Number of entries.
+	UCHAR ucNumEntries;
+	// Dynamically allocate entries.
+	ATOM_PPLIB_CAC_Leakage_Record entries[] __counted_by(ucNumEntries);
</span> }ATOM_PPLIB_CAC_Leakage_Table;
 
 typedef struct _ATOM_PPLIB_PhaseSheddingLimits_Record
<span
class="hunk">@@ -568,8 +573,10 @@ typedef struct _ATOM_PPLIB_PhaseSheddingLimits_Record
</span> 
 typedef struct _ATOM_PPLIB_PhaseSheddingLimits_Table
 {
<span
class="del">-    UCHAR ucNumEntries;                                                 // Number of entries.
-    ATOM_PPLIB_PhaseSheddingLimits_Record entries[1];                   // Dynamically allocate entries.
</span><span
class="add">+	// Number of entries.
+	UCHAR ucNumEntries;
+	// Dynamically allocate entries.
+	ATOM_PPLIB_PhaseSheddingLimits_Record entries[] __counted_by(ucNumEntries);
</span> }ATOM_PPLIB_PhaseSheddingLimits_Table;
 
 typedef struct _VCEClockInfo{
<span
class="hunk">@@ -580,8 +587,8 @@ typedef struct _VCEClockInfo{
</span> }VCEClockInfo;
 
 typedef struct _VCEClockInfoArray{
<span
class="del">-    UCHAR ucNumEntries;
-    VCEClockInfo entries[1];
</span><span
class="add">+	UCHAR ucNumEntries;
+	VCEClockInfo entries[] __counted_by(ucNumEntries);
</span> }VCEClockInfoArray;
 
 typedef struct _ATOM_PPLIB_VCE_Clock_Voltage_Limit_Record
<span
class="hunk">@@ -592,8 +599,8 @@ typedef struct _ATOM_PPLIB_VCE_Clock_Voltage_Limit_Record
</span> 
 typedef struct _ATOM_PPLIB_VCE_Clock_Voltage_Limit_Table
 {
<span
class="del">-    UCHAR numEntries;
-    ATOM_PPLIB_VCE_Clock_Voltage_Limit_Record entries[1];
</span><span
class="add">+	UCHAR numEntries;
+	ATOM_PPLIB_VCE_Clock_Voltage_Limit_Record entries[] __counted_by(numEntries);
</span> }ATOM_PPLIB_VCE_Clock_Voltage_Limit_Table;
 
 typedef struct _ATOM_PPLIB_VCE_State_Record
<span
class="hunk">@@ -604,8 +611,8 @@ typedef struct _ATOM_PPLIB_VCE_State_Record
</span> 
 typedef struct _ATOM_PPLIB_VCE_State_Table
 {
<span
class="del">-    UCHAR numEntries;
-    ATOM_PPLIB_VCE_State_Record entries[1];
</span><span
class="add">+	UCHAR numEntries;
+	ATOM_PPLIB_VCE_State_Record entries[] __counted_by(numEntries);
</span> }ATOM_PPLIB_VCE_State_Table;
 
 
<span
class="hunk">@@ -626,8 +633,8 @@ typedef struct _UVDClockInfo{
</span> }UVDClockInfo;
 
 typedef struct _UVDClockInfoArray{
<span
class="del">-    UCHAR ucNumEntries;
-    UVDClockInfo entries[1];
</span><span
class="add">+	UCHAR ucNumEntries;
+	UVDClockInfo entries[] __counted_by(ucNumEntries);
</span> }UVDClockInfoArray;
 
 typedef struct _ATOM_PPLIB_UVD_Clock_Voltage_Limit_Record
<span
class="hunk">@@ -638,8 +645,8 @@ typedef struct _ATOM_PPLIB_UVD_Clock_Voltage_Limit_Record
</span> 
 typedef struct _ATOM_PPLIB_UVD_Clock_Voltage_Limit_Table
 {
<span
class="del">-    UCHAR numEntries;
-    ATOM_PPLIB_UVD_Clock_Voltage_Limit_Record entries[1];
</span><span
class="add">+	UCHAR numEntries;
+	ATOM_PPLIB_UVD_Clock_Voltage_Limit_Record entries[] __counted_by(numEntries);
</span> }ATOM_PPLIB_UVD_Clock_Voltage_Limit_Table;
 
 typedef struct _ATOM_PPLIB_UVD_Table
<span
class="hunk">@@ -657,8 +664,8 @@ typedef struct _ATOM_PPLIB_SAMClk_Voltage_Limit_Record
</span> }ATOM_PPLIB_SAMClk_Voltage_Limit_Record;
 
 typedef struct _ATOM_PPLIB_SAMClk_Voltage_Limit_Table{
<span
class="del">-    UCHAR numEntries;
-    ATOM_PPLIB_SAMClk_Voltage_Limit_Record entries[];
</span><span
class="add">+	UCHAR numEntries;
+	ATOM_PPLIB_SAMClk_Voltage_Limit_Record entries[] __counted_by(numEntries);
</span> }ATOM_PPLIB_SAMClk_Voltage_Limit_Table;
 
 typedef struct _ATOM_PPLIB_SAMU_Table
<span
class="hunk">@@ -675,8 +682,8 @@ typedef struct _ATOM_PPLIB_ACPClk_Voltage_Limit_Record
</span> }ATOM_PPLIB_ACPClk_Voltage_Limit_Record;
 
 typedef struct _ATOM_PPLIB_ACPClk_Voltage_Limit_Table{
<span
class="del">-    UCHAR numEntries;
-    ATOM_PPLIB_ACPClk_Voltage_Limit_Record entries[1];
</span><span
class="add">+	UCHAR numEntries;
+	ATOM_PPLIB_ACPClk_Voltage_Limit_Record entries[] __counted_by(numEntries);
</span> }ATOM_PPLIB_ACPClk_Voltage_Limit_Table;
 
 typedef struct _ATOM_PPLIB_ACP_Table
<span
class="hunk">@@ -743,9 +750,9 @@ typedef struct ATOM_PPLIB_VQ_Budgeting_Record{
</span> } ATOM_PPLIB_VQ_Budgeting_Record;
 
 typedef struct ATOM_PPLIB_VQ_Budgeting_Table {
<span
class="del">-    UCHAR revid;
-    UCHAR numEntries;
-    ATOM_PPLIB_VQ_Budgeting_Record         entries[1];
</span><span
class="add">+	UCHAR revid;
+	UCHAR numEntries;
+	ATOM_PPLIB_VQ_Budgeting_Record entries[] __counted_by(numEntries);
</span> } ATOM_PPLIB_VQ_Budgeting_Table;
 
 #pragma pack()
-- 
2.43.0

</pre></div></content></entry><entry><author><name>Icenowy Zheng</name><email>uwu@icenowy.me</email></author><title>[PATCH 2/2] drm/radeon: repeat the same EOP packet for EOP workaround on CIK</title><updated>2024-06-17T11:14:21Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240617105846.1516006-3-uwu@icenowy.me/"/><id>urn:uuid:1bc5cfcf-92c8-1306-4afa-6fa9601ff9bd</id><thr:in-reply-to
ref="urn:uuid:f06c1431-2419-0bc8-2a26-05c03f28978d"
href="http://lore.kernel.org/amd-gfx/20240617105846.1516006-1-uwu@icenowy.me/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Ths first EOP packet with a sequence number as seq-1 seems to confuse
some PCIe hardware (e.g. Loongson 7A PCHs).

Use the real sequence number instead.

Fixes: a9c73a0e022c (&#34;drm/radeon: workaround for CP HW bug on CIK&#34;)
Signed-off-by: Icenowy Zheng &lt;uwu@icenowy.me&gt;
---
 drivers/gpu/drm/radeon/cik.c | 7 ++-----
 1 file <a href="http://lore.kernel.org/amd-gfx/20240617105846.1516006-3-uwu@icenowy.me/#related">changed</a>, 2 insertions(+), 5 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/radeon/cik.c b/drivers/gpu/drm/radeon/cik.c
index 8275eeba0b349..9d203054f922a 100644
--- a/drivers/gpu/drm/radeon/cik.c
+++ b/drivers/gpu/drm/radeon/cik.c
</span><span
class="hunk">@@ -3543,9 +3543,7 @@ void cik_fence_gfx_ring_emit(struct radeon_device *rdev,
</span> 	struct radeon_ring *ring = &#38;rdev-&gt;ring[fence-&gt;ring];
 	u64 addr = rdev-&gt;fence_drv[fence-&gt;ring].gpu_addr;
 
<span
class="del">-	/* Workaround for cache flush problems. First send a dummy EOP
-	 * event down the pipe with seq one below.
-	 */
</span><span
class="add">+	/* Workaround for cache flush problems by sending the EOP event twice */
</span> 	radeon_ring_write(ring, PACKET3(PACKET3_EVENT_WRITE_EOP, 4));
 	radeon_ring_write(ring, (EOP_TCL1_ACTION_EN |
 				 EOP_TC_ACTION_EN |
<span
class="hunk">@@ -3554,10 +3552,9 @@ void cik_fence_gfx_ring_emit(struct radeon_device *rdev,
</span> 	radeon_ring_write(ring, addr &#38; 0xfffffffc);
 	radeon_ring_write(ring, (upper_32_bits(addr) &#38; 0xffff) |
 				DATA_SEL(1) | INT_SEL(0));
<span
class="del">-	radeon_ring_write(ring, fence-&gt;seq - 1);
</span><span
class="add">+	radeon_ring_write(ring, fence-&gt;seq);
</span> 	radeon_ring_write(ring, 0);
 
<span
class="del">-	/* Then send the real EOP event down the pipe. */
</span> 	radeon_ring_write(ring, PACKET3(PACKET3_EVENT_WRITE_EOP, 4));
 	radeon_ring_write(ring, (EOP_TCL1_ACTION_EN |
 				 EOP_TC_ACTION_EN |
-- 
2.45.1

</pre></div></content></entry><entry><author><name>Icenowy Zheng</name><email>uwu@icenowy.me</email></author><title>[PATCH 1/2] drm/amdgpu: make duplicated EOP packet for GFX7/8 have real content</title><updated>2024-06-17T11:14:19Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240617105846.1516006-2-uwu@icenowy.me/"/><id>urn:uuid:298b980f-ccbc-1760-a461-acf188e1b204</id><thr:in-reply-to
ref="urn:uuid:f06c1431-2419-0bc8-2a26-05c03f28978d"
href="http://lore.kernel.org/amd-gfx/20240617105846.1516006-1-uwu@icenowy.me/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The duplication of EOP packets for GFX7/8, with the former one have
seq-1 written and the latter one have seq written, seems to confuse some
hardware platform (e.g. Loongson 7A series PCIe controllers).

Make the content of the duplicated EOP packet the same with the real
one, only masking any possible interrupts.

Fixes: bf26da927a1c (&#34;drm/amdgpu: add cache flush workaround to gfx8 emit_fence&#34;)
Fixes: a2e73f56fa62 (&#34;drm/amdgpu: Add support for CIK parts&#34;)
Signed-off-by: Icenowy Zheng &lt;uwu@icenowy.me&gt;
---
 drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c | 12 +++++-------
 drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c | 12 ++++--------
 2 files <a href="http://lore.kernel.org/amd-gfx/20240617105846.1516006-2-uwu@icenowy.me/#related">changed</a>, 9 insertions(+), 15 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c b/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c
index 541dbd70d8c75..778f27f1a34fe 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c
</span><span
class="hunk">@@ -2117,9 +2117,8 @@ static void gfx_v7_0_ring_emit_fence_gfx(struct amdgpu_ring *ring, u64 addr,
</span> {
 	bool write64bit = flags &#38; AMDGPU_FENCE_FLAG_64BIT;
 	bool int_sel = flags &#38; AMDGPU_FENCE_FLAG_INT;
<span
class="del">-	/* Workaround for cache flush problems. First send a dummy EOP
-	 * event down the pipe with seq one below.
-	 */
</span><span
class="add">+
+	/* Workaround for cache flush problems, send EOP twice. */
</span> 	amdgpu_ring_write(ring, PACKET3(PACKET3_EVENT_WRITE_EOP, 4));
 	amdgpu_ring_write(ring, (EOP_TCL1_ACTION_EN |
 				 EOP_TC_ACTION_EN |
<span
class="hunk">@@ -2127,11 +2126,10 @@ static void gfx_v7_0_ring_emit_fence_gfx(struct amdgpu_ring *ring, u64 addr,
</span> 				 EVENT_INDEX(5)));
 	amdgpu_ring_write(ring, addr &#38; 0xfffffffc);
 	amdgpu_ring_write(ring, (upper_32_bits(addr) &#38; 0xffff) |
<span
class="del">-				DATA_SEL(1) | INT_SEL(0));
-	amdgpu_ring_write(ring, lower_32_bits(seq - 1));
-	amdgpu_ring_write(ring, upper_32_bits(seq - 1));
</span><span
class="add">+				DATA_SEL(write64bit ? 2 : 1) | INT_SEL(0));
+	amdgpu_ring_write(ring, lower_32_bits(seq));
+	amdgpu_ring_write(ring, upper_32_bits(seq));
</span> 
<span
class="del">-	/* Then send the real EOP event down the pipe. */
</span> 	amdgpu_ring_write(ring, PACKET3(PACKET3_EVENT_WRITE_EOP, 4));
 	amdgpu_ring_write(ring, (EOP_TCL1_ACTION_EN |
 				 EOP_TC_ACTION_EN |
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c b/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c
index 2f0e72caee1af..39a7d60f1fd69 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c
</span><span
class="hunk">@@ -6153,9 +6153,7 @@ static void gfx_v8_0_ring_emit_fence_gfx(struct amdgpu_ring *ring, u64 addr,
</span> 	bool write64bit = flags &#38; AMDGPU_FENCE_FLAG_64BIT;
 	bool int_sel = flags &#38; AMDGPU_FENCE_FLAG_INT;
 
<span
class="del">-	/* Workaround for cache flush problems. First send a dummy EOP
-	 * event down the pipe with seq one below.
-	 */
</span><span
class="add">+	/* Workaround for cache flush problems, send EOP twice. */
</span> 	amdgpu_ring_write(ring, PACKET3(PACKET3_EVENT_WRITE_EOP, 4));
 	amdgpu_ring_write(ring, (EOP_TCL1_ACTION_EN |
 				 EOP_TC_ACTION_EN |
<span
class="hunk">@@ -6164,12 +6162,10 @@ static void gfx_v8_0_ring_emit_fence_gfx(struct amdgpu_ring *ring, u64 addr,
</span> 				 EVENT_INDEX(5)));
 	amdgpu_ring_write(ring, addr &#38; 0xfffffffc);
 	amdgpu_ring_write(ring, (upper_32_bits(addr) &#38; 0xffff) |
<span
class="del">-				DATA_SEL(1) | INT_SEL(0));
-	amdgpu_ring_write(ring, lower_32_bits(seq - 1));
-	amdgpu_ring_write(ring, upper_32_bits(seq - 1));
</span><span
class="add">+			  DATA_SEL(write64bit ? 2 : 1) | INT_SEL(0));
+	amdgpu_ring_write(ring, lower_32_bits(seq));
+	amdgpu_ring_write(ring, upper_32_bits(seq));
</span> 
<span
class="del">-	/* Then send the real EOP event down the pipe:
-	 * EVENT_WRITE_EOP - flush caches, send int */
</span> 	amdgpu_ring_write(ring, PACKET3(PACKET3_EVENT_WRITE_EOP, 4));
 	amdgpu_ring_write(ring, (EOP_TCL1_ACTION_EN |
 				 EOP_TC_ACTION_EN |
-- 
2.45.1

</pre></div></content></entry><entry><author><name>Icenowy Zheng</name><email>uwu@icenowy.me</email></author><title>[PATCH 0/2] Fixes of AMD GFX7/8 hang on Loongson platforms</title><updated>2024-06-17T11:14:12Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240617105846.1516006-1-uwu@icenowy.me/"/><id>urn:uuid:f06c1431-2419-0bc8-2a26-05c03f28978d</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This patchset tries to fix some workaround code in amdgpu/radeon driver,
that makes Loongson 3A+7A platform suffering from GPU crashes.

Icenowy Zheng (2):
  drm/amdgpu: make duplicated EOP packet for GFX7/8 have real content
  drm/radeon: repeat the same EOP packet for EOP workaround on CIK

 drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c | 12 +++++-------
 drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c | 12 ++++--------
 drivers/gpu/drm/radeon/cik.c          |  7 ++-----
 3 files changed, 11 insertions(+), 20 deletions(-)

-- 
2.45.1

</pre></div></content></entry><entry><author><name>Jane Jian</name><email>Jane.Jian@amd.com</email></author><title>[PATCH] drm/amdgpu: normalize registers as local xcc to read/write under sriov</title><updated>2024-06-17T10:11:22Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240617101114.243566-1-Jane.Jian@amd.com/"/><id>urn:uuid:012077a7-52b7-5b6f-1325-90154fdd7416</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHY]
sriov has the higher bit violation when flushing tlb

[HOW]
normalize the registers to keep lower 16-bit(dword aligned) to aviod higher bit violation
RLCG will mask xcd out and always assume it&#39;s accessing its own xcd

also fix the typo in sriov_w/rreg:
for KIQ case, use xcc with xcc_id to read and write

v2
amend some typos

Signed-off-by: Jane Jian &lt;Jane.Jian@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c  | 12 ++++++++++--
 drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c     |  8 ++++++--
 drivers/gpu/drm/amd/amdgpu/soc15_common.h |  2 ++
 3 files <a href="http://lore.kernel.org/amd-gfx/20240617101114.243566-1-Jane.Jian@amd.com/#related">changed</a>, 18 insertions(+), 4 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c
index 63f2286858c4..d43652a38484 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c
</span><span
class="hunk">@@ -1075,6 +1075,10 @@ void amdgpu_sriov_wreg(struct amdgpu_device *adev,
</span> 	if (amdgpu_device_skip_hw_access(adev))
 		return;
 
<span
class="add">+	/* Select lower 16 bits to write in local xcc */
+	if ((hwip == GC_HWIP) &#38;&#38; !(acc_flags &#38; AMDGPU_REGS_NO_KIQ))
+		offset = NORMALIZE_XCC_REG_OFFSET(offset);
+
</span> 	if (!amdgpu_sriov_runtime(adev) &#38;&#38;
 		amdgpu_virt_get_rlcg_reg_access_flag(adev, acc_flags, hwip, true, &#38;rlcg_flag)) {
 		amdgpu_virt_rlcg_reg_rw(adev, offset, value, rlcg_flag, xcc_id);
<span
class="hunk">@@ -1084,7 +1088,7 @@ void amdgpu_sriov_wreg(struct amdgpu_device *adev,
</span> 	if (acc_flags &#38; AMDGPU_REGS_NO_KIQ)
 		WREG32_NO_KIQ(offset, value);
 	else
<span
class="del">-		WREG32(offset, value);
</span><span
class="add">+		WREG32_XCC(offset, value, xcc_id);
</span> }
 
 u32 amdgpu_sriov_rreg(struct amdgpu_device *adev,
<span
class="hunk">@@ -1095,6 +1099,10 @@ u32 amdgpu_sriov_rreg(struct amdgpu_device *adev,
</span> 	if (amdgpu_device_skip_hw_access(adev))
 		return 0;
 
<span
class="add">+	/* Select lower 16 bits to read in local xcc */
+	if ((hwip == GC_HWIP) &#38;&#38; !(acc_flags &#38; AMDGPU_REGS_NO_KIQ))
+		offset = NORMALIZE_XCC_REG_OFFSET(offset);
+
</span> 	if (!amdgpu_sriov_runtime(adev) &#38;&#38;
 		amdgpu_virt_get_rlcg_reg_access_flag(adev, acc_flags, hwip, false, &#38;rlcg_flag))
 		return amdgpu_virt_rlcg_reg_rw(adev, offset, 0, rlcg_flag, xcc_id);
<span
class="hunk">@@ -1102,7 +1110,7 @@ u32 amdgpu_sriov_rreg(struct amdgpu_device *adev,
</span> 	if (acc_flags &#38; AMDGPU_REGS_NO_KIQ)
 		return RREG32_NO_KIQ(offset);
 	else
<span
class="del">-		return RREG32(offset);
</span><span
class="add">+		return RREG32_XCC(offset, xcc_id);
</span> }
 
 bool amdgpu_sriov_xnack_support(struct amdgpu_device *adev)
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
index 88b4644f8e96..5bb275b96e6a 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
</span><span
class="hunk">@@ -853,8 +853,12 @@ static void gmc_v9_0_flush_gpu_tlb(struct amdgpu_device *adev, uint32_t vmid,
</span> 	 */
 	if (adev-&gt;gfx.kiq[inst].ring.sched.ready &#38;&#38;
 	    (amdgpu_sriov_runtime(adev) || !amdgpu_sriov_vf(adev))) {
<span
class="del">-		uint32_t req = hub-&gt;vm_inv_eng0_req + hub-&gt;eng_distance * eng;
-		uint32_t ack = hub-&gt;vm_inv_eng0_ack + hub-&gt;eng_distance * eng;
</span><span
class="add">+
+		/* Select lower 16 bits to write in local xcc */
+		if (AMDGPU_IS_GFXHUB(vmhub)) {
+			req = NORMALIZE_XCC_REG_OFFSET(req);
+			ack = NORMALIZE_XCC_REG_OFFSET(ack);
+		}
</span> 
 		amdgpu_gmc_fw_reg_write_reg_wait(adev, req, ack, inv_req,
 						 1 &lt;&lt; vmid, inst);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/soc15_common.h b/drivers/gpu/drm/amd/amdgpu/soc15_common.h
index 242b24f73c17..9ddf68e7d06e 100644
--- a/drivers/gpu/drm/amd/amdgpu/soc15_common.h
+++ b/drivers/gpu/drm/amd/amdgpu/soc15_common.h
</span><span
class="hunk">@@ -210,4 +210,6 @@
</span> #define WREG64_MCA(ext, mca_base, idx, val) \
 	WREG64_PCIE_EXT(adev-&gt;asic_funcs-&gt;encode_ext_smn_addressing(ext) + mca_base + (idx * 8), val)
 
<span
class="add">+#define NORMALIZE_XCC_REG_OFFSET(offset) (offset &#38; 0xffff)
+
</span> #endif
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Jane Jian</name><email>Jane.Jian@amd.com</email></author><title>[PATCH] drm/amdgpu: normalize registers as local xcc to read/write under sriov</title><updated>2024-06-17T09:50:01Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240617094954.243360-1-Jane.Jian@amd.com/"/><id>urn:uuid:59f29581-baba-fa31-fcdf-2a2e4edbb2c5</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHY]
sriov has the higher bit violation when flushing tlb

[HOW]
normalize the registers to keep lower 16-bit(dword aligned) to aviod higher bit violation
RLCG will mask xcd out and always assume it&#39;s accessing its own xcd

also fix the typo in sriov_w/rreg:
for KIQ case, use xcc with xcc_id to read and write

Signed-off-by: Jane Jian &lt;Jane.Jian@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c  | 12 ++++++++++--
 drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c     |  9 +++++++--
 drivers/gpu/drm/amd/amdgpu/soc15_common.h |  2 ++
 3 files <a href="http://lore.kernel.org/amd-gfx/20240617094954.243360-1-Jane.Jian@amd.com/#related">changed</a>, 19 insertions(+), 4 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c
index 63f2286858c4..d43652a38484 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c
</span><span
class="hunk">@@ -1075,6 +1075,10 @@ void amdgpu_sriov_wreg(struct amdgpu_device *adev,
</span> 	if (amdgpu_device_skip_hw_access(adev))
 		return;
 
<span
class="add">+	/* Select lower 16 bits to write in local xcc */
+	if ((hwip == GC_HWIP) &#38;&#38; !(acc_flags &#38; AMDGPU_REGS_NO_KIQ))
+		offset = NORMALIZE_XCC_REG_OFFSET(offset);
+
</span> 	if (!amdgpu_sriov_runtime(adev) &#38;&#38;
 		amdgpu_virt_get_rlcg_reg_access_flag(adev, acc_flags, hwip, true, &#38;rlcg_flag)) {
 		amdgpu_virt_rlcg_reg_rw(adev, offset, value, rlcg_flag, xcc_id);
<span
class="hunk">@@ -1084,7 +1088,7 @@ void amdgpu_sriov_wreg(struct amdgpu_device *adev,
</span> 	if (acc_flags &#38; AMDGPU_REGS_NO_KIQ)
 		WREG32_NO_KIQ(offset, value);
 	else
<span
class="del">-		WREG32(offset, value);
</span><span
class="add">+		WREG32_XCC(offset, value, xcc_id);
</span> }
 
 u32 amdgpu_sriov_rreg(struct amdgpu_device *adev,
<span
class="hunk">@@ -1095,6 +1099,10 @@ u32 amdgpu_sriov_rreg(struct amdgpu_device *adev,
</span> 	if (amdgpu_device_skip_hw_access(adev))
 		return 0;
 
<span
class="add">+	/* Select lower 16 bits to read in local xcc */
+	if ((hwip == GC_HWIP) &#38;&#38; !(acc_flags &#38; AMDGPU_REGS_NO_KIQ))
+		offset = NORMALIZE_XCC_REG_OFFSET(offset);
+
</span> 	if (!amdgpu_sriov_runtime(adev) &#38;&#38;
 		amdgpu_virt_get_rlcg_reg_access_flag(adev, acc_flags, hwip, false, &#38;rlcg_flag))
 		return amdgpu_virt_rlcg_reg_rw(adev, offset, 0, rlcg_flag, xcc_id);
<span
class="hunk">@@ -1102,7 +1110,7 @@ u32 amdgpu_sriov_rreg(struct amdgpu_device *adev,
</span> 	if (acc_flags &#38; AMDGPU_REGS_NO_KIQ)
 		return RREG32_NO_KIQ(offset);
 	else
<span
class="del">-		return RREG32(offset);
</span><span
class="add">+		return RREG32_XCC(offset, xcc_id);
</span> }
 
 bool amdgpu_sriov_xnack_support(struct amdgpu_device *adev)
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
index 88b4644f8e96..e6c2fcf452d3 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
</span><span
class="hunk">@@ -853,8 +853,13 @@ static void gmc_v9_0_flush_gpu_tlb(struct amdgpu_device *adev, uint32_t vmid,
</span> 	 */
 	if (adev-&gt;gfx.kiq[inst].ring.sched.ready &#38;&#38;
 	    (amdgpu_sriov_runtime(adev) || !amdgpu_sriov_vf(adev))) {
<span
class="del">-		uint32_t req = hub-&gt;vm_inv_eng0_req + hub-&gt;eng_distance * eng;
-		uint32_t ack = hub-&gt;vm_inv_eng0_ack + hub-&gt;eng_distance * eng;
</span><span
class="add">+
+		/* Select lower 16 bits to write in local xcc */
+		if (AMDGPU_IS_GFXHUB(vmhub))
+		{
+			req = NORMALIZE_XCC_REG_OFFSET(req);
+			ack = NORMALIZE_XCC_REG_OFFSET(ack);
+		}
</span> 
 		amdgpu_gmc_fw_reg_write_reg_wait(adev, req, ack, inv_req,
 						 1 &lt;&lt; vmid, inst);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/soc15_common.h b/drivers/gpu/drm/amd/amdgpu/soc15_common.h
index 242b24f73c17..9ddf68e7d06e 100644
--- a/drivers/gpu/drm/amd/amdgpu/soc15_common.h
+++ b/drivers/gpu/drm/amd/amdgpu/soc15_common.h
</span><span
class="hunk">@@ -210,4 +210,6 @@
</span> #define WREG64_MCA(ext, mca_base, idx, val) \
 	WREG64_PCIE_EXT(adev-&gt;asic_funcs-&gt;encode_ext_smn_addressing(ext) + mca_base + (idx * 8), val)
 
<span
class="add">+#define NORMALIZE_XCC_REG_OFFSET(offset) (offset &#38; 0xffff)
+
</span> #endif
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Thomas Wei&#223;schuh</name><email>linux@weissschuh.net</email></author><title>[PATCH] drm/amdgpu: convert bios_hardcoded_edid to drm_edid</title><updated>2024-06-17T07:15:00Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240616-amdgpu-edid-bios-v1-1-2874f212b365@weissschuh.net/"/><id>urn:uuid:74c3257c-51b1-beec-3cae-ddcb62886368</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Instead of manually passing around &#39;struct edid *&#39; and its size,
use &#39;struct drm_edid&#39;, which encapsulates a validated combination of
both.

As the drm_edid_ can handle NULL gracefully, the explicit checks can be
dropped.

Also save a few characters by transforming &#39;&#38;array[0]&#39; to the equivalent
&#39;array&#39; and using &#39;max_t(int, ...)&#39; instead of manual casts.

Signed-off-by: Thomas Wei&#223;schuh &lt;linux@weissschuh.net&gt;
---
While this patch introduces a new user for drm_edid_raw(),
if amdgpu proper gets migrated to &#39;struct drm_edid&#39;, that usage will go
away.

This is only compile-tested.

I have some more patches for the rest of amdgpu,
to move to &#39;struct drm_edid&#39;.
This patch is a test-balloon for the general idea.

The same can also be done for drm/radeon.
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c |  6 +-----
 drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h       |  4 ++--
 drivers/gpu/drm/amd/amdgpu/amdgpu_vkms.c       |  2 +-
 drivers/gpu/drm/amd/amdgpu/atombios_encoders.c | 21 +++++++--------------
 drivers/gpu/drm/amd/amdgpu/dce_v10_0.c         |  2 +-
 drivers/gpu/drm/amd/amdgpu/dce_v11_0.c         |  2 +-
 drivers/gpu/drm/amd/amdgpu/dce_v6_0.c          |  2 +-
 drivers/gpu/drm/amd/amdgpu/dce_v8_0.c          |  2 +-
 8 files <a href="http://lore.kernel.org/amd-gfx/20240616-amdgpu-edid-bios-v1-1-2874f212b365@weissschuh.net/#related">changed</a>, 15 insertions(+), 26 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c
index 9caba10315a8..f1b11b27cce0 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c
</span><span
class="hunk">@@ -265,11 +265,7 @@ struct edid *amdgpu_connector_edid(struct drm_connector *connector)
</span> static struct edid *
 amdgpu_connector_get_hardcoded_edid(struct amdgpu_device *adev)
 {
<span
class="del">-	if (adev-&gt;mode_info.bios_hardcoded_edid) {
-		return kmemdup((unsigned char *)adev-&gt;mode_info.bios_hardcoded_edid,
-			       adev-&gt;mode_info.bios_hardcoded_edid_size, GFP_KERNEL);
-	}
-	return NULL;
</span><span
class="add">+	return drm_edid_duplicate(drm_edid_raw(adev-&gt;mode_info.bios_hardcoded_edid));
</span> }
 
 static void amdgpu_connector_get_edid(struct drm_connector *connector)
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
index 1fe21a70ddd0..928ac3f1e2ba 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
</span><span
class="hunk">@@ -51,6 +51,7 @@ struct amdgpu_encoder;
</span> struct amdgpu_router;
 struct amdgpu_hpd;
 struct edid;
<span
class="add">+struct drm_edid;
</span> 
 #define to_amdgpu_crtc(x) container_of(x, struct amdgpu_crtc, base)
 #define to_amdgpu_connector(x) container_of(x, struct amdgpu_connector, base)
<span
class="hunk">@@ -325,8 +326,7 @@ struct amdgpu_mode_info {
</span> 	/* FMT dithering */
 	struct drm_property *dither_property;
 	/* hardcoded DFP edid from BIOS */
<span
class="del">-	struct edid *bios_hardcoded_edid;
-	int bios_hardcoded_edid_size;
</span><span
class="add">+	const struct drm_edid *bios_hardcoded_edid;
</span> 
 	/* firmware flags */
 	u32 firmware_flags;
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vkms.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vkms.c
index e30eecd02ae1..543275db8302 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vkms.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vkms.c
</span><span
class="hunk">@@ -539,7 +539,7 @@ static int amdgpu_vkms_sw_fini(void *handle)
</span> 
 	adev-&gt;mode_info.mode_config_initialized = false;
 
<span
class="del">-	kfree(adev-&gt;mode_info.bios_hardcoded_edid);
</span><span
class="add">+	drm_edid_free(adev-&gt;mode_info.bios_hardcoded_edid);
</span> 	kfree(adev-&gt;amdgpu_vkms_output);
 	return 0;
 }
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c b/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c
index 25feab188dfe..90383094ed1e 100644
--- a/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c
+++ b/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c
</span><span
class="hunk">@@ -2064,20 +2064,13 @@ amdgpu_atombios_encoder_get_lcd_info(struct amdgpu_encoder *encoder)
</span> 				case LCD_FAKE_EDID_PATCH_RECORD_TYPE:
 					fake_edid_record = (ATOM_FAKE_EDID_PATCH_RECORD *)record;
 					if (fake_edid_record-&gt;ucFakeEDIDLength) {
<span
class="del">-						struct edid *edid;
-						int edid_size =
-							max((int)EDID_LENGTH, (int)fake_edid_record-&gt;ucFakeEDIDLength);
-						edid = kmalloc(edid_size, GFP_KERNEL);
-						if (edid) {
-							memcpy((u8 *)edid, (u8 *)&#38;fake_edid_record-&gt;ucFakeEDIDString[0],
-							       fake_edid_record-&gt;ucFakeEDIDLength);
-
-							if (drm_edid_is_valid(edid)) {
-								adev-&gt;mode_info.bios_hardcoded_edid = edid;
-								adev-&gt;mode_info.bios_hardcoded_edid_size = edid_size;
-							} else
-								kfree(edid);
-						}
</span><span
class="add">+						const struct drm_edid *edid;
+						edid = drm_edid_alloc(fake_edid_record-&gt;ucFakeEDIDString,
+								      max_t(int, EDID_LENGTH, fake_edid_record-&gt;ucFakeEDIDLength));
+						if (drm_edid_valid(edid))
+							adev-&gt;mode_info.bios_hardcoded_edid = edid;
+						else
+							drm_edid_free(edid);
</span> 					}
 					record += fake_edid_record-&gt;ucFakeEDIDLength ?
 						  struct_size(fake_edid_record,
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c
index b44fce44c066..11d648e688ce 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c
</span><span
class="hunk">@@ -2846,7 +2846,7 @@ static int dce_v10_0_sw_fini(void *handle)
</span> {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
<span
class="del">-	kfree(adev-&gt;mode_info.bios_hardcoded_edid);
</span><span
class="add">+	drm_edid_free(adev-&gt;mode_info.bios_hardcoded_edid);
</span> 
 	drm_kms_helper_poll_fini(adev_to_drm(adev));
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c
index 80b2e7f79acf..01536f523032 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c
</span><span
class="hunk">@@ -2973,7 +2973,7 @@ static int dce_v11_0_sw_fini(void *handle)
</span> {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
<span
class="del">-	kfree(adev-&gt;mode_info.bios_hardcoded_edid);
</span><span
class="add">+	drm_edid_free(adev-&gt;mode_info.bios_hardcoded_edid);
</span> 
 	drm_kms_helper_poll_fini(adev_to_drm(adev));
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v6_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v6_0.c
index db20012600f5..0e5b568a96fc 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v6_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v6_0.c
</span><span
class="hunk">@@ -2745,7 +2745,7 @@ static int dce_v6_0_sw_fini(void *handle)
</span> {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
<span
class="del">-	kfree(adev-&gt;mode_info.bios_hardcoded_edid);
</span><span
class="add">+	drm_edid_free(adev-&gt;mode_info.bios_hardcoded_edid);
</span> 
 	drm_kms_helper_poll_fini(adev_to_drm(adev));
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
index 5b56100ec902..895f050a3e62 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
</span><span
class="hunk">@@ -2766,7 +2766,7 @@ static int dce_v8_0_sw_fini(void *handle)
</span> {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
<span
class="del">-	kfree(adev-&gt;mode_info.bios_hardcoded_edid);
</span><span
class="add">+	drm_edid_free(adev-&gt;mode_info.bios_hardcoded_edid);
</span> 
 	drm_kms_helper_poll_fini(adev_to_drm(adev));
 

<span
class="del">---
</span>base-commit: a3e18a540541325a8c8848171f71e0d45ad30b2c
change-id: 20240616-amdgpu-edid-bios-a31aa16b0321

Best regards,
-- 
Thomas Wei&#223;schuh &lt;linux@weissschuh.net&gt;

</pre></div></content></entry><entry><author><name>Srinivasan Shanmugam</name><email>srinivasan.shanmugam@amd.com</email></author><title>[PATCH] drm/amdgpu: Add NULL check for imu.funcs in gfx_v11_0_rlc_backdoor_autoload_enable</title><updated>2024-06-15T12:33:49Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240615123322.2683117-1-srinivasan.shanmugam@amd.com/"/><id>urn:uuid:b33fa979-3920-cffb-a103-733ac11957ff</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This commit adds a null check for `adev-&gt;gfx.imu.funcs` in the
`gfx_v11_0_rlc_backdoor_autoload_enable` function. This prevents
potential null pointer dereferences when calling the `load_microcode`,
`setup_imu`, and `start_imu` functions.

Previously, if `adev-&gt;gfx.imu.funcs` was null, it could lead to a null
pointer dereference. With this change, these function calls are   only
made if `adev-&gt;gfx.imu.funcs` is not null.

Fixes the below:
drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c:4503 gfx_v11_0_hw_init()
error: we previously assumed &#39;adev-&gt;gfx.imu.funcs&#39; could be null (see line 4497)

drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c
    4491 static int gfx_v11_0_hw_init(void *handle)
    4492 {
    4493         int r;
    4494         struct amdgpu_device *adev = (struct amdgpu_device *)handle;
    4495
    4496         if (adev-&gt;firmware.load_type == AMDGPU_FW_LOAD_RLC_BACKDOOR_AUTO) {
    4497                 if (adev-&gt;gfx.imu.funcs) {
                             ^^^^^^^^^^^^^^^^^^^ Check for NULL

    4498                         /* RLC autoload sequence 1: Program rlc ram */
    4499                         if (adev-&gt;gfx.imu.funcs-&gt;program_rlc_ram)
    4500                                 adev-&gt;gfx.imu.funcs-&gt;program_rlc_ram(adev);
    4501                 }
    4502                 /* rlc autoload firmware */
--&gt; 4503                 r = gfx_v11_0_rlc_backdoor_autoload_enable(adev);
                                                                    ^^^^ Unchecked dereference inside the function.
    4505                         return r;
    4506         } else {

Fixes: 3d879e81f0f9 (&#34;drm/amdgpu: add init support for GFX11 (v2)&#34;)
Reported-by: Dan Carpenter &lt;dan.carpenter@linaro.org&gt;
Cc: Hawking Zhang &lt;Hawking.Zhang@amd.com&gt;
Cc: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Cc: Christian K&#246;nig &lt;christian.koenig@amd.com&gt;
Signed-off-by: Srinivasan Shanmugam &lt;srinivasan.shanmugam@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c | 18 ++++++++++--------
 1 file <a href="http://lore.kernel.org/amd-gfx/20240615123322.2683117-1-srinivasan.shanmugam@amd.com/#related">changed</a>, 10 insertions(+), 8 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c b/drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c
index 2a510351dfce..4af4567ba197 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c
</span><span
class="hunk">@@ -1459,14 +1459,16 @@ static int gfx_v11_0_rlc_backdoor_autoload_enable(struct amdgpu_device *adev)
</span> 
 	WREG32_SOC15(GC, 0, regGFX_IMU_RLC_BOOTLOADER_SIZE, rlc_g_size);
 
<span
class="del">-	/* RLC autoload sequence 3: load IMU fw */
-	if (adev-&gt;gfx.imu.funcs-&gt;load_microcode)
-		adev-&gt;gfx.imu.funcs-&gt;load_microcode(adev);
-	/* RLC autoload sequence 4 init IMU fw */
-	if (adev-&gt;gfx.imu.funcs-&gt;setup_imu)
-		adev-&gt;gfx.imu.funcs-&gt;setup_imu(adev);
-	if (adev-&gt;gfx.imu.funcs-&gt;start_imu)
-		adev-&gt;gfx.imu.funcs-&gt;start_imu(adev);
</span><span
class="add">+	if (adev-&gt;gfx.imu.funcs) {
+		/* RLC autoload sequence 3: load IMU fw */
+		if (adev-&gt;gfx.imu.funcs-&gt;load_microcode)
+			adev-&gt;gfx.imu.funcs-&gt;load_microcode(adev);
+		/* RLC autoload sequence 4 init IMU fw */
+		if (adev-&gt;gfx.imu.funcs-&gt;setup_imu)
+			adev-&gt;gfx.imu.funcs-&gt;setup_imu(adev);
+		if (adev-&gt;gfx.imu.funcs-&gt;start_imu)
+			adev-&gt;gfx.imu.funcs-&gt;start_imu(adev);
+	}
</span> 
 	/* RLC autoload sequence 5 disable gpa mode */
 	gfx_v11_0_disable_gpa_mode(adev);
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Mukul Joshi</name><email>mukul.joshi@amd.com</email></author><title
type="html">[PATCH] Revert &#34;drm/amdgpu: Add missing locking for MES API calls&#34;</title><updated>2024-06-14T21:25:51Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240614212531.195093-1-mukul.joshi@amd.com/"/><id>urn:uuid:d5c823d8-a973-3bb4-68e5-db343d644273</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This reverts commit aa68f57443c5aed125079ae66fef0e9fd7008b33.

This is causing a BUG message during suspend.

[   61.603542] BUG: sleeping function called from invalid context at kernel/locking/mutex.c:283
[   61.603550] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 2028, name: kworker/u64:14
[   61.603553] preempt_count: 1, expected: 0
[   61.603555] RCU nest depth: 0, expected: 0
[   61.603557] Preemption disabled at:
[   61.603559] [&lt;ffffffffc08a3261&gt;] amdgpu_gfx_disable_kgq+0x61/0x160 [amdgpu]
[   61.603789] CPU: 9 PID: 2028 Comm: kworker/u64:14 Tainted: G        W          6.8.0+ #7
[   61.603795] Workqueue: events_unbound async_run_entry_fn
[   61.603801] Call Trace:
[   61.603803]  &lt;TASK&gt;
[   61.603806]  dump_stack_lvl+0x37/0x50
[   61.603811]  ? amdgpu_gfx_disable_kgq+0x61/0x160 [amdgpu]
[   61.604007]  dump_stack+0x10/0x20
[   61.604010]  __might_resched+0x16f/0x1d0
[   61.604016]  __might_sleep+0x43/0x70
[   61.604020]  mutex_lock+0x1f/0x60
[   61.604024]  amdgpu_mes_unmap_legacy_queue+0x6d/0x100 [amdgpu]
[   61.604226]  gfx11_kiq_unmap_queues+0x3dc/0x430 [amdgpu]
[   61.604422]  ? srso_alias_return_thunk+0x5/0xfbef5
[   61.604429]  amdgpu_gfx_disable_kgq+0x122/0x160 [amdgpu]
[   61.604621]  gfx_v11_0_hw_fini+0xda/0x100 [amdgpu]
[   61.604814]  gfx_v11_0_suspend+0xe/0x20 [amdgpu]
[   61.605008]  amdgpu_device_ip_suspend_phase2+0x135/0x1d0 [amdgpu]
[   61.605175]  amdgpu_device_suspend+0xec/0x180 [amdgpu]

Signed-off-by: Mukul Joshi &lt;mukul.joshi@amd.com&gt;
Reviewed-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_mes.c | 12 ------------
 1 file <a href="http://lore.kernel.org/amd-gfx/20240614212531.195093-1-mukul.joshi@amd.com/#related">changed</a>, 12 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_mes.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_mes.c
index 1a65ced60e68..48a5b0713fed 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_mes.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_mes.c
</span><span
class="hunk">@@ -801,9 +801,7 @@ int amdgpu_mes_map_legacy_queue(struct amdgpu_device *adev,
</span> 	queue_input.mqd_addr = amdgpu_bo_gpu_offset(ring-&gt;mqd_obj);
 	queue_input.wptr_addr = ring-&gt;wptr_gpu_addr;
 
<span
class="del">-	amdgpu_mes_lock(&#38;adev-&gt;mes);
</span> 	r = adev-&gt;mes.funcs-&gt;map_legacy_queue(&#38;adev-&gt;mes, &#38;queue_input);
<span
class="del">-	amdgpu_mes_unlock(&#38;adev-&gt;mes);
</span> 	if (r)
 		DRM_ERROR(&#34;failed to map legacy queue\n&#34;);
 
<span
class="hunk">@@ -826,9 +824,7 @@ int amdgpu_mes_unmap_legacy_queue(struct amdgpu_device *adev,
</span> 	queue_input.trail_fence_addr = gpu_addr;
 	queue_input.trail_fence_data = seq;
 
<span
class="del">-	amdgpu_mes_lock(&#38;adev-&gt;mes);
</span> 	r = adev-&gt;mes.funcs-&gt;unmap_legacy_queue(&#38;adev-&gt;mes, &#38;queue_input);
<span
class="del">-	amdgpu_mes_unlock(&#38;adev-&gt;mes);
</span> 	if (r)
 		DRM_ERROR(&#34;failed to unmap legacy queue\n&#34;);
 
<span
class="hunk">@@ -849,13 +845,11 @@ uint32_t amdgpu_mes_rreg(struct amdgpu_device *adev, uint32_t reg)
</span> 		goto error;
 	}
 
<span
class="del">-	amdgpu_mes_lock(&#38;adev-&gt;mes);
</span> 	r = adev-&gt;mes.funcs-&gt;misc_op(&#38;adev-&gt;mes, &#38;op_input);
 	if (r)
 		DRM_ERROR(&#34;failed to read reg (0x%x)\n&#34;, reg);
 	else
 		val = *(adev-&gt;mes.read_val_ptr);
<span
class="del">-	amdgpu_mes_unlock(&#38;adev-&gt;mes);
</span> 
 error:
 	return val;
<span
class="hunk">@@ -877,9 +871,7 @@ int amdgpu_mes_wreg(struct amdgpu_device *adev,
</span> 		goto error;
 	}
 
<span
class="del">-	amdgpu_mes_lock(&#38;adev-&gt;mes);
</span> 	r = adev-&gt;mes.funcs-&gt;misc_op(&#38;adev-&gt;mes, &#38;op_input);
<span
class="del">-	amdgpu_mes_unlock(&#38;adev-&gt;mes);
</span> 	if (r)
 		DRM_ERROR(&#34;failed to write reg (0x%x)\n&#34;, reg);
 
<span
class="hunk">@@ -906,9 +898,7 @@ int amdgpu_mes_reg_write_reg_wait(struct amdgpu_device *adev,
</span> 		goto error;
 	}
 
<span
class="del">-	amdgpu_mes_lock(&#38;adev-&gt;mes);
</span> 	r = adev-&gt;mes.funcs-&gt;misc_op(&#38;adev-&gt;mes, &#38;op_input);
<span
class="del">-	amdgpu_mes_unlock(&#38;adev-&gt;mes);
</span> 	if (r)
 		DRM_ERROR(&#34;failed to reg_write_reg_wait\n&#34;);
 
<span
class="hunk">@@ -933,9 +923,7 @@ int amdgpu_mes_reg_wait(struct amdgpu_device *adev, uint32_t reg,
</span> 		goto error;
 	}
 
<span
class="del">-	amdgpu_mes_lock(&#38;adev-&gt;mes);
</span> 	r = adev-&gt;mes.funcs-&gt;misc_op(&#38;adev-&gt;mes, &#38;op_input);
<span
class="del">-	amdgpu_mes_unlock(&#38;adev-&gt;mes);
</span> 	if (r)
 		DRM_ERROR(&#34;failed to reg_write_reg_wait\n&#34;);
 
-- 
2.35.1

</pre></div></content></entry><entry><author><name>Victor Lu</name><email>victorchengchi.lu@amd.com</email></author><title>[PATCH] drm/amdgpu: Do not wait for MP0_C2PMSG_33 IFWI init in SRIOV</title><updated>2024-06-14T20:32:26Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240614203205.4266-1-victorchengchi.lu@amd.com/"/><id>urn:uuid:436ebbd4-71ef-262b-db50-660ddf742c28</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">SRIOV does not need to wait for IFWI init, and MP0_C2PMSG_33 is blocked
for VF access.

Signed-off-by: Victor Lu &lt;victorchengchi.lu@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c | 26 ++++++++++---------
 1 file <a href="http://lore.kernel.org/amd-gfx/20240614203205.4266-1-victorchengchi.lu@amd.com/#related">changed</a>, 14 insertions(+), 12 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
index 9e0cfe06c8b1..4edcbd272fa4 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
</span><span
class="hunk">@@ -264,19 +264,21 @@ static int amdgpu_discovery_read_binary_from_mem(struct amdgpu_device *adev,
</span> 	u32 msg;
 	int i, ret = 0;
 
<span
class="del">-	/* It can take up to a second for IFWI init to complete on some dGPUs,
-	 * but generally it should be in the 60-100ms range.  Normally this starts
-	 * as soon as the device gets power so by the time the OS loads this has long
-	 * completed.  However, when a card is hotplugged via e.g., USB4, we need to
-	 * wait for this to complete.  Once the C2PMSG is updated, we can
-	 * continue.
-	 */
</span><span
class="add">+	if (!amdgpu_sriov_vf(adev)) {
+		/* It can take up to a second for IFWI init to complete on some dGPUs,
+		 * but generally it should be in the 60-100ms range.  Normally this starts
+		 * as soon as the device gets power so by the time the OS loads this has long
+		 * completed.  However, when a card is hotplugged via e.g., USB4, we need to
+		 * wait for this to complete.  Once the C2PMSG is updated, we can
+		 * continue.
+		 */
</span> 
<span
class="del">-	for (i = 0; i &lt; 1000; i++) {
-		msg = RREG32(mmMP0_SMN_C2PMSG_33);
-		if (msg &#38; 0x80000000)
-			break;
-		usleep_range(1000, 1100);
</span><span
class="add">+		for (i = 0; i &lt; 1000; i++) {
+			msg = RREG32(mmMP0_SMN_C2PMSG_33);
+			if (msg &#38; 0x80000000)
+				break;
+			usleep_range(1000, 1100);
+		}
</span> 	}
 
 	vram_size = (uint64_t)RREG32(mmRCC_CONFIG_MEMSIZE) &lt;&lt; 20;
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Nathan Chancellor</name><email>nathan@kernel.org</email></author><title>[PATCH] drm/amd/display: Disable CONFIG_DRM_AMD_DC_FP for RISC-V with clang</title><updated>2024-06-14T19:55:37Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240614-amdgpu-disable-drm-amd-dc-fp-riscv-clang-v1-1-a6d40617dc9b@kernel.org/"/><id>urn:uuid:eaada13a-2d3c-1277-5af5-d2eae598fc8d</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Commit 77acc6b55ae4 (&#34;riscv: add support for kernel-mode FPU&#34;) and
commit a28e4b672f04 (&#34;drm/amd/display: use ARCH_HAS_KERNEL_FPU_SUPPORT&#34;)
enabled support for CONFIG_DRM_AMD_DC_FP with RISC-V. Unfortunately,
this exposed -Wframe-larger-than warnings (which become fatal with
CONFIG_WERROR=y) when building ARCH=riscv allmodconfig with clang:

  drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn32/display_mode_vba_32.c:58:13: error: stack frame size (2448) exceeds limit (2048) in &#39;DISPCLKDPPCLKDCFCLKDeepSleepPrefetchParametersWatermarksAndPerformanceCalculation&#39; [-Werror,-Wframe-larger-than]
     58 | static void DISPCLKDPPCLKDCFCLKDeepSleepPrefetchParametersWatermarksAndPerformanceCalculation(
        |             ^
  1 error generated.

Many functions in this file use a large number of parameters, which must
be passed on the stack at a certain pointer due to register exhaustion,
which can cause high stack usage when inlining and issues with stack
slot analysis get involved. While the compiler can and should do better
(as GCC uses less than half the amount of stack space for the same
function), it is not as simple as a fix as adjusting the functions not
to take a large number of parameters.

Unfortunately, modifying these files to avoid the problem is a difficult
to justify approach because any revisions to the files in the kernel
tree never make it back to the original source (so copies of the code
for newer hardware revisions just reintroduce the issue) and the files
are hard to read/modify due to being &#34;gcc-parsable HW gospel, coming
straight from HW engineers&#34;.

Avoid building the problematic code for RISC-V by modifying the existing
condition for arm64 that exists for the same reason. Factor out the
logical not to make the condition a little more readable naturally.

Fixes: a28e4b672f04 (&#34;drm/amd/display: use ARCH_HAS_KERNEL_FPU_SUPPORT&#34;)
Reported-by: Palmer Dabbelt &lt;palmer@rivosinc.com&gt;
Closes: <a
href="https://lore.kernel.org/20240530145741.7506-2-palmer@rivosinc.com/">https://lore.kernel.org/20240530145741.7506-2-palmer@rivosinc.com/</a>
Signed-off-by: Nathan Chancellor &lt;nathan@kernel.org&gt;
---
 drivers/gpu/drm/amd/display/Kconfig | 2 +-
 1 file <a href="http://lore.kernel.org/amd-gfx/20240614-amdgpu-disable-drm-amd-dc-fp-riscv-clang-v1-1-a6d40617dc9b@kernel.org/#related">changed</a>, 1 insertion(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/Kconfig b/drivers/gpu/drm/amd/display/Kconfig
index 5fcd4f778dc3..47b8b49da8a7 100644
--- a/drivers/gpu/drm/amd/display/Kconfig
+++ b/drivers/gpu/drm/amd/display/Kconfig
</span><span
class="hunk">@@ -8,7 +8,7 @@ config DRM_AMD_DC
</span> 	depends on BROKEN || !CC_IS_CLANG || ARM64 || RISCV || SPARC64 || X86_64
 	select SND_HDA_COMPONENT if SND_HDA_CORE
 	# !CC_IS_CLANG: <a
href="https://github.com/ClangBuiltLinux/linux/issues/1752">https://github.com/ClangBuiltLinux/linux/issues/1752</a>
<span
class="del">-	select DRM_AMD_DC_FP if ARCH_HAS_KERNEL_FPU_SUPPORT &#38;&#38; (!ARM64 || !CC_IS_CLANG)
</span><span
class="add">+	select DRM_AMD_DC_FP if ARCH_HAS_KERNEL_FPU_SUPPORT &#38;&#38; !(CC_IS_CLANG &#38;&#38; (ARM64 || RISCV))
</span> 	help
 	  Choose this option if you want to use the new display engine
 	  support for AMDGPU. This adds required support for Vega and

<span
class="del">---
</span>base-commit: c6c4dd54012551cce5cde408b35468f2c62b0cce
change-id: 20240614-amdgpu-disable-drm-amd-dc-fp-riscv-clang-31c84f6b990d

Best regards,
-- 
Nathan Chancellor &lt;nathan@kernel.org&gt;

</pre></div></content></entry><entry><author><name>Alex Deucher</name><email>alexander.deucher@amd.com</email></author><title>[PATCH 2/2] drm/radeon: fix UBSAN warning in kv_dpm.c</title><updated>2024-06-14T18:34:07Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240614183337.483183-2-alexander.deucher@amd.com/"/><id>urn:uuid:9a83d593-1de5-f1a4-4895-66abfddb8b06</id><thr:in-reply-to
ref="urn:uuid:96e977e2-8398-9912-03ce-d8cfec970f15"
href="http://lore.kernel.org/amd-gfx/20240614183337.483183-1-alexander.deucher@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Adds bounds check for sumo_vid_mapping_entry.

Signed-off-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;
---
 drivers/gpu/drm/radeon/sumo_dpm.c | 2 ++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240614183337.483183-2-alexander.deucher@amd.com/#related">changed</a>, 2 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/radeon/sumo_dpm.c b/drivers/gpu/drm/radeon/sumo_dpm.c
index 21d27e6235f3..b11f7c5bbcbe 100644
--- a/drivers/gpu/drm/radeon/sumo_dpm.c
+++ b/drivers/gpu/drm/radeon/sumo_dpm.c
</span><span
class="hunk">@@ -1619,6 +1619,8 @@ void sumo_construct_vid_mapping_table(struct radeon_device *rdev,
</span> 
 	for (i = 0; i &lt; SUMO_MAX_HARDWARE_POWERLEVELS; i++) {
 		if (table[i].ulSupportedSCLK != 0) {
<span
class="add">+			if (table[i].usVoltageIndex &gt;= SUMO_MAX_NUMBER_VOLTAGES)
+				continue;
</span> 			vid_mapping_table-&gt;entries[table[i].usVoltageIndex].vid_7bit =
 				table[i].usVoltageID;
 			vid_mapping_table-&gt;entries[table[i].usVoltageIndex].vid_2bit =
-- 
2.45.1

</pre></div></content></entry><entry><author><name>Alex Deucher</name><email>alexander.deucher@amd.com</email></author><title>[PATCH 1/2] drm/amdgpu: fix UBSAN warning in kv_dpm.c</title><updated>2024-06-14T18:34:04Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240614183337.483183-1-alexander.deucher@amd.com/"/><id>urn:uuid:96e977e2-8398-9912-03ce-d8cfec970f15</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Adds bounds check for sumo_vid_mapping_entry.

Closes: <a
href="https://gitlab.freedesktop.org/drm/amd/-/issues/3392">https://gitlab.freedesktop.org/drm/amd/-/issues/3392</a>
Signed-off-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;
---
 drivers/gpu/drm/amd/pm/legacy-dpm/kv_dpm.c | 2 ++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240614183337.483183-1-alexander.deucher@amd.com/#related">changed</a>, 2 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/pm/legacy-dpm/kv_dpm.c b/drivers/gpu/drm/amd/pm/legacy-dpm/kv_dpm.c
index 6bb42d04b247..e8b6989a40f3 100644
--- a/drivers/gpu/drm/amd/pm/legacy-dpm/kv_dpm.c
+++ b/drivers/gpu/drm/amd/pm/legacy-dpm/kv_dpm.c
</span><span
class="hunk">@@ -164,6 +164,8 @@ static void sumo_construct_vid_mapping_table(struct amdgpu_device *adev,
</span> 
 	for (i = 0; i &lt; SUMO_MAX_HARDWARE_POWERLEVELS; i++) {
 		if (table[i].ulSupportedSCLK != 0) {
<span
class="add">+			if (table[i].usVoltageIndex &gt;= SUMO_MAX_NUMBER_VOLTAGES)
+				continue;
</span> 			vid_mapping_table-&gt;entries[table[i].usVoltageIndex].vid_7bit =
 				table[i].usVoltageID;
 			vid_mapping_table-&gt;entries[table[i].usVoltageIndex].vid_2bit =
-- 
2.45.1

</pre></div></content></entry><entry><author><name>Alex Deucher</name><email>alexander.deucher@amd.com</email></author><title>[PATCH] drm/amdgpu/atomfirmware: fix parsing of vram_info</title><updated>2024-06-14T17:55:29Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240614175458.459062-1-alexander.deucher@amd.com/"/><id>urn:uuid:8fa90e71-b2b6-3621-ae88-6b29d5dbcab9</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">v3.x changed the how vram width was encoded.  The previous
implementation actually worked correctly for most boards.
Fix the implementation to work correctly everywhere.

This fixes the vram width reported in the kernel log on
some boards.

Signed-off-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_atomfirmware.c | 2 +-
 1 file <a href="http://lore.kernel.org/amd-gfx/20240614175458.459062-1-alexander.deucher@amd.com/#related">changed</a>, 1 insertion(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_atomfirmware.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_atomfirmware.c
index f932bec6e534..f873dd3cae16 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_atomfirmware.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_atomfirmware.c
</span><span
class="hunk">@@ -433,7 +433,7 @@ amdgpu_atomfirmware_get_vram_info(struct amdgpu_device *adev,
</span> 						mem_channel_number = vram_info-&gt;v30.channel_num;
 						mem_channel_width = vram_info-&gt;v30.channel_width;
 						if (vram_width)
<span
class="del">-							*vram_width = mem_channel_number * (1 &lt;&lt; mem_channel_width);
</span><span
class="add">+							*vram_width = mem_channel_number * 16;
</span> 						break;
 					default:
 						return -EINVAL;
-- 
2.45.1

</pre></div></content></entry><entry><author><name>Mario Limonciello</name><email>mario.limonciello@amd.com</email></author><title>[PATCH 1/2] drm/amdgpu/pptable: Fix __counted_by attribute</title><updated>2024-06-14T17:06:09Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240614170551.6195-1-mario.limonciello@amd.com/"/><id>urn:uuid:99d538fe-cdfe-7140-8ad0-59d75208eed2</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">The attribute is not helpful if commented out.

Cc: Tasos Sahanidis &lt;tasos@tasossah.com&gt;
Fixes: c6c4dd540125 (&#34;drm/amdgpu/pptable: Fix UBSAN array-index-out-of-bounds&#34;)
Signed-off-by: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
---
 drivers/gpu/drm/amd/include/pptable.h | 2 +-
 1 file <a href="http://lore.kernel.org/amd-gfx/20240614170551.6195-1-mario.limonciello@amd.com/#related">changed</a>, 1 insertion(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/include/pptable.h b/drivers/gpu/drm/amd/include/pptable.h
index f83ace2d7ec3..984770d0eb4c 100644
--- a/drivers/gpu/drm/amd/include/pptable.h
+++ b/drivers/gpu/drm/amd/include/pptable.h
</span><span
class="hunk">@@ -480,7 +480,7 @@ typedef struct _StateArray{
</span> 	//how many states we have
 	UCHAR ucNumEntries;
 
<span
class="del">-	ATOM_PPLIB_STATE_V2 states[] /* __counted_by(ucNumEntries) */;
</span><span
class="add">+	ATOM_PPLIB_STATE_V2 states[] __counted_by(ucNumEntries);
</span> }StateArray;
 
 
-- 
2.43.0

</pre></div></content></entry><entry><author><name>Mario Limonciello</name><email>mario.limonciello@amd.com</email></author><title>[PATCH 2/2] drm/amd/pm: powerplay: Add `__counted_by` attribute for flexible arrays</title><updated>2024-06-14T17:06:09Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240614170551.6195-2-mario.limonciello@amd.com/"/><id>urn:uuid:b0485a8d-3cbc-4cc8-c4cd-7bc22759b172</id><thr:in-reply-to
ref="urn:uuid:99d538fe-cdfe-7140-8ad0-59d75208eed2"
href="http://lore.kernel.org/amd-gfx/20240614170551.6195-1-mario.limonciello@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This attribute is used to hint the length of flexible arrays to
compiler and sanitizers.

Signed-off-by: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
---
 .../drm/amd/pm/powerplay/hwmgr/pptable_v1_0.h | 36 +++++++++---------
 drivers/gpu/drm/amd/pm/powerplay/inc/hwmgr.h  | 38 +++++++++----------
 2 files <a href="http://lore.kernel.org/amd-gfx/20240614170551.6195-2-mario.limonciello@amd.com/#related">changed</a>, 37 insertions(+), 37 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/pm/powerplay/hwmgr/pptable_v1_0.h b/drivers/gpu/drm/amd/pm/powerplay/hwmgr/pptable_v1_0.h
index 2cf2a7b12623..7711e892c31f 100644
--- a/drivers/gpu/drm/amd/pm/powerplay/hwmgr/pptable_v1_0.h
+++ b/drivers/gpu/drm/amd/pm/powerplay/hwmgr/pptable_v1_0.h
</span><span
class="hunk">@@ -163,8 +163,8 @@ typedef struct _ATOM_Tonga_State {
</span> 
 typedef struct _ATOM_Tonga_State_Array {
 	UCHAR ucRevId;
<span
class="del">-	UCHAR ucNumEntries;		/* Number of entries. */
-	ATOM_Tonga_State entries[];	/* Dynamically allocate entries. */
</span><span
class="add">+	UCHAR ucNumEntries;
+	ATOM_Tonga_State entries[] __counted_by(ucNumEntries);
</span> } ATOM_Tonga_State_Array;
 
 typedef struct _ATOM_Tonga_MCLK_Dependency_Record {
<span
class="hunk">@@ -178,8 +178,8 @@ typedef struct _ATOM_Tonga_MCLK_Dependency_Record {
</span> 
 typedef struct _ATOM_Tonga_MCLK_Dependency_Table {
 	UCHAR ucRevId;
<span
class="del">-	UCHAR ucNumEntries; 										/* Number of entries. */
-	ATOM_Tonga_MCLK_Dependency_Record entries[];				/* Dynamically allocate entries. */
</span><span
class="add">+	UCHAR ucNumEntries;
+	ATOM_Tonga_MCLK_Dependency_Record entries[] __counted_by(ucNumEntries);
</span> } ATOM_Tonga_MCLK_Dependency_Table;
 
 typedef struct _ATOM_Tonga_SCLK_Dependency_Record {
<span
class="hunk">@@ -193,8 +193,8 @@ typedef struct _ATOM_Tonga_SCLK_Dependency_Record {
</span> 
 typedef struct _ATOM_Tonga_SCLK_Dependency_Table {
 	UCHAR ucRevId;
<span
class="del">-	UCHAR ucNumEntries; 										/* Number of entries. */
-	ATOM_Tonga_SCLK_Dependency_Record entries[];				 /* Dynamically allocate entries. */
</span><span
class="add">+	UCHAR ucNumEntries;
+	ATOM_Tonga_SCLK_Dependency_Record entries[] __counted_by(ucNumEntries);
</span> } ATOM_Tonga_SCLK_Dependency_Table;
 
 typedef struct _ATOM_Polaris_SCLK_Dependency_Record {
<span
class="hunk">@@ -209,8 +209,8 @@ typedef struct _ATOM_Polaris_SCLK_Dependency_Record {
</span> 
 typedef struct _ATOM_Polaris_SCLK_Dependency_Table {
 	UCHAR ucRevId;
<span
class="del">-	UCHAR ucNumEntries;							/* Number of entries. */
-	ATOM_Polaris_SCLK_Dependency_Record entries[];				 /* Dynamically allocate entries. */
</span><span
class="add">+	UCHAR ucNumEntries;
+	ATOM_Polaris_SCLK_Dependency_Record entries[] __counted_by(ucNumEntries);
</span> } ATOM_Polaris_SCLK_Dependency_Table;
 
 typedef struct _ATOM_Tonga_PCIE_Record {
<span
class="hunk">@@ -221,8 +221,8 @@ typedef struct _ATOM_Tonga_PCIE_Record {
</span> 
 typedef struct _ATOM_Tonga_PCIE_Table {
 	UCHAR ucRevId;
<span
class="del">-	UCHAR ucNumEntries; 										/* Number of entries. */
-	ATOM_Tonga_PCIE_Record entries[];							/* Dynamically allocate entries. */
</span><span
class="add">+	UCHAR ucNumEntries;
+	ATOM_Tonga_PCIE_Record entries[] __counted_by(ucNumEntries);
</span> } ATOM_Tonga_PCIE_Table;
 
 typedef struct _ATOM_Polaris10_PCIE_Record {
<span
class="hunk">@@ -234,8 +234,8 @@ typedef struct _ATOM_Polaris10_PCIE_Record {
</span> 
 typedef struct _ATOM_Polaris10_PCIE_Table {
 	UCHAR ucRevId;
<span
class="del">-	UCHAR ucNumEntries;                                         /* Number of entries. */
-	ATOM_Polaris10_PCIE_Record entries[];                      /* Dynamically allocate entries. */
</span><span
class="add">+	UCHAR ucNumEntries;
+	ATOM_Polaris10_PCIE_Record entries[] __counted_by(ucNumEntries);
</span> } ATOM_Polaris10_PCIE_Table;
 
 
<span
class="hunk">@@ -251,8 +251,8 @@ typedef struct _ATOM_Tonga_MM_Dependency_Record {
</span> 
 typedef struct _ATOM_Tonga_MM_Dependency_Table {
 	UCHAR ucRevId;
<span
class="del">-	UCHAR ucNumEntries; 										/* Number of entries. */
-	ATOM_Tonga_MM_Dependency_Record entries[]; 			   /* Dynamically allocate entries. */
</span><span
class="add">+	UCHAR ucNumEntries;
+	ATOM_Tonga_MM_Dependency_Record entries[] __counted_by(ucNumEntries);
</span> } ATOM_Tonga_MM_Dependency_Table;
 
 typedef struct _ATOM_Tonga_Voltage_Lookup_Record {
<span
class="hunk">@@ -264,8 +264,8 @@ typedef struct _ATOM_Tonga_Voltage_Lookup_Record {
</span> 
 typedef struct _ATOM_Tonga_Voltage_Lookup_Table {
 	UCHAR ucRevId;
<span
class="del">-	UCHAR ucNumEntries; 										/* Number of entries. */
-	ATOM_Tonga_Voltage_Lookup_Record entries[];				/* Dynamically allocate entries. */
</span><span
class="add">+	UCHAR ucNumEntries;
+	ATOM_Tonga_Voltage_Lookup_Record entries[] __counted_by(ucNumEntries);
</span> } ATOM_Tonga_Voltage_Lookup_Table;
 
 typedef struct _ATOM_Tonga_Fan_Table {
<span
class="hunk">@@ -367,7 +367,7 @@ typedef struct _ATOM_Tonga_VCE_State_Record {
</span> typedef struct _ATOM_Tonga_VCE_State_Table {
 	UCHAR ucRevId;
 	UCHAR ucNumEntries;
<span
class="del">-	ATOM_Tonga_VCE_State_Record entries[];
</span><span
class="add">+	ATOM_Tonga_VCE_State_Record entries[] __counted_by(ucNumEntries);
</span> } ATOM_Tonga_VCE_State_Table;
 
 typedef struct _ATOM_Tonga_PowerTune_Table {
<span
class="hunk">@@ -481,7 +481,7 @@ typedef struct _ATOM_Tonga_Hard_Limit_Record {
</span> typedef struct _ATOM_Tonga_Hard_Limit_Table {
 	UCHAR ucRevId;
 	UCHAR ucNumEntries;
<span
class="del">-	ATOM_Tonga_Hard_Limit_Record entries[];
</span><span
class="add">+	ATOM_Tonga_Hard_Limit_Record entries[] __counted_by(ucNumEntries);
</span> } ATOM_Tonga_Hard_Limit_Table;
 
 typedef struct _ATOM_Tonga_GPIO_Table {
<span
class="head">diff --git a/drivers/gpu/drm/amd/pm/powerplay/inc/hwmgr.h b/drivers/gpu/drm/amd/pm/powerplay/inc/hwmgr.h
index 69928a4a074b..9118fcddbf11 100644
--- a/drivers/gpu/drm/amd/pm/powerplay/inc/hwmgr.h
+++ b/drivers/gpu/drm/amd/pm/powerplay/inc/hwmgr.h
</span><span
class="hunk">@@ -60,7 +60,7 @@ struct vi_dpm_level {
</span> 
 struct vi_dpm_table {
 	uint32_t count;
<span
class="del">-	struct vi_dpm_level dpm_level[];
</span><span
class="add">+	struct vi_dpm_level dpm_level[] __counted_by(count);
</span> };
 
 #define PCIE_PERF_REQ_REMOVE_REGISTRY   0
<span
class="hunk">@@ -91,7 +91,7 @@ struct phm_set_power_state_input {
</span> 
 struct phm_clock_array {
 	uint32_t count;
<span
class="del">-	uint32_t values[];
</span><span
class="add">+	uint32_t values[] __counted_by(count);
</span> };
 
 struct phm_clock_voltage_dependency_record {
<span
class="hunk">@@ -122,8 +122,8 @@ struct phm_acpclock_voltage_dependency_record {
</span> };
 
 struct phm_clock_voltage_dependency_table {
<span
class="del">-	uint32_t count;							/* Number of entries. */
-	struct phm_clock_voltage_dependency_record entries[];		/* Dynamically allocate count entries. */
</span><span
class="add">+	uint32_t count;
+	struct phm_clock_voltage_dependency_record entries[] __counted_by(count);
</span> };
 
 struct phm_phase_shedding_limits_record {
<span
class="hunk">@@ -140,7 +140,7 @@ struct phm_uvd_clock_voltage_dependency_record {
</span> 
 struct phm_uvd_clock_voltage_dependency_table {
 	uint8_t count;
<span
class="del">-	struct phm_uvd_clock_voltage_dependency_record entries[];
</span><span
class="add">+	struct phm_uvd_clock_voltage_dependency_record entries[] __counted_by(count);
</span> };
 
 struct phm_acp_clock_voltage_dependency_record {
<span
class="hunk">@@ -150,7 +150,7 @@ struct phm_acp_clock_voltage_dependency_record {
</span> 
 struct phm_acp_clock_voltage_dependency_table {
 	uint32_t count;
<span
class="del">-	struct phm_acp_clock_voltage_dependency_record entries[];
</span><span
class="add">+	struct phm_acp_clock_voltage_dependency_record entries[] __counted_by(count);
</span> };
 
 struct phm_vce_clock_voltage_dependency_record {
<span
class="hunk">@@ -160,33 +160,33 @@ struct phm_vce_clock_voltage_dependency_record {
</span> };
 
 struct phm_phase_shedding_limits_table {
<span
class="del">-	uint32_t                           count;
-	struct phm_phase_shedding_limits_record  entries[];
</span><span
class="add">+	uint32_t count;
+	struct phm_phase_shedding_limits_record  entries[] __counted_by(count);
</span> };
 
 struct phm_vceclock_voltage_dependency_table {
<span
class="del">-	uint8_t count;                                    /* Number of entries. */
-	struct phm_vceclock_voltage_dependency_record entries[1]; /* Dynamically allocate count entries. */
</span><span
class="add">+	uint8_t count;
+	struct phm_vceclock_voltage_dependency_record entries[] __counted_by(count);
</span> };
 
 struct phm_uvdclock_voltage_dependency_table {
<span
class="del">-	uint8_t count;                                    /* Number of entries. */
-	struct phm_uvdclock_voltage_dependency_record entries[1]; /* Dynamically allocate count entries. */
</span><span
class="add">+	uint8_t count;
+	struct phm_uvdclock_voltage_dependency_record entries[] __counted_by(count);
</span> };
 
 struct phm_samuclock_voltage_dependency_table {
<span
class="del">-	uint8_t count;                                    /* Number of entries. */
-	struct phm_samuclock_voltage_dependency_record entries[1]; /* Dynamically allocate count entries. */
</span><span
class="add">+	uint8_t count;
+	struct phm_samuclock_voltage_dependency_record entries[] __counted_by(count);
</span> };
 
 struct phm_acpclock_voltage_dependency_table {
<span
class="del">-	uint32_t count;                                    /* Number of entries. */
-	struct phm_acpclock_voltage_dependency_record entries[1]; /* Dynamically allocate count entries. */
</span><span
class="add">+	uint32_t count;
+	struct phm_acpclock_voltage_dependency_record entries[] __counted_by(count);
</span> };
 
 struct phm_vce_clock_voltage_dependency_table {
 	uint8_t count;
<span
class="del">-	struct phm_vce_clock_voltage_dependency_record entries[];
</span><span
class="add">+	struct phm_vce_clock_voltage_dependency_record entries[] __counted_by(count);
</span> };
 
 
<span
class="hunk">@@ -393,7 +393,7 @@ union phm_cac_leakage_record {
</span> 
 struct phm_cac_leakage_table {
 	uint32_t count;
<span
class="del">-	union phm_cac_leakage_record entries[];
</span><span
class="add">+	union phm_cac_leakage_record entries[] __counted_by(count);
</span> };
 
 struct phm_samu_clock_voltage_dependency_record {
<span
class="hunk">@@ -404,7 +404,7 @@ struct phm_samu_clock_voltage_dependency_record {
</span> 
 struct phm_samu_clock_voltage_dependency_table {
 	uint8_t count;
<span
class="del">-	struct phm_samu_clock_voltage_dependency_record entries[];
</span><span
class="add">+	struct phm_samu_clock_voltage_dependency_record entries[] __counted_by(count);
</span> };
 
 struct phm_cac_tdp_table {
-- 
2.43.0

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v6 8/8] drm/amdgpu: Make it possible to async flip overlay planes</title><updated>2024-06-14T15:37:00Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240614153535.351689-9-andrealmeid@igalia.com/"/><id>urn:uuid:c48d3a9d-2a8c-0791-e468-eb533a333ff5</id><thr:in-reply-to
ref="urn:uuid:400f6c4b-d455-6e8d-6ac9-9c2f09e5fe29"
href="http://lore.kernel.org/amd-gfx/20240614153535.351689-1-andrealmeid@igalia.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">amdgpu can handle async flips on overlay planes, so mark it as true
during the plane initialization.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c | 1 +
 1 file <a href="http://lore.kernel.org/amd-gfx/20240614153535.351689-9-andrealmeid@igalia.com/#related">changed</a>, 1 insertion(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
index 0c126c5609d3..7d508d816f0d 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
</span><span
class="hunk">@@ -1709,6 +1709,7 @@ int amdgpu_dm_plane_init(struct amdgpu_display_manager *dm,
</span> 	} else if (plane-&gt;type == DRM_PLANE_TYPE_OVERLAY) {
 		unsigned int zpos = 1 + drm_plane_index(plane);
 		drm_plane_create_zpos_property(plane, zpos, 1, 254);
<span
class="add">+		plane-&gt;async_flip = true;
</span> 	} else if (plane-&gt;type == DRM_PLANE_TYPE_CURSOR) {
 		drm_plane_create_zpos_immutable_property(plane, 255);
 	}
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v6 7/8] drm/vc4: Enable async flips on the primary plane</title><updated>2024-06-14T15:36:51Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240614153535.351689-8-andrealmeid@igalia.com/"/><id>urn:uuid:cc45c605-6a0b-5877-d0f2-edac19328be4</id><thr:in-reply-to
ref="urn:uuid:400f6c4b-d455-6e8d-6ac9-9c2f09e5fe29"
href="http://lore.kernel.org/amd-gfx/20240614153535.351689-1-andrealmeid@igalia.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This driver can perfom async flips on primary planes, so enable it.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---
 drivers/gpu/drm/vc4/vc4_plane.c | 4 +++-
 1 file <a href="http://lore.kernel.org/amd-gfx/20240614153535.351689-8-andrealmeid@igalia.com/#related">changed</a>, 3 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/vc4/vc4_plane.c b/drivers/gpu/drm/vc4/vc4_plane.c
index 07caf2a47c6c..e3d41da14e6f 100644
--- a/drivers/gpu/drm/vc4/vc4_plane.c
+++ b/drivers/gpu/drm/vc4/vc4_plane.c
</span><span
class="hunk">@@ -1672,8 +1672,10 @@ struct drm_plane *vc4_plane_init(struct drm_device *dev,
</span> 					  DRM_COLOR_YCBCR_BT709,
 					  DRM_COLOR_YCBCR_LIMITED_RANGE);
 
<span
class="del">-	if (type == DRM_PLANE_TYPE_PRIMARY)
</span><span
class="add">+	if (type == DRM_PLANE_TYPE_PRIMARY) {
</span> 		drm_plane_create_zpos_immutable_property(plane, 0);
<span
class="add">+		plane-&gt;async_flip = true;
+	}
</span> 
 	return plane;
 }
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v6 6/8] drm/nouveau: Enable async flips on the primary plane</title><updated>2024-06-14T15:36:42Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240614153535.351689-7-andrealmeid@igalia.com/"/><id>urn:uuid:76c9cf0c-ebe5-4888-1ca6-42545750b63a</id><thr:in-reply-to
ref="urn:uuid:400f6c4b-d455-6e8d-6ac9-9c2f09e5fe29"
href="http://lore.kernel.org/amd-gfx/20240614153535.351689-1-andrealmeid@igalia.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This driver can perfom async flips on primary planes, so enable it.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---
 drivers/gpu/drm/nouveau/dispnv04/crtc.c | 4 ++++
 drivers/gpu/drm/nouveau/dispnv50/wndw.c | 4 ++++
 2 files <a href="http://lore.kernel.org/amd-gfx/20240614153535.351689-7-andrealmeid@igalia.com/#related">changed</a>, 8 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/nouveau/dispnv04/crtc.c b/drivers/gpu/drm/nouveau/dispnv04/crtc.c
index 4310ad71870b..fd06d46d49ec 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/crtc.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/crtc.c
</span><span
class="hunk">@@ -1285,6 +1285,7 @@ int
</span> nv04_crtc_create(struct drm_device *dev, int crtc_num)
 {
 	struct nouveau_display *disp = nouveau_display(dev);
<span
class="add">+	struct nouveau_drm *drm = nouveau_drm(dev);
</span> 	struct nouveau_crtc *nv_crtc;
 	struct drm_plane *primary;
 	int ret;
<span
class="hunk">@@ -1338,6 +1339,9 @@ nv04_crtc_create(struct drm_device *dev, int crtc_num)
</span> 	if (ret)
 		return ret;
 
<span
class="add">+	if (drm-&gt;client.device.info.chipset &gt;= 0x11)
+		primary-&gt;async_flip = true;
+
</span> 	return nvif_head_vblank_event_ctor(&#38;nv_crtc-&gt;head, &#34;kmsVbl&#34;, nv04_crtc_vblank_handler,
 					   false, &#38;nv_crtc-&gt;vblank);
 }
<span
class="head">diff --git a/drivers/gpu/drm/nouveau/dispnv50/wndw.c b/drivers/gpu/drm/nouveau/dispnv50/wndw.c
index 7a2cceaee6e9..55db0fdf61e7 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/wndw.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/wndw.c
</span><span
class="hunk">@@ -763,6 +763,10 @@ nv50_wndw_new_(const struct nv50_wndw_func *func, struct drm_device *dev,
</span> 			return ret;
 	}
 
<span
class="add">+	if (type == DRM_PLANE_TYPE_PRIMARY &#38;&#38;
+	    drm-&gt;client.device.info.chipset &gt;= 0x11)
+		wndw-&gt;plane.async_flip = true;
+
</span> 	return 0;
 }
 
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v6 5/8] drm/i915: Enable async flips on the primary plane</title><updated>2024-06-14T15:36:37Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240614153535.351689-6-andrealmeid@igalia.com/"/><id>urn:uuid:c9284834-80ae-6e58-62a6-4619e5a49dad</id><thr:in-reply-to
ref="urn:uuid:400f6c4b-d455-6e8d-6ac9-9c2f09e5fe29"
href="http://lore.kernel.org/amd-gfx/20240614153535.351689-1-andrealmeid@igalia.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This driver can perfom async flips on primary planes, so enable it.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---
 drivers/gpu/drm/i915/display/i9xx_plane.c | 3 +++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240614153535.351689-6-andrealmeid@igalia.com/#related">changed</a>, 3 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/i915/display/i9xx_plane.c b/drivers/gpu/drm/i915/display/i9xx_plane.c
index 0279c8aabdd1..0142beef20dc 100644
--- a/drivers/gpu/drm/i915/display/i9xx_plane.c
+++ b/drivers/gpu/drm/i915/display/i9xx_plane.c
</span><span
class="hunk">@@ -931,6 +931,9 @@ intel_primary_plane_create(struct drm_i915_private *dev_priv, enum pipe pipe)
</span> 
 	intel_plane_helper_add(plane);
 
<span
class="add">+	if (plane-&gt;async_flip)
+		plane-&gt;base.async_flip = true;
+
</span> 	return plane;
 
 fail:
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v6 4/8] drm: atmel-hlcdc: Enable async flips on the primary plane</title><updated>2024-06-14T15:36:23Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240614153535.351689-5-andrealmeid@igalia.com/"/><id>urn:uuid:d0d2df0d-7a53-27e1-1258-aa1c6816ac71</id><thr:in-reply-to
ref="urn:uuid:400f6c4b-d455-6e8d-6ac9-9c2f09e5fe29"
href="http://lore.kernel.org/amd-gfx/20240614153535.351689-1-andrealmeid@igalia.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This driver can perfom async flips on primary planes, so enable it.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---
 drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_plane.c | 3 +++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240614153535.351689-5-andrealmeid@igalia.com/#related">changed</a>, 3 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_plane.c b/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_plane.c
index 4a7ba0918eca..22b8a5c888ef 100644
--- a/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_plane.c
+++ b/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_plane.c
</span><span
class="hunk">@@ -1227,6 +1227,9 @@ static int atmel_hlcdc_plane_create(struct drm_device *dev,
</span> 	if (ret)
 		return ret;
 
<span
class="add">+	if (type == DRM_PLANE_TYPE_PRIMARY)
+		plane-&gt;base.async_flip = true;
+
</span> 	drm_plane_helper_add(&#38;plane-&gt;base,
 			     &#38;atmel_hlcdc_layer_plane_helper_funcs);
 
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v6 3/8] drm/amdgpu: Enable async flips on the primary plane</title><updated>2024-06-14T15:36:16Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240614153535.351689-4-andrealmeid@igalia.com/"/><id>urn:uuid:b804dc25-6393-fb6c-26d4-6bbd66bc4417</id><thr:in-reply-to
ref="urn:uuid:400f6c4b-d455-6e8d-6ac9-9c2f09e5fe29"
href="http://lore.kernel.org/amd-gfx/20240614153535.351689-1-andrealmeid@igalia.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">This driver can perfom async flips on primary planes, so enable it.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c | 1 +
 1 file <a href="http://lore.kernel.org/amd-gfx/20240614153535.351689-4-andrealmeid@igalia.com/#related">changed</a>, 1 insertion(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
index 8a4c40b4c27e..0c126c5609d3 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
</span><span
class="hunk">@@ -1705,6 +1705,7 @@ int amdgpu_dm_plane_init(struct amdgpu_display_manager *dm,
</span> 
 	if (plane-&gt;type == DRM_PLANE_TYPE_PRIMARY) {
 		drm_plane_create_zpos_immutable_property(plane, 0);
<span
class="add">+		plane-&gt;async_flip = true;
</span> 	} else if (plane-&gt;type == DRM_PLANE_TYPE_OVERLAY) {
 		unsigned int zpos = 1 + drm_plane_index(plane);
 		drm_plane_create_zpos_property(plane, zpos, 1, 254);
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v6 2/8] drm: Support per-plane async flip configuration</title><updated>2024-06-14T15:36:17Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240614153535.351689-3-andrealmeid@igalia.com/"/><id>urn:uuid:dcb8c520-fe7f-068c-84d9-648b2b917949</id><thr:in-reply-to
ref="urn:uuid:400f6c4b-d455-6e8d-6ac9-9c2f09e5fe29"
href="http://lore.kernel.org/amd-gfx/20240614153535.351689-1-andrealmeid@igalia.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Drivers have different capabilities on what plane types they can or
cannot perform async flips. Create a plane::async_flip field so each
driver can choose which planes they allow doing async flips.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---
 drivers/gpu/drm/drm_atomic_uapi.c | 4 ++--
 include/drm/drm_plane.h           | 5 +++++
 2 files <a href="http://lore.kernel.org/amd-gfx/20240614153535.351689-3-andrealmeid@igalia.com/#related">changed</a>, 7 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/drm_atomic_uapi.c b/drivers/gpu/drm/drm_atomic_uapi.c
index 2e1d9391febe..ed1af3455477 100644
--- a/drivers/gpu/drm/drm_atomic_uapi.c
+++ b/drivers/gpu/drm/drm_atomic_uapi.c
</span><span
class="hunk">@@ -1079,9 +1079,9 @@ int drm_atomic_set_property(struct drm_atomic_state *state,
</span> 			break;
 		}
 
<span
class="del">-		if (async_flip &#38;&#38; plane_state-&gt;plane-&gt;type != DRM_PLANE_TYPE_PRIMARY) {
</span><span
class="add">+		if (async_flip &#38;&#38; !plane-&gt;async_flip) {
</span> 			drm_dbg_atomic(prop-&gt;dev,
<span
class="del">-				       &#34;[OBJECT:%d] Only primary planes can be changed during async flip\n&#34;,
</span><span
class="add">+				       &#34;[PLANE:%d] does not support async flips\n&#34;,
</span> 				       obj-&gt;id);
 			ret = -EINVAL;
 			break;
<span
class="head">diff --git a/include/drm/drm_plane.h b/include/drm/drm_plane.h
index 9507542121fa..0bebc72af5c3 100644
--- a/include/drm/drm_plane.h
+++ b/include/drm/drm_plane.h
</span><span
class="hunk">@@ -786,6 +786,11 @@ struct drm_plane {
</span> 	 * @kmsg_panic: Used to register a panic notifier for this plane
 	 */
 	struct kmsg_dumper kmsg_panic;
<span
class="add">+
+	/**
+	 * @async_flip: indicates if a plane can do async flips
+	 */
+	bool async_flip;
</span> };
 
 #define obj_to_plane(x) container_of(x, struct drm_plane, base)
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v6 1/8] drm/atomic: Allow userspace to use explicit sync with atomic async flips</title><updated>2024-06-14T15:36:09Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240614153535.351689-2-andrealmeid@igalia.com/"/><id>urn:uuid:dcd3a6f0-b352-791d-fc1a-cb41c8064749</id><thr:in-reply-to
ref="urn:uuid:400f6c4b-d455-6e8d-6ac9-9c2f09e5fe29"
href="http://lore.kernel.org/amd-gfx/20240614153535.351689-1-andrealmeid@igalia.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Allow userspace to use explicit synchronization with atomic async flips.
That means that the flip will wait for some hardware fence, and then
will flip as soon as possible (async) in regard of the vblank.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---
 drivers/gpu/drm/drm_atomic_uapi.c | 4 +++-
 1 file <a href="http://lore.kernel.org/amd-gfx/20240614153535.351689-2-andrealmeid@igalia.com/#related">changed</a>, 3 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/drm_atomic_uapi.c b/drivers/gpu/drm/drm_atomic_uapi.c
index 22bbb2d83e30..2e1d9391febe 100644
--- a/drivers/gpu/drm/drm_atomic_uapi.c
+++ b/drivers/gpu/drm/drm_atomic_uapi.c
</span><span
class="hunk">@@ -1070,7 +1070,9 @@ int drm_atomic_set_property(struct drm_atomic_state *state,
</span> 			break;
 		}
 
<span
class="del">-		if (async_flip &#38;&#38; prop != config-&gt;prop_fb_id) {
</span><span
class="add">+		if (async_flip &#38;&#38;
+		    prop != config-&gt;prop_fb_id &#38;&#38;
+		    prop != config-&gt;prop_in_fence_fd) {
</span> 			ret = drm_atomic_plane_get_property(plane, plane_state,
 							    prop, &#38;old_val);
 			ret = drm_atomic_check_prop_changes(ret, old_val, prop_value, prop);
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v6 0/8] drm: Support per-plane async flip configuration</title><updated>2024-06-14T15:36:05Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240614153535.351689-1-andrealmeid@igalia.com/"/><id>urn:uuid:400f6c4b-d455-6e8d-6ac9-9c2f09e5fe29</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">AMD hardware can do async flips with overlay planes, but currently there&#39;s no
easy way to enable that in DRM. To solve that, this patchset creates a new
drm_plane field, bool async_flip, that allows drivers to choose which plane can
or cannot do async flips. This is latter used on drm_atomic_set_property when
users want to do async flips.

Patch 1 allows async commits with IN_FENCE_ID in any driver.

Patches 2 to 7 have no function change. As per current code, every driver that
allows async page flips using the atomic API, allows doing it only in the
primary plane. Those patches then enable it for every driver.

Patch 8 finally enables async flip on overlay planes for amdgpu.

Changes from v5:
- Instead of enabling plane-&gt;async_flip in the common code, move it to driver
code.
- Enable primary plane async flip on every driver
<a
href="https://lore.kernel.org/dri-devel/20240612193713.167448-1-andrealmeid@igalia.com/">https://lore.kernel.org/dri-devel/20240612193713.167448-1-andrealmeid@igalia.com/</a>

Andr&#233; Almeida (8):
  drm/atomic: Allow userspace to use explicit sync with atomic async
    flips
  drm: Support per-plane async flip configuration
  drm/amdgpu: Enable async flips on the primary plane
  drm: atmel-hlcdc: Enable async flips on the primary plane
  drm/i915: Enable async flips on the primary plane
  drm/nouveau: Enable async flips on the primary plane
  drm/vc4: Enable async flips on the primary plane
  drm/amdgpu: Make it possible to async flip overlay planes

 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c | 2 ++
 drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_plane.c         | 3 +++
 drivers/gpu/drm/drm_atomic_uapi.c                       | 8 +++++---
 drivers/gpu/drm/i915/display/i9xx_plane.c               | 3 +++
 drivers/gpu/drm/nouveau/dispnv04/crtc.c                 | 4 ++++
 drivers/gpu/drm/nouveau/dispnv50/wndw.c                 | 4 ++++
 drivers/gpu/drm/vc4/vc4_plane.c                         | 4 +++-
 include/drm/drm_plane.h                                 | 5 +++++
 8 files changed, 29 insertions(+), 4 deletions(-)

-- 
2.45.2

</pre></div></content></entry><entry><author><name>Jane Jian</name><email>Jane.Jian@amd.com</email></author><title>[PATCH] drm/amdgpu: keep init xcc0 for all xccs under sriov</title><updated>2024-06-14T11:10:31Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240614111022.236072-1-Jane.Jian@amd.com/"/><id>urn:uuid:f5cb20f3-58bf-b55e-0459-9e9a368b616f</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">[WHY]
sriov has the higher bit violation when flushing tlb

[HOW]
for sriov only init XCC0(lower 16-bit) for all XCCs to avoid higher bit violation
since kiq ring is always local, local address without XCC ID is enough to be sent to the XCC KIQ

Signed-off-by: Jane Jian &lt;Jane.Jian@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/gfxhub_v1_2.c | 23 +++++++++++++++--------
 1 file <a href="http://lore.kernel.org/amd-gfx/20240614111022.236072-1-Jane.Jian@amd.com/#related">changed</a>, 15 insertions(+), 8 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gfxhub_v1_2.c b/drivers/gpu/drm/amd/amdgpu/gfxhub_v1_2.c
index e14acab5cceb..4e38a66a52f4 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfxhub_v1_2.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfxhub_v1_2.c
</span><span
class="hunk">@@ -537,29 +537,36 @@ static void gfxhub_v1_2_xcc_init(struct amdgpu_device *adev, uint32_t xcc_mask)
</span> {
 	struct amdgpu_vmhub *hub;
 	int i;
<span
class="add">+	uint32_t gc_index;
</span> 
 	for_each_inst(i, xcc_mask) {
 		hub = &#38;adev-&gt;vmhub[AMDGPU_GFXHUB(i)];
 
<span
class="add">+		/* for sriov only init XCC0(lower 16-bit) to avoid higher bit violation */
+		if (amdgpu_sriov_vf(adev))
+			gc_index = 0;
+		else
+			gc_index = GET_INST(GC, i);
+
</span> 		hub-&gt;ctx0_ptb_addr_lo32 =
<span
class="del">-			SOC15_REG_OFFSET(GC, GET_INST(GC, i),
</span><span
class="add">+			SOC15_REG_OFFSET(GC, gc_index,
</span> 				regVM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LO32);
 		hub-&gt;ctx0_ptb_addr_hi32 =
<span
class="del">-			SOC15_REG_OFFSET(GC, GET_INST(GC, i),
</span><span
class="add">+			SOC15_REG_OFFSET(GC, gc_index,
</span> 				regVM_CONTEXT0_PAGE_TABLE_BASE_ADDR_HI32);
 		hub-&gt;vm_inv_eng0_sem =
<span
class="del">-			SOC15_REG_OFFSET(GC, GET_INST(GC, i), regVM_INVALIDATE_ENG0_SEM);
</span><span
class="add">+			SOC15_REG_OFFSET(GC, gc_index, regVM_INVALIDATE_ENG0_SEM);
</span> 		hub-&gt;vm_inv_eng0_req =
<span
class="del">-			SOC15_REG_OFFSET(GC, GET_INST(GC, i), regVM_INVALIDATE_ENG0_REQ);
</span><span
class="add">+			SOC15_REG_OFFSET(GC, gc_index, regVM_INVALIDATE_ENG0_REQ);
</span> 		hub-&gt;vm_inv_eng0_ack =
<span
class="del">-			SOC15_REG_OFFSET(GC, GET_INST(GC, i), regVM_INVALIDATE_ENG0_ACK);
</span><span
class="add">+			SOC15_REG_OFFSET(GC, gc_index, regVM_INVALIDATE_ENG0_ACK);
</span> 		hub-&gt;vm_context0_cntl =
<span
class="del">-			SOC15_REG_OFFSET(GC, GET_INST(GC, i), regVM_CONTEXT0_CNTL);
</span><span
class="add">+			SOC15_REG_OFFSET(GC, gc_index, regVM_CONTEXT0_CNTL);
</span> 		hub-&gt;vm_l2_pro_fault_status =
<span
class="del">-			SOC15_REG_OFFSET(GC, GET_INST(GC, i),
</span><span
class="add">+			SOC15_REG_OFFSET(GC, gc_index,
</span> 				regVM_L2_PROTECTION_FAULT_STATUS);
 		hub-&gt;vm_l2_pro_fault_cntl =
<span
class="del">-			SOC15_REG_OFFSET(GC, GET_INST(GC, i), regVM_L2_PROTECTION_FAULT_CNTL);
</span><span
class="add">+			SOC15_REG_OFFSET(GC, gc_index, regVM_L2_PROTECTION_FAULT_CNTL);
</span> 
 		hub-&gt;ctx_distance = regVM_CONTEXT1_CNTL -
 				regVM_CONTEXT0_CNTL;
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Joao Paulo Pereira da Silva</name><email>jppaulo11@usp.br</email></author><title>[PATCH] drm/amd/display/dc: Remove dc code repetition</title><updated>2024-06-13T16:06:11Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240613160549.139004-1-jppaulo11@usp.br/"/><id>urn:uuid:9a6b8c6c-5657-1c86-c60e-6a1e2d5dbbd5</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Code is repeated in functions optc1_enable_crtc
(dc/optc/dcn10/dcn10_optc.c) and optc2_enable_crtc
(dc/optc/dcn20/dcn20_optc.c).

So, remove it with the creation of a macro.

Signed-off-by: Joao Paulo Pereira da Silva &lt;jppaulo11@usp.br&gt;
---
 .../amd/display/dc/optc/dcn10/dcn10_optc.c    | 29 ++-----------------
 .../amd/display/dc/optc/dcn10/dcn10_optc.h    | 27 +++++++++++++++++
 .../amd/display/dc/optc/dcn20/dcn20_optc.c    | 29 ++-----------------
 3 files <a href="http://lore.kernel.org/amd-gfx/20240613160549.139004-1-jppaulo11@usp.br/#related">changed</a>, 33 insertions(+), 52 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/optc/dcn10/dcn10_optc.c b/drivers/gpu/drm/amd/display/dc/optc/dcn10/dcn10_optc.c
index 5574bc628053..facdeeb41250 100644
--- a/drivers/gpu/drm/amd/display/dc/optc/dcn10/dcn10_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/optc/dcn10/dcn10_optc.c
</span><span
class="hunk">@@ -41,6 +41,8 @@
</span> 
 #define STATIC_SCREEN_EVENT_MASK_RANGETIMING_DOUBLE_BUFFER_UPDATE_EN 0x100
 
<span
class="add">+#define OPTC_SRC_SEL_FIELD OPTC_SRC_SEL
+
</span> /**
  * apply_front_porch_workaround() - This is a workaround for a bug that has
  *                                  existed since R5xx and has not been fixed
<span
class="hunk">@@ -517,32 +519,7 @@ void optc1_enable_optc_clock(struct timing_generator *optc, bool enable)
</span>  */
 static bool optc1_enable_crtc(struct timing_generator *optc)
 {
<span
class="del">-	/* TODO FPGA wait for answer
-	 * OTG_MASTER_UPDATE_MODE != CRTC_MASTER_UPDATE_MODE
-	 * OTG_MASTER_UPDATE_LOCK != CRTC_MASTER_UPDATE_LOCK
-	 */
-	struct optc *optc1 = DCN10TG_FROM_TG(optc);
-
-	/* opp instance for OTG. For DCN1.0, ODM is remoed.
-	 * OPP and OPTC should 1:1 mapping
-	 */
-	REG_UPDATE(OPTC_DATA_SOURCE_SELECT,
-			OPTC_SRC_SEL, optc-&gt;inst);
-
-	/* VTG enable first is for HW workaround */
-	REG_UPDATE(CONTROL,
-			VTG0_ENABLE, 1);
-
-	REG_SEQ_START();
-
-	/* Enable CRTC */
-	REG_UPDATE_2(OTG_CONTROL,
-			OTG_DISABLE_POINT_CNTL, 3,
-			OTG_MASTER_EN, 1);
-
-	REG_SEQ_SUBMIT();
-	REG_SEQ_WAIT_DONE();
-
</span><span
class="add">+	_optc1_enable_crtc(optc);
</span> 	return true;
 }
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/optc/dcn10/dcn10_optc.h b/drivers/gpu/drm/amd/display/dc/optc/dcn10/dcn10_optc.h
index 2f3bd7648ba7..aea80fa6fe91 100644
--- a/drivers/gpu/drm/amd/display/dc/optc/dcn10/dcn10_optc.h
+++ b/drivers/gpu/drm/amd/display/dc/optc/dcn10/dcn10_optc.h
</span><span
class="hunk">@@ -604,4 +604,31 @@ struct dcn_optc_mask {
</span> 
 void dcn10_timing_generator_init(struct optc *optc);
 
<span
class="add">+#define _optc1_enable_crtc(optc)					\
+	do {								\
+		/* TODO FPGA wait for answer */				\
+		/* OTG_MASTER_UPDATE_MODE != CRTC_MASTER_UPDATE_MODE */	\
+		/* OTG_MASTER_UPDATE_LOCK != CRTC_MASTER_UPDATE_LOCK */	\
+		struct optc *optc1 = DCN10TG_FROM_TG(optc);		\
+									\
+		/* opp instance for OTG. For DCN1.0, ODM is remoed. */	\
+		/* OPP and OPTC should 1:1 mapping */			\
+		REG_UPDATE(OPTC_DATA_SOURCE_SELECT,			\
+				OPTC_SRC_SEL_FIELD, optc-&gt;inst);	\
+									\
+		/* VTG enable first is for HW workaround */		\
+		REG_UPDATE(CONTROL,					\
+				VTG0_ENABLE, 1);			\
+									\
+		REG_SEQ_START();					\
+									\
+		/* Enable CRTC */					\
+		REG_UPDATE_2(OTG_CONTROL,				\
+				OTG_DISABLE_POINT_CNTL, 3,		\
+				OTG_MASTER_EN, 1);			\
+									\
+		REG_SEQ_SUBMIT();					\
+		REG_SEQ_WAIT_DONE();					\
+	} while (0)
+
</span> #endif /* __DC_TIMING_GENERATOR_DCN10_H__ */
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/optc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/optc/dcn20/dcn20_optc.c
index d6f095b4555d..012e0c52aeec 100644
--- a/drivers/gpu/drm/amd/display/dc/optc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/optc/dcn20/dcn20_optc.c
</span><span
class="hunk">@@ -37,6 +37,8 @@
</span> #define FN(reg_name, field_name) \
 	optc1-&gt;tg_shift-&gt;field_name, optc1-&gt;tg_mask-&gt;field_name
 
<span
class="add">+#define OPTC_SRC_SEL_FIELD OPTC_SEG0_SRC_SEL
+
</span> /**
  * optc2_enable_crtc() - Enable CRTC - call ASIC Control Object to enable Timing generator.
  *
<span
class="hunk">@@ -47,32 +49,7 @@
</span>  */
 bool optc2_enable_crtc(struct timing_generator *optc)
 {
<span
class="del">-	/* TODO FPGA wait for answer
-	 * OTG_MASTER_UPDATE_MODE != CRTC_MASTER_UPDATE_MODE
-	 * OTG_MASTER_UPDATE_LOCK != CRTC_MASTER_UPDATE_LOCK
-	 */
-	struct optc *optc1 = DCN10TG_FROM_TG(optc);
-
-	/* opp instance for OTG. For DCN1.0, ODM is remoed.
-	 * OPP and OPTC should 1:1 mapping
-	 */
-	REG_UPDATE(OPTC_DATA_SOURCE_SELECT,
-			OPTC_SEG0_SRC_SEL, optc-&gt;inst);
-
-	/* VTG enable first is for HW workaround */
-	REG_UPDATE(CONTROL,
-			VTG0_ENABLE, 1);
-
-	REG_SEQ_START();
-
-	/* Enable CRTC */
-	REG_UPDATE_2(OTG_CONTROL,
-			OTG_DISABLE_POINT_CNTL, 3,
-			OTG_MASTER_EN, 1);
-
-	REG_SEQ_SUBMIT();
-	REG_SEQ_WAIT_DONE();
-
</span><span
class="add">+	_optc1_enable_crtc(optc);
</span> 	return true;
 }
 
-- 
2.44.0

</pre></div></content></entry><entry><author><name>Tao Zhou</name><email>tao.zhou1@amd.com</email></author><title>[PATCH] drm/amdkfd: add ASIC version check for the reset selection of RAS poison</title><updated>2024-06-13T11:14:21Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240613111358.31261-1-tao.zhou1@amd.com/"/><id>urn:uuid:03e492d4-de89-1e41-2933-ca75b551ab42</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">GFX v9.4.3 uses mode1 reset, other ASICs choose mode2.

Signed-off-by: Tao Zhou &lt;tao.zhou1@amd.com&gt;
---
 drivers/gpu/drm/amd/amdkfd/kfd_int_process_v9.c | 10 ++++++++--
 1 file <a href="http://lore.kernel.org/amd-gfx/20240613111358.31261-1-tao.zhou1@amd.com/#related">changed</a>, 8 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_int_process_v9.c b/drivers/gpu/drm/amd/amdkfd/kfd_int_process_v9.c
index 78dde62fb04a..816800555f7f 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_int_process_v9.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_int_process_v9.c
</span><span
class="hunk">@@ -164,7 +164,10 @@ static void event_interrupt_poison_consumption_v9(struct kfd_node *dev,
</span> 	case SOC15_IH_CLIENTID_SE3SH:
 	case SOC15_IH_CLIENTID_UTCL2:
 		block = AMDGPU_RAS_BLOCK__GFX;
<span
class="del">-		reset = AMDGPU_RAS_GPU_RESET_MODE1_RESET;
</span><span
class="add">+		if (amdgpu_ip_version(dev-&gt;adev, GC_HWIP, 0) == IP_VERSION(9, 4, 3))
+			reset = AMDGPU_RAS_GPU_RESET_MODE1_RESET;
+		else
+			reset = AMDGPU_RAS_GPU_RESET_MODE2_RESET;
</span> 		break;
 	case SOC15_IH_CLIENTID_VMC:
 	case SOC15_IH_CLIENTID_VMC1:
<span
class="hunk">@@ -177,7 +180,10 @@ static void event_interrupt_poison_consumption_v9(struct kfd_node *dev,
</span> 	case SOC15_IH_CLIENTID_SDMA3:
 	case SOC15_IH_CLIENTID_SDMA4:
 		block = AMDGPU_RAS_BLOCK__SDMA;
<span
class="del">-		reset = AMDGPU_RAS_GPU_RESET_MODE1_RESET;
</span><span
class="add">+		if (amdgpu_ip_version(dev-&gt;adev, GC_HWIP, 0) == IP_VERSION(9, 4, 3))
+			reset = AMDGPU_RAS_GPU_RESET_MODE1_RESET;
+		else
+			reset = AMDGPU_RAS_GPU_RESET_MODE2_RESET;
</span> 		break;
 	default:
 		dev_warn(dev-&gt;adev-&gt;dev,
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Tao Zhou</name><email>tao.zhou1@amd.com</email></author><title>[PATCH] drm/amdkfd: use mode1 reset for RAS poison consumption</title><updated>2024-06-13T06:57:42Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240613065726.30129-1-tao.zhou1@amd.com/"/><id>urn:uuid:faab9ed1-d7a0-b460-4914-00979545c6e8</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Per FW requirement, replace mode2 with mode1.

Signed-off-by: Tao Zhou &lt;tao.zhou1@amd.com&gt;
---
 drivers/gpu/drm/amd/amdkfd/kfd_int_process_v9.c | 4 ++--
 1 file <a href="http://lore.kernel.org/amd-gfx/20240613065726.30129-1-tao.zhou1@amd.com/#related">changed</a>, 2 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_int_process_v9.c b/drivers/gpu/drm/amd/amdkfd/kfd_int_process_v9.c
index e1c21d250611..78dde62fb04a 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_int_process_v9.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_int_process_v9.c
</span><span
class="hunk">@@ -164,7 +164,7 @@ static void event_interrupt_poison_consumption_v9(struct kfd_node *dev,
</span> 	case SOC15_IH_CLIENTID_SE3SH:
 	case SOC15_IH_CLIENTID_UTCL2:
 		block = AMDGPU_RAS_BLOCK__GFX;
<span
class="del">-		reset = AMDGPU_RAS_GPU_RESET_MODE2_RESET;
</span><span
class="add">+		reset = AMDGPU_RAS_GPU_RESET_MODE1_RESET;
</span> 		break;
 	case SOC15_IH_CLIENTID_VMC:
 	case SOC15_IH_CLIENTID_VMC1:
<span
class="hunk">@@ -177,7 +177,7 @@ static void event_interrupt_poison_consumption_v9(struct kfd_node *dev,
</span> 	case SOC15_IH_CLIENTID_SDMA3:
 	case SOC15_IH_CLIENTID_SDMA4:
 		block = AMDGPU_RAS_BLOCK__SDMA;
<span
class="del">-		reset = AMDGPU_RAS_GPU_RESET_MODE2_RESET;
</span><span
class="add">+		reset = AMDGPU_RAS_GPU_RESET_MODE1_RESET;
</span> 		break;
 	default:
 		dev_warn(dev-&gt;adev-&gt;dev,
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Mario Limonciello</name><email>mario.limonciello@amd.com</email></author><title>[PATCH v3] drm/fb-helper: Detect when lid is closed during initialization</title><updated>2024-06-13T05:17:30Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240613051700.1112-1-mario.limonciello@amd.com/"/><id>urn:uuid:c3edc70d-a3ff-2134-0e4c-28c09f3c33cb</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">If the lid on a laptop is closed when eDP connectors are populated
then it remains enabled when the initial framebuffer configuration
is built.

When creating the initial framebuffer configuration detect the
lid status and if it&#39;s closed disable any eDP connectors.

Also set up a workqueue to monitor for any future lid events.

Suggested-by: Dmitry Torokhov &lt;dmitry.torokhov@gmail.com&gt;
Reported-by: Chris Bainbridge &lt;chris.bainbridge@gmail.com&gt;
Closes: <a
href="https://gitlab.freedesktop.org/drm/amd/-/issues/3349">https://gitlab.freedesktop.org/drm/amd/-/issues/3349</a>
Signed-off-by: Mario Limonciello &lt;mario.limonciello@amd.com&gt;
---
v2-&gt;v3:
 * Use input device instead of ACPI device
 * Detect lid open/close events
---
 drivers/gpu/drm/drm_client_modeset.c |  29 ++++++
 drivers/gpu/drm/drm_fb_helper.c      | 132 +++++++++++++++++++++++++++
 include/drm/drm_device.h             |   6 ++
 include/drm/drm_fb_helper.h          |   2 +
 4 files <a href="http://lore.kernel.org/amd-gfx/20240613051700.1112-1-mario.limonciello@amd.com/#related">changed</a>, 169 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/drm_client_modeset.c b/drivers/gpu/drm/drm_client_modeset.c
index 31af5cf37a09..b8adfe87334b 100644
--- a/drivers/gpu/drm/drm_client_modeset.c
+++ b/drivers/gpu/drm/drm_client_modeset.c
</span><span
class="hunk">@@ -257,6 +257,34 @@ static void drm_client_connectors_enabled(struct drm_connector **connectors,
</span> 		enabled[i] = drm_connector_enabled(connectors[i], false);
 }
 
<span
class="add">+static void drm_client_match_edp_lid(struct drm_device *dev,
+				     struct drm_connector **connectors,
+				     unsigned int connector_count,
+				     bool *enabled)
+{
+	int i;
+
+	for (i = 0; i &lt; connector_count; i++) {
+		struct drm_connector *connector = connectors[i];
+
+		switch (connector-&gt;connector_type) {
+		case DRM_MODE_CONNECTOR_LVDS:
+		case DRM_MODE_CONNECTOR_eDP:
+			if (!enabled[i])
+				continue;
+			break;
+		default:
+			continue;
+		}
+
+		if (dev-&gt;lid_closed) {
+			drm_dbg_kms(dev, &#34;[CONNECTOR:%d:%s] lid is closed, disabling\n&#34;,
+				    connector-&gt;base.id, connector-&gt;name);
+			enabled[i] = false;
+		}
+	}
+}
+
</span> static bool drm_client_target_cloned(struct drm_device *dev,
 				     struct drm_connector **connectors,
 				     unsigned int connector_count,
<span
class="hunk">@@ -844,6 +872,7 @@ int drm_client_modeset_probe(struct drm_client_dev *client, unsigned int width,
</span> 		memset(crtcs, 0, connector_count * sizeof(*crtcs));
 		memset(offsets, 0, connector_count * sizeof(*offsets));
 
<span
class="add">+		drm_client_match_edp_lid(dev, connectors, connector_count, enabled);
</span> 		if (!drm_client_target_cloned(dev, connectors, connector_count, modes,
 					      offsets, enabled, width, height) &#38;&#38;
 		    !drm_client_target_preferred(dev, connectors, connector_count, modes,
<span
class="head">diff --git a/drivers/gpu/drm/drm_fb_helper.c b/drivers/gpu/drm/drm_fb_helper.c
index d612133e2cf7..41dd5887599a 100644
--- a/drivers/gpu/drm/drm_fb_helper.c
+++ b/drivers/gpu/drm/drm_fb_helper.c
</span><span
class="hunk">@@ -30,6 +30,8 @@
</span> #define pr_fmt(fmt) KBUILD_MODNAME &#34;: &#34; fmt
 
 #include &lt;linux/console.h&gt;
<span
class="add">+#include &lt;linux/input.h&gt;
+#include &lt;linux/mod_devicetable.h&gt;
</span> #include &lt;linux/pci.h&gt;
 #include &lt;linux/sysrq.h&gt;
 #include &lt;linux/vga_switcheroo.h&gt;
<span
class="hunk">@@ -413,6 +415,128 @@ static void drm_fb_helper_damage_work(struct work_struct *work)
</span> 	drm_fb_helper_fb_dirty(helper);
 }
 
<span
class="add">+static void drm_fb_helper_lid_event(struct input_handle *handle, unsigned int type,
+				    unsigned int code, int value)
+{
+	if (type == EV_SW &#38;&#38; code == SW_LID) {
+		struct drm_fb_helper *fb_helper = handle-&gt;handler-&gt;private;
+
+		if (value != fb_helper-&gt;dev-&gt;lid_closed) {
+			fb_helper-&gt;dev-&gt;lid_closed = value;
+			queue_work(fb_helper-&gt;input_wq, &#38;fb_helper-&gt;lid_work);
+		}
+	}
+}
+
+struct drm_fb_lid {
+	struct input_handle handle;
+};
+
+static int drm_fb_helper_lid_connect(struct input_handler *handler,
+				     struct input_dev *dev,
+				     const struct input_device_id *id)
+{
+	struct drm_fb_helper *fb_helper = handler-&gt;private;
+	struct drm_fb_lid *lid;
+	char *name;
+	int error;
+
+	lid = kzalloc(sizeof(*lid), GFP_KERNEL);
+	if (!lid)
+		return -ENOMEM;
+
+	name = kasprintf(GFP_KERNEL, &#34;drm-fb-helper-lid-%s&#34;, dev_name(&#38;dev-&gt;dev));
+	if (!name) {
+		error = -ENOMEM;
+		goto err_free_lid;
+	}
+
+	lid-&gt;handle.dev = dev;
+	lid-&gt;handle.handler = handler;
+	lid-&gt;handle.name = name;
+	lid-&gt;handle.private = lid;
+
+	error = input_register_handle(&#38;lid-&gt;handle);
+	if (error)
+		goto err_free_name;
+
+	error = input_open_device(&#38;lid-&gt;handle);
+	if (error)
+		goto err_unregister_handle;
+
+	fb_helper-&gt;dev-&gt;lid_closed = dev-&gt;sw[SW_LID];
+	drm_dbg_kms(fb_helper-&gt;dev, &#34;initial lid state is set to %d\n&#34;, fb_helper-&gt;dev-&gt;lid_closed);
+
+	return 0;
+
+err_unregister_handle:
+	input_unregister_handle(&#38;lid-&gt;handle);
+err_free_name:
+	kfree(name);
+err_free_lid:
+	kfree(lid);
+	return error;
+}
+
+static void drm_fb_helper_lid_disconnect(struct input_handle *handle)
+{
+	struct drm_fb_lid *lid = handle-&gt;private;
+
+	input_close_device(handle);
+	input_unregister_handle(handle);
+
+	kfree(handle-&gt;name);
+	kfree(lid);
+}
+
+static const struct input_device_id drm_fb_helper_lid_ids[] = {
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT | INPUT_DEVICE_ID_MATCH_SWBIT,
+		.evbit = { BIT_MASK(EV_SW) },
+		.swbit = { [BIT_WORD(SW_LID)] = BIT_MASK(SW_LID) },
+	},
+	{ },
+};
+
+static struct input_handler drm_fb_helper_lid_handler = {
+	.event =	drm_fb_helper_lid_event,
+	.connect =	drm_fb_helper_lid_connect,
+	.disconnect =	drm_fb_helper_lid_disconnect,
+	.name =		&#34;drm-fb-helper-lid&#34;,
+	.id_table =	drm_fb_helper_lid_ids,
+};
+
+static void drm_fb_helper_lid_work(struct work_struct *work)
+{
+	struct drm_fb_helper *fb_helper = container_of(work, struct drm_fb_helper,
+						       lid_work);
+	drm_fb_helper_hotplug_event(fb_helper);
+}
+
+static int drm_fb_helper_create_lid_handler(struct drm_fb_helper *fb_helper)
+{
+	int ret = 0;
+
+	if (fb_helper-&gt;deferred_setup)
+		return 0;
+
+	fb_helper-&gt;input_wq = create_singlethread_workqueue(&#34;drm-fb-lid&#34;);
+	if (fb_helper-&gt;input_wq == NULL)
+		return -ENOMEM;
+
+	drm_fb_helper_lid_handler.private = fb_helper;
+	ret = input_register_handler(&#38;drm_fb_helper_lid_handler);
+	if (ret)
+		goto remove_wq;
+
+	return 0;
+
+remove_wq:
+	destroy_workqueue(fb_helper-&gt;input_wq);
+	fb_helper-&gt;input_wq = NULL;
+	return ret;
+}
+
</span> /**
  * drm_fb_helper_prepare - setup a drm_fb_helper structure
  * @dev: DRM device
<span
class="hunk">@@ -445,6 +569,7 @@ void drm_fb_helper_prepare(struct drm_device *dev, struct drm_fb_helper *helper,
</span> 	spin_lock_init(&#38;helper-&gt;damage_lock);
 	INIT_WORK(&#38;helper-&gt;resume_work, drm_fb_helper_resume_worker);
 	INIT_WORK(&#38;helper-&gt;damage_work, drm_fb_helper_damage_work);
<span
class="add">+	INIT_WORK(&#38;helper-&gt;lid_work, drm_fb_helper_lid_work);
</span> 	helper-&gt;damage_clip.x1 = helper-&gt;damage_clip.y1 = ~0;
 	mutex_init(&#38;helper-&gt;lock);
 	helper-&gt;funcs = funcs;
<span
class="hunk">@@ -593,6 +718,9 @@ void drm_fb_helper_fini(struct drm_fb_helper *fb_helper)
</span> 	if (!drm_fbdev_emulation)
 		return;
 
<span
class="add">+	input_unregister_handler(&#38;drm_fb_helper_lid_handler);
+	destroy_workqueue(fb_helper-&gt;input_wq);
+
</span> 	cancel_work_sync(&#38;fb_helper-&gt;resume_work);
 	cancel_work_sync(&#38;fb_helper-&gt;damage_work);
 
<span
class="hunk">@@ -1842,6 +1970,10 @@ __drm_fb_helper_initial_config_and_unlock(struct drm_fb_helper *fb_helper)
</span> 	width = dev-&gt;mode_config.max_width;
 	height = dev-&gt;mode_config.max_height;
 
<span
class="add">+	ret = drm_fb_helper_create_lid_handler(fb_helper);
+	if (ret)
+		return ret;
+
</span> 	drm_client_modeset_probe(&#38;fb_helper-&gt;client, width, height);
 	ret = drm_fb_helper_single_fb_probe(fb_helper);
 	if (ret &lt; 0) {
<span
class="head">diff --git a/include/drm/drm_device.h b/include/drm/drm_device.h
index 63767cf24371..619af597784c 100644
--- a/include/drm/drm_device.h
+++ b/include/drm/drm_device.h
</span><span
class="hunk">@@ -316,6 +316,12 @@ struct drm_device {
</span> 	 * Root directory for debugfs files.
 	 */
 	struct dentry *debugfs_root;
<span
class="add">+
+	/**
+	 * @lid_closed: Flag to tell the lid switch state
+	 */
+	bool lid_closed;
+
</span> };
 
 #endif
<span
class="head">diff --git a/include/drm/drm_fb_helper.h b/include/drm/drm_fb_helper.h
index 375737fd6c36..7fb36c10299d 100644
--- a/include/drm/drm_fb_helper.h
+++ b/include/drm/drm_fb_helper.h
</span><span
class="hunk">@@ -143,6 +143,8 @@ struct drm_fb_helper {
</span> 	spinlock_t damage_lock;
 	struct work_struct damage_work;
 	struct work_struct resume_work;
<span
class="add">+	struct work_struct lid_work;
+	struct workqueue_struct *input_wq;
</span> 
 	/**
 	 * @lock:
-- 
2.43.0

</pre></div></content></entry><entry><author><name>YiPeng Chai</name><email>YiPeng.Chai@amd.com</email></author><title>[PATCH 5/5] drm/amdgpu: add gpu reset check before page retirement thread runs</title><updated>2024-06-13T02:27:24Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240613022504.81787-5-YiPeng.Chai@amd.com/"/><id>urn:uuid:6e06134d-beec-fab1-f86d-1408c1de6bbc</id><thr:in-reply-to
ref="urn:uuid:b016da6a-4ae8-9c55-9382-26cce713f7e9"
href="http://lore.kernel.org/amd-gfx/20240613022504.81787-1-YiPeng.Chai@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">If gpu is recovering, clear all message reset flags
in fifo and wait for gpu to complete recovery.

Signed-off-by: YiPeng Chai &lt;YiPeng.Chai@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c | 12 ++++++++++++
 1 file <a href="http://lore.kernel.org/amd-gfx/20240613022504.81787-5-YiPeng.Chai@amd.com/#related">changed</a>, 12 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
index 341c9bd0d1a4..bf4f8d439ebe 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
</span><span
class="hunk">@@ -2982,6 +2982,18 @@ static int amdgpu_ras_page_retirement_thread(void *param)
</span> 
 		atomic_dec(&#38;con-&gt;page_retirement_req_cnt);
 
<span
class="add">+		reinit_completion(&#38;con-&gt;gpu_reset_completion);
+
+		if (amdgpu_in_reset(adev) || atomic_read(&#38;con-&gt;in_recovery)) {
+			uint32_t reset;
+
+			amdgpu_ras_clear_poison_fifo_msg_reset_flag(adev, &#38;reset);
+
+			if (!wait_for_completion_timeout(&#38;con-&gt;gpu_reset_completion,
+				msecs_to_jiffies(MAX_GPU_RESET_COMPLETION_TIME)))
+				dev_err(adev-&gt;dev, &#34;Waiting for GPU to complete reset timeout!\n&#34;);
+		}
+
</span> #ifdef HAVE_KFIFO_PUT_NON_POINTER
 		if (!amdgpu_ras_get_poison_req(adev, &#38;poison_msg))
 			continue;
-- 
2.34.1

</pre></div></content></entry><entry><author><name>YiPeng Chai</name><email>YiPeng.Chai@amd.com</email></author><title>[PATCH 4/5] drm/amdgpu: wait for gpu to complete reset</title><updated>2024-06-13T02:27:15Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240613022504.81787-4-YiPeng.Chai@amd.com/"/><id>urn:uuid:e9911efe-ea36-d89d-9edf-daaacd7031c9</id><thr:in-reply-to
ref="urn:uuid:b016da6a-4ae8-9c55-9382-26cce713f7e9"
href="http://lore.kernel.org/amd-gfx/20240613022504.81787-1-YiPeng.Chai@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Add completion to wait for gpu to complete reset.

Signed-off-by: YiPeng Chai &lt;YiPeng.Chai@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c | 12 ++++++++++++
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h |  1 +
 2 files <a href="http://lore.kernel.org/amd-gfx/20240613022504.81787-4-YiPeng.Chai@amd.com/#related">changed</a>, 13 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
index 7dfb2e548d70..341c9bd0d1a4 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
</span><span
class="hunk">@@ -124,6 +124,8 @@ const char *get_ras_block_str(struct ras_common_if *ras_block)
</span> 
 #define AMDGPU_RAS_RETIRE_PAGE_INTERVAL 100  //ms
 
<span
class="add">+#define MAX_GPU_RESET_COMPLETION_TIME  120000 //ms
+
</span> #define RAS_POISON_FIFO_MSG_PENDING_THRESHOLD  (AMDGPU_RAS_POISON_FIFO_SIZE/4)
 
 enum amdgpu_ras_retire_page_reservation {
<span
class="hunk">@@ -2526,6 +2528,8 @@ static void amdgpu_ras_do_recovery(struct work_struct *work)
</span> 		atomic_set(&#38;hive-&gt;ras_recovery, 0);
 		amdgpu_put_xgmi_hive(hive);
 	}
<span
class="add">+
+	complete(&#38;ras-&gt;gpu_reset_completion);
</span> }
 
 /* alloc/realloc bps array */
<span
class="hunk">@@ -2946,7 +2950,14 @@ static int amdgpu_ras_poison_consumption_handler(struct amdgpu_device *adev,
</span> 			con-&gt;gpu_reset_flags |= reset;
 		}
 
<span
class="add">+		reinit_completion(&#38;con-&gt;gpu_reset_completion);
+
</span> 		amdgpu_ras_reset_gpu(adev);
<span
class="add">+
+		if (!wait_for_completion_timeout(&#38;con-&gt;gpu_reset_completion,
+				msecs_to_jiffies(MAX_GPU_RESET_COMPLETION_TIME)))
+			dev_err(adev-&gt;dev, &#34;Waiting for GPU to complete reset timeout! reset:0x%x\n&#34;,
+				reset);
</span> 	}
 
 	return 0;
<span
class="hunk">@@ -3072,6 +3083,7 @@ int amdgpu_ras_recovery_init(struct amdgpu_device *adev)
</span> 		}
 	}
 
<span
class="add">+	init_completion(&#38;con-&gt;gpu_reset_completion);
</span> 	mutex_init(&#38;con-&gt;page_rsv_lock);
 	INIT_KFIFO(con-&gt;poison_fifo);
 	mutex_init(&#38;con-&gt;page_retirement_lock);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
index 103436bb650e..d5ddd0ca5de1 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
</span><span
class="hunk">@@ -537,6 +537,7 @@ struct amdgpu_ras {
</span> 	DECLARE_KFIFO(poison_fifo, struct ras_poison_msg, AMDGPU_RAS_POISON_FIFO_SIZE);
 	struct ras_ecc_log_info  umc_ecc_log;
 	struct delayed_work page_retirement_dwork;
<span
class="add">+	struct completion gpu_reset_completion;
</span> 
 	/* Fatal error detected flag */
 	atomic_t fed;
-- 
2.34.1

</pre></div></content></entry><entry><author><name>YiPeng Chai</name><email>YiPeng.Chai@amd.com</email></author><title>[PATCH 3/5] drm/amdgpu: clear all messages reset flags in fifo before gpu reset</title><updated>2024-06-13T02:27:14Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240613022504.81787-3-YiPeng.Chai@amd.com/"/><id>urn:uuid:2fbb5a80-2b08-d0c1-aec0-a584877ff6be</id><thr:in-reply-to
ref="urn:uuid:b016da6a-4ae8-9c55-9382-26cce713f7e9"
href="http://lore.kernel.org/amd-gfx/20240613022504.81787-1-YiPeng.Chai@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">To avoid resetting the gpu repeatedly, clear all
message reset flags in the fifo before the first
gpu reset.

Signed-off-by: YiPeng Chai &lt;YiPeng.Chai@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c | 59 ++++++++++++++++++++++++-
 1 file <a href="http://lore.kernel.org/amd-gfx/20240613022504.81787-3-YiPeng.Chai@amd.com/#related">changed</a>, 58 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
index 1e6e06009577..7dfb2e548d70 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
</span><span
class="hunk">@@ -2768,6 +2768,49 @@ static int amdgpu_ras_get_poison_req(struct amdgpu_device *adev,
</span> 
 	return kfifo_get(&#38;con-&gt;poison_fifo, poison_msg);
 }
<span
class="add">+
+static void amdgpu_ras_clear_poison_fifo_msg_reset_flag(struct amdgpu_device *adev,
+			uint32_t *cached_reset)
+{
+	struct amdgpu_ras *con = amdgpu_ras_get_context(adev);
+	struct ras_poison_msg msg;
+	uint32_t cached_msg_count;
+	uint32_t reset = 0;
+	int i, ret;
+
+	cached_msg_count = kfifo_len(&#38;con-&gt;poison_fifo);
+
+	for (i = 0; i &lt; cached_msg_count; i++) {
+		ret = kfifo_get(&#38;con-&gt;poison_fifo, &#38;msg);
+		if (!ret)
+			continue;
+
+		if (msg.block != AMDGPU_RAS_BLOCK__UMC) {
+			reset |= msg.reset;
+
+			/* Clear reset flag */
+			msg.reset = 0;
+		}
+
+		/* add message back to fifo */
+		ret = kfifo_put(&#38;con-&gt;poison_fifo, msg);
+		if (!ret)
+			dev_info(adev-&gt;dev, &#34;Poison fifo drop message!\n&#34;);
+	}
+	*cached_reset = reset;
+}
+
+static void amdgpu_ras_clear_poison_fifo(struct amdgpu_device *adev)
+{
+	struct amdgpu_ras *con = amdgpu_ras_get_context(adev);
+	struct ras_poison_msg msg;
+	int ret;
+
+	do {
+		ret = kfifo_get(&#38;con-&gt;poison_fifo, &#38;msg);
+	} while (ret);
+
+}
</span> #endif
 
 #ifdef HAVE_RADIX_TREE_ITER_DELETE
<span
class="hunk">@@ -2886,9 +2929,23 @@ static int amdgpu_ras_poison_consumption_handler(struct amdgpu_device *adev,
</span> 		poison_msg-&gt;pasid_fn(adev, pasid, poison_msg-&gt;data);
 
 	if (reset) {
<span
class="add">+		uint32_t fifo_cached_reset = 0;
+
</span> 		flush_delayed_work(&#38;con-&gt;page_retirement_dwork);
 
<span
class="del">-		con-&gt;gpu_reset_flags |= reset;
</span><span
class="add">+		amdgpu_ras_clear_poison_fifo_msg_reset_flag(adev, &#38;fifo_cached_reset);
+
+		reset |= fifo_cached_reset;
+
+		if (reset &#38; AMDGPU_RAS_GPU_RESET_MODE1_RESET) {
+			con-&gt;gpu_reset_flags |= AMDGPU_RAS_GPU_RESET_MODE1_RESET;
+			amdgpu_ras_clear_poison_fifo(adev);
+		} else if (reset &#38; AMDGPU_RAS_GPU_RESET_MODE2_RESET) {
+			con-&gt;gpu_reset_flags |= AMDGPU_RAS_GPU_RESET_MODE2_RESET;
+		} else {
+			con-&gt;gpu_reset_flags |= reset;
+		}
+
</span> 		amdgpu_ras_reset_gpu(adev);
 	}
 
-- 
2.34.1

</pre></div></content></entry><entry><author><name>YiPeng Chai</name><email>YiPeng.Chai@amd.com</email></author><title>[PATCH 2/5] drm/amdgpu: add threshold to interrupt waiting for DE data to be ready</title><updated>2024-06-13T02:27:13Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240613022504.81787-2-YiPeng.Chai@amd.com/"/><id>urn:uuid:fcd3a563-c55c-4f06-333b-60933e1fe1ee</id><thr:in-reply-to
ref="urn:uuid:b016da6a-4ae8-9c55-9382-26cce713f7e9"
href="http://lore.kernel.org/amd-gfx/20240613022504.81787-1-YiPeng.Chai@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">If the number of messages to be processed in the fifo exceeds
the threshold, it will not continue to wait for the DE data
to be ready.

Signed-off-by: YiPeng Chai &lt;YiPeng.Chai@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c | 13 +++++++++++++
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h |  4 +++-
 2 files <a href="http://lore.kernel.org/amd-gfx/20240613022504.81787-2-YiPeng.Chai@amd.com/#related">changed</a>, 16 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
index ed260966363f..1e6e06009577 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
</span><span
class="hunk">@@ -124,6 +124,8 @@ const char *get_ras_block_str(struct ras_common_if *ras_block)
</span> 
 #define AMDGPU_RAS_RETIRE_PAGE_INTERVAL 100  //ms
 
<span
class="add">+#define RAS_POISON_FIFO_MSG_PENDING_THRESHOLD  (AMDGPU_RAS_POISON_FIFO_SIZE/4)
+
</span> enum amdgpu_ras_retire_page_reservation {
 	AMDGPU_RAS_RETIRE_PAGE_RESERVED,
 	AMDGPU_RAS_RETIRE_PAGE_PENDING,
<span
class="hunk">@@ -2832,6 +2834,7 @@ static void amdgpu_ras_poison_creation_handler(struct amdgpu_device *adev,
</span> 	struct ras_query_if info;
 	uint32_t timeout = timeout_ms;
 	struct amdgpu_ras *ras = amdgpu_ras_get_context(adev);
<span
class="add">+	bool trigger_threshold = false;
</span> 
 	memset(&#38;info, 0, sizeof(info));
 	info.head.block = AMDGPU_RAS_BLOCK__UMC;
<span
class="hunk">@@ -2845,6 +2848,12 @@ static void amdgpu_ras_poison_creation_handler(struct amdgpu_device *adev,
</span> 			return;
 		}
 
<span
class="add">+		if (atomic_read(&#38;ras-&gt;page_retirement_req_cnt) &gt;
+				RAS_POISON_FIFO_MSG_PENDING_THRESHOLD) {
+			trigger_threshold = true;
+			break;
+		}
+
</span> 		if (timeout &#38;&#38; !ecc_log-&gt;de_updated) {
 			msleep(1);
 			timeout--;
<span
class="hunk">@@ -2856,6 +2865,10 @@ static void amdgpu_ras_poison_creation_handler(struct amdgpu_device *adev,
</span> 		return;
 	}
 
<span
class="add">+	if (trigger_threshold)
+		dev_dbg(adev-&gt;dev, &#34;Waiting for deferred data %d ms, pending msg:%d\n&#34;,
+			timeout_ms - timeout, atomic_read(&#38;ras-&gt;page_retirement_req_cnt));
+
</span> 	if (!ret)
 		schedule_delayed_work(&#38;ras-&gt;page_retirement_dwork, 0);
 }
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
index e70c45712ddb..103436bb650e 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h
</span><span
class="hunk">@@ -36,6 +36,8 @@
</span> 
 struct amdgpu_iv_entry;
 
<span
class="add">+#define AMDGPU_RAS_POISON_FIFO_SIZE  128
+
</span> #define AMDGPU_RAS_GPU_ERR_MEM_TRAINING(x)		AMDGPU_GET_REG_FIELD(x, 0, 0)
 #define AMDGPU_RAS_GPU_ERR_FW_LOAD(x)			AMDGPU_GET_REG_FIELD(x, 1, 1)
 #define AMDGPU_RAS_GPU_ERR_WAFL_LINK_TRAINING(x)	AMDGPU_GET_REG_FIELD(x, 2, 2)
<span
class="hunk">@@ -532,7 +534,7 @@ struct amdgpu_ras {
</span> 	struct mutex page_retirement_lock;
 	atomic_t page_retirement_req_cnt;
 	struct mutex page_rsv_lock;
<span
class="del">-	DECLARE_KFIFO(poison_fifo, struct ras_poison_msg, 128);
</span><span
class="add">+	DECLARE_KFIFO(poison_fifo, struct ras_poison_msg, AMDGPU_RAS_POISON_FIFO_SIZE);
</span> 	struct ras_ecc_log_info  umc_ecc_log;
 	struct delayed_work page_retirement_dwork;
 
-- 
2.34.1

</pre></div></content></entry><entry><author><name>YiPeng Chai</name><email>YiPeng.Chai@amd.com</email></author><title>[PATCH 1/5] drm/amdgpu: add condition check for waking up thread</title><updated>2024-06-13T02:27:11Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240613022504.81787-1-YiPeng.Chai@amd.com/"/><id>urn:uuid:b016da6a-4ae8-9c55-9382-26cce713f7e9</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">1. Cannot add messages to fifo in gpu reset mode.
2. Only when the message is successfully saved to the
fifo, the thread can be awakened.

Signed-off-by: YiPeng Chai &lt;YiPeng.Chai@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c | 16 ++++++++++------
 drivers/gpu/drm/amd/amdgpu/amdgpu_umc.c | 18 +++++++++++-------
 2 files <a href="http://lore.kernel.org/amd-gfx/20240613022504.81787-1-YiPeng.Chai@amd.com/#related">changed</a>, 21 insertions(+), 13 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
index d0dcd3d37e6d..ed260966363f 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c
</span><span
class="hunk">@@ -2093,12 +2093,16 @@ static void amdgpu_ras_interrupt_poison_creation_handler(struct ras_manager *obj
</span> 	if (amdgpu_ip_version(obj-&gt;adev, UMC_HWIP, 0) &gt;= IP_VERSION(12, 0, 0)) {
 		struct amdgpu_ras *con = amdgpu_ras_get_context(obj-&gt;adev);
 
<span
class="del">-		amdgpu_ras_put_poison_req(obj-&gt;adev,
-			AMDGPU_RAS_BLOCK__UMC, 0, NULL, NULL, false);
-
-		atomic_inc(&#38;con-&gt;page_retirement_req_cnt);
-
-		wake_up(&#38;con-&gt;page_retirement_wq);
</span><span
class="add">+		if (!amdgpu_in_reset(obj-&gt;adev) &#38;&#38; !atomic_read(&#38;con-&gt;in_recovery)) {
+			int ret;
+
+			ret = amdgpu_ras_put_poison_req(obj-&gt;adev,
+				AMDGPU_RAS_BLOCK__UMC, 0, NULL, NULL, false);
+			if (!ret) {
+				atomic_inc(&#38;con-&gt;page_retirement_req_cnt);
+				wake_up(&#38;con-&gt;page_retirement_wq);
+			}
+		}
</span> 	}
 #endif
 }
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_umc.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_umc.c
index 1dbe69eabb9a..94181ae85886 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_umc.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_umc.c
</span><span
class="hunk">@@ -293,16 +293,20 @@ int amdgpu_umc_pasid_poison_handler(struct amdgpu_device *adev,
</span> 
 			amdgpu_ras_error_data_fini(&#38;err_data);
 		} else {
<span
class="del">-				struct amdgpu_ras *con = amdgpu_ras_get_context(adev);
-
</span> #ifdef HAVE_KFIFO_PUT_NON_POINTER
<span
class="del">-				amdgpu_ras_put_poison_req(adev,
-					block, pasid, pasid_fn, data, reset);
-#endif
</span><span
class="add">+			struct amdgpu_ras *con = amdgpu_ras_get_context(adev);
</span> 
<span
class="del">-				atomic_inc(&#38;con-&gt;page_retirement_req_cnt);
</span><span
class="add">+			if (!amdgpu_in_reset(adev) &#38;&#38; !atomic_read(&#38;con-&gt;in_recovery)) {
+				int ret;
</span> 
<span
class="del">-				wake_up(&#38;con-&gt;page_retirement_wq);
</span><span
class="add">+				ret = amdgpu_ras_put_poison_req(adev,
+					block, pasid, pasid_fn, data, reset);
+				if (!ret) {
+					atomic_inc(&#38;con-&gt;page_retirement_req_cnt);
+					wake_up(&#38;con-&gt;page_retirement_wq);
+				}
+			}
+#endif
</span> 		}
 	} else {
 		if (adev-&gt;virt.ops &#38;&#38; adev-&gt;virt.ops-&gt;ras_poison_handler)
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Douglas Anderson</name><email>dianders@chromium.org</email></author><title>[PATCH v2 8/8] drm/amdgpu: Call drm_atomic_helper_shutdown() at shutdown time</title><updated>2024-06-12T22:28:54Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240612152752.v2.8.I27914059cc822b52db9bf72b4013b525b60e06fd@changeid/"/><id>urn:uuid:46f83cef-8ab9-d1d8-f938-f6f13e330c5b</id><thr:in-reply-to
ref="urn:uuid:fd5858fb-2a6a-68b3-4e6b-2e8ed2da1cdd"
href="http://lore.kernel.org/amd-gfx/20240612222435.3188234-1-dianders@chromium.org/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Based on grepping through the source code this driver appears to be
missing a call to drm_atomic_helper_shutdown() at system shutdown
time. Among other things, this means that if a panel is in use that it
won&#39;t be cleanly powered off at system shutdown time.

The fact that we should call drm_atomic_helper_shutdown() in the case
of OS shutdown/restart comes straight out of the kernel doc &#34;driver
instance overview&#34; in drm_drv.c.

Suggested-by: Maxime Ripard &lt;mripard@kernel.org&gt;
Cc: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Cc: Christian K&#246;nig &lt;christian.koenig@amd.com&gt;
Cc: Xinhui Pan &lt;Xinhui.Pan@amd.com&gt;
Signed-off-by: Douglas Anderson &lt;dianders@chromium.org&gt;
---
This commit is only compile-time tested.

...and further, I&#39;d say that this patch is more of a plea for help
than a patch I think is actually right. I&#39;m _fairly_ certain that
drm/amdgpu needs this call at shutdown time but the logic is a bit
hard for me to follow. I&#39;d appreciate if anyone who actually knows
what this should look like could illuminate me, or perhaps even just
post a patch themselves!

(no changes since v1)

 drivers/gpu/drm/amd/amdgpu/amdgpu.h        |  1 +
 drivers/gpu/drm/amd/amdgpu/amdgpu_device.c | 10 ++++++++++
 drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c    |  2 ++
 3 files <a href="http://lore.kernel.org/amd-gfx/20240612152752.v2.8.I27914059cc822b52db9bf72b4013b525b60e06fd@changeid/#related">changed</a>, 13 insertions(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
index f87d53e183c3..c202a1d5ff5f 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
</span><span
class="hunk">@@ -1197,6 +1197,7 @@ static inline struct amdgpu_device *amdgpu_ttm_adev(struct ttm_device *bdev)
</span> int amdgpu_device_init(struct amdgpu_device *adev,
 		       uint32_t flags);
 void amdgpu_device_fini_hw(struct amdgpu_device *adev);
<span
class="add">+void amdgpu_device_shutdown_hw(struct amdgpu_device *adev);
</span> void amdgpu_device_fini_sw(struct amdgpu_device *adev);
 
 int amdgpu_gpu_wait_for_idle(struct amdgpu_device *adev);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
index 861ccff78af9..a8c4b8412e04 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
</span><span
class="hunk">@@ -4531,6 +4531,16 @@ void amdgpu_device_fini_hw(struct amdgpu_device *adev)
</span> 
 }
 
<span
class="add">+void amdgpu_device_shutdown_hw(struct amdgpu_device *adev)
+{
+	if (adev-&gt;mode_info.mode_config_initialized) {
+		if (!drm_drv_uses_atomic_modeset(adev_to_drm(adev)))
+			drm_helper_force_disable_all(adev_to_drm(adev));
+		else
+			drm_atomic_helper_shutdown(adev_to_drm(adev));
+	}
+}
+
</span> void amdgpu_device_fini_sw(struct amdgpu_device *adev)
 {
 	int idx;
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
index ea14f1c8f430..b34bf9259d5c 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
</span><span
class="hunk">@@ -2409,6 +2409,8 @@ amdgpu_pci_shutdown(struct pci_dev *pdev)
</span> 	struct drm_device *dev = pci_get_drvdata(pdev);
 	struct amdgpu_device *adev = drm_to_adev(dev);
 
<span
class="add">+	amdgpu_device_shutdown_hw(adev);
+
</span> 	if (amdgpu_ras_intr_triggered())
 		return;
 
-- 
2.45.2.505.gda0bf45e8d-goog

</pre></div></content></entry><entry><author><name>Douglas Anderson</name><email>dianders@chromium.org</email></author><title>[PATCH v2 7/8] drm/radeon: Call drm_helper_force_disable_all() at shutdown/remove time</title><updated>2024-06-12T22:28:44Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240612152752.v2.7.I022cfc2dcd30e77d4f7005a2d912dd7ab76c0338@changeid/"/><id>urn:uuid:efc4d0dc-c3ff-68d3-dbf6-ce84f8f58287</id><thr:in-reply-to
ref="urn:uuid:fd5858fb-2a6a-68b3-4e6b-2e8ed2da1cdd"
href="http://lore.kernel.org/amd-gfx/20240612222435.3188234-1-dianders@chromium.org/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Based on grepping through the source code, this driver appears to be
missing a call to drm_atomic_helper_shutdown(), or in this case the
non-atomic equivalent drm_helper_force_disable_all(), at system
shutdown time and at driver remove time. This is important because
drm_helper_force_disable_all() will cause panels to get disabled
cleanly which may be important for their power sequencing. Future
changes will remove any custom powering off in individual panel
drivers so the DRM drivers need to start getting this right.

The fact that we should call drm_atomic_helper_shutdown(), or in this
case the non-atomic equivalent drm_helper_force_disable_all(), in the
case of OS shutdown/restart comes straight out of the kernel doc
&#34;driver instance overview&#34; in drm_drv.c.

NOTE: in order to get things inserted in the right place, I had to
replace the old/deprecated drm_put_dev() function with the equivalent
new calls.

Suggested-by: Maxime Ripard &lt;mripard@kernel.org&gt;
Reviewed-by: Maxime Ripard &lt;mripard@kernel.org&gt;
Cc: Alex Deucher &lt;alexander.deucher@amd.com&gt;
Cc: Christian K&#246;nig &lt;christian.koenig@amd.com&gt;
Cc: Xinhui Pan &lt;Xinhui.Pan@amd.com&gt;
Signed-off-by: Douglas Anderson &lt;dianders@chromium.org&gt;
---
I honestly have no idea if I got this patch right. The shutdown()
function already had some special case logic for PPC, Loongson, and
VMs and I don&#39;t 100% for sure know how this interacts with
those. Everything here is just compile tested.

(no changes since v1)

 drivers/gpu/drm/radeon/radeon_drv.c | 7 ++++++-
 1 file <a href="http://lore.kernel.org/amd-gfx/20240612152752.v2.7.I022cfc2dcd30e77d4f7005a2d912dd7ab76c0338@changeid/#related">changed</a>, 6 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/radeon/radeon_drv.c b/drivers/gpu/drm/radeon/radeon_drv.c
index 7bf08164140e..9ea7f163a731 100644
--- a/drivers/gpu/drm/radeon/radeon_drv.c
+++ b/drivers/gpu/drm/radeon/radeon_drv.c
</span><span
class="hunk">@@ -38,6 +38,7 @@
</span> #include &lt;linux/pci.h&gt;
 
 #include &lt;drm/drm_aperture.h&gt;
<span
class="add">+#include &lt;drm/drm_crtc_helper.h&gt;
</span> #include &lt;drm/drm_drv.h&gt;
 #include &lt;drm/drm_file.h&gt;
 #include &lt;drm/drm_gem.h&gt;
<span
class="hunk">@@ -330,7 +331,9 @@ radeon_pci_remove(struct pci_dev *pdev)
</span> {
 	struct drm_device *dev = pci_get_drvdata(pdev);
 
<span
class="del">-	drm_put_dev(dev);
</span><span
class="add">+	drm_dev_unregister(dev);
+	drm_helper_force_disable_all(dev);
+	drm_dev_put(dev);
</span> }
 
 static void
<span
class="hunk">@@ -341,6 +344,8 @@ radeon_pci_shutdown(struct pci_dev *pdev)
</span> 	 */
 	if (radeon_device_is_virtual())
 		radeon_pci_remove(pdev);
<span
class="add">+	else
+		drm_helper_force_disable_all(pci_get_drvdata(pdev));
</span> 
 #if defined(CONFIG_PPC64) || defined(CONFIG_MACH_LOONGSON64)
 	/*
-- 
2.45.2.505.gda0bf45e8d-goog

</pre></div></content></entry><entry><author><name>Douglas Anderson</name><email>dianders@chromium.org</email></author><title>[PATCH v2 0/8] drm: make leftover drivers call drm_atomic_helper_shutdown() at the right times</title><updated>2024-06-12T22:24:46Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240612222435.3188234-1-dianders@chromium.org/"/><id>urn:uuid:fd5858fb-2a6a-68b3-4e6b-2e8ed2da1cdd</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">
This patch series is the leftovers of a patch series sent in September
2023 [1] in an attempt to get some of the patches landed finally.

This patch series originally came about after a _long_ discussion
between me and Maxime Ripard in response to a different patch I sent
out [2]. As part of that discussion, we realized that it would be good
if DRM drivers consistently called drm_atomic_helper_shutdown()
properly at shutdown and driver remove time as it&#39;s documented that
they should do. The eventual goal of this would be to enable removing
some hacky code from panel drivers where they had to hook into
shutdown themselves because the DRM driver wasn&#39;t calling them.

It turns out that quite a lot of drivers seemed to be missing
drm_atomic_helper_shutdown() in one or both places that it was
supposed to be. This patch series attempts to fix all the drivers that
I was able to identify.

NOTE: fixing this wasn&#39;t exactly cookie cutter. Each driver has its
own unique way of setting itself up and tearing itself down. Some
drivers also use the component model, which adds extra fun. I&#39;ve made
my best guess at solving this and I&#39;ve run a bunch of compile tests
(specifically, allmodconfig for amd64, arm64, and powerpc). That being
said, these code changes are not totally trivial and I&#39;ve done zero
real testing on them. Making these patches was also a little mind
numbing and I&#39;m certain my eyes glazed over at several points when
writing them. What I&#39;m trying to say is to please double-check that I
didn&#39;t do anything too silly, like cast your driver&#39;s drvdata to the
wrong type. Even better, test these patches!

Apparently most of these drivers now land through drm-misc [3], so
hopefully they can land. The two that don&#39;t (amdgpu and radeon) are
the ones I&#39;m most ucertain about anyway so I&#39;ve stuck them at the end.
If I&#39;ve totally buggered those up feel free to take my patch as a bug
report and submit your own proper fix. ...or if there&#39;s some reason
that we don&#39;t need to do anything for those drivers then let me know
and we can drop them.

I&#39;d like to call out a few drivers that I _didn&#39;t_ fix in this series
and why. If any of these drivers should be fixed then please yell.
- DRM drivers backed by usb_driver (like gud, gm12u320, udl): I didn&#39;t
  add the call to drm_atomic_helper_shutdown() at shutdown time
  because there&#39;s no &#34;.shutdown&#34; callback for them USB drivers. Given
  that USB is hotpluggable, I&#39;m assuming that they are robust against
  this and the special shutdown callback isn&#39;t needed.
- ofdrm and simpledrm: These didn&#39;t have drm_atomic_helper_shutdown()
  in either shutdown or remove, but I didn&#39;t add it. I think that&#39;s OK
  since they&#39;re sorta special and not really directly controlling
  hardware power sequencing.
- virtio, vkms, vmwgfx, xen: I believe these are all virtual (thus
  they wouldn&#39;t directly drive a panel) and adding the shutdown
  didn&#39;t look straightforward, so I skipped them.

I&#39;ve let each patch in the series get CCed straight from
get_maintainer. That means not everyone will have received every patch
but everyone should be on the cover letter. I know some people dislike
this but when touching this many drivers there&#39;s not much
choice. dri-devel and lkml have been CCed and lore/lei exist, so
hopefully that&#39;s enough for folks. I&#39;m happy to add people to the
whole series for future posts.

[1] <a
href="https://lore.kernel.org/r/20230901234202.566951-1-dianders@chromium.org">https://lore.kernel.org/r/20230901234202.566951-1-dianders@chromium.org</a>
[2] <a
href="https://lore.kernel.org/r/20230804140605.RFC.4.I930069a32baab6faf46d6b234f89613b5cec0f14@changeid">https://lore.kernel.org/r/20230804140605.RFC.4.I930069a32baab6faf46d6b234f89613b5cec0f14@changeid</a>
[3] <a
href="https://lore.kernel.org/r/Zmm6_27GikpmT3HQ@phenom.ffwll.local">https://lore.kernel.org/r/Zmm6_27GikpmT3HQ@phenom.ffwll.local</a>

Changes in v2:
- Gathered whatever hadn&#39;t landed, rebased, and reposted.

Douglas Anderson (8):
  drm/kmb: Call drm_atomic_helper_shutdown() at shutdown time
  drm/nouveau: Call drm_atomic_helper_shutdown() or equiv at shutdown
    time
  drm/tegra: Call drm_atomic_helper_shutdown() at shutdown time
  drm/arcpgu: Call drm_atomic_helper_shutdown() at shutdown time
  drm/sprd: Call drm_atomic_helper_shutdown() at remove time
  drm/gma500: Call drm_helper_force_disable_all() at shutdown/remove
    time
  drm/radeon: Call drm_helper_force_disable_all() at shutdown/remove
    time
  drm/amdgpu: Call drm_atomic_helper_shutdown() at shutdown time

 drivers/gpu/drm/amd/amdgpu/amdgpu.h        |  1 +
 drivers/gpu/drm/amd/amdgpu/amdgpu_device.c | 10 ++++++++++
 drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c    |  2 ++
 drivers/gpu/drm/gma500/psb_drv.c           |  8 ++++++++
 drivers/gpu/drm/kmb/kmb_drv.c              |  6 ++++++
 drivers/gpu/drm/nouveau/nouveau_display.c  |  9 +++++++++
 drivers/gpu/drm/nouveau/nouveau_display.h  |  1 +
 drivers/gpu/drm/nouveau/nouveau_drm.c      | 13 +++++++++++++
 drivers/gpu/drm/nouveau/nouveau_drv.h      |  1 +
 drivers/gpu/drm/nouveau/nouveau_platform.c |  6 ++++++
 drivers/gpu/drm/radeon/radeon_drv.c        |  7 ++++++-
 drivers/gpu/drm/sprd/sprd_drm.c            |  4 +++-
 drivers/gpu/drm/tegra/drm.c                |  6 ++++++
 drivers/gpu/drm/tiny/arcpgu.c              |  6 ++++++
 14 files changed, 78 insertions(+), 2 deletions(-)

-- 
2.45.2.505.gda0bf45e8d-goog

</pre></div></content></entry><entry><author><name>Xiaogang.Chen</name><email>xiaogang.chen@amd.com</email></author><title
type="html">[PATCH] drm/amdkfd: Update mm interval notifier tree without acquiring mm&#39;s mmap lock</title><updated>2024-06-12T20:10:54Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240612201101.225674-1-xiaogang.chen@amd.com/"/><id>urn:uuid:95a84a66-a1e7-0c8f-c274-be4a622197c9</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Xiaogang Chen &lt;xiaogang.chen@amd.com&gt;

Current kfd/svm driver acquires mm&#39;s mmap write lock before update
mm-&gt;notifier_subscriptions-&gt;itree. This tree is already protected
by mm-&gt;notifier_subscriptions-&gt;lock at mmu notifier. Each process mm interval
tree update from different components in kernel go to mmu interval notifier
where they got serialized. This patch removes mmap write lock acquiring at
kfd/svm driver when need updates process mm interval tree. It reduces chance
of dead lock or warning from lockdev and simplifies the driver code.

In addition, the patch adjusts some locks granularity to reduce the lock number
that driver holds at same time which also reduces the chance of dead lock or
warning from lockdev.

Signed-off-by: Xiaogang Chen&lt;Xiaogang.Chen@amd.com&gt;
---
 drivers/gpu/drm/amd/amdkfd/kfd_chardev.c |   3 +-
 drivers/gpu/drm/amd/amdkfd/kfd_migrate.c |   6 +-
 drivers/gpu/drm/amd/amdkfd/kfd_svm.c     | 181 +++++++++++++++--------
 drivers/gpu/drm/amd/amdkfd/kfd_svm.h     |   2 +-
 4 files <a href="http://lore.kernel.org/amd-gfx/20240612201101.225674-1-xiaogang.chen@amd.com/#related">changed</a>, 122 insertions(+), 70 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c
index fdf171ad4a3c..b52588ded567 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c
</span><span
class="hunk">@@ -1078,9 +1078,8 @@ static int kfd_ioctl_alloc_memory_of_gpu(struct file *filep,
</span> 	/* Flush pending deferred work to avoid racing with deferred actions
 	 * from previous memory map changes (e.g. munmap).
 	 */
<span
class="del">-	svm_range_list_lock_and_flush_work(&#38;p-&gt;svms, current-&gt;mm);
</span><span
class="add">+	svm_range_list_flush_work(&#38;p-&gt;svms);
</span> 	mutex_lock(&#38;p-&gt;svms.lock);
<span
class="del">-	mmap_write_unlock(current-&gt;mm);
</span> 	if (interval_tree_iter_first(&#38;p-&gt;svms.objects,
 				     args-&gt;va_addr &gt;&gt; PAGE_SHIFT,
 				     (args-&gt;va_addr + args-&gt;size - 1) &gt;&gt; PAGE_SHIFT)) {
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_migrate.c b/drivers/gpu/drm/amd/amdkfd/kfd_migrate.c
index 8ee3d07ffbdf..eb46643d96b2 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_migrate.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_migrate.c
</span><span
class="hunk">@@ -969,10 +969,12 @@ static vm_fault_t svm_migrate_to_ram(struct vm_fault *vmf)
</span> 	mutex_lock(&#38;p-&gt;svms.lock);
 
 	prange = svm_range_from_addr(&#38;p-&gt;svms, addr, NULL);
<span
class="add">+
+	mutex_unlock(&#38;p-&gt;svms.lock);
</span> 	if (!prange) {
 		pr_debug(&#34;failed get range svms 0x%p addr 0x%lx\n&#34;, &#38;p-&gt;svms, addr);
 		r = -EFAULT;
<span
class="del">-		goto out_unlock_svms;
</span><span
class="add">+		goto out_unref_process;
</span> 	}
 
 	mutex_lock(&#38;prange-&gt;migrate_mutex);
<span
class="hunk">@@ -993,8 +995,6 @@ static vm_fault_t svm_migrate_to_ram(struct vm_fault *vmf)
</span> 
 out_unlock_prange:
 	mutex_unlock(&#38;prange-&gt;migrate_mutex);
<span
class="del">-out_unlock_svms:
-	mutex_unlock(&#38;p-&gt;svms.lock);
</span> out_unref_process:
 	pr_debug(&#34;CPU fault svms 0x%p address 0x%lx done\n&#34;, &#38;p-&gt;svms, addr);
 	kfd_unref_process(p);
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_svm.c b/drivers/gpu/drm/amd/amdkfd/kfd_svm.c
index 407636a68814..46f81c1215d9 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_svm.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_svm.c
</span><span
class="hunk">@@ -106,12 +106,31 @@ static void svm_range_unlink(struct svm_range *prange)
</span> }
 
 static void
<span
class="del">-svm_range_add_notifier_locked(struct mm_struct *mm, struct svm_range *prange)
</span><span
class="add">+svm_range_add_notifier(struct mm_struct *mm, struct svm_range *prange, bool locked)
</span> {
 	pr_debug(&#34;svms 0x%p prange 0x%p [0x%lx 0x%lx]\n&#34;, prange-&gt;svms,
 		 prange, prange-&gt;start, prange-&gt;last);
 
<span
class="del">-	mmu_interval_notifier_insert_locked(&#38;prange-&gt;notifier, mm,
</span><span
class="add">+	/* mm-&gt;notifier_subscriptions should have been setup for this process
+	 * ex: during kfd process creation
+	 */
+	WARN_ON_ONCE(!mm-&gt;notifier_subscriptions);
+
+	/* not necessary hold mmap lock to update mm interval notifier tree as
+	 * opeations on mm-&gt;notifier_subscriptions-&gt;itree are serialized by
+	 * mm-&gt;notifier_subscriptions-&gt;lock
+	 */
+	if (locked) {
+		/* if mmap write lock has been hold use lock version to udpate
+		 * mm interval notifier tree
+		 */
+		mmu_interval_notifier_insert_locked(&#38;prange-&gt;notifier, mm,
+			   prange-&gt;start &lt;&lt; PAGE_SHIFT,
+			   prange-&gt;npages &lt;&lt; PAGE_SHIFT,
+			   &#38;svm_range_mn_ops);
+	} else
+		/* use no-mmap-lock version to update mm interval notifier tree */
+		mmu_interval_notifier_insert(&#38;prange-&gt;notifier, mm,
</span> 				     prange-&gt;start &lt;&lt; PAGE_SHIFT,
 				     prange-&gt;npages &lt;&lt; PAGE_SHIFT,
 				     &#38;svm_range_mn_ops);
<span
class="hunk">@@ -895,6 +914,7 @@ svm_range_copy_array(void *psrc, size_t size, uint64_t num_elements,
</span> 	*vram_pages = 0;
 	for (i = 0; i &lt; num_elements; i++) {
 		dma_addr_t *temp;
<span
class="add">+
</span> 		temp = (dma_addr_t *)dst + i;
 		*temp = *((dma_addr_t *)src + i);
 		if (*temp&#38;SVM_RANGE_VRAM_DOMAIN)
<span
class="hunk">@@ -1500,7 +1520,7 @@ static int svm_range_reserve_bos(struct svm_validate_context *ctx, bool intr)
</span> 	uint32_t gpuidx;
 	int r;
 
<span
class="del">-	drm_exec_init(&#38;ctx-&gt;exec, intr ? DRM_EXEC_INTERRUPTIBLE_WAIT: 0, 0);
</span><span
class="add">+	drm_exec_init(&#38;ctx-&gt;exec, intr ? DRM_EXEC_INTERRUPTIBLE_WAIT : 0, 0);
</span> 	drm_exec_until_all_locked(&#38;ctx-&gt;exec) {
 		for_each_set_bit(gpuidx, ctx-&gt;bitmap, MAX_GPU_INSTANCE) {
 			pdd = kfd_process_device_from_gpuidx(ctx-&gt;process, gpuidx);
<span
class="hunk">@@ -1751,25 +1771,20 @@ static int svm_range_validate_and_map(struct mm_struct *mm,
</span> }
 
 /**
<span
class="del">- * svm_range_list_lock_and_flush_work - flush pending deferred work
</span><span
class="add">+ * svm_range_list_flush_work - flush pending deferred work
</span>  *
  * @svms: the svm range list
  * @mm: the mm structure
<span
class="del">- *
- * Context: Returns with mmap write lock held, pending deferred work flushed
- *
</span>  */
 void
<span
class="del">-svm_range_list_lock_and_flush_work(struct svm_range_list *svms,
-				   struct mm_struct *mm)
</span><span
class="add">+svm_range_list_flush_work(struct svm_range_list *svms)
</span> {
 retry_flush_work:
 	flush_work(&#38;svms-&gt;deferred_list_work);
<span
class="del">-	mmap_write_lock(mm);
</span> 
 	if (list_empty(&#38;svms-&gt;deferred_range_list))
 		return;
<span
class="del">-	mmap_write_unlock(mm);
</span><span
class="add">+
</span> 	pr_debug(&#34;retry flush\n&#34;);
 	goto retry_flush_work;
 }
<span
class="hunk">@@ -1804,7 +1819,11 @@ static void svm_range_restore_work(struct work_struct *work)
</span> 	}
 
 	mutex_lock(&#38;process_info-&gt;lock);
<span
class="del">-	svm_range_list_lock_and_flush_work(svms, mm);
</span><span
class="add">+
+	svm_range_list_flush_work(svms);
+
+	mmap_read_lock(mm);
+
</span> 	mutex_lock(&#38;svms-&gt;lock);
 
 	evicted_ranges = atomic_read(&#38;svms-&gt;evicted_ranges);
<span
class="hunk">@@ -1854,8 +1873,9 @@ static void svm_range_restore_work(struct work_struct *work)
</span> 	pr_debug(&#34;restore svm ranges successfully\n&#34;);
 
 out_reschedule:
<span
class="add">+
</span> 	mutex_unlock(&#38;svms-&gt;lock);
<span
class="del">-	mmap_write_unlock(mm);
</span><span
class="add">+	mmap_read_unlock(mm);
</span> 	mutex_unlock(&#38;process_info-&gt;lock);
 
 	/* If validation failed, reschedule another attempt */
<span
class="hunk">@@ -2186,8 +2206,8 @@ svm_range_add(struct kfd_process *p, uint64_t start, uint64_t size,
</span> }
 
 static void
<span
class="del">-svm_range_update_notifier_and_interval_tree(struct mm_struct *mm,
-					    struct svm_range *prange)
</span><span
class="add">+svm_range_update_notifier_and_interval_tree(struct svm_range_list *svms,
+					struct mm_struct *mm, struct svm_range *prange)
</span> {
 	unsigned long start;
 	unsigned long last;
<span
class="hunk">@@ -2203,14 +2223,28 @@ svm_range_update_notifier_and_interval_tree(struct mm_struct *mm,
</span> 		  prange-&gt;last);
 
 	if (start != 0 &#38;&#38; last != 0) {
<span
class="add">+
+		mutex_lock(&#38;svms-&gt;lock);
+		mutex_lock(&#38;prange-&gt;lock);
</span> 		interval_tree_remove(&#38;prange-&gt;it_node, &#38;prange-&gt;svms-&gt;objects);
<span
class="add">+		mutex_unlock(&#38;prange-&gt;lock);
+		mutex_unlock(&#38;svms-&gt;lock);
+
</span> 		svm_range_remove_notifier(prange);
 	}
<span
class="add">+
+	mutex_lock(&#38;prange-&gt;lock);
</span> 	prange-&gt;it_node.start = prange-&gt;start;
 	prange-&gt;it_node.last = prange-&gt;last;
<span
class="add">+	mutex_unlock(&#38;prange-&gt;lock);
</span> 
<span
class="add">+	mutex_lock(&#38;svms-&gt;lock);
+	mutex_lock(&#38;prange-&gt;lock);
</span> 	interval_tree_insert(&#38;prange-&gt;it_node, &#38;prange-&gt;svms-&gt;objects);
<span
class="del">-	svm_range_add_notifier_locked(mm, prange);
</span><span
class="add">+	mutex_unlock(&#38;prange-&gt;lock);
+	mutex_unlock(&#38;svms-&gt;lock);
+
+	svm_range_add_notifier(mm, prange, true);
</span> }
 
 static void
<span
class="hunk">@@ -2225,32 +2259,51 @@ svm_range_handle_list_op(struct svm_range_list *svms, struct svm_range *prange,
</span> 	case SVM_OP_UNMAP_RANGE:
 		pr_debug(&#34;remove 0x%p prange 0x%p [0x%lx 0x%lx]\n&#34;,
 			 svms, prange, prange-&gt;start, prange-&gt;last);
<span
class="add">+
+		mutex_lock(&#38;svms-&gt;lock);
+		svm_range_lock(prange);
</span> 		svm_range_unlink(prange);
<span
class="add">+		svm_range_unlock(prange);
+		mutex_unlock(&#38;svms-&gt;lock);
+
</span> 		svm_range_remove_notifier(prange);
 		svm_range_free(prange, true);
 		break;
 	case SVM_OP_UPDATE_RANGE_NOTIFIER:
 		pr_debug(&#34;update notifier 0x%p prange 0x%p [0x%lx 0x%lx]\n&#34;,
 			 svms, prange, prange-&gt;start, prange-&gt;last);
<span
class="del">-		svm_range_update_notifier_and_interval_tree(mm, prange);
</span><span
class="add">+		svm_range_update_notifier_and_interval_tree(svms, mm, prange);
</span> 		break;
 	case SVM_OP_UPDATE_RANGE_NOTIFIER_AND_MAP:
 		pr_debug(&#34;update and map 0x%p prange 0x%p [0x%lx 0x%lx]\n&#34;,
 			 svms, prange, prange-&gt;start, prange-&gt;last);
<span
class="del">-		svm_range_update_notifier_and_interval_tree(mm, prange);
</span><span
class="add">+		svm_range_update_notifier_and_interval_tree(svms, mm, prange);
+
</span> 		/* TODO: implement deferred validation and mapping */
 		break;
 	case SVM_OP_ADD_RANGE:
 		pr_debug(&#34;add 0x%p prange 0x%p [0x%lx 0x%lx]\n&#34;, svms, prange,
 			 prange-&gt;start, prange-&gt;last);
<span
class="add">+
+		mutex_lock(&#38;svms-&gt;lock);
+		mutex_lock(&#38;prange-&gt;lock);
</span> 		svm_range_add_to_svms(prange);
<span
class="del">-		svm_range_add_notifier_locked(mm, prange);
</span><span
class="add">+		mutex_unlock(&#38;prange-&gt;lock);
+		mutex_unlock(&#38;svms-&gt;lock);
+
+		svm_range_add_notifier(mm, prange, true);
</span> 		break;
 	case SVM_OP_ADD_RANGE_AND_MAP:
 		pr_debug(&#34;add and map 0x%p prange 0x%p [0x%lx 0x%lx]\n&#34;, svms,
 			 prange, prange-&gt;start, prange-&gt;last);
<span
class="add">+
+		mutex_lock(&#38;svms-&gt;lock);
+		mutex_lock(&#38;prange-&gt;lock);
</span> 		svm_range_add_to_svms(prange);
<span
class="del">-		svm_range_add_notifier_locked(mm, prange);
</span><span
class="add">+		mutex_unlock(&#38;prange-&gt;lock);
+		mutex_unlock(&#38;svms-&gt;lock);
+
+		svm_range_add_notifier(mm, prange, true);
</span> 		/* TODO: implement deferred validation and mapping */
 		break;
 	default:
<span
class="hunk">@@ -2316,6 +2369,12 @@ static void svm_range_deferred_list_work(struct work_struct *work)
</span> 
 		mm = prange-&gt;work_item.mm;
 retry:
<span
class="add">+		/* use mmap write lock to prevent unmap_from_cpu for same process
+		 * happening at same time to prevent race conditions between
+		 * svm_range_deferred_list_work and unmap_from_cpu, ex:
+		 * work_item.op of prange may be changed by unmap_from_cpu
+		 * during svm_range_deferred_list_work
+		 */
</span> 		mmap_write_lock(mm);
 
 		/* Checking for the need to drain retry faults must be inside
<span
class="hunk">@@ -2327,20 +2386,11 @@ static void svm_range_deferred_list_work(struct work_struct *work)
</span> 			goto retry;
 		}
 
<span
class="del">-		/* Remove from deferred_list must be inside mmap write lock, for
-		 * two race cases:
-		 * 1. unmap_from_cpu may change work_item.op and add the range
-		 *    to deferred_list again, cause use after free bug.
-		 * 2. svm_range_list_lock_and_flush_work may hold mmap write
-		 *    lock and continue because deferred_list is empty, but
-		 *    deferred_list work is actually waiting for mmap lock.
-		 */
</span> 		spin_lock(&#38;svms-&gt;deferred_list_lock);
 		list_del_init(&#38;prange-&gt;deferred_list);
 		spin_unlock(&#38;svms-&gt;deferred_list_lock);
 
<span
class="del">-		mutex_lock(&#38;svms-&gt;lock);
-		mutex_lock(&#38;prange-&gt;migrate_mutex);
</span><span
class="add">+		svm_range_lock(prange);
</span> 		while (!list_empty(&#38;prange-&gt;child_list)) {
 			struct svm_range *pchild;
 
<span
class="hunk">@@ -2349,12 +2399,15 @@ static void svm_range_deferred_list_work(struct work_struct *work)
</span> 			pr_debug(&#34;child prange 0x%p op %d\n&#34;, pchild,
 				 pchild-&gt;work_item.op);
 			list_del_init(&#38;pchild-&gt;child_list);
<span
class="add">+			svm_range_unlock(prange);
+
</span> 			svm_range_handle_list_op(svms, pchild, mm);
<span
class="add">+			svm_range_lock(prange);
</span> 		}
<span
class="del">-		mutex_unlock(&#38;prange-&gt;migrate_mutex);
</span><span
class="add">+		svm_range_unlock(prange);
</span> 
 		svm_range_handle_list_op(svms, prange, mm);
<span
class="del">-		mutex_unlock(&#38;svms-&gt;lock);
</span><span
class="add">+
</span> 		mmap_write_unlock(mm);
 
 		/* Pairs with mmget in svm_range_add_list_work. If dropping the
<span
class="hunk">@@ -2814,7 +2867,7 @@ svm_range *svm_range_create_unregistered_range(struct kfd_node *node,
</span> 		prange-&gt;preferred_loc = KFD_IOCTL_SVM_LOCATION_SYSMEM;
 
 	svm_range_add_to_svms(prange);
<span
class="del">-	svm_range_add_notifier_locked(mm, prange);
</span><span
class="add">+	svm_range_add_notifier(mm, prange, false);
</span> 
 	return prange;
 }
<span
class="hunk">@@ -2911,7 +2964,6 @@ svm_range_restore_pages(struct amdgpu_device *adev, unsigned int pasid,
</span> 	struct kfd_node *node;
 	int32_t best_loc;
 	int32_t gpuidx = MAX_GPU_INSTANCE;
<span
class="del">-	bool write_locked = false;
</span> 	struct vm_area_struct *vma;
 	bool migration = false;
 	int r = 0;
<span
class="hunk">@@ -2959,35 +3011,26 @@ svm_range_restore_pages(struct amdgpu_device *adev, unsigned int pasid,
</span> 		r = -EFAULT;
 		goto out;
 	}
<span
class="del">-	mmap_read_lock(mm);
-retry_write_locked:
</span><span
class="add">+
</span> 	mutex_lock(&#38;svms-&gt;lock);
 	prange = svm_range_from_addr(svms, addr, NULL);
<span
class="add">+	mutex_unlock(&#38;svms-&gt;lock);
</span> 	if (!prange) {
 		pr_debug(&#34;failed to find prange svms 0x%p address [0x%llx]\n&#34;,
 			 svms, addr);
<span
class="del">-		if (!write_locked) {
-			/* Need the write lock to create new range with MMU notifier.
-			 * Also flush pending deferred work to make sure the interval
-			 * tree is up to date before we add a new range
-			 */
-			mutex_unlock(&#38;svms-&gt;lock);
-			mmap_read_unlock(mm);
-			mmap_write_lock(mm);
-			write_locked = true;
-			goto retry_write_locked;
-		}
</span><span
class="add">+		/* not need to hold mmap write lock before create new range in
+		 * mm interval notifier tree, mm has its own lock to protect it
+		 */
</span> 		prange = svm_range_create_unregistered_range(node, p, mm, addr);
 		if (!prange) {
 			pr_debug(&#34;failed to create unregistered range svms 0x%p address [0x%llx]\n&#34;,
 				 svms, addr);
<span
class="del">-			mmap_write_downgrade(mm);
</span> 			r = -EFAULT;
 			goto out_unlock_svms;
 		}
 	}
<span
class="del">-	if (write_locked)
-		mmap_write_downgrade(mm);
</span><span
class="add">+
+	mmap_read_lock(mm);
</span> 
 	mutex_lock(&#38;prange-&gt;migrate_mutex);
 
<span
class="hunk">@@ -3082,10 +3125,8 @@ svm_range_restore_pages(struct amdgpu_device *adev, unsigned int pasid,
</span> 
 out_unlock_range:
 	mutex_unlock(&#38;prange-&gt;migrate_mutex);
<span
class="del">-out_unlock_svms:
-	mutex_unlock(&#38;svms-&gt;lock);
</span> 	mmap_read_unlock(mm);
<span
class="del">-
</span><span
class="add">+out_unlock_svms:
</span> 	svm_range_count_fault(node, p, gpuidx);
 
 	mmput(mm);
<span
class="hunk">@@ -3192,6 +3233,7 @@ int svm_range_list_init(struct kfd_process *p)
</span> {
 	struct svm_range_list *svms = &#38;p-&gt;svms;
 	int i;
<span
class="add">+	int ret;
</span> 
 	svms-&gt;objects = RB_ROOT_CACHED;
 	mutex_init(&#38;svms-&gt;lock);
<span
class="hunk">@@ -3208,6 +3250,14 @@ int svm_range_list_init(struct kfd_process *p)
</span> 		if (KFD_IS_SVM_API_SUPPORTED(p-&gt;pdds[i]-&gt;dev-&gt;adev))
 			bitmap_set(svms-&gt;bitmap_supported, i, 1);
 
<span
class="add">+	 /* signals the notifier is being registered for itree mode
+	  * it does not register new mmu_notifier or increae mm-&gt;mm_count,
+	  * so not need call mmu_notifier_unregister at svm_range_list_fini
+	  */
+	ret = mmu_notifier_register(NULL, p-&gt;mm);
+	if (ret)
+		return ret;
+
</span> 	return 0;
 }
 
<span
class="hunk">@@ -3553,29 +3603,27 @@ svm_range_set_attr(struct kfd_process *p, struct mm_struct *mm,
</span> 
 	mutex_lock(&#38;process_info-&gt;lock);
 
<span
class="del">-	svm_range_list_lock_and_flush_work(svms, mm);
</span><span
class="add">+	svm_range_list_flush_work(svms);
</span> 
 	r = svm_range_is_valid(p, start, size);
 	if (r) {
 		pr_debug(&#34;invalid range r=%d\n&#34;, r);
<span
class="del">-		mmap_write_unlock(mm);
</span> 		goto out;
 	}
 
<span
class="del">-	mutex_lock(&#38;svms-&gt;lock);
-
</span> 	/* Add new range and split existing ranges as needed */
 	r = svm_range_add(p, start, size, nattr, attrs, &#38;update_list,
 			  &#38;insert_list, &#38;remove_list, &#38;remap_list);
<span
class="del">-	if (r) {
-		mutex_unlock(&#38;svms-&gt;lock);
-		mmap_write_unlock(mm);
</span><span
class="add">+	if (r)
</span> 		goto out;
<span
class="del">-	}
</span><span
class="add">+
</span> 	/* Apply changes as a transaction */
 	list_for_each_entry_safe(prange, next, &#38;insert_list, list) {
<span
class="add">+		mutex_lock(&#38;svms-&gt;lock);
</span> 		svm_range_add_to_svms(prange);
<span
class="del">-		svm_range_add_notifier_locked(mm, prange);
</span><span
class="add">+		mutex_unlock(&#38;svms-&gt;lock);
+
+		svm_range_add_notifier(mm, prange, false);
</span> 	}
 	list_for_each_entry(prange, &#38;update_list, update_list) {
 		svm_range_apply_attrs(p, prange, nattr, attrs, &#38;update_mapping);
<span
class="hunk">@@ -3585,12 +3633,17 @@ svm_range_set_attr(struct kfd_process *p, struct mm_struct *mm,
</span> 		pr_debug(&#34;unlink old 0x%p prange 0x%p [0x%lx 0x%lx]\n&#34;,
 			 prange-&gt;svms, prange, prange-&gt;start,
 			 prange-&gt;last);
<span
class="add">+
+		mutex_lock(&#38;svms-&gt;lock);
</span> 		svm_range_unlink(prange);
<span
class="add">+		mutex_unlock(&#38;svms-&gt;lock);
+
</span> 		svm_range_remove_notifier(prange);
 		svm_range_free(prange, false);
 	}
 
<span
class="del">-	mmap_write_downgrade(mm);
</span><span
class="add">+	mmap_read_lock(mm);
+
</span> 	/* Trigger migrations and revalidate and map to GPUs as needed. If
 	 * this fails we may be left with partially completed actions. There
 	 * is no clean way of rolling back to the previous state in such a
<span
class="hunk">@@ -3646,8 +3699,8 @@ svm_range_set_attr(struct kfd_process *p, struct mm_struct *mm,
</span> 
 	dynamic_svm_range_dump(svms);
 
<span
class="del">-	mutex_unlock(&#38;svms-&gt;lock);
</span> 	mmap_read_unlock(mm);
<span
class="add">+
</span> out:
 	mutex_unlock(&#38;process_info-&gt;lock);
 
<span
class="head">diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_svm.h b/drivers/gpu/drm/amd/amdkfd/kfd_svm.h
index 70c1776611c4..f7cee69ff191 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_svm.h
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_svm.h
</span><span
class="hunk">@@ -195,7 +195,7 @@ int kfd_criu_restore_svm(struct kfd_process *p,
</span> int kfd_criu_resume_svm(struct kfd_process *p);
 struct kfd_process_device *
 svm_range_get_pdd_by_node(struct svm_range *prange, struct kfd_node *node);
<span
class="del">-void svm_range_list_lock_and_flush_work(struct svm_range_list *svms, struct mm_struct *mm);
</span><span
class="add">+void svm_range_list_flush_work(struct svm_range_list *svms);
</span> 
 /* SVM API and HMM page migration work together, device memory type
  * is initialized to not 0 when page migration register device memory.
-- 
2.25.1

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v5 3/3] drm/amdgpu: Make it possible to async flip overlay planes</title><updated>2024-06-12T19:37:46Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240612193713.167448-4-andrealmeid@igalia.com/"/><id>urn:uuid:9a6ed8f4-9d3d-7047-857c-df65db5a3fbc</id><thr:in-reply-to
ref="urn:uuid:ef7cd8bb-af07-370e-fa70-846ae804ddf2"
href="http://lore.kernel.org/amd-gfx/20240612193713.167448-1-andrealmeid@igalia.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">amdgpu can handle async flips on overlay planes, so mark it as true
during the plane initialization.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c | 1 +
 1 file <a href="http://lore.kernel.org/amd-gfx/20240612193713.167448-4-andrealmeid@igalia.com/#related">changed</a>, 1 insertion(+)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
index 8a4c40b4c27e..dc5392c08a87 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
</span><span
class="hunk">@@ -1708,6 +1708,7 @@ int amdgpu_dm_plane_init(struct amdgpu_display_manager *dm,
</span> 	} else if (plane-&gt;type == DRM_PLANE_TYPE_OVERLAY) {
 		unsigned int zpos = 1 + drm_plane_index(plane);
 		drm_plane_create_zpos_property(plane, zpos, 1, 254);
<span
class="add">+		plane-&gt;async_flip = true;
</span> 	} else if (plane-&gt;type == DRM_PLANE_TYPE_CURSOR) {
 		drm_plane_create_zpos_immutable_property(plane, 255);
 	}
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v5 2/3] drm: Allow drivers to choose plane types to async flip</title><updated>2024-06-12T19:37:42Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240612193713.167448-3-andrealmeid@igalia.com/"/><id>urn:uuid:24f9a68f-abd5-f93f-5efa-cd9fc13a9aa1</id><thr:in-reply-to
ref="urn:uuid:ef7cd8bb-af07-370e-fa70-846ae804ddf2"
href="http://lore.kernel.org/amd-gfx/20240612193713.167448-1-andrealmeid@igalia.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Different planes may have different capabilities of doing async flips,
so create a field to let drivers allow async flip per plane type.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---
 drivers/gpu/drm/drm_atomic_uapi.c | 4 ++--
 drivers/gpu/drm/drm_plane.c       | 3 +++
 include/drm/drm_plane.h           | 5 +++++
 3 files <a href="http://lore.kernel.org/amd-gfx/20240612193713.167448-3-andrealmeid@igalia.com/#related">changed</a>, 10 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/drm_atomic_uapi.c b/drivers/gpu/drm/drm_atomic_uapi.c
index 2e1d9391febe..dd4b1578f141 100644
--- a/drivers/gpu/drm/drm_atomic_uapi.c
+++ b/drivers/gpu/drm/drm_atomic_uapi.c
</span><span
class="hunk">@@ -1079,9 +1079,9 @@ int drm_atomic_set_property(struct drm_atomic_state *state,
</span> 			break;
 		}
 
<span
class="del">-		if (async_flip &#38;&#38; plane_state-&gt;plane-&gt;type != DRM_PLANE_TYPE_PRIMARY) {
</span><span
class="add">+		if (async_flip &#38;&#38; !plane_state-&gt;plane-&gt;async_flip) {
</span> 			drm_dbg_atomic(prop-&gt;dev,
<span
class="del">-				       &#34;[OBJECT:%d] Only primary planes can be changed during async flip\n&#34;,
</span><span
class="add">+				       &#34;[OBJECT:%d] This type of plane cannot be changed during async flip\n&#34;,
</span> 				       obj-&gt;id);
 			ret = -EINVAL;
 			break;
<span
class="head">diff --git a/drivers/gpu/drm/drm_plane.c b/drivers/gpu/drm/drm_plane.c
index 57662a1fd345..bbcec3940636 100644
--- a/drivers/gpu/drm/drm_plane.c
+++ b/drivers/gpu/drm/drm_plane.c
</span><span
class="hunk">@@ -385,6 +385,9 @@ static int __drm_universal_plane_init(struct drm_device *dev,
</span> 
 	drm_modeset_lock_init(&#38;plane-&gt;mutex);
 
<span
class="add">+	if (type == DRM_PLANE_TYPE_PRIMARY)
+		plane-&gt;async_flip = true;
+
</span> 	plane-&gt;base.properties = &#38;plane-&gt;properties;
 	plane-&gt;dev = dev;
 	plane-&gt;funcs = funcs;
<span
class="head">diff --git a/include/drm/drm_plane.h b/include/drm/drm_plane.h
index 9507542121fa..0bebc72af5c3 100644
--- a/include/drm/drm_plane.h
+++ b/include/drm/drm_plane.h
</span><span
class="hunk">@@ -786,6 +786,11 @@ struct drm_plane {
</span> 	 * @kmsg_panic: Used to register a panic notifier for this plane
 	 */
 	struct kmsg_dumper kmsg_panic;
<span
class="add">+
+	/**
+	 * @async_flip: indicates if a plane can do async flips
+	 */
+	bool async_flip;
</span> };
 
 #define obj_to_plane(x) container_of(x, struct drm_plane, base)
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v5 0/3] drm/atomic: Allow drivers to write their own plane check for async</title><updated>2024-06-12T19:37:38Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240612193713.167448-1-andrealmeid@igalia.com/"/><id>urn:uuid:ef7cd8bb-af07-370e-fa70-846ae804ddf2</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Hi,

AMD hardware can do async flips with overlay planes, so this patchset does a
small redesign to allow drivers to choose per plane type if they can or cannot
do async flips.

It also allows async commits with IN_FENCE_ID in any driver.

Changes from v4:
- Rebased on top current drm-misc/drm-misc-next

Changes from v3:
- Major patchset redesign 
v3: <a
href="https://lore.kernel.org/lkml/20240128212515.630345-1-andrealmeid@igalia.com/">https://lore.kernel.org/lkml/20240128212515.630345-1-andrealmeid@igalia.com/</a>

Changes from v2:
 - Allow IN_FENCE_ID for any driver
 - Allow overlay planes again
v2: <a
href="https://lore.kernel.org/lkml/20240119181235.255060-1-andrealmeid@igalia.com/">https://lore.kernel.org/lkml/20240119181235.255060-1-andrealmeid@igalia.com/</a>

Changes from v1:
 - Drop overlay planes option for now
v1: <a
href="https://lore.kernel.org/dri-devel/20240116045159.1015510-1-andrealmeid@igalia.com/">https://lore.kernel.org/dri-devel/20240116045159.1015510-1-andrealmeid@igalia.com/</a>

Andr&#233; Almeida (3):
  drm/atomic: Allow userspace to use explicit sync with atomic async
    flips
  drm: Allow drivers to choose plane types to async flip
  drm/amdgpu: Make it possible to async flip overlay planes

 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c | 1 +
 drivers/gpu/drm/drm_atomic_uapi.c                       | 4 +++-
 include/drm/drm_plane.h                                 | 5 +++++
 3 files changed, 9 insertions(+), 1 deletion(-)

-- 
2.45.2

</pre></div></content></entry><entry><author><name>Andr&#233; Almeida</name><email>andrealmeid@igalia.com</email></author><title>[PATCH v5 1/3] drm/atomic: Allow userspace to use explicit sync with atomic async flips</title><updated>2024-06-12T19:37:39Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240612193713.167448-2-andrealmeid@igalia.com/"/><id>urn:uuid:27f4d3dc-2f83-2118-6fda-99e6ff013d83</id><thr:in-reply-to
ref="urn:uuid:ef7cd8bb-af07-370e-fa70-846ae804ddf2"
href="http://lore.kernel.org/amd-gfx/20240612193713.167448-1-andrealmeid@igalia.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Allow userspace to use explicit synchronization with atomic async flips.
That means that the flip will wait for some hardware fence, and then
will flip as soon as possible (async) in regard of the vblank.

Signed-off-by: Andr&#233; Almeida &lt;andrealmeid@igalia.com&gt;
---
 drivers/gpu/drm/drm_atomic_uapi.c | 4 +++-
 1 file <a href="http://lore.kernel.org/amd-gfx/20240612193713.167448-2-andrealmeid@igalia.com/#related">changed</a>, 3 insertions(+), 1 deletion(-)

<span
class="head">diff --git a/drivers/gpu/drm/drm_atomic_uapi.c b/drivers/gpu/drm/drm_atomic_uapi.c
index 22bbb2d83e30..2e1d9391febe 100644
--- a/drivers/gpu/drm/drm_atomic_uapi.c
+++ b/drivers/gpu/drm/drm_atomic_uapi.c
</span><span
class="hunk">@@ -1070,7 +1070,9 @@ int drm_atomic_set_property(struct drm_atomic_state *state,
</span> 			break;
 		}
 
<span
class="del">-		if (async_flip &#38;&#38; prop != config-&gt;prop_fb_id) {
</span><span
class="add">+		if (async_flip &#38;&#38;
+		    prop != config-&gt;prop_fb_id &#38;&#38;
+		    prop != config-&gt;prop_in_fence_fd) {
</span> 			ret = drm_atomic_plane_get_property(plane, plane_state,
 							    prop, &#38;old_val);
 			ret = drm_atomic_check_prop_changes(ret, old_val, prop_value, prop);
-- 
2.45.2

</pre></div></content></entry><entry><author><name>gregkh</name><email>gregkh@linuxfoundation.org</email></author><title
type="html">Patch &#34;Revert &#34;drm/amdgpu: init iommu after amdkfd device init&#34;&#34; has been added to the 5.15-stable tree</title><updated>2024-06-13T09:28:54Z</updated><link
href="http://lore.kernel.org/amd-gfx/2024061239-rehydrate-flyable-343e@gregkh/"/><id>urn:uuid:5cf9706f-8f8b-8796-72be-87b40ca8ed61</id><thr:in-reply-to
ref="urn:uuid:793e1742-c213-858d-e24d-0031698ea3a5"
href="http://lore.kernel.org/amd-gfx/20240523173031.4212-1-W_Armin@gmx.de/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">
This is a note to let you know that I&#39;ve just added the patch titled

    Revert &#34;drm/amdgpu: init iommu after amdkfd device init&#34;

to the 5.15-stable tree which can be found at:
    <a
href="http://www.kernel.org/git/?p=linux/kernel/git/stable/stable-queue.git;a=summary">http://www.kernel.org/git/?p=linux/kernel/git/stable/stable-queue.git;a=summary</a>

The filename of the patch is:
     revert-drm-amdgpu-init-iommu-after-amdkfd-device-init.patch
and it can be found in the queue-5.15 subdirectory.

If you, or anyone else, feels it should not be added to the stable tree,
please let &lt;stable@vger.kernel.org&gt; know about it.


From W_Armin@gmx.de  Wed Jun 12 14:43:21 2024
From: Armin Wolf &lt;W_Armin@gmx.de&gt;
Date: Thu, 23 May 2024 19:30:31 +0200
Subject: Revert &#34;drm/amdgpu: init iommu after amdkfd device init&#34;
To: alexander.deucher@amd.com, christian.koenig@amd.com, Xinhui.Pan@amd.com, gregkh@linuxfoundation.org, sashal@kernel.org
Cc: stable@vger.kernel.org, bkauler@gmail.com, yifan1.zhang@amd.com, Prike.Liang@amd.com, dri-devel@lists.freedesktop.org, amd-gfx@lists.freedesktop.org
Message-ID: &lt;20240523173031.4212-1-W_Armin@gmx.de&gt;

From: Armin Wolf &lt;W_Armin@gmx.de&gt;

This reverts commit 56b522f4668167096a50c39446d6263c96219f5f.

A user reported that this commit breaks the integrated gpu of his
notebook, causing a black screen. He was able to bisect the problematic
commit and verified that by reverting it the notebook works again.
He also confirmed that kernel 6.8.1 also works on his device, so the
upstream commit itself seems to be ok.

An amdgpu developer (Alex Deucher) confirmed that this patch should
have never been ported to 5.15 in the first place, so revert this
commit from the 5.15 stable series.

Reported-by: Barry Kauler &lt;bkauler@gmail.com&gt;
Signed-off-by: Armin Wolf &lt;W_Armin@gmx.de&gt;
Link: <a
href="https://lore.kernel.org/r/20240523173031.4212-1-W_Armin@gmx.de">https://lore.kernel.org/r/20240523173031.4212-1-W_Armin@gmx.de</a>
Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_device.c |    8 ++++----
 1 file <a href="http://lore.kernel.org/amd-gfx/2024061239-rehydrate-flyable-343e@gregkh/#related">changed</a>, 4 insertions(+), 4 deletions(-)

--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
@@ -2487,6 +2487,10 @@ static int amdgpu_device_ip_init(struct
 	if (r)
 		goto init_failed;
 
+	r = amdgpu_amdkfd_resume_iommu(adev);
+	if (r)
+		goto init_failed;
+
 	r = amdgpu_device_ip_hw_init_phase1(adev);
 	if (r)
 		goto init_failed;
@@ -2525,10 +2529,6 @@ static int amdgpu_device_ip_init(struct
 	if (!adev-&gt;gmc.xgmi.pending_reset)
 		amdgpu_amdkfd_device_init(adev);
 
-	r = amdgpu_amdkfd_resume_iommu(adev);
-	if (r)
-		goto init_failed;
-
 	amdgpu_fru_get_product_info(adev);
 
 init_failed:


Patches currently in stable-queue which might be from W_Armin@gmx.de are

queue-5.15/revert-drm-amdgpu-init-iommu-after-amdkfd-device-init.patch
</pre></div></content></entry><entry><author><name>Yiqing Yao</name><email>YiQing.Yao@amd.com</email></author><title>[PATCH v2] drm/amdgpu: use local xcc to flush tlb</title><updated>2024-06-12T09:37:20Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240612093641.3682677-1-YiQing.Yao@amd.com/"/><id>urn:uuid:1465f0fd-fec1-4549-1bb8-237bc36dc1eb</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">When flushing gpu tlb using kiq for gfxhub, kiq ring is always
local by selecting kiq instance. Test shows mmreg write data packet&#39;s
higher bits then 16 have no effect when flush using kiq on gfxhub.

Also some variant have policy blocking higher offset when req/ack is set
with extra bits and can cause flush to timeout.

So keep the lower 16 bits only.

Remove redundant code.

Signed-off-by: Yiqing Yao &lt;YiQing.Yao@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c | 12 ++++++++++--
 1 file <a href="http://lore.kernel.org/amd-gfx/20240612093641.3682677-1-YiQing.Yao@amd.com/#related">changed</a>, 10 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
index 350f6b6676f1..f3fe318e0c1d 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
</span><span
class="hunk">@@ -853,8 +853,16 @@ static void gmc_v9_0_flush_gpu_tlb(struct amdgpu_device *adev, uint32_t vmid,
</span> 	 */
 	if (adev-&gt;gfx.kiq[inst].ring.sched.ready &#38;&#38;
 	    (amdgpu_sriov_runtime(adev) || !amdgpu_sriov_vf(adev))) {
<span
class="del">-		uint32_t req = hub-&gt;vm_inv_eng0_req + hub-&gt;eng_distance * eng;
-		uint32_t ack = hub-&gt;vm_inv_eng0_ack + hub-&gt;eng_distance * eng;
</span><span
class="add">+
+		/* 
+		 * Select lower 16 bits to write in local xcc when flushing
+		 * using kiq to write gfx as higher bits are always ignored
+		 */
+		if (vmhub &lt; AMDGPU_MMHUB0(0))
+		{
+			req = req &#38; 0xffff;
+			ack = ack &#38; 0xffff;
+		}
</span> 
 		amdgpu_gmc_fw_reg_write_reg_wait(adev, req, ack, inv_req,
 						 1 &lt;&lt; vmid, inst);
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Jane Jian</name><email>Jane.Jian@amd.com</email></author><title>[PATCH] drm/amdgpu/vcn: port mmsch ctx table size fix from jpeg v4</title><updated>2024-06-12T03:42:35Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240612034153.229075-1-Jane.Jian@amd.com/"/><id>urn:uuid:45ff7019-5f74-6d42-350f-fa1d7702826d</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">add jpeg table size to ctx table size rather than override it

v2:
save jpeg header info otherwise it will lose debug info
Signed-off-by: Jane Jian &lt;Jane.Jian@amd.com&gt;
---
 drivers/gpu/drm/amd/amdgpu/jpeg_v4_0_3.c | 7 +++++--
 1 file <a href="http://lore.kernel.org/amd-gfx/20240612034153.229075-1-Jane.Jian@amd.com/#related">changed</a>, 5 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/amdgpu/jpeg_v4_0_3.c b/drivers/gpu/drm/amd/amdgpu/jpeg_v4_0_3.c
index 04d8966423de..ba052b104668 100644
--- a/drivers/gpu/drm/amd/amdgpu/jpeg_v4_0_3.c
+++ b/drivers/gpu/drm/amd/amdgpu/jpeg_v4_0_3.c
</span><span
class="hunk">@@ -200,9 +200,12 @@ static int jpeg_v4_0_3_start_sriov(struct amdgpu_device *adev)
</span> 	for (i = 0; i &lt; adev-&gt;jpeg.num_jpeg_inst; i++) {
 		jpeg_inst = GET_INST(JPEG, i);
 
<span
class="del">-		memset(&#38;header, 0, sizeof(struct mmsch_v4_0_3_init_header));
</span><span
class="add">+		size = sizeof(struct mmsch_v4_0_3_init_header);
+		table_loc = (uint32_t *)table-&gt;cpu_addr;
+		memcpy(&#38;header, (void *)table_loc, size);
+
</span> 		header.version = MMSCH_VERSION;
<span
class="del">-		header.total_size = sizeof(struct mmsch_v4_0_3_init_header) &gt;&gt; 2;
</span><span
class="add">+		header.total_size = RREG32_SOC15(VCN, 0, regMMSCH_VF_CTX_SIZE);
</span> 
 		table_loc = (uint32_t *)table-&gt;cpu_addr;
 		table_loc += header.total_size;
-- 
2.34.1

</pre></div></content></entry><entry><author><name>Aurabindo Pillai</name><email>aurabindo.pillai@amd.com</email></author><title>[PATCH] drm/amd/display: Enable idle optimizations on DCN401</title><updated>2024-06-11T19:23:40Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240611192329.1983538-1-aurabindo.pillai@amd.com/"/><id>urn:uuid:5692ed24-d41d-9cab-71e8-70e60e3a06ff</id><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">Idle optimizations were disabled due to some bugs which are now fixed in
DMCUB and PM firwmare. Enable these the optimizations back.

Signed-off-by: Aurabindo Pillai &lt;aurabindo.pillai@amd.com&gt;
---
 .../gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c    | 2 --
 1 file <a href="http://lore.kernel.org/amd-gfx/20240611192329.1983538-1-aurabindo.pillai@amd.com/#related">changed</a>, 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c b/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c
index ea803df8645e..d78dc63f82fd 100644
--- a/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c
</span><span
class="hunk">@@ -731,9 +731,7 @@ static const struct dc_debug_options debug_defaults_drv = {
</span> 		}
 	},
 	.force_cositing = CHROMA_COSITING_TOPLEFT + 1,
<span
class="del">-	.disable_idle_power_optimizations = true,
</span> 	.edp_oled_no_backlight_enable = true,
<span
class="del">-	.disable_boot_optimizations = true,
</span> };
 
 static struct dce_aux *dcn401_aux_engine_create(
-- 
2.45.2

</pre></div></content></entry><entry><author><name>Hamza Mahfooz</name><email>hamza.mahfooz@amd.com</email></author><title>[PATCH 35/36] drm/amd/display: [FW Promotion] Release 0.0.222.0</title><updated>2024-06-11T16:53:32Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240611165204.195093-36-hamza.mahfooz@amd.com/"/><id>urn:uuid:f4259b7c-51f4-4def-ca4e-9db1348b9998</id><thr:in-reply-to
ref="urn:uuid:90e69e36-b93d-fc6e-f9f8-f09ad9345173"
href="http://lore.kernel.org/amd-gfx/20240611165204.195093-1-hamza.mahfooz@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Anthony Koo &lt;anthony.koo@amd.com&gt;

 - Add new condition for PSR exit due to ESD recovery
 - Add new VB scaling feature for ABM by interpolating between
   existing VB parameters, allowing driver to have fine grain
   scaled VB levels between 0 - 250

Acked-by: Hamza Mahfooz &lt;hamza.mahfooz@amd.com&gt;
Signed-off-by: Anthony Koo &lt;anthony.koo@amd.com&gt;
---
 drivers/gpu/drm/amd/display/dmub/inc/dmub_cmd.h | 9 +++++++--
 1 file <a href="http://lore.kernel.org/amd-gfx/20240611165204.195093-36-hamza.mahfooz@amd.com/#related">changed</a>, 7 insertions(+), 2 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dmub/inc/dmub_cmd.h b/drivers/gpu/drm/amd/display/dmub/inc/dmub_cmd.h
index b75653faf40e..78e8698fe378 100644
--- a/drivers/gpu/drm/amd/display/dmub/inc/dmub_cmd.h
+++ b/drivers/gpu/drm/amd/display/dmub/inc/dmub_cmd.h
</span><span
class="hunk">@@ -208,6 +208,11 @@ union abm_flags {
</span> 		 * @abm_new_frame: Indicates if a new frame update needed for ABM to ramp up into steady
 		 */
 		unsigned int abm_new_frame : 1;
<span
class="add">+
+		/**
+		 * @vb_scaling_enabled: Indicates variBright Scaling Enable
+		 */
+		unsigned int vb_scaling_enabled : 1;
</span> 	} bitfields;
 
 	unsigned int u32All;
<span
class="hunk">@@ -2796,9 +2801,9 @@ struct dmub_cmd_psr_copy_settings_data {
</span> 	 */
 	uint8_t relock_delay_frame_cnt;
 	/**
<span
class="del">-	 * Explicit padding to 4 byte boundary.
</span><span
class="add">+	 * esd recovery indicate.
</span> 	 */
<span
class="del">-	uint8_t pad3;
</span><span
class="add">+	uint8_t esd_recovery;
</span> 	/**
 	 * DSC Slice height.
 	 */
-- 
2.45.1

</pre></div></content></entry><entry><author><name>Hamza Mahfooz</name><email>hamza.mahfooz@amd.com</email></author><title>[PATCH 25/36] drm/amd/display: Fix warning caused by an attempt to configure a non-otg master</title><updated>2024-06-11T16:53:31Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240611165204.195093-26-hamza.mahfooz@amd.com/"/><id>urn:uuid:ce249509-e9f5-4255-588b-f9da9eb679ae</id><thr:in-reply-to
ref="urn:uuid:90e69e36-b93d-fc6e-f9f8-f09ad9345173"
href="http://lore.kernel.org/amd-gfx/20240611165204.195093-1-hamza.mahfooz@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Rodrigo Siqueira &lt;rodrigo.siqueira@amd.com&gt;

When booting the system with DCN401, the driver adds the following dmesg
warning:

WARNING: CPU: 8 PID: 175 at
drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc_resource.c:1923
resource_get_opp_heads_for_otg_master+0x13/0x70 [amdgpu]

Modules linked in: amdgpu(+) hid_generic amdxcp i2c_algo_bit
drm_ttm_helper ttm drm_exec gpu_sched drm_suballoc_helper drm_buddy
drm_display_helper drm_kms_helper usbhid hid drm i2c_piix4 ahci igc
libahci video wmi

CPU: 8 PID: 175 Comm: systemd-udevd Not tainted 6.8.0-EXTRA-PROMO-MAY-29+ #66
Hardware name: ASUS System Product Name/TUF GAMING X570-PRO (WI-FI),
BIOS 4021 08/10/2021

RIP: 0010:resource_get_opp_heads_for_otg_master+0x13/0x70 [amdgpu]
Code: 8b 66 0f 1f 44 00 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 0f 1f 44 00 00 55 48 83 bf f8 07 00 00 00 48 89 e5 74 0c &lt;0f&gt; 0b 31
f6 89 f0 5d e9 0c 65 01 e5 48 83 bf e0 07 00 00 00 75 ea

RSP: 0018:ffffa5f000816ed8 EFLAGS: 00010246
[...]
PKRU: 55555554
Call Trace:
 &lt;TASK&gt;
 ? show_regs+0x65/0x70
 ? __warn+0x85/0x160
 ? resource_get_opp_heads_for_otg_master+0x13/0x70 [amdgpu]
 ? report_bug+0x192/0x1c0
 ? handle_bug+0x44/0x90
 ? exc_invalid_op+0x18/0x70
[...]

This warning is triggered by a check in the function
resource_get_opp_heads_for_otg_master that validates if the request
operation is in a master OTG pipe; if not, the warning above is
displayed. In other words, another part of the code might be calling
this function in a non-OTG master pipe context, resulting in the log
message.

The reason the ASSERT was triggered is that the current state wasn&#39;t
updated after applying the context to the hardware. This means that the
update_dsc_for_odm_change might be called from a non-OTG-MASTER. To
prevent this, it&#39;s crucial to check if the current reference is pointing
to an OTG master before operate in the old OTG master reference. If it&#39;s
not, the function must set the old OTG reference to NULL and avoid
calling resource_get_opp_heads_for_otg_master before the context is
updated.

Reviewed-by: Wenjing Liu &lt;wenjing.liu@amd.com&gt;
Acked-by: Hamza Mahfooz &lt;hamza.mahfooz@amd.com&gt;
Co-developed-by: Wenjing Liu &lt;wenjing.liu@amd.com&gt;
Signed-off-by: Wenjing Liu &lt;wenjing.liu@amd.com&gt;
Signed-off-by: Rodrigo Siqueira &lt;rodrigo.siqueira@amd.com&gt;
---
 .../amd/display/dc/hwss/dcn401/dcn401_hwseq.c | 24 ++++++++++++++-----
 1 file <a href="http://lore.kernel.org/amd-gfx/20240611165204.195093-26-hamza.mahfooz@amd.com/#related">changed</a>, 18 insertions(+), 6 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
index 0fafbec442b1..cb8e417fb032 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
</span><span
class="hunk">@@ -1561,16 +1561,28 @@ static void update_dsc_for_odm_change(struct dc *dc, struct dc_state *context,
</span> 	struct pipe_ctx *new_pipe;
 	struct pipe_ctx *old_opp_heads[MAX_PIPES];
 	struct dccg *dccg = dc-&gt;res_pool-&gt;dccg;
<span
class="del">-	struct pipe_ctx *old_otg_master =
-			&#38;dc-&gt;current_state-&gt;res_ctx.pipe_ctx[otg_master-&gt;pipe_idx];
-	int old_opp_head_count = resource_get_opp_heads_for_otg_master(
-			old_otg_master, &#38;dc-&gt;current_state-&gt;res_ctx,
-			old_opp_heads);
</span><span
class="add">+	struct pipe_ctx *old_otg_master;
+	int old_opp_head_count = 0;
+
+	old_otg_master = &#38;dc-&gt;current_state-&gt;res_ctx.pipe_ctx[otg_master-&gt;pipe_idx];
+
+	if (resource_is_pipe_type(old_otg_master, OTG_MASTER)) {
+		old_opp_head_count = resource_get_opp_heads_for_otg_master(old_otg_master,
+									   &#38;dc-&gt;current_state-&gt;res_ctx,
+									   old_opp_heads);
+	} else {
+		// DC cannot assume that the current state and the new state
+		// share the same OTG pipe since this is not true when called
+		// in the context of a commit stream not checked. Hence, set
+		// old_otg_master to NULL to skip the DSC configuration.
+		old_otg_master = NULL;
+	}
+
</span> 
 	if (otg_master-&gt;stream_res.dsc)
 		dcn32_update_dsc_on_stream(otg_master,
 				otg_master-&gt;stream-&gt;timing.flags.DSC);
<span
class="del">-	if (old_otg_master-&gt;stream_res.dsc) {
</span><span
class="add">+	if (old_otg_master &#38;&#38; old_otg_master-&gt;stream_res.dsc) {
</span> 		for (i = 0; i &lt; old_opp_head_count; i++) {
 			old_pipe = old_opp_heads[i];
 			new_pipe = &#38;context-&gt;res_ctx.pipe_ctx[old_pipe-&gt;pipe_idx];
-- 
2.45.1

</pre></div></content></entry><entry><author><name>Hamza Mahfooz</name><email>hamza.mahfooz@amd.com</email></author><title
type="html">[PATCH 29/36] drm/amd/display: Remove unused value set from &#39;min_hratio_fact&#39; in dml</title><updated>2024-06-11T16:53:31Z</updated><link
href="http://lore.kernel.org/amd-gfx/20240611165204.195093-30-hamza.mahfooz@amd.com/"/><id>urn:uuid:612d3d83-ce82-38c3-5043-310704275297</id><thr:in-reply-to
ref="urn:uuid:90e69e36-b93d-fc6e-f9f8-f09ad9345173"
href="http://lore.kernel.org/amd-gfx/20240611165204.195093-1-hamza.mahfooz@amd.com/"/><content
type="xhtml"><div
xmlns="http://www.w3.org/1999/xhtml"><pre
style="white-space:pre-wrap">From: Ivan Lipski &lt;ivlipski@amd.com&gt;

These portions of code are flagged as &#39;UNUSED_VALUE&#39; by the
Coverity analysis since the assigned values of these vars
are never used in the code.

Reviewed-by: Alex Hung &lt;alex.hung@amd.com&gt;
Reviewed-by: Aurabindo Pillai &lt;aurabindo.pillai@amd.com&gt;
Acked-by: Hamza Mahfooz &lt;hamza.mahfooz@amd.com&gt;
Signed-off-by: Ivan Lipski &lt;ivlipski@amd.com&gt;
---
 .../drm/amd/display/dc/dml/dcn20/display_rq_dlg_calc_20.c    | 5 -----
 .../drm/amd/display/dc/dml/dcn20/display_rq_dlg_calc_20v2.c  | 5 -----
 .../drm/amd/display/dc/dml/dcn21/display_rq_dlg_calc_21.c    | 5 -----
 .../drm/amd/display/dc/dml/dcn30/display_rq_dlg_calc_30.c    | 5 -----
 .../drm/amd/display/dc/dml/dcn31/display_rq_dlg_calc_31.c    | 5 -----
 .../drm/amd/display/dc/dml/dcn314/display_rq_dlg_calc_314.c  | 5 -----
 .../gpu/drm/amd/display/dc/dml/dml1_display_rq_dlg_calc.c    | 5 -----
 7 files <a href="http://lore.kernel.org/amd-gfx/20240611165204.195093-30-hamza.mahfooz@amd.com/#related">changed</a>, 35 deletions(-)

<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml/dcn20/display_rq_dlg_calc_20.c b/drivers/gpu/drm/amd/display/dc/dml/dcn20/display_rq_dlg_calc_20.c
index 548cdef8a8ad..07146569e335 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/dcn20/display_rq_dlg_calc_20.c
+++ b/drivers/gpu/drm/amd/display/dc/dml/dcn20/display_rq_dlg_calc_20.c
</span><span
class="hunk">@@ -1156,11 +1156,6 @@ static void dml20_rq_dlg_get_dlg_params(struct display_mode_lib *mode_lib,
</span> 		swath_width_pixels_ub_c = swath_width_ub_c * 1;
 	}
 
<span
class="del">-	hscale_pixel_rate_l = 0.;
-	hscale_pixel_rate_c = 0.;
-	min_hratio_fact_l = 1.0;
-	min_hratio_fact_c = 1.0;
-
</span> 	if (htaps_l &lt;= 1)
 		min_hratio_fact_l = 2.0;
 	else if (htaps_l &lt;= 6) {
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml/dcn20/display_rq_dlg_calc_20v2.c b/drivers/gpu/drm/amd/display/dc/dml/dcn20/display_rq_dlg_calc_20v2.c
index 0fc9f3e3ffae..f4bba1f2aeb6 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/dcn20/display_rq_dlg_calc_20v2.c
+++ b/drivers/gpu/drm/amd/display/dc/dml/dcn20/display_rq_dlg_calc_20v2.c
</span><span
class="hunk">@@ -1157,11 +1157,6 @@ static void dml20v2_rq_dlg_get_dlg_params(struct display_mode_lib *mode_lib,
</span> 		swath_width_pixels_ub_c = swath_width_ub_c * 1;
 	}
 
<span
class="del">-	hscale_pixel_rate_l = 0.;
-	hscale_pixel_rate_c = 0.;
-	min_hratio_fact_l = 1.0;
-	min_hratio_fact_c = 1.0;
-
</span> 	if (htaps_l &lt;= 1)
 		min_hratio_fact_l = 2.0;
 	else if (htaps_l &lt;= 6) {
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml/dcn21/display_rq_dlg_calc_21.c b/drivers/gpu/drm/amd/display/dc/dml/dcn21/display_rq_dlg_calc_21.c
index 708e1632170d..c229a9edf82a 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/dcn21/display_rq_dlg_calc_21.c
+++ b/drivers/gpu/drm/amd/display/dc/dml/dcn21/display_rq_dlg_calc_21.c
</span><span
class="hunk">@@ -1205,11 +1205,6 @@ static void dml_rq_dlg_get_dlg_params(
</span> 		swath_width_pixels_ub_c = swath_width_ub_c * 1;
 	}
 
<span
class="del">-	hscale_pixel_rate_l = 0.;
-	hscale_pixel_rate_c = 0.;
-	min_hratio_fact_l = 1.0;
-	min_hratio_fact_c = 1.0;
-
</span> 	if (hratio_l &lt;= 1)
 		min_hratio_fact_l = 2.0;
 	else if (htaps_l &lt;= 6) {
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml/dcn30/display_rq_dlg_calc_30.c b/drivers/gpu/drm/amd/display/dc/dml/dcn30/display_rq_dlg_calc_30.c
index 0497a5d74a62..f3ee7baac786 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/dcn30/display_rq_dlg_calc_30.c
+++ b/drivers/gpu/drm/amd/display/dc/dml/dcn30/display_rq_dlg_calc_30.c
</span><span
class="hunk">@@ -1309,11 +1309,6 @@ static void dml_rq_dlg_get_dlg_params(struct display_mode_lib *mode_lib,
</span> 		swath_width_pixels_ub_c = swath_width_ub_c * 1;
 	}
 
<span
class="del">-	hscale_pixel_rate_l = 0.;
-	hscale_pixel_rate_c = 0.;
-	min_hratio_fact_l = 1.0;
-	min_hratio_fact_c = 1.0;
-
</span> 	if (hratio_l &lt;= 1)
 		min_hratio_fact_l = 2.0;
 	else if (htaps_l &lt;= 6) {
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml/dcn31/display_rq_dlg_calc_31.c b/drivers/gpu/drm/amd/display/dc/dml/dcn31/display_rq_dlg_calc_31.c
index 4113ce79c4af..b6d954d9aa00 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/dcn31/display_rq_dlg_calc_31.c
+++ b/drivers/gpu/drm/amd/display/dc/dml/dcn31/display_rq_dlg_calc_31.c
</span><span
class="hunk">@@ -1150,11 +1150,6 @@ static void dml_rq_dlg_get_dlg_params(
</span> 		swath_width_pixels_ub_c = swath_width_ub_c * 1;
 	}
 
<span
class="del">-	hscale_pixel_rate_l = 0.;
-	hscale_pixel_rate_c = 0.;
-	min_hratio_fact_l = 1.0;
-	min_hratio_fact_c = 1.0;
-
</span> 	if (hratio_l &lt;= 1)
 		min_hratio_fact_l = 2.0;
 	else if (htaps_l &lt;= 6) {
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml/dcn314/display_rq_dlg_calc_314.c b/drivers/gpu/drm/amd/display/dc/dml/dcn314/display_rq_dlg_calc_314.c
index b3e8dc08030c..94975b0fa398 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/dcn314/display_rq_dlg_calc_314.c
+++ b/drivers/gpu/drm/amd/display/dc/dml/dcn314/display_rq_dlg_calc_314.c
</span><span
class="hunk">@@ -1238,11 +1238,6 @@ static void dml_rq_dlg_get_dlg_params(
</span> 		swath_width_pixels_ub_c = swath_width_ub_c * 1;
 	}
 
<span
class="del">-	hscale_pixel_rate_l = 0.;
-	hscale_pixel_rate_c = 0.;
-	min_hratio_fact_l = 1.0;
-	min_hratio_fact_c = 1.0;
-
</span> 	if (hratio_l &lt;= 1)
 		min_hratio_fact_l = 2.0;
 	else if (htaps_l &lt;= 6) {
<span
class="head">diff --git a/drivers/gpu/drm/amd/display/dc/dml/dml1_display_rq_dlg_calc.c b/drivers/gpu/drm/amd/display/dc/dml/dml1_display_rq_dlg_calc.c
index 3df559c591f8..dae13f202220 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/dml1_display_rq_dlg_calc.c
+++ b/drivers/gpu/drm/amd/display/dc/dml/dml1_display_rq_dlg_calc.c
</span><span
class="hunk">@@ -1596,11 +1596,6 @@ void dml1_rq_dlg_get_dlg_params(
</span> 		swath_width_pixels_ub_c = swath_width_ub_c * 1;
 	}
 
<span
class="del">-	hscale_pixel_rate_l = 0.;
-	hscale_pixel_rate_c = 0.;
-	min_hratio_fact_l = 1.0;
-	min_hratio_fact_c = 1.0;
-
</span> 	if (htaps_l &lt;= 1)
 		min_hratio_fact_l = 2.0;
 	else if (htaps_l &lt;= 6) {
-- 
2.45.1

</pre></div></content></entry></feed>